package com.konnect.jpms.util;

import java.sql.Connection;
import java.sql.Date;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Time;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collections;
import java.util.Comparator;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TimeZone;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpSession;

import org.apache.log4j.Logger;
import org.joda.time.LocalDate;
import org.joda.time.Period;
import org.joda.time.PeriodType;

import com.konnect.jpms.ajax.GetLeaveStatus;
import com.konnect.jpms.document.SendDocument;
import com.konnect.jpms.employee.EmpDashboardData;
import com.konnect.jpms.payroll.ApprovePayroll;
import com.konnect.jpms.reports.EmployeeLeaveEntryReport;
import com.konnect.jpms.reports.MyProfile;
import com.konnect.jpms.salary.EmpSalaryApproval;
import com.konnect.jpms.select.FillFinancialYears;
import com.konnect.jpms.select.FillPayCycles;
import com.konnect.jpms.select.FillResourceType;
import com.konnect.jpms.tms.UpdateClockEntries;

public class CommonFunctions implements IStatements {

	private String strTimeZone = null;

	private String strReportDateFormat = null;
	private String strCURRENCY_FULL = null;
	private String strCURRENCY_SHORT = null;
	private String strReportDayFormat = null;
	private String strReportTimeFormat = null;
	private String strReportTimeAM_PMFormat = null;
	private String strPaycycleDuration = null;
	private String strDisplayPayCycle = null;
	private String strFinancialYearFrom = null;

	private String strFinancialYearTo = null;
	private String strOrgName = null;
	private String strOrgSubTitle = null;
	private String strOrgAddress = null;
	private String strOrgLogo = null;
	private String strOrgLogoSmall = null;
	private String strEmpOrgLogo = null;
	private String strEmpOrgLogoSmall = null;
	private String strOEmpCodeAlpha = null;
	private String strOContractorCodeAlpha = null;
	private String strOSalaryCalculationType = null;
	private String strOSalaryCalculationDays = null;

	private String strEmailLocalHost = null;
	private String strStandardHrs = null;
	private String strAttendanceIntegratedWithActivity = null;
	private String strUserNameFormat = null;
	private String strCommonAttendanceFormat = null;

	private String strMaxEmployee = null;
	private String strMaxAdmin = null;
	private String strMaxOrganisation = null;
	private String strMaxLocations = null;
	private String strMaxUserLevels = null;
	private String[] arrEnabledModules = null;
	private String[] arrAllModules = null;

	boolean isTrial = false;
	boolean isTermsCondition = false;
	boolean isForcePassword = false;
	String isPaycycleAdjustment;
	String isWorkFlow;
	String isBonusPaidWithPayroll;
	String isSpecificEmp;
	String backUpLocation;
	String backUpRetriveLocation;
	String dumpLocation;
	String strDocSaveLocation;
	String strDocRetriveLocation;
	boolean isRemoteLocation;
	boolean isEPF_Condition1;

	String isExceptionAutoApprove;
	String isArrear;
	String isDeviceIntegration;
	String isBreakPolicy;
	String maxTimeLimitIN;
	String maxTimeLimitOUT;
	String projectDocumentFolder;
	String retriveProjectDocumentFolder;
	String roundOffCondtion;
	private String strHostPort = null;

	boolean isWorkRig;
	boolean isTaskRig;
	boolean isCloud;
	boolean isOffice365Smtp;
	boolean isTermsConditionsAccept;

	boolean isClockOnOff;
	boolean isEmpWebClockOnOff;
	String strSalaryStructure;
	String strTermsConditionsType;
	boolean isReceipt;
	boolean isHalfDayLeave;

	String strLunchDeduction;
	boolean isProductionLine;
	boolean isSandwichAbsent;
	boolean isTerminateWithoutFullAndFinal;
	boolean isTDSAutoApprove;
	boolean isShowTimeVariance;

	// String searchingData;
	// Map<String,String> hmLinksList;

	String strUI_Theme;

	boolean isCalLeaveInAttendanceDependantNo;

	public boolean getIsCalLeaveInAttendanceDependantNo() {
		return isCalLeaveInAttendanceDependantNo;
	}

	public void setIsCalLeaveInAttendanceDependantNo(boolean isCalLeaveInAttendanceDependantNo) {
		this.isCalLeaveInAttendanceDependantNo = isCalLeaveInAttendanceDependantNo;
	}

	public String getStrUI_Theme() {
		return strUI_Theme;
	}

	public void setStrUI_Theme(String strUI_Theme) {
		this.strUI_Theme = strUI_Theme;
	}

	public boolean getIsTerminateWithoutFullAndFinal() {
		return isTerminateWithoutFullAndFinal;
	}

	public void setIsTerminateWithoutFullAndFinal(boolean isTerminateWithoutFullAndFinal) {
		this.isTerminateWithoutFullAndFinal = isTerminateWithoutFullAndFinal;
	}

	public boolean getIsShowTimeVariance() {
		return isShowTimeVariance;
	}

	public void setIsShowTimeVariance(boolean isShowTimeVariance) {
		this.isShowTimeVariance = isShowTimeVariance;
	}

	public boolean getIsTDSAutoApprove() {
		return isTDSAutoApprove;
	}

	public void setIsTDSAutoApprove(boolean isTDSAutoApprove) {
		this.isTDSAutoApprove = isTDSAutoApprove;
	}
	public boolean getIsSandwichAbsent() {
		return isSandwichAbsent;
	}

	public void setIsSandwichAbsent(boolean isSandwichAbsent) {
		this.isSandwichAbsent = isSandwichAbsent;
	}

	public boolean getIsProductionLine() {
		return isProductionLine;
	}

	public void setIsProductionLine(boolean isProductionLine) {
		this.isProductionLine = isProductionLine;
	}

	public String getStrLunchDeduction() {
		return strLunchDeduction;
	}

	public void setStrLunchDeduction(String strLunchDeduction) {
		this.strLunchDeduction = strLunchDeduction;
	}

	public boolean getIsHalfDayLeave() {
		return isHalfDayLeave;
	}

	public void setIsHalfDayLeave(boolean isHalfDayLeave) {
		this.isHalfDayLeave = isHalfDayLeave;
	}

	public boolean getIsReceipt() {
		return isReceipt;
	}

	public void setIsReceipt(boolean isReceipt) {
		this.isReceipt = isReceipt;
	}

	public String getStrTermsConditionsType() {
		return strTermsConditionsType;
	}

	public void setStrTermsConditionsType(String strTermsConditionsType) {
		this.strTermsConditionsType = strTermsConditionsType;
	}

	public String getStrSalaryStructure() {
		return strSalaryStructure;
	}

	public void setStrSalaryStructure(String strSalaryStructure) {
		this.strSalaryStructure = strSalaryStructure;
	}

	public boolean isClockOnOff() {
		return isClockOnOff;
	}

	public void setClockOnOff(boolean isClockOnOff) {
		this.isClockOnOff = isClockOnOff;
	}

	public boolean isEmpWebClockOnOff() {
		return isEmpWebClockOnOff;
	}

	public void setEmpWebClockOnOff(boolean isEmpWebClockOnOff) {
		this.isEmpWebClockOnOff = isEmpWebClockOnOff;
	}

	public boolean isOffice365Smtp() {
		return isOffice365Smtp;
	}

	public void setOffice365Smtp(boolean isOffice365Smtp) {
		this.isOffice365Smtp = isOffice365Smtp;
	}

	public boolean isTermsConditionsAccept() {
		return isTermsConditionsAccept;
	}

	public void setTermsConditionsAccept(boolean isTermsConditionsAccept) {
		this.isTermsConditionsAccept = isTermsConditionsAccept;
	}

	public boolean isCloud() {
		return isCloud;
	}

	public void setCloud(boolean isCloud) {
		this.isCloud = isCloud;
	}

	public String getIsBreakPolicy() {
		return isBreakPolicy;
	}

	public void setIsBreakPolicy(String isBreakPolicy) {
		this.isBreakPolicy = isBreakPolicy;
	}

	public String getIsExceptionAutoApprove() {
		return isExceptionAutoApprove;
	}

	public void setIsExceptionAutoApprove(String isExceptionAutoApprove) {
		this.isExceptionAutoApprove = isExceptionAutoApprove;
	}

	public String getStrOSalaryCalculationDays() {
		return strOSalaryCalculationDays;
	}

	public void setStrOSalaryCalculationDays(String strOSalaryCalculationDays) {
		this.strOSalaryCalculationDays = strOSalaryCalculationDays;
	}

	public String getIsDeviceIntegration() {
		return isDeviceIntegration;
	}

	public void setIsDeviceIntegration(String isDeviceIntegration) {
		this.isDeviceIntegration = isDeviceIntegration;
	}

	public String getIsArrear() {
		return isArrear;
	}

	public void setIsArrear(String isArrear) {
		this.isArrear = isArrear;
	}

	private CommonFunctions CF;
	private static Logger log = Logger.getLogger(CommonFunctions.class);

	public CommonFunctions(CommonFunctions CF) {
		this.CF = CF;
	}

	public CommonFunctions() {
	}

	public HttpServletRequest request;
	public void setRequest(HttpServletRequest request) {
		this.request = request;
	}

	public CommonFunctions(CommonFunctions CF, HttpServletRequest request) {
		super();
		this.CF = CF;
		this.request = request;
	}

	public CommonFunctions(HttpServletRequest request) {
		super();
		this.request = request;
	}

	UtilityFunctions uF = new UtilityFunctions();

	/*
	 * public void setListLinks(Map<String,String> hmLinksList) {
	 * this.hmLinksList = hmLinksList;
	 * System.out.println("In setlinks"+hmLinksList); }
	 * 
	 * public Map<String,String> getListLinks() {
	 * System.out.println("In getListLinks"+hmLinksList); return hmLinksList; }
	 * 
	 * public String getSearchingData() { return searchingData; }
	 * 
	 * public void setSearchingData(String searchingData) {
	 * System.out.println(" CF searchingData:"+searchingData);
	 * this.searchingData = searchingData; }
	 */

	public Map<String, String> getWLocationMap(Connection con, String strUserType, HttpServletRequest request1, String strEmpId) {
		Map<String, String> hmEmpWLocation = new HashMap<String, String>();

		ResultSet rs = null;
		UtilityFunctions uF = new UtilityFunctions();
		PreparedStatement pst = null;
		try {

			if (strUserType != null && (strUserType.equalsIgnoreCase(ADMIN) || strUserType.equalsIgnoreCase(CEO) || strUserType.equalsIgnoreCase(CFO))) {
				pst = con.prepareStatement("SELECT * FROM work_location_info order by wlocation_name");
			} else if (strUserType != null && (strUserType.equalsIgnoreCase(HRMANAGER) || strUserType.equalsIgnoreCase(ACCOUNTANT))) {

				pst = con
						.prepareStatement("SELECT * FROM work_location_info wi where wlocation_id = (select wlocation_id from employee_official_details where emp_id=?) order by wlocation_name");
				pst.setInt(1, uF.parseToInt(strEmpId));

			} else {
				pst = con.prepareStatement("SELECT * FROM work_location_info order by wlocation_name");
			}
			rs = pst.executeQuery();
			while (rs.next()) {
				hmEmpWLocation.put(rs.getString("wlocation_id"), rs.getString("wlocation_name"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmEmpWLocation;
	}

	public void getUserModulesList(Connection con, List<String> alUserModulesList) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		try {

			pst = con.prepareStatement("select * from user_modules");
			rs = pst.executeQuery();
			while (rs.next()) {
				String[] arr = null;
				if (rs.getString("modules_enabled") != null) {
					arr = rs.getString("modules_enabled").split(",");
				}
				for (int i = 0; arr != null && i < arr.length; i++) {
					alUserModulesList.add(arr[i]);
				}
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
	}

	public Map<String, String> getHolidayList(Connection con, HttpServletRequest request) {

		Map<String, String> hmHolidays = new HashMap<String, String>();
		PreparedStatement pst = null;
		ResultSet rs = null;

		try {

			pst = con.prepareStatement(selectHolidaysR1);
			pst.setInt(1, uF.parseToInt(uF.getDateFormat(uF.getCurrentDate(CF.getStrTimeZone()) + "", DBDATE, "yyyy")));

			rs = pst.executeQuery();
			while (rs.next()) {
				hmHolidays.put(uF.getDateFormat(rs.getString("_date"), DBDATE, DATE_FORMAT), rs.getString("colour_code"));
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmHolidays;
	}

	public Map<String, String> getWeekEndList() {

		Map<String, String> hmWeekEnds = new HashMap<String, String>();
		PreparedStatement pst = null;
		ResultSet rs = null;
		Connection con = null;
		Database db = new Database();
		db.setRequest(request);

		try {

			con = db.makeConnection(con);

			pst = con.prepareStatement("select * from work_location_info");
			rs = pst.executeQuery();
			while (rs.next()) {
				if ("FD".equalsIgnoreCase(rs.getString("wlocation_weeklyofftype1"))) {
					hmWeekEnds.put(rs.getString("wlocation_weeklyoff1") + "_" + rs.getString("wlocation_id"), "#a9cfff");
				}
				if ("FD".equalsIgnoreCase(rs.getString("wlocation_weeklyofftype2"))) {
					hmWeekEnds.put(rs.getString("wlocation_weeklyoff2") + "_" + rs.getString("wlocation_id"), "#c8e1ff");
				}
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			db.closeResultSet(rs);
			db.closeStatements(pst);
			db.closeConnection(con);
		}
		return hmWeekEnds;
	}

	public Map<String, String> getWeekEndList(Connection con) {

		Map<String, String> hmWeekEnds = new HashMap<String, String>();
		PreparedStatement pst = null;
		ResultSet rs = null;

		try {

			pst = con.prepareStatement("select * from work_location_info");
			rs = pst.executeQuery();
			while (rs.next()) {
				if ("FD".equalsIgnoreCase(rs.getString("wlocation_weeklyofftype1"))) {
					hmWeekEnds.put(rs.getString("wlocation_weeklyoff1") + "_" + rs.getString("wlocation_id"), "#a9cfff");
				}
				if ("FD".equalsIgnoreCase(rs.getString("wlocation_weeklyofftype2"))) {
					hmWeekEnds.put(rs.getString("wlocation_weeklyoff2") + "_" + rs.getString("wlocation_id"), "#c8e1ff");
				}
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmWeekEnds;
	}

	public Map<String, Set<String>> getWeekEndDateList(Connection con, String strD1, String strD2, CommonFunctions CF, UtilityFunctions uF,
			Map<String, Set<String>> hmWeekEndHalfDates, String strLoation) {

		Map<String, Set<String>> hmWeekEndDates = new HashMap<String, Set<String>>();
		PreparedStatement pst = null;
		ResultSet rs = null;
		try {
			String strTimezone = "Asia/Calcutta";
			if (CF.getStrTimeZone() != null) {
				strTimezone = CF.getStrTimeZone();
			}
			int diff = uF.parseToInt(uF.dateDifference(strD1, DATE_FORMAT, strD2, DATE_FORMAT, strTimezone));
			SimpleDateFormat smft = new SimpleDateFormat(DATE_FORMAT);
			Calendar cal1 = GregorianCalendar.getInstance();
			cal1.setTime(uF.getDateFormatUtil(strD1, DATE_FORMAT));
			Map<String, String> DateDays = new HashMap<String, String>();
			for (int i = 0; i < diff; i++) {
				DateDays.put(smft.format(cal1.getTime()), uF.getDay(cal1.get(Calendar.DAY_OF_WEEK)));
				cal1.add(Calendar.DATE, 1);
			}
			cal1.setTime(uF.getDateFormatUtil(strD1, DATE_FORMAT));
			if (strLoation == null) {
				pst = con.prepareStatement("select * from work_location_info");
			} else {
				pst = con.prepareStatement("select * from work_location_info where wlocation_id=?");
				pst.setInt(1, uF.parseToInt(strLoation));
			}
			rs = pst.executeQuery();
			while (rs.next()) {
				String weeklyofftype1 = rs.getString("wlocation_weeklyofftype1");
				String weeklyofftype2 = rs.getString("wlocation_weeklyofftype2");
				String weeklyofftype3 = rs.getString("wlocation_weeklyofftype3");

				String weeklyoff1 = rs.getString("wlocation_weeklyoff1");
				String weeklyoff2 = rs.getString("wlocation_weeklyoff2");
				String weeklyoff3 = rs.getString("wlocation_weeklyoff3");

				String weeklyoffno1 = rs.getString("wlocation_weeknos1");
				if (weeklyoffno1 == null)
					weeklyoffno1 = "";
				List<String> weekOffNo1List = Arrays.asList(weeklyoffno1.split(","));

				String weeklyoffno2 = rs.getString("wlocation_weeknos2");
				if (weeklyoffno2 == null)
					weeklyoffno2 = "";
				List<String> weekOffNo2List = Arrays.asList(weeklyoffno2.split(","));

				String weeklyoffno3 = rs.getString("wlocation_weeknos3");
				if (weeklyoffno3 == null)
					weeklyoffno3 = "";
				List<String> weekOffNo3List = Arrays.asList(weeklyoffno3.split(","));

				for (int i = 0; i < diff; i++) {

					Set<String> list = hmWeekEndDates.get(rs.getString("wlocation_id"));
					if (list == null)
						list = new HashSet<String>();
					String day = DateDays.get(smft.format(cal1.getTime()));
					// System.out.println("day ===>> " +day);
					String strDate = uF.getDateFormat(smft.format(cal1.getTime()), DATE_FORMAT, DATE_FORMAT);
					// System.out.println("strDate ===>> " +strDate);
					int checkWeek = CF.getMonthCount(uF, strDate);
					// System.out.println("checkWeek ===>> " +checkWeek);
					// System.out.println("weeklyofftype1 ===>> "
					// +weeklyofftype1);
					// System.out.println("weeklyofftype2 ===>> "
					// +weeklyofftype2);
					// System.out.println("weeklyofftype3 ===>> "
					// +weeklyofftype3);
					if (weeklyofftype1 != null && weeklyofftype1.equalsIgnoreCase("FD") && weeklyoff1 != null && weeklyoff1.equalsIgnoreCase(day)) {
						if (weekOffNo1List.contains(checkWeek + "")) {
							list.add(smft.format(cal1.getTime()));
						}
					} else if (weeklyofftype2 != null && weeklyofftype2.equalsIgnoreCase("FD") && weeklyoff2 != null && weeklyoff2.equalsIgnoreCase(day)) {
						if (weekOffNo2List.contains(checkWeek + "")) {
							list.add(smft.format(cal1.getTime()));
						}
					} else if (weeklyofftype3 != null && weeklyofftype3.equalsIgnoreCase("FD") && weeklyoff3 != null && weeklyoff3.equalsIgnoreCase(day)) {
						if (weekOffNo3List.contains(checkWeek + "")) {
							// Date strDayDate = uF.getDateFormat(strDate,
							// DATE_FORMAT);
							// Date strMinDate = uF.getDateFormat("01/08/2018",
							// DATE_FORMAT);
							// Date strMinDate1 = uF.getDateFormat("26/07/2018",
							// DATE_FORMAT);
							// if(strDayDate.after(strMinDate) ||
							// strDayDate.before(strMinDate1)) {
							list.add(smft.format(cal1.getTime()));
							// } // need change for KPCA
						}
					}

					if (hmWeekEndHalfDates != null) {
						Set<String> halflist = hmWeekEndHalfDates.get(rs.getString("wlocation_id"));
						if (halflist == null)
							halflist = new HashSet<String>();
						if (weeklyofftype1 != null && weeklyofftype1.equalsIgnoreCase("HD") && weeklyoff1 != null && weeklyoff1.equalsIgnoreCase(day)) {
							if (weekOffNo1List.contains(checkWeek + "")) {
								if (!list.contains(smft.format(cal1.getTime()))) {
									halflist.add(smft.format(cal1.getTime()));
								}
							}
						} else if (weeklyofftype2 != null && weeklyofftype2.equalsIgnoreCase("HD") && weeklyoff2 != null && weeklyoff2.equalsIgnoreCase(day)) {
							if (weekOffNo2List.contains(checkWeek + "")) {
								if (!list.contains(smft.format(cal1.getTime()))) {
									halflist.add(smft.format(cal1.getTime()));
								}
							}
						} else if (weeklyofftype3 != null && weeklyofftype3.equalsIgnoreCase("HD") && weeklyoff3 != null && weeklyoff3.equalsIgnoreCase(day)) {
							if (weekOffNo3List.contains(checkWeek + "")) {
								if (!list.contains(smft.format(cal1.getTime()))) {
									halflist.add(smft.format(cal1.getTime()));
								}
							}

						}
						hmWeekEndHalfDates.put(rs.getString("wlocation_id"), halflist);
					}
					hmWeekEndDates.put(rs.getString("wlocation_id"), list);

					cal1.add(Calendar.DATE, 1);
				}
				cal1.setTime(uF.getDateFormatUtil(strD1, DATE_FORMAT));
				
//				System.out.println(" hmWeekEndDates ==========>> " + hmWeekEndDates);
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmWeekEndDates;
	}

	public void clockOnOffEntryForActivity(Connection con, UtilityFunctions uF, CommonFunctions CF, String strEmpId, String strMode, int activityId,
			String strReason) {
		PreparedStatement pst = null;
		try {
			//
			pst = con
					.prepareStatement("insert into task_activity (task_date, activity_id, emp_id, activity, start_time, end_time, _comment) values (?,?,?,?,?,?,?)");
			pst.setDate(1, uF.getCurrentDate(CF.getStrTimeZone()));
			pst.setInt(2, activityId);
			pst.setInt(3, uF.parseToInt(strEmpId));
			pst.setString(4, strMode);
			pst.setTime(5, uF.getCurrentTime(CF.getStrTimeZone()));
			pst.setTime(6, uF.getCurrentTime(CF.getStrTimeZone()));
			pst.setString(7, uF.showData(strReason, ""));
			pst.execute();

			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
	}

	public Map<String, Map<String, String>> getCurrencyDetails(Connection con) {

		PreparedStatement pst = null;
		ResultSet rs = null;

		Map<String, Map<String, String>> hmCurrencyDetailsMap = new HashMap<String, Map<String, String>>();
		try {
			pst = con.prepareStatement("select * from currency_details");
			rs = pst.executeQuery();

			while (rs.next()) {
				Map<String, String> hmInner = new HashMap<String, String>();

				if (rs.getString("short_currency") != null
						&& (rs.getString("short_currency").equalsIgnoreCase("RS.") || rs.getString("short_currency").equalsIgnoreCase("RS") || rs.getString(
								"short_currency").equalsIgnoreCase("INR"))) {
					// hmInner.put("SHORT_CURR",
					// "<span class=\"rupee\">\u20B9</span>");
					// hmInner.put("SHORT_CURR",
					// "<span class=\"rupee\">&#8377;</span>");
					hmInner.put("SHORT_CURR", "&#8377;");
				
				//===start parvez date: 11-03-2022===	
					hmInner.put("SHORT_CURR_INR", rs.getString("short_currency"));
				//===end parvez date: 11-03-2022===	
				} else {
					hmInner.put("SHORT_CURR", rs.getString("short_currency"));
				}

				if (rs.getString("short_currency") != null
						&& (rs.getString("short_currency").equalsIgnoreCase("RS.") || rs.getString("short_currency").equalsIgnoreCase("RS") || rs.getString(
								"short_currency").equalsIgnoreCase("INR"))) {
					// hmInner.put("LONG_CURR",
					// "<span class=\"rupee\">\u20B9;</span>");
					hmInner.put("LONG_CURR", "&#8377;");
				} else {
					hmInner.put("LONG_CURR", rs.getString("long_currency"));
				}

				hmInner.put("CURR_DESC", rs.getString("currency_desc"));
				hmInner.put("CURR_CONVERSION_USD", rs.getString("currency_conversion_usd"));
				hmInner.put("CURR_INR_VALUE", rs.getString("inr_value"));

				hmCurrencyDetailsMap.put(rs.getString("currency_id"), hmInner);
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmCurrencyDetailsMap;
	}

	public Map<String, String> getEmpCurrency(Connection con) {

		PreparedStatement pst = null;
		ResultSet rs = null;

		Map<String, String> hmEmpCurrencyMap = new HashMap<String, String>();
		try {
			pst = con
					.prepareStatement("select emp_id,org_currency from employee_official_details eod left join org_details od on eod.org_id = od.org_id where eod.emp_id>0");
			rs = pst.executeQuery();

			while (rs.next()) {
				hmEmpCurrencyMap.put(rs.getString("emp_id"), rs.getString("org_currency"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmEmpCurrencyMap;
	}

	public Map<String, String> getEmpPaymentMode(Connection con, UtilityFunctions uF) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmEmpPaymentMap = new HashMap<String, String>();
		try {
			pst = con.prepareStatement("select * from employee_official_details");
			rs = pst.executeQuery();

			while (rs.next()) {
				hmEmpPaymentMap.put(rs.getString("emp_id"), rs.getString("payment_mode"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmEmpPaymentMap;
	}

	public Map<String, String> getPaymentMode() {
		Map<String, String> hmEmpPaymentMap = new HashMap<String, String>();
		hmEmpPaymentMap.put("0", "N/a");
		hmEmpPaymentMap.put("1", "Bank Trf.");
		hmEmpPaymentMap.put("2", "Cash");
		hmEmpPaymentMap.put("3", "Cheque");

		return hmEmpPaymentMap;
	}

	public Map<String, String> getEmpGenderMap(Connection con) {

		PreparedStatement pst = null;
		ResultSet rs = null;

		Map<String, String> hmEmpGenderMap = new HashMap<String, String>();
		try {

			pst = con.prepareStatement(selectEmpDetails);
			rs = pst.executeQuery();

			while (rs.next()) {
				hmEmpGenderMap.put(rs.getString("emp_per_id"), ((rs.getString("emp_gender") != null) ? rs.getString("emp_gender") : "Not Specified"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmEmpGenderMap;
	}

	public Map<String, String> getProjectNameMap(Connection con) {

		PreparedStatement pst = null;
		ResultSet rs = null;

		Map<String, String> hmProjectNameMap = new HashMap<String, String>();
		try {

			pst = con.prepareStatement("select * from projectmntnc");
			rs = pst.executeQuery();

			while (rs.next()) {
				hmProjectNameMap.put(rs.getString("pro_id"), rs.getString("pro_name"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmProjectNameMap;
	}

	public Map<String, String> getTravelPlanMap(Connection con) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmTravelPlanMap = new HashMap<String, String>();
		try {

			pst = con.prepareStatement("select * from emp_leave_entry where istravel = true");
			rs = pst.executeQuery();

			while (rs.next()) {
				hmTravelPlanMap.put(rs.getString("leave_id"), rs.getString("plan_name"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmTravelPlanMap;
	}

	public Map<String, String> getEmpAgeMap(CommonFunctions CF, Connection con) {
		PreparedStatement pst = null;
		ResultSet rs = null;

		Map<String, String> hmEmpAgeMap = new HashMap<String, String>();
		UtilityFunctions uF = new UtilityFunctions();

		try {

			pst = con.prepareStatement(selectEmpDetails);
			rs = pst.executeQuery();

			while (rs.next()) {

				String strDays = uF.dateDifference(rs.getString("emp_date_of_birth"), DBDATE, uF.getCurrentDate(CF.getStrTimeZone()) + "", DBDATE,
						CF.getStrTimeZone());
				double dblYears = uF.parseToDouble(strDays) / 365;
				hmEmpAgeMap.put(rs.getString("emp_per_id"), dblYears + "");
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmEmpAgeMap;
	}

	public void getHolidayList(Connection con, HttpServletRequest request, String strD1, String strD2, CommonFunctions CF, Map<String, String> hmHolidayDates,
			Map<String, String> hmHolidays, Map<String, String> hmWeekEnds, boolean isWithLocation) {

		PreparedStatement pst = null;
		ResultSet rs = null;

		try {

			if (strD1 != null && strD2 != null) {
				pst = con.prepareStatement(selectHolidaysR2);
				pst.setDate(1, uF.getDateFormat(strD1, DATE_FORMAT));
				pst.setDate(2, uF.getDateFormat(strD2, DATE_FORMAT));

			} else {
				pst = con.prepareStatement(selectHolidaysR1);
				pst.setInt(1, uF.parseToInt(uF.getDateFormat(uF.getCurrentDate(CF.getStrTimeZone()) + "", DBDATE, "yyyy")));

			}
			// System.out.println("pst======>"+pst);
			rs = pst.executeQuery();

			while (rs.next()) {

				if (isWithLocation) {
					if (hmHolidayDates != null
							&& !hmHolidayDates.containsKey(uF.getDateFormat(rs.getString("_date"), DBDATE, CF.getStrReportDateFormat()) + "_"
									+ rs.getString("wlocation_id"))
							&& !hmWeekEnds.containsKey(uF.getDateFormat(rs.getString("_date"), DBDATE, DATE_FORMAT) + "_" + rs.getString("wlocation_id"))) {
						hmHolidayDates.put(uF.getDateFormat(rs.getString("_date"), DBDATE, CF.getStrReportDateFormat()) + "_" + rs.getString("wlocation_id"),
								rs.getString("colour_code"));
						int count = uF.parseToInt(hmHolidays.get(rs.getString("wlocation_id")));
						hmHolidays.put(rs.getString("wlocation_id"), (count + 1) + "");
					}
				} else {
					if (hmHolidayDates != null && !hmHolidayDates.containsKey(uF.getDateFormat(rs.getString("_date"), DBDATE, CF.getStrReportDateFormat()))
							&& !hmWeekEnds.containsKey(uF.getDateFormat(rs.getString("_date"), DBDATE, DATE_FORMAT) + "_" + rs.getString("wlocation_id"))) {
						hmHolidayDates.put(uF.getDateFormat(rs.getString("_date"), DBDATE, CF.getStrReportDateFormat()), rs.getString("colour_code"));
						int count = uF.parseToInt(hmHolidays.get(rs.getString("wlocation_id")));
						hmHolidays.put(rs.getString("wlocation_id"), (count + 1) + "");
					}
				}

			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
	}

	public Map<String, Set<String>> getHolidayList(Connection con, HttpServletRequest request, UtilityFunctions uF, String strD1, String strD2) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, Set<String>> holidaysMp = new HashMap<String, Set<String>>();
		try {

			pst = con.prepareStatement(selectHolidaysR2);
			pst.setDate(1, uF.getDateFormat(strD1, DATE_FORMAT));
			pst.setDate(2, uF.getDateFormat(strD2, DATE_FORMAT));

			rs = pst.executeQuery();
			while (rs.next()) {
				Set<String> list = holidaysMp.get(rs.getString("wlocation_id"));
				if (list == null)
					list = new HashSet<String>();

				list.add(uF.getDateFormat(rs.getString("_date"), DBDATE, DATE_FORMAT));
				holidaysMp.put(rs.getString("wlocation_id"), list);
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return holidaysMp;
	}

	public void getHolidayList(Connection con, HttpServletRequest request, String strD1, String strD2, CommonFunctions CF, Map<String, String> hmHolidayDates,
			Map<String, String> hmHolidays, boolean isWithLocation) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		try {

			String strTimezone = "Asia/Calcutta";
			String strReportDateFormat = DATE_FORMAT_STR;
			if (CF.getStrTimeZone() != null) {
				strTimezone = CF.getStrTimeZone();
			}
			if (CF.getStrReportDateFormat() != null) {
				strReportDateFormat = CF.getStrReportDateFormat();
			}
			if (strD1 != null && strD2 != null) {
				pst = con.prepareStatement(selectHolidaysR2);
				pst.setDate(1, uF.getDateFormat(strD1, DATE_FORMAT));
				pst.setDate(2, uF.getDateFormat(strD2, DATE_FORMAT));
			} else {
				pst = con.prepareStatement(selectHolidaysR1);
				pst.setInt(1, uF.parseToInt(uF.getDateFormat(uF.getCurrentDate(strTimezone) + "", DBDATE, "yyyy")));
			}
			// System.out.println("pst======>"+pst);
			rs = pst.executeQuery();
			while (rs.next()) {
				if (isWithLocation) {
					if (hmHolidayDates != null
							&& !hmHolidayDates.containsKey(uF.getDateFormat(rs.getString("_date"), DBDATE, strReportDateFormat) + "_"
									+ rs.getString("wlocation_id"))) {
						hmHolidayDates.put(uF.getDateFormat(rs.getString("_date"), DBDATE, strReportDateFormat) + "_" + rs.getString("wlocation_id"),
								rs.getString("colour_code"));
						int count = uF.parseToInt(hmHolidays.get(rs.getString("wlocation_id")));
						hmHolidays.put(rs.getString("wlocation_id"), (count + 1) + "");
					}
				} else {
					if (hmHolidayDates != null && !hmHolidayDates.containsKey(uF.getDateFormat(rs.getString("_date"), DBDATE, strReportDateFormat))) {
						hmHolidayDates.put(uF.getDateFormat(rs.getString("_date"), DBDATE, strReportDateFormat), rs.getString("colour_code"));
						int count = uF.parseToInt(hmHolidays.get(rs.getString("wlocation_id")));
						hmHolidays.put(rs.getString("wlocation_id"), (count + 1) + "");
					}
				}
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
	}

	public void getHolidayList(String strD1, HttpServletRequest request, String strD2, CommonFunctions CF, Map<String, String> hmHolidayDates,
			Map<String, String> hmHolidays, boolean isWithLocation) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Connection con = null;
		Database db = new Database();
		db.setRequest(request);

		try {

			con = db.makeConnection(con);

			if (strD1 != null && strD2 != null) {
				pst = con.prepareStatement(selectHolidaysR2);
				pst.setDate(1, uF.getDateFormat(strD1, DATE_FORMAT));
				pst.setDate(2, uF.getDateFormat(strD2, DATE_FORMAT));

			} else {
				pst = con.prepareStatement(selectHolidaysR1);
				pst.setInt(1, uF.parseToInt(uF.getDateFormat(uF.getCurrentDate(CF.getStrTimeZone()) + "", DBDATE, "yyyy")));

			}
			// System.out.println("pst======>"+pst);
			rs = pst.executeQuery();

			while (rs.next()) {

				if (isWithLocation) {
					if (hmHolidayDates != null
							&& !hmHolidayDates.containsKey(uF.getDateFormat(rs.getString("_date"), DBDATE, CF.getStrReportDateFormat()) + "_"
									+ rs.getString("wlocation_id"))) {
						hmHolidayDates.put(uF.getDateFormat(rs.getString("_date"), DBDATE, CF.getStrReportDateFormat()) + "_" + rs.getString("wlocation_id"),
								rs.getString("colour_code"));
						int count = uF.parseToInt((String) hmHolidays.get(rs.getString("wlocation_id")));
						hmHolidays.put(rs.getString("wlocation_id"), (count + 1) + "");
					}
				} else {
					if (hmHolidayDates != null && !hmHolidayDates.containsKey(uF.getDateFormat(rs.getString("_date"), DBDATE, CF.getStrReportDateFormat()))) {
						hmHolidayDates.put(uF.getDateFormat(rs.getString("_date"), DBDATE, CF.getStrReportDateFormat()), rs.getString("colour_code"));
						int count = uF.parseToInt((String) hmHolidays.get(rs.getString("wlocation_id")));
						hmHolidays.put(rs.getString("wlocation_id"), (count + 1) + "");
					}
				}

			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			db.closeResultSet(rs);
			db.closeStatements(pst);
			db.closeConnection(con);
		}
	}

	public void getWLocationHolidayList(Connection con, UtilityFunctions uF, String strD1, String strD2, CommonFunctions CF,
			Map<String, Map<String, String>> hmWLocationHolidaysColour, Map<String, Map<String, String>> hmWLocationHolidaysName,
			Map<String, Map<String, String>> hmWLocationHolidaysWeekEnd) {

		Map<String, String> hmHolidaysColour = new HashMap<String, String>();
		Map<String, String> hmHolidaysName = new HashMap<String, String>();
		Map<String, String> hmHolidaysWeekEnd = new HashMap<String, String>();

		PreparedStatement pst = null;
		ResultSet rs = null;

		try {

			if (strD1 != null && strD2 != null) {
				pst = con
						.prepareStatement("select * from holidays h, work_location_info wi where wi.wlocation_id = h.wlocation_id and _date between ? and ? and (h.is_optional_holiday is null or h.is_optional_holiday=false) order by wi.wlocation_id");
				pst.setDate(1, uF.getDateFormat(strD1, DATE_FORMAT));
				pst.setDate(2, uF.getDateFormat(strD2, DATE_FORMAT));
			} else {
				// pst = con.prepareStatement(selectHolidaysR1);
				// pst.setInt(1,
				// uF.parseToInt(uF.getDateFormat(uF.getCurrentDate(CF.getStrTimeZone())
				// + "", DBDATE, "yyyy")));

				pst = con
						.prepareStatement("select * from holidays h, work_location_info wi where wi.wlocation_id = h.wlocation_id and (h.is_optional_holiday is null or h.is_optional_holiday=false) order by wi.wlocation_id");
			}
			// log.debug("pst===>" + pst);
			// System.out.println("=====+>" + pst);
			rs = pst.executeQuery();

			String strWLocationIdOld = null;
			String strWLocationIdNew = null;
			while (rs.next()) {

				strWLocationIdNew = rs.getString("wlocation_id");
				if (strWLocationIdNew != null && !strWLocationIdNew.equalsIgnoreCase(strWLocationIdOld)) {
					hmHolidaysColour = new HashMap<String, String>();
					hmHolidaysName = new HashMap<String, String>();
					hmHolidaysWeekEnd = new HashMap<String, String>();
				}

				hmHolidaysName.put(uF.getDateFormat(rs.getString("_date"), DBDATE, DATE_FORMAT), rs.getString("description"));
				hmHolidaysColour.put(uF.getDateFormat(rs.getString("_date"), DBDATE, DATE_FORMAT), rs.getString("colour_code"));

				if ("FD".equalsIgnoreCase(rs.getString("wlocation_weeklyofftype1")) || "FD".equalsIgnoreCase(rs.getString("wlocation_weeklyofftype2"))
						|| "FD".equalsIgnoreCase(rs.getString("wlocation_weeklyofftype3"))) {
					hmHolidaysWeekEnd.put(rs.getString("wlocation_weeklyoff1"), "H");
					hmHolidaysWeekEnd.put(rs.getString("wlocation_weeklyoff2"), "H");
					hmHolidaysWeekEnd.put(rs.getString("wlocation_weeklyoff3"), "H");
				}

				if (hmWLocationHolidaysColour != null) {
					hmWLocationHolidaysColour.put(strWLocationIdNew, hmHolidaysColour);
				}
				if (hmWLocationHolidaysName != null) {
					hmWLocationHolidaysName.put(strWLocationIdNew, hmHolidaysName);
				}
				if (hmWLocationHolidaysWeekEnd != null) {
					hmWLocationHolidaysWeekEnd.put(strWLocationIdNew, hmHolidaysWeekEnd);
				}

				strWLocationIdOld = strWLocationIdNew;
			}
			rs.close();
			pst.close();

			pst = con.prepareStatement("select * from work_location_info order by wlocation_id");
			rs = pst.executeQuery();
			while (rs.next()) {

				strWLocationIdNew = rs.getString("wlocation_id");
				if (strWLocationIdNew != null && strWLocationIdNew.equalsIgnoreCase(strWLocationIdOld)) {
					hmHolidaysWeekEnd = new HashMap<String, String>();
				}

				if ("FD".equalsIgnoreCase(rs.getString("wlocation_weeklyofftype1")) || "FD".equalsIgnoreCase(rs.getString("wlocation_weeklyofftype2"))
						|| "FD".equalsIgnoreCase(rs.getString("wlocation_weeklyofftype2")) || "FD".equalsIgnoreCase(rs.getString("wlocation_weeklyofftype3"))) {
					hmHolidaysWeekEnd.put(rs.getString("wlocation_weeklyoff1"), "H");
					hmHolidaysWeekEnd.put(rs.getString("wlocation_weeklyoff2"), "H");
					hmHolidaysWeekEnd.put(rs.getString("wlocation_weeklyoff3"), "H");
				}

				if (hmWLocationHolidaysWeekEnd != null) {
					hmWLocationHolidaysWeekEnd.put(strWLocationIdNew, hmHolidaysWeekEnd);
				}

				strWLocationIdOld = strWLocationIdNew;
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
	}

	public Map<String, String> getLunchDeductionServiceDetails(Connection con) {

		Map<String, String> hmLunchDeduction = new HashMap<String, String>();

		PreparedStatement pst = null;
		ResultSet rs = null;

		try {

			pst = con.prepareStatement(selectService);
			rs = pst.executeQuery();

			while (rs.next()) {
				hmLunchDeduction.put(rs.getString("service_id"), rs.getString("is_lunch_ded"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmLunchDeduction;
	}

	public Map<String, Map<String, String>> getDailyRatesDesignation(Connection con) {
		Map<String, Map<String, String>> hmPayrollPolicy = new HashMap<String, Map<String, String>>();

		PreparedStatement pst = null;
		ResultSet rs = null;
		try {
			pst = con.prepareStatement(selectPayrollPolicy);
			rs = pst.executeQuery();

			Map<String, String> hm = new HashMap<String, String>();
			while (rs.next()) {
				hm = new HashMap<String, String>();

				hm.put("MONDAY", rs.getString("monamount"));
				hm.put("TUESDAY", rs.getString("tuesamount"));
				hm.put("WEDNESDAY", rs.getString("wedamount"));
				hm.put("THURSDAY", rs.getString("thursamount"));
				hm.put("FRIDAY", rs.getString("friamount"));
				hm.put("SATURDAY", rs.getString("satamount"));
				hm.put("SUNDAY", rs.getString("sunamount"));
				hm.put("FIXED", rs.getString("fxdamount"));
				hm.put("PAYMODE", rs.getString("paymode"));
				hm.put("LOADING", rs.getString("loading"));

				hm.put("MON_LOADING", rs.getString("loading_mon"));
				hm.put("TUE_LOADING", rs.getString("loading_tue"));
				hm.put("WED_LOADING", rs.getString("loading_wed"));
				hm.put("THURS_LOADING", rs.getString("loading_thurs"));
				hm.put("FRI_LOADING", rs.getString("loading_fri"));
				hm.put("SAT_LOADING", rs.getString("loading_sat"));
				hm.put("SUN_LOADING", rs.getString("loading_sun"));

				hmPayrollPolicy.put(rs.getString("desig_id"), hm);
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmPayrollPolicy;
	}

	public Map<String, String> getEmpPayMode(Connection con) {
		Map<String, String> hmEmpPayMode = new HashMap<String, String>();

		PreparedStatement pst = null;
		ResultSet rs = null;
		try {

			pst = con.prepareStatement(selectPayrollPolicy1);
			rs = pst.executeQuery();
			while (rs.next()) {
				hmEmpPayMode.put("D" + rs.getString("desig_id") + "S" + rs.getString("service_id"), rs.getString("paymode"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmEmpPayMode;
	}

	public Map<String, String> getDesigMap(Connection con) {
		Map<String, String> hmCodeDesig = new HashMap<String, String>();

		PreparedStatement pst = null;
		ResultSet rs = null;

		try {

			pst = con.prepareStatement(selectDesig);
			rs = pst.executeQuery();
			while (rs.next()) {
				hmCodeDesig.put(rs.getString("designation_id"), rs.getString("designation_name"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmCodeDesig;
	}

	public Map<String, String> getClientDesigMap(Connection con) {
		Map<String, String> hmCodeDesig = new HashMap<String, String>();
		PreparedStatement pst = null;
		ResultSet rs = null;
		try {
			pst = con.prepareStatement("select * from client_designations");
			rs = pst.executeQuery();
			while (rs.next()) {
				hmCodeDesig.put(rs.getString("client_desig_id"), rs.getString("client_desig_name"));
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmCodeDesig;
	}

	public Map<String, String> getClientDepartMap(Connection con) {
		Map<String, String> hmCodeDesig = new HashMap<String, String>();
		PreparedStatement pst = null;
		ResultSet rs = null;
		try {
			pst = con.prepareStatement("select * from client_departments");
			rs = pst.executeQuery();
			while (rs.next()) {
				hmCodeDesig.put(rs.getString("client_depart_id"), rs.getString("client_depart_name"));
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmCodeDesig;
	}

	public Map<String, String> getClientLocationMap(Connection con) {
		Map<String, String> hmCodeDesig = new HashMap<String, String>();
		PreparedStatement pst = null;
		ResultSet rs = null;
		try {
			pst = con.prepareStatement("select * from client_locations");
			rs = pst.executeQuery();
			while (rs.next()) {
				hmCodeDesig.put(rs.getString("client_loc_id"), rs.getString("client_loc_name"));
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmCodeDesig;
	}

	public Map<String, String> getEmpDesigMap(Connection con) {
		Map<String, String> hmEmpCodeDesig = new HashMap<String, String>();

		PreparedStatement pst = null;
		ResultSet rs = null;

		try {

			pst = con.prepareStatement(selectEmployeeDesig);
			rs = pst.executeQuery();
			while (rs.next()) {
				hmEmpCodeDesig.put(rs.getString("emp_id"), rs.getString("designation_name"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmEmpCodeDesig;
	}

	public Map<String, String> getEmpDepartmentMap(Connection con) {
		Map<String, String> hmEmpDepartment = new HashMap<String, String>();
		ResultSet rs = null;
		PreparedStatement pst = null;

		try {

			pst = con
					.prepareStatement("SELECT * FROM employee_official_details eod, employee_personal_details epd WHERE epd.emp_per_id=eod.emp_id order by emp_id");
			rs = pst.executeQuery();
			while (rs.next()) {
				hmEmpDepartment.put(rs.getString("emp_id"), rs.getString("depart_id"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmEmpDepartment;
	}

	public Map<String, String> getAttendanceBasedEmpNameMap(Connection con, String struserType, String strEmpId, String strFinancialYearStart,
			String strFinancialYearEnd) {
		Map<String, String> hmEmpCodeName = new HashMap<String, String>();
		PreparedStatement pst = null;
		ResultSet rs = null;

		try {

			Map<String, String> hmFeatureStatus = getFeatureStatusMap(con);
			boolean flagMiddleName = uF.parseToBoolean(hmFeatureStatus.get(F_SHOW_EMPLOYEE_MIDDLE_NAME));

			if (struserType != null && (struserType.equalsIgnoreCase(ADMIN) || struserType.equalsIgnoreCase(CEO) || struserType.equalsIgnoreCase(CFO))) {
				pst = con.prepareStatement(selectEmployeeR3_Attendance);
				pst.setDate(1, uF.getDateFormat(strFinancialYearStart, DATE_FORMAT));
				pst.setDate(2, uF.getDateFormat(strFinancialYearEnd, DATE_FORMAT));
			} else if (struserType != null && (struserType.equalsIgnoreCase(HRMANAGER) || struserType.equalsIgnoreCase(ACCOUNTANT))) {
				pst = con.prepareStatement(selectEmployee_OName_HRManager_Attendance);
				pst.setInt(1, uF.parseToInt(strEmpId));
				pst.setDate(2, uF.getDateFormat(strFinancialYearStart, DATE_FORMAT));
				pst.setDate(3, uF.getDateFormat(strFinancialYearEnd, DATE_FORMAT));
			} else {
				pst = con.prepareStatement(selectEmployeeR3_Attendance);
				pst.setDate(1, uF.getDateFormat(strFinancialYearStart, DATE_FORMAT));
				pst.setDate(2, uF.getDateFormat(strFinancialYearEnd, DATE_FORMAT));
			}

			rs = pst.executeQuery();
			while (rs.next()) {
				if (rs.getInt("emp_id") < 0) {
					continue;
				}

				String strEmpMName = "";

				if (flagMiddleName) {
					if (rs.getString("emp_mname") != null && rs.getString("emp_mname").trim().length() > 0) {
						strEmpMName = " " + rs.getString("emp_mname");
					}
				}

				hmEmpCodeName.put(rs.getString("emp_id"), rs.getString("emp_fname") + strEmpMName + " " + rs.getString("emp_lname"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmEmpCodeName;
	}

	public Map<String, String> getEmpNameMap(String struserType, String strEmpId) {

		Map<String, String> hmEmpCodeName = new HashMap<String, String>();

		PreparedStatement pst = null;
		ResultSet rs = null;
		Connection con = null;
		Database db = new Database();
		db.setRequest(request);

		try {

			con = db.makeConnection(con);

			Map<String, String> hmFeatureStatus = getFeatureStatusMap(con);
			boolean flagMiddleName = uF.parseToBoolean(hmFeatureStatus.get(F_SHOW_EMPLOYEE_MIDDLE_NAME));

			if (struserType != null && (struserType.equalsIgnoreCase(ADMIN) || struserType.equalsIgnoreCase(CEO) || struserType.equalsIgnoreCase(CFO))) {
				pst = con.prepareStatement(selectEmployeeR31);
			} else if (struserType != null && (struserType.equalsIgnoreCase(HRMANAGER) || struserType.equalsIgnoreCase(ACCOUNTANT))) {
				pst = con.prepareStatement(selectEmployee_OName_HRManager);
				pst.setInt(1, uF.parseToInt(strEmpId));
			} else if (struserType != null && struserType.equalsIgnoreCase(MANAGER)) {
				pst = con.prepareStatement(selectEmployee_OName_Manager);
				pst.setInt(1, uF.parseToInt(strEmpId));
			} else {
				pst = con.prepareStatement(selectEmployeeR31);
			}

			rs = pst.executeQuery();
			while (rs.next()) {
				if (rs.getInt("emp_id") < 0) {
					continue;
				}

				String strEmpMName = "";

				if (flagMiddleName) {
					if (rs.getString("emp_mname") != null && rs.getString("emp_mname").trim().length() > 0) {
						strEmpMName = " " + rs.getString("emp_mname");
					}
				}

				hmEmpCodeName.put(rs.getString("emp_id"), rs.getString("emp_fname") + strEmpMName + " " + rs.getString("emp_lname"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			db.closeResultSet(rs);
			db.closeStatements(pst);
			db.closeConnection(con);
		}
		return hmEmpCodeName;
	}

	public Map<String, String> getEmpNameMap(Connection con, String struserType, String strEmpId) {

		Map<String, String> hmEmpCodeName = new HashMap<String, String>();

		Map<String, String> hmFeatureStatus = getFeatureStatusMap(con);
		boolean flagMiddleName = uF.parseToBoolean(hmFeatureStatus.get(F_SHOW_EMPLOYEE_MIDDLE_NAME));

		PreparedStatement pst = null;
		ResultSet rs = null;

		try {

			if (struserType != null && (struserType.equalsIgnoreCase(ADMIN) || struserType.equalsIgnoreCase(CEO) || struserType.equalsIgnoreCase(CFO))) {
				pst = con.prepareStatement(selectEmployeeR31);
			} else if (struserType != null && (struserType.equalsIgnoreCase(HRMANAGER) || struserType.equalsIgnoreCase(ACCOUNTANT))) {
				pst = con.prepareStatement(selectEmployee_OName_HRManager);
				pst.setInt(1, uF.parseToInt(strEmpId));
			} else if (struserType != null && struserType.equalsIgnoreCase(MANAGER)) {
				pst = con.prepareStatement(selectEmployee_OName_Manager);
				pst.setInt(1, uF.parseToInt(strEmpId));
			} else {
				pst = con.prepareStatement(selectEmployeeR31);
			}
			// System.out.println("pst=====>"+pst);
			rs = pst.executeQuery();
			while (rs.next()) {
				if (rs.getInt("emp_id") < 0) {
					continue;
				}

				// String strMiddleName = (rs.getString("emp_mname") != null &&
				// !rs.getString("emp_mname").trim().equals("")) ?
				// rs.getString("emp_mname").trim() + " " : "";

				String strMiddleName = "";

				if (flagMiddleName) {
					if (rs.getString("emp_mname") != null && rs.getString("emp_mname").trim().length() > 0) {
						strMiddleName = " " + rs.getString("emp_mname");
					}
				}

				String strEmpName = rs.getString("emp_fname") + uF.showData(strMiddleName, "") + " " + rs.getString("emp_lname");
				hmEmpCodeName.put(rs.getString("emp_id"), strEmpName);
				/* created by seema */
				if(rs.getString("emp_image")!=null) {
					hmEmpCodeName.put("empImage"+rs.getString("emp_id"), rs.getString("emp_image"));
				} else {
					hmEmpCodeName.put("empImage"+rs.getString("emp_id"), "");
				}
				/* created by seema */
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmEmpCodeName;
	}

	public void getEmpNameCodeMap(Connection con, String struserType, String strEmpId, Map<String, String> hmEmpCode, Map<String, String> hmEmpName) {

		PreparedStatement pst = null;
		ResultSet rs = null;

		try {

			Map<String, String> hmFeatureStatus = getFeatureStatusMap(con);
			boolean flagMiddleName = uF.parseToBoolean(hmFeatureStatus.get(F_SHOW_EMPLOYEE_MIDDLE_NAME));

			if (struserType != null && (struserType.equalsIgnoreCase(ADMIN) || struserType.equalsIgnoreCase(CEO) || struserType.equalsIgnoreCase(CFO))) {
				pst = con.prepareStatement(selectEmployeeR31);
			} else if (struserType != null && (struserType.equalsIgnoreCase(HRMANAGER) || struserType.equalsIgnoreCase(ACCOUNTANT))) {
				pst = con.prepareStatement(selectEmployee_OName_HRManager);
				pst.setInt(1, uF.parseToInt(strEmpId));
			} else if (struserType != null && struserType.equalsIgnoreCase(MANAGER)) {
				pst = con.prepareStatement(selectEmployee_OName_Manager);
				pst.setInt(1, uF.parseToInt(strEmpId));
			} else {
				pst = con.prepareStatement(selectEmployeeR31);
			}
			rs = pst.executeQuery();
			while (rs.next()) {
				if (rs.getInt("emp_id") < 0) {
					continue;
				}
				if (hmEmpName != null) {

					String strEmpMName = "";

					if (flagMiddleName) {
						if (rs.getString("emp_mname") != null && rs.getString("emp_mname").trim().length() > 0) {
							strEmpMName = " " + rs.getString("emp_mname");
						}
					}

					hmEmpName.put(rs.getString("emp_id"), rs.getString("emp_fname") + strEmpMName + " " + rs.getString("emp_lname"));
				}
				if (hmEmpCode != null) {
					hmEmpCode.put(rs.getString("emp_id"), rs.getString("empcode"));
				}
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
	}

	public Map<String, Map<String, String>> getEmpInfoMap(Connection con, boolean isFamilyInfo) {
		Map<String, Map<String, String>> hmEmpInfo = new HashMap<String, Map<String, String>>();

		PreparedStatement pst = null;
		ResultSet rs = null;

		try {

			Map<String, String> hmFeatureStatus = getFeatureStatusMap(con);
			boolean flagMiddleName = uF.parseToBoolean(hmFeatureStatus.get(F_SHOW_EMPLOYEE_MIDDLE_NAME));

			Map<String, String> hmEmpInner = new HashMap<String, String>();

			if (isFamilyInfo) {
				pst = con.prepareStatement("select * from emp_family_members order by emp_id");
				rs = pst.executeQuery();
				while (rs.next()) {

					hmEmpInner = hmEmpInfo.get(rs.getString("emp_id"));
					if (hmEmpInner == null)
						hmEmpInner = new HashMap<String, String>();

					hmEmpInner.put(rs.getString("member_type"), rs.getString("member_name"));
					hmEmpInfo.put(rs.getString("emp_id"), hmEmpInner);
				}
				rs.close();
				pst.close();
			}

			pst = con.prepareStatement(selectEmployeeR31);
			rs = pst.executeQuery();
			// System.out.println("pst ===>> " + pst);
			while (rs.next()) {
				if (rs.getInt("emp_id") < 0) {
					continue;
				}

				String strEmpMName = "";
				if (flagMiddleName) {
					if (rs.getString("emp_mname") != null && rs.getString("emp_mname").trim().length() > 0) {
						strEmpMName = " " + rs.getString("emp_mname");
					}
				}

				hmEmpInner = hmEmpInfo.get(rs.getString("emp_id"));
				if (hmEmpInner == null)
					hmEmpInner = new HashMap<String, String>();

				hmEmpInner.put("SALUTATION", rs.getString("salutation"));// 0
				hmEmpInner.put("FNAME", rs.getString("emp_fname"));// 1
				hmEmpInner.put("MNAME", rs.getString("emp_mname"));// 2
				hmEmpInner.put("LNAME", rs.getString("emp_lname"));// 3
				hmEmpInner.put("FULLNAME", rs.getString("emp_fname") + strEmpMName + " " + rs.getString("emp_lname"));// 4
				hmEmpInner.put("EMPCODE", rs.getString("empcode"));// 5
				hmEmpInner.put("IMAGE", rs.getString("emp_image"));// 6
				hmEmpInner.put("EMAIL", rs.getString("emp_email"));// 7
				hmEmpInner.put("DOB", rs.getString("emp_date_of_birth"));// 8
				hmEmpInner.put("JOINING_DATE", rs.getString("joining_date"));// 9
				hmEmpInner.put("END_DATE", rs.getString("employment_end_date"));// 10
				hmEmpInner.put("EPF_NO", rs.getString("emp_pf_no"));// 11
				hmEmpInner.put("GENDER", rs.getString("emp_gender"));// 12
				hmEmpInner.put("MARITAL_STATUS", rs.getString("marital_status"));// 13
				hmEmpInner.put("CONTACT_NO", rs.getString("emp_contactno"));// 14
				hmEmpInner.put("EMP_MOB_NO", rs.getString("emp_contactno_mob"));// 15

				hmEmpInfo.put(rs.getString("emp_id"), hmEmpInner);
			}
			rs.close();
			pst.close();
			
			pst = con.prepareStatement("select * from emp_off_board where approved_1=1 and approved_2=1 order by emp_id");
			rs = pst.executeQuery();
			while (rs.next()) {
				hmEmpInner = hmEmpInfo.get(rs.getString("emp_id"));
				if (hmEmpInner == null)
					hmEmpInner = new HashMap<String, String>();
				if(hmEmpInner.get("END_DATE")==null || hmEmpInner.get("END_DATE").equals("")) {
					hmEmpInner.put("END_DATE", rs.getString("last_day_date"));
				}
				hmEmpInfo.put(rs.getString("emp_id"), hmEmpInner);
			}
			rs.close();
			pst.close();
			
			// System.out.println("hmEmpInfo ==== ===>> " + hmEmpInfo);
		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmEmpInfo;
	}

	public Map<String, Map<String, String>> getCandiInfoMap(Connection con, boolean isFamilyInfo) {
		Map<String, Map<String, String>> hmCandiInfo = new HashMap<String, Map<String, String>>();
		UtilityFunctions uF = new UtilityFunctions();
		PreparedStatement pst = null;
		ResultSet rs = null;
		try {

			Map<String, String> hmFeatureStatus = getFeatureStatusMap(con);
			boolean flagMiddleName = uF.parseToBoolean(hmFeatureStatus.get(F_SHOW_EMPLOYEE_MIDDLE_NAME));

			Map<String, String> hmCandiInner = new HashMap<String, String>();
			if (isFamilyInfo) {
				pst = con.prepareStatement("select * from candidate_family_members order by emp_id");
				rs = pst.executeQuery();
				while (rs.next()) {

					hmCandiInner = hmCandiInfo.get(rs.getString("emp_id"));
					if (hmCandiInner == null)
						hmCandiInner = new HashMap<String, String>();

					hmCandiInner.put(rs.getString("member_type"), rs.getString("member_name"));
					hmCandiInfo.put(rs.getString("emp_id"), hmCandiInner);
				}
				rs.close();
				pst.close();
			}

			pst = con
					.prepareStatement("SELECT cpd.emp_per_id, cpd.salutation, cpd.emp_fname,cpd.emp_mname, cpd.emp_lname, cpd.empcode, cpd.emp_image, cpd.emp_email, "
							+ "cpd.emp_date_of_birth, cad.candidate_joining_date, cpd.emp_gender, cpd.marital_status, cad.ctc_offered, cad.annual_ctc_offered FROM "
							+ "candidate_personal_details cpd, candidate_application_details cad where cpd.emp_per_id = cad.candidate_id order by emp_per_id");
			rs = pst.executeQuery();
			// System.out.println("new Date ===> " + new Date());
			while (rs.next()) {
				if (rs.getInt("emp_per_id") < 0) {
					continue;
				}

				String strEmpMName = "";

				if (flagMiddleName) {
					if (rs.getString("emp_mname") != null && rs.getString("emp_mname").trim().length() > 0) {
						strEmpMName = " " + rs.getString("emp_mname");
					}
				}

				hmCandiInner = hmCandiInfo.get(rs.getString("emp_per_id"));
				if (hmCandiInner == null)
					hmCandiInner = new HashMap<String, String>();
				hmCandiInner.put("SALUTATION", rs.getString("salutation"));
				hmCandiInner.put("CANDI_ID", rs.getString("emp_per_id"));
				hmCandiInner.put("FNAME", rs.getString("emp_fname"));
				hmCandiInner.put("LNAME", rs.getString("emp_lname"));
				hmCandiInner.put("FULLNAME", rs.getString("emp_fname") + strEmpMName + " " + rs.getString("emp_lname"));
				hmCandiInner.put("EMPCODE", rs.getString("empcode"));
				hmCandiInner.put("IMAGE", rs.getString("emp_image"));
				hmCandiInner.put("EMAIL", rs.getString("emp_email"));
				hmCandiInner.put("DOB", rs.getString("emp_date_of_birth"));
				// System.out.println("candidate_joining_date ===>> " +
				// rs.getString("candidate_joining_date"));
				if (rs.getString("candidate_joining_date") != null && !rs.getString("candidate_joining_date").equals("")) {
					hmCandiInner.put("JOINING_DATE", uF.getDateFormat(rs.getString("candidate_joining_date"), DBDATE, getStrReportDateFormat()));
				} else {
					hmCandiInner.put("JOINING_DATE", "-");
				}
				hmCandiInner.put("GENDER", rs.getString("emp_gender"));
				hmCandiInner.put("MARITAL_STATUS", rs.getString("marital_status"));
				hmCandiInner.put("OFFERED_CTC", rs.getString("ctc_offered"));
				hmCandiInner.put("OFFERED_ANNUAL_CTC", rs.getString("annual_ctc_offered"));

				hmCandiInfo.put(rs.getString("emp_per_id"), hmCandiInner);
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmCandiInfo;
	}

	public Map<String, String> getEmpProfileImage(Connection con) {

		Map<String, String> hmEmpProgileImage = new HashMap<String, String>();

		PreparedStatement pst = null;
		ResultSet rs = null;

		try {
			pst = con.prepareStatement(selectEmployeeR3);
			rs = pst.executeQuery();
			while (rs.next()) {
				if (rs.getInt("emp_id") < 0) {
					continue;
				}

				hmEmpProgileImage.put(rs.getString("emp_id"), rs.getString("emp_image"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmEmpProgileImage;
	}

	public Map<String, String> getExistingEmpNameMap(Connection con) {
		Map<String, String> hmEmpCodeName = new LinkedHashMap<String, String>();
		PreparedStatement pst = null;
		ResultSet rs = null;
		try {

			Map<String, String> hmFeatureStatus = getFeatureStatusMap(con);
			boolean flagMiddleName = uF.parseToBoolean(hmFeatureStatus.get(F_SHOW_EMPLOYEE_MIDDLE_NAME));
			pst = con.prepareStatement(selectActualEmployees);
			// log.debug("pst===>" + pst);
			rs = pst.executeQuery();
			while (rs.next()) {
				if (rs.getInt("emp_id") < 0) {
					continue;
				}

				String strEmpMName = "";

				if (flagMiddleName) {
					if (rs.getString("emp_mname") != null && rs.getString("emp_mname").trim().length() > 0) {
						strEmpMName = " " + rs.getString("emp_mname");
					}
				}

				hmEmpCodeName.put(rs.getString("emp_id"), rs.getString("emp_fname") + strEmpMName + " " + rs.getString("emp_lname"));
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmEmpCodeName;
	}

	public Map<String, String> getEmpCodeMap(Connection con) {
		Map<String, String> hmEmpCode = new HashMap<String, String>();

		PreparedStatement pst = null;
		ResultSet rs = null;

		try {

			pst = con.prepareStatement(selectEmployeeR3);
			rs = pst.executeQuery();
			while (rs.next()) {
				hmEmpCode.put(rs.getString("emp_id"), rs.getString("empcode"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmEmpCode;
	}

	public Map<String, String> getEmpCodeMap1(Connection con) {
		Map<String, String> hmEmpCode = new HashMap<String, String>();

		PreparedStatement pst = null;
		ResultSet rs = null;
		try {
			pst = con.prepareStatement(selectEmployeeR3);
			rs = pst.executeQuery();
			while (rs.next()) {
				hmEmpCode.put(rs.getString("empcode"), rs.getString("emp_id"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmEmpCode;
	}

	public Map<String, String> getEmpJoiningDateMap(Connection con, UtilityFunctions uF) {
		Map<String, String> hmEmpJoiningDate = new HashMap<String, String>();

		PreparedStatement pst = null;
		ResultSet rs = null;

		try {
			pst = con.prepareStatement(selectEmployeeR3);
			rs = pst.executeQuery();
			while (rs.next()) {
				hmEmpJoiningDate.put(rs.getString("emp_id"), uF.getDateFormat(rs.getString("joining_date"), DBDATE, DATE_FORMAT));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmEmpJoiningDate;
	}

	public Map<String, String> getEmpJoiningDateMap(Connection con, UtilityFunctions uF, Map<String, String> hmEmpEndDateMap) {
		Map<String, String> hmEmpJoiningDate = new HashMap<String, String>();

		PreparedStatement pst = null;
		ResultSet rs = null;

		try {

			pst = con.prepareStatement(selectEmployeeR3);
			rs = pst.executeQuery();
			while (rs.next()) {
				hmEmpJoiningDate.put(rs.getString("emp_id"), uF.getDateFormat(rs.getString("joining_date"), DBDATE, DATE_FORMAT));
				if (rs.getString("employment_end_date") != null) {
					hmEmpEndDateMap.put(rs.getString("emp_id"), uF.getDateFormat(rs.getString("employment_end_date"), DBDATE, DATE_FORMAT));
				}
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmEmpJoiningDate;
	}

	public Map<String, String> getLoanPoliciesMap(Connection con, UtilityFunctions uF, String strOrgId) {
		Map<String, String> hmLoanPoliciesMap = new HashMap<String, String>();

		PreparedStatement pst = null;
		ResultSet rs = null;
		try {
			pst = con.prepareStatement(selectLoanDetails2);
			pst.setInt(1, uF.parseToInt(strOrgId));
			rs = pst.executeQuery();
			while (rs.next()) {
				hmLoanPoliciesMap.put(rs.getString("loan_id"), rs.getString("loan_code"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmLoanPoliciesMap;
	}

	public void getLoanPayrollDetails(Connection con, UtilityFunctions uF, List<String> alLoans, Map<String, Map<String, String>> hmEmpLoan, String strD1,
			String strD2, Map<String, String> hmEmpSalLastEffectiveDate) {
		PreparedStatement pst = null;
		ResultSet rs = null;

		try {
			Map<String, String> hmEmpLoanInner = new HashMap<String, String>();

			pst = con.prepareStatement(selectLoanDetails3);
			pst.setDate(1, uF.getDateFormat(strD1, DATE_FORMAT));
			pst.setDate(2, uF.getDateFormat(strD2, DATE_FORMAT));
			pst.setString(3, "S");
			rs = pst.executeQuery();

			while (rs.next()) {
				String strEffectiveDate = "";
				if (hmEmpSalLastEffectiveDate != null && hmEmpSalLastEffectiveDate.get(rs.getString("emp_id")) != null
						&& !hmEmpSalLastEffectiveDate.get(rs.getString("emp_id")).equals("")) {
					strEffectiveDate = "_" + hmEmpSalLastEffectiveDate.get(rs.getString("emp_id"));
				}
				hmEmpLoanInner = hmEmpLoan.get(rs.getString("emp_id") + strEffectiveDate);
				if (hmEmpLoanInner == null)
					hmEmpLoanInner = new HashMap<String, String>();
				double loanAmt = uF.parseToDouble(rs.getString("amount_paid"));
				if (hmEmpLoanInner != null) {
					loanAmt += uF.parseToDouble(hmEmpLoanInner.get(rs.getString("loan_id")));
				}
				// hmEmpLoanInner.put(rs.getString("loan_id"),
				// uF.formatIntoTwoDecimal(uF.parseToDouble(rs.getString("amount_paid"))));
				hmEmpLoanInner.put(rs.getString("loan_id"), uF.formatIntoTwoDecimal(loanAmt));
				hmEmpLoan.put(rs.getString("emp_id") + strEffectiveDate, hmEmpLoanInner);

				if (!alLoans.contains(rs.getString("loan_id"))) {
					alLoans.add(rs.getString("loan_id"));
				}
			}
			rs.close();
			pst.close();

			// System.out.println("464 hmEmpLoan====>> " + hmEmpLoan);

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
	}

	public Map<String, String> getEmpProbationEndDateMap(Connection con, UtilityFunctions uF) {
		Map<String, String> hmEmpProbationEnd = new HashMap<String, String>();

		PreparedStatement pst = null;
		ResultSet rs = null;

		try {

			pst = con.prepareStatement("select * from probation_policy");
			rs = pst.executeQuery();
			while (rs.next()) {
				hmEmpProbationEnd.put(rs.getString("emp_id"), uF.getDateFormat(rs.getString("probation_end_date"), DBDATE, DATE_FORMAT));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmEmpProbationEnd;
	}

	public Map<String, String> getEmpEmailMap(Connection con) {
		Map<String, String> hmEmpCodeEmail = new HashMap<String, String>();

		PreparedStatement pst = null;
		ResultSet rs = null;
		try {
			pst = con.prepareStatement(selectEmployeeR3);
			rs = pst.executeQuery();
			while (rs.next()) {
				hmEmpCodeEmail.put(rs.getString("emp_id"), rs.getString("emp_email"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmEmpCodeEmail;
	}

	public Map<String, String> getEmpContactNoMap(Connection con) {
		Map<String, String> hmEmpCodeContactNo = new HashMap<String, String>();

		PreparedStatement pst = null;
		ResultSet rs = null;
		try {
			pst = con.prepareStatement(selectEmployeeR3);
			rs = pst.executeQuery();
			while (rs.next()) {
				hmEmpCodeContactNo.put(rs.getString("emp_id"), rs.getString("emp_contactno"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmEmpCodeContactNo;
	}

	public double getDeductionAmountMap(Connection con, double dblIncomeAmount) {

		double dblDedAmount = 0.0d;

		PreparedStatement pst = null;
		ResultSet rs = null;
		try {

			pst = con.prepareStatement(selectDeductionR1);
			pst.setDouble(1, dblIncomeAmount);
			pst.setDouble(2, dblIncomeAmount);

			rs = pst.executeQuery();
			if (rs.next()) {
				dblDedAmount = rs.getDouble("deduction_amount");
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return dblDedAmount;
	}

	public Map<String, String> getEmpTypeMap(Connection con) {

		Map<String, String> hmEmpType = new HashMap<String, String>();

		PreparedStatement pst = null;
		ResultSet rs = null;

		try {

			pst = con.prepareStatement(selectEmployeeR1);
			pst.setBoolean(1, true);
			pst.setBoolean(2, true);

			rs = pst.executeQuery();
			while (rs.next()) {
				hmEmpType.put(rs.getString("emp_id"), rs.getString("emptype"));
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmEmpType;
	}

	public Map<String, String> getServicesMap(Connection con, boolean isByServiceCode) {

		Map<String, String> hmServices = new HashMap<String, String>();
		PreparedStatement pst = null;
		ResultSet rs = null;

		try {

			// System.out.println("==++OPEN===");
			pst = con.prepareStatement(selectServiceR);
			rs = pst.executeQuery();

			//
			// cst = con.prepareStatement("{? = call sel_service()}");
			// cst.registerOutParameter(1, Types.OTHER);
			// cst.execute();
			// rs = (ResultSet) cst.getObject(1);

			while (rs.next()) {
				if (isByServiceCode) {
					hmServices.put(rs.getString("service_id"), rs.getString("service_code"));
				} else {
					hmServices.put(rs.getString("service_id"), rs.getString("service_name"));
				}
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmServices;
	}

	public Map<String, String> getProjectServicesMap(Connection con, boolean isByServiceCode) {

		Map<String, String> hmServices = new HashMap<String, String>();
		PreparedStatement pst = null;
		ResultSet rs = null;
		try {

			pst = con.prepareStatement("select * from services_project  order by service_name");
			rs = pst.executeQuery();
			while (rs.next()) {
				if (isByServiceCode) {
					hmServices.put(rs.getString("service_project_id"), rs.getString("service_name"));
				} else {
					hmServices.put(rs.getString("service_project_id"), rs.getString("service_name"));
				}
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmServices;
	}

	public void getRosterHoursMap(Connection con, Date dtMin, Date dtMax, Map<String, Map<String, String>> hmRosterHours,
			Map<String, Map<String, String>> hmRosterServices) {

		Map<String, String> hmHoursInner = new HashMap<String, String>();
		Map<String, String> hmServicesInner = new HashMap<String, String>();

		PreparedStatement pst = null;
		ResultSet rs = null;

		try {

			pst = con.prepareStatement(selectRosterHSDetails);
			pst.setDate(1, dtMin);
			pst.setDate(2, dtMax);

			rs = pst.executeQuery();

			String strOldEmpId = null;
			String strNewEmpId = null;
			while (rs.next()) {

				strNewEmpId = rs.getString("emp_id");

				if (strNewEmpId != null && !strNewEmpId.equalsIgnoreCase(strOldEmpId)) {
					hmHoursInner = new HashMap<String, String>();
					hmServicesInner = new HashMap<String, String>();
				}
				hmHoursInner.put(
						new UtilityFunctions().getDateFormat(rs.getString("_date"), DBDATE, CF.getStrReportDateFormat()) + "_" + rs.getString("service_id"),
						uF.formatIntoTwoDecimal(uF.parseToDouble(rs.getString("actual_hours"))));
				hmServicesInner.put(new UtilityFunctions().getDateFormat(rs.getString("_date"), DBDATE, CF.getStrReportDateFormat()),
						rs.getString("service_name"));

				hmRosterHours.put(rs.getString("emp_id"), hmHoursInner);
				hmRosterServices.put(rs.getString("emp_id"), hmServicesInner);

				strOldEmpId = strNewEmpId;
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
	}

	public Map<String, String> getEmpTravelEligibility(Connection con, UtilityFunctions uF) {

		Map<String, String> hmEmpTravelEligibility = new HashMap<String, String>();

		PreparedStatement pst = null;
		ResultSet rs = null;

		try {

			pst = con.prepareStatement("select * from travel_advance_eligibility");
			rs = pst.executeQuery();

			while (rs.next()) {
				if (uF.parseToBoolean(rs.getString("is_eligible"))) {
					hmEmpTravelEligibility.put(rs.getString("emp_id"),
							uF.formatIntoTwoDecimalWithOutComma(uF.parseToDouble(rs.getString("eligibility_amount"))));
				}
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmEmpTravelEligibility;
	}

	public void getEarlyLateReporting(Connection con, Date dtMin, Date dtMax, Map<String, Map<String, String>> hmEarlyLate) {

		Map<String, String> hmEarlyLateInner = new HashMap<String, String>();
		UtilityFunctions uF = new UtilityFunctions();

		PreparedStatement pst = null;
		ResultSet rs = null;

		try {

			Map<String, String> hmTardyType = CF.getTardyType(con);
			double dblTardyIn = uF.parseToDouble(hmTardyType.get("TARDY_IN"));
			double dblTardyOut = uF.parseToDouble(hmTardyType.get("TARDY_OUT"));

			pst = con.prepareStatement(selectEarlyLateEntries);
			pst.setDate(1, dtMin);
			pst.setDate(2, dtMax);
			rs = pst.executeQuery();
			String strServiceId = null;
			String strOldEmpId = null;
			String strNewEmpId = null;
			String strDate = null;
			while (rs.next()) {

				strNewEmpId = rs.getString("emp_id");
				strServiceId = rs.getString("service_id");
				strDate = uF.getDateFormat(rs.getString("in_out_timestamp"), DBTIMESTAMP, CF.getStrReportDateFormat());

				if (strNewEmpId != null && !strNewEmpId.equalsIgnoreCase(strOldEmpId)) {
					hmEarlyLateInner = new HashMap<String, String>();
				}

				double nStatus = rs.getDouble("early_late");

				if (rs.getString("in_out") != null && rs.getString("in_out").equalsIgnoreCase("IN") && nStatus != 0) {
					if (rs.getInt("approved") == -2) {

						if (strNewEmpId != null && strNewEmpId.equalsIgnoreCase("251")) {
						}

						if ((rs.getDouble("early_late") < 0 && rs.getDouble("early_late") < uF.convertMinutesIntoHours(dblTardyIn))
								|| rs.getDouble("early_late") > 0) {
							hmEarlyLateInner.put(
									new UtilityFunctions().getDateFormat(rs.getString("in_out_timestamp"), DBTIMESTAMP, CF.getStrReportDateFormat()) + "_"
											+ strServiceId, "<a href=\"UpdateClockEntries.action?EMPID=" + strNewEmpId + "&PAY=Y&D1=" + strDate + "&D2="
											+ strDate + "&SID=" + strServiceId + " \"><div title=\"Came office " + ((nStatus > 0) ? "late" : "early") + " by "
											+ Math.abs(rs.getDouble("early_late")) + " hrs\" class=\"late_mark\"></div></a>");
						}
					}

					// if (!hmEarlyLate.containsKey(rs.getString("emp_id"))) {
					hmEarlyLate.put(rs.getString("emp_id"), hmEarlyLateInner);
					// }

				} else if (rs.getString("in_out") != null && rs.getString("in_out").equalsIgnoreCase("OUT") && nStatus != 0) {
					if (rs.getInt("approved") == -2) {

						if (uF.convertMinutesIntoHours(Math.abs(dblTardyOut)) < rs.getDouble("early_late") || rs.getDouble("early_late") < 0) {
							hmEarlyLateInner.put(
									new UtilityFunctions().getDateFormat(rs.getString("in_out_timestamp"), DBTIMESTAMP, CF.getStrReportDateFormat()) + "_"
											+ strServiceId, "<a href=\"UpdateClockEntries.action?EMPID=" + strNewEmpId + "&PAY=Y&D1=" + strDate + "&D2="
											+ strDate + "&SID=" + strServiceId + " \"><div title=\"Left office " + ((nStatus > 0) ? "late" : "early") + " by "
											+ Math.abs(rs.getDouble("early_late")) + " hrs\" class=\"late_mark\"></div></a>");

						}
					}

					// if (!hmEarlyLate.containsKey(rs.getString("emp_id"))) {
					hmEarlyLate.put(rs.getString("emp_id"), hmEarlyLateInner);
					// }
				}

				strOldEmpId = strNewEmpId;

			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
	}

	public void getEarlyLateReporting(Connection con, String dtMin, String dtMax, Map<String, Map<String, String>> hmEarlyLate) {

		Map<String, String> hmEarlyLateInner = new HashMap<String, String>();
		UtilityFunctions uF = new UtilityFunctions();
		PreparedStatement pst = null;
		ResultSet rs = null;

		try {

			Map<String, String> hmTardyType = CF.getTardyType(con);
			double dblTardyIn = uF.parseToDouble(hmTardyType.get("TARDY_IN"));
			double dblTardyOut = uF.parseToDouble(hmTardyType.get("TARDY_OUT"));

			pst = con.prepareStatement(selectEarlyLateEntries);
			pst.setDate(1, uF.getDateFormat(dtMin, DATE_FORMAT));
			pst.setDate(2, uF.getDateFormat(dtMax, DATE_FORMAT));

			rs = pst.executeQuery();

			log.debug("pst=" + pst);

			String strOldEmpId = null;
			String strNewEmpId = null;
			String strDate = null;
			while (rs.next()) {

				strNewEmpId = rs.getString("emp_id");
				strDate = uF.getDateFormat(rs.getString("in_out_timestamp"), DBTIMESTAMP, CF.getStrReportDateFormat());

				if (strNewEmpId != null && !strNewEmpId.equalsIgnoreCase(strOldEmpId)) {
					hmEarlyLateInner = new HashMap<String, String>();
				}

				if (rs.getString("in_out") != null && rs.getString("in_out").equalsIgnoreCase("IN")) {
					if (rs.getInt("approved") == -2) {

						if ((rs.getDouble("early_late") < 0 && rs.getDouble("early_late") < uF.convertMinutesIntoHours(dblTardyIn))
								|| rs.getDouble("early_late") > 0) {
							hmEarlyLateInner.put(
									new UtilityFunctions().getDateFormat(rs.getString("in_out_timestamp"), DBTIMESTAMP, CF.getStrReportDateFormat()),
									"<a href=\"UpdateClockEntries.action?EMPID=" + strNewEmpId + "&PAY=Y&D1=" + strDate + "&D2=" + strDate
											+ " \"><div title=\"Came office early by " + Math.abs(rs.getDouble("early_late"))
											+ " hrs\" class=\"late_mark\"></div></a>");
						}
					}

					if (!hmEarlyLate.containsKey(rs.getString("emp_id"))) {
						hmEarlyLate.put(rs.getString("emp_id"), hmEarlyLateInner);
					}

				} else if (rs.getString("in_out") != null && rs.getString("in_out").equalsIgnoreCase("OUT")) {
					if (rs.getInt("approved") == -2) {
						if (uF.convertMinutesIntoHours(dblTardyOut) < Math.abs(rs.getDouble("early_late")) || rs.getDouble("early_late") < 0) {
							hmEarlyLateInner.put(
									new UtilityFunctions().getDateFormat(rs.getString("in_out_timestamp"), DBTIMESTAMP, CF.getStrReportDateFormat()),
									"<a href=\"UpdateClockEntries.action?EMPID=" + strNewEmpId + "&PAY=Y&D1=" + strDate + "&D2=" + strDate
											+ " \"><div title=\"Left office early by " + Math.abs(rs.getDouble("early_late"))
											+ " hrs\" class=\"late_mark\"></div></a>");

						}
					}

					if (!hmEarlyLate.containsKey(rs.getString("emp_id"))) {
						hmEarlyLate.put(rs.getString("emp_id"), hmEarlyLateInner);
					}
				}

				strOldEmpId = strNewEmpId;
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
	}

	public void getRosterServicesIDList(Connection con, CommonFunctions CF, String strMin, String strMax, Map<String, String> hmServiceName,
			Map<String, Map<String, String>> hmServiceId, List<String> alServiceId) {

		Map<String, String> hmServiceIdInner = new HashMap<String, String>();

		PreparedStatement pst = null;
		ResultSet rs = null;

		try {

			String strReportDateFormat = DATE_FORMAT_STR;
			if (CF.getStrReportDateFormat() != null) {
				strReportDateFormat = CF.getStrReportDateFormat();
			}
			pst = con.prepareStatement(selectRosterHSDetails);
			pst.setDate(1, uF.getDateFormat(strMin, DATE_FORMAT));
			pst.setDate(2, uF.getDateFormat(strMax, DATE_FORMAT));

			rs = pst.executeQuery();

			String strOldEmpId = null;
			String strNewEmpId = null;
			while (rs.next()) {

				strNewEmpId = rs.getString("emp_id");

				if (strNewEmpId != null && !strNewEmpId.equalsIgnoreCase(strOldEmpId)) {
					hmServiceIdInner = new HashMap<String, String>();
				}

				hmServiceIdInner.put(uF.getDateFormat(rs.getString("_date"), DBDATE, strReportDateFormat), rs.getString("service_id"));

				hmServiceName.put(rs.getString("service_id"), rs.getString("service_name"));

				hmServiceId.put(rs.getString("emp_id"), hmServiceIdInner);

				if (alServiceId != null && !alServiceId.contains(rs.getString("service_id"))) {
					alServiceId.add(rs.getString("service_id"));
				}

				strOldEmpId = strNewEmpId;

			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
	}

	public Map<String, String> getESIDetailsMap(Connection con, UtilityFunctions uF, Map<String, String> hmESIDetailsMap, String strFinancialYearStart,
			String strFinancialYearEnd, int nLevelId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		try {
			pst = con
					.prepareStatement("select * from esi_details esd inner join level_details ld on esd.org_id= ld.org_id where financial_year_start=? and financial_year_end=?  and ld.level_id=?");
			pst.setDate(1, uF.getDateFormat(strFinancialYearStart, DATE_FORMAT));
			pst.setDate(2, uF.getDateFormat(strFinancialYearEnd, DATE_FORMAT));
			pst.setInt(3, nLevelId);
			// System.out.println("pst====>" + pst);
			rs = pst.executeQuery();
			while (rs.next()) {
				hmESIDetailsMap.put("EE_CONTRIBUTION", rs.getString("eesi_contribution"));
				hmESIDetailsMap.put("ER_CONTRIBUTION", rs.getString("ersi_contribution"));
				hmESIDetailsMap.put("SALARY_HEAD_ID", rs.getString("salary_head_id"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

		return hmESIDetailsMap;
	}

	public void getEPFDetailsMap(Connection con, Map<String, String> hmEPFDetailsMap, String strFinancialYearStart, String strFinancialYearEnd) {

		PreparedStatement pst = null;
		ResultSet rs = null;

		try {

			pst = con.prepareStatement("select * from epf_details where financial_year_start=? and financial_year_end=?");
			pst.setDate(1, uF.getDateFormat(strFinancialYearStart, DATE_FORMAT));
			pst.setDate(2, uF.getDateFormat(strFinancialYearEnd, DATE_FORMAT));

			rs = pst.executeQuery();
			while (rs.next()) {

				hmEPFDetailsMap.put("EEPF_CONTRIBUTION", rs.getString("eepf_contribution"));
				hmEPFDetailsMap.put("ERPF_CONTRIBUTION", rs.getString("erpf_contribution"));
				hmEPFDetailsMap.put("ERPS_CONTRIBUTION", rs.getString("erps_contribution"));
				hmEPFDetailsMap.put("ERDLI_CONTRIBUTION", rs.getString("erdli_contribution"));

				hmEPFDetailsMap.put("EPF_ADMIN_CHARGES", rs.getString("pf_admin_charges"));
				hmEPFDetailsMap.put("EDLI_ADMIN_CHARGES", rs.getString("edli_admin_charges"));

				hmEPFDetailsMap.put("EPF_MAX_LIMIT", rs.getString("epf_max_limit"));
				hmEPFDetailsMap.put("EPS_MAX_LIMIT", rs.getString("eps_max_limit"));
				hmEPFDetailsMap.put("EDLI_MAX_LIMIT", rs.getString("edli_max_limit"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
	}

	public void getAllowanceMap(Connection con, Map<String, String> hmFirstAidAllowance) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		try {
			pst = con.prepareStatement(selectEmployeeR6);
			rs = pst.executeQuery();
			while (rs.next()) {
				if (uF.parseToBoolean(rs.getString("first_aid_allowance"))) {
					hmFirstAidAllowance.put(rs.getString("emp_id"), rs.getString("first_aid_allowance"));
				}

			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
	}

	public double getAllowanceValue(Connection con, double dblHours, int nEmpId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		double dblVal = 0;
		try {
			pst = con.prepareStatement(selectAllowanceR2);
			pst.setDouble(1, dblHours);
			pst.setInt(2, nEmpId);

			rs = pst.executeQuery();

			while (rs.next()) {
				dblVal = rs.getDouble("allowance_value");
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return dblVal;
	}

	public double getDeductionTime(Connection con, Map<String, String> hm) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		double dblVal = 0;

		try {

			pst = con.prepareStatement(selectSettings);
			rs = pst.executeQuery();

			while (rs.next()) {
				if (rs.getString("options").equalsIgnoreCase(O_LUNCH_DEDUCT_TIME)) {
					hm.put(O_LUNCH_DEDUCT_TIME, rs.getString("value"));
				}
				if (rs.getString("options").equalsIgnoreCase(O_LUNCH_DEDUCT)) {
					hm.put(O_LUNCH_DEDUCT, rs.getString("value"));
				}
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return dblVal;
	}

	public double calculateTimeDeduction(Connection con, double dblHoursWorked) {

		Map<String, String> hmSettings = new HashMap<String, String>();
		getDeductionTime(con, hmSettings);

		double deductTime = uF.parseToDouble(hmSettings.get(O_LUNCH_DEDUCT_TIME));
		double deductAmount = uF.parseToDouble(hmSettings.get(O_LUNCH_DEDUCT));

		if (dblHoursWorked >= deductTime) {
			dblHoursWorked -= deductAmount;
		}

		return dblHoursWorked;

	}

	public void getNoticeList(Connection con, UtilityFunctions uF, CommonFunctions CF, List<Map<String, String>> al) {

		Map<String, String> hm = new HashMap<String, String>();
		PreparedStatement pst = null;
		ResultSet rs = null;
		try {

			pst = con.prepareStatement(selectNoticeV1);
			pst.setDate(1, uF.getCurrentDate(CF.getStrTimeZone()));
			rs = pst.executeQuery();

			while (rs.next()) {
				hm = new HashMap<String, String>();

				hm.put("HEADLINE", rs.getString("heading"));
				hm.put("HEADLINE_LIMITED", uF.limitContent(rs.getString("heading"), 50));

				String strContent = "";
				if (rs.getString("content") != null) {
					strContent = rs.getString("content");
					strContent = strContent.replaceAll("\n", "<br/>");
				}
				hm.put("CONTENT", strContent);
				hm.put("DISPLAY_DATE", uF.getDateFormat(rs.getString("display_date"), DBDATE, CF.getStrReportDateFormat()));

				al.add(hm);
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
	}

	public String[] getPrevPayCycle(Connection con, String strDate, String strTimeZone, CommonFunctions CF) {

		PreparedStatement pst = null;
		ResultSet rs = null;

		UtilityFunctions uF = new UtilityFunctions();
		String[] strPayCycleDate = new String[3];

		try {

			String startDate = null;
			String strDisplayPaycycle = null;
			String strPaycycleDuration = null;

			pst = con.prepareStatement(selectSettings);
			rs = pst.executeQuery();

			while (rs.next()) {
				if (rs.getString("options").equalsIgnoreCase(O_START_PAY_CLYCLE)) {
					startDate = rs.getString("value");
				}
				if (rs.getString("options").equalsIgnoreCase(O_DISPLAY_PAY_CLYCLE)) {
					strDisplayPaycycle = rs.getString("value");
				}
				if (rs.getString("options").equalsIgnoreCase(O_PAYCYCLE_DURATION)) {
					strPaycycleDuration = rs.getString("value");
				}
			}
			rs.close();
			pst.close();

			String[] arrDisplayPAycycle = null;
			int minCycle = 0;
			int maxCycle = 0;
			if (strDisplayPaycycle != null) {
				arrDisplayPAycycle = strDisplayPaycycle.split("-");
				minCycle = uF.parseToInt(arrDisplayPAycycle[0]);
				maxCycle = uF.parseToInt(arrDisplayPAycycle[1]);
			}

			Calendar calCurrent = GregorianCalendar.getInstance(TimeZone.getTimeZone((strTimeZone)));
			calCurrent.set(Calendar.DAY_OF_MONTH, uF.parseToInt(uF.getDateFormat(strDate, DATE_FORMAT, "dd")));
			calCurrent.set(Calendar.MONTH, uF.parseToInt(uF.getDateFormat(strDate, DATE_FORMAT, "MM")) - 1);
			calCurrent.set(Calendar.YEAR, uF.parseToInt(uF.getDateFormat(strDate, DATE_FORMAT, "yyyy")));

			calCurrent.add(Calendar.DAY_OF_MONTH, -1);

			Calendar cal = GregorianCalendar.getInstance(TimeZone.getTimeZone(strTimeZone));
			cal.set(Calendar.DAY_OF_MONTH, uF.parseToInt(uF.getDateFormat(startDate, DATE_FORMAT, "dd")));
			cal.set(Calendar.MONTH, uF.parseToInt(uF.getDateFormat(startDate, DATE_FORMAT, "MM")) - 1);
			cal.set(Calendar.YEAR, uF.parseToInt(uF.getDateFormat(startDate, DATE_FORMAT, "yyyy")));

			StringBuilder sb = new StringBuilder();
			int nPayCycle = 0;

			int nDurationCount = 0;
			String dt1 = null;
			String dt2 = null;

			// java.util.Date strCurrentDate = calCurrent.getTime();
			java.util.Date strCurrentDate = uF.getDateFormatUtil(
					((calCurrent.get(Calendar.DAY_OF_MONTH) < 10) ? "0" + calCurrent.get(Calendar.DAY_OF_MONTH) : calCurrent.get(Calendar.DAY_OF_MONTH)) + "/"
							+ (((calCurrent.get(Calendar.MONTH)) < 10) ? "0" + (calCurrent.get(Calendar.MONTH)) : (calCurrent.get(Calendar.MONTH))) + "/"
							+ calCurrent.get(Calendar.YEAR), DATE_FORMAT);

			java.util.Date strCurrentPayCycleD1 = null;
			java.util.Date strCurrentPayCycleD2 = null;

			while (true) {
				sb = new StringBuilder();
				nPayCycle++;

				if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("M")) {
					nDurationCount = cal.getActualMaximum(Calendar.DAY_OF_MONTH) - 1;
				} else if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("F")) {
					nDurationCount = 15 - 1;
					if (cal.get(Calendar.DAY_OF_MONTH) == 16) {
						int nActual = cal.getActualMaximum(Calendar.DAY_OF_MONTH);
						nDurationCount = nActual - 15 - 1;
					}
				} else if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("BW")) {
					nDurationCount = 14 - 1;
				} else if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("W")) {
					nDurationCount = 7 - 1;
				} else {
					nDurationCount = cal.getMaximum(Calendar.DAY_OF_MONTH) - 1;
				}

				dt1 = ((cal.get(Calendar.DAY_OF_MONTH) < 10) ? "0" + cal.get(Calendar.DAY_OF_MONTH) : cal.get(Calendar.DAY_OF_MONTH)) + "/"
						+ (((cal.get(Calendar.MONTH) + 1) < 10) ? "0" + (cal.get(Calendar.MONTH) + 1) : (cal.get(Calendar.MONTH) + 1)) + "/"
						+ cal.get(Calendar.YEAR);
				cal.add(Calendar.DAY_OF_MONTH, nDurationCount);
				dt2 = ((cal.get(Calendar.DAY_OF_MONTH) < 10) ? "0" + cal.get(Calendar.DAY_OF_MONTH) : cal.get(Calendar.DAY_OF_MONTH)) + "/"
						+ (((cal.get(Calendar.MONTH) + 1) < 10) ? "0" + (cal.get(Calendar.MONTH) + 1) : (cal.get(Calendar.MONTH) + 1)) + "/"
						+ cal.get(Calendar.YEAR);

				if (nPayCycle < minCycle) {
					cal.add(Calendar.DAY_OF_MONTH, 1);
					continue;
				}

				sb.append("Pay Cycle " + nPayCycle + ", " + dt1 + " - " + dt2);

				strCurrentPayCycleD1 = uF.getDateFormatUtil(dt1, DATE_FORMAT);
				strCurrentPayCycleD2 = uF.getDateFormatUtil(dt2, DATE_FORMAT);

				if (strCurrentDate.equals(strCurrentPayCycleD1) || strCurrentDate.equals(strCurrentPayCycleD2)
						|| (strCurrentDate.after(strCurrentPayCycleD1) && strCurrentDate.before(strCurrentPayCycleD2))) {
					strPayCycleDate[0] = dt1;
					strPayCycleDate[1] = dt2;
					strPayCycleDate[2] = nPayCycle + "";

				}

				cal.add(Calendar.DAY_OF_MONTH, 1);

				if (nPayCycle >= maxCycle) {
					break;
				}

			}

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return strPayCycleDate;
	}

	public String[] getPrevPayCycle(String strDate, String strTimeZone, CommonFunctions CF) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		UtilityFunctions uF = new UtilityFunctions();
		String[] strPayCycleDate = new String[3];
		Database db = new Database();
		db.setRequest(request);
		Connection con = null;

		try {
			con = db.makeConnection(con);

			String startDate = null;
			String strDisplayPaycycle = null;
			String strPaycycleDuration = null;

			pst = con.prepareStatement(selectSettings);
			rs = pst.executeQuery();

			while (rs.next()) {
				if (rs.getString("options").equalsIgnoreCase(O_START_PAY_CLYCLE)) {
					startDate = rs.getString("value");
				}
				if (rs.getString("options").equalsIgnoreCase(O_DISPLAY_PAY_CLYCLE)) {
					strDisplayPaycycle = rs.getString("value");
				}
				if (rs.getString("options").equalsIgnoreCase(O_PAYCYCLE_DURATION)) {
					strPaycycleDuration = rs.getString("value");
				}
			}
			rs.close();
			pst.close();

			String[] arrDisplayPAycycle = null;
			int minCycle = 0;
			int maxCycle = 0;
			if (strDisplayPaycycle != null) {
				arrDisplayPAycycle = strDisplayPaycycle.split("-");
				minCycle = uF.parseToInt(arrDisplayPAycycle[0]);
				maxCycle = uF.parseToInt(arrDisplayPAycycle[1]);
			}

			Calendar calCurrent = GregorianCalendar.getInstance(TimeZone.getTimeZone((strTimeZone)));
			calCurrent.set(Calendar.DAY_OF_MONTH, uF.parseToInt(uF.getDateFormat(strDate, DATE_FORMAT, "dd")));
			calCurrent.set(Calendar.MONTH, uF.parseToInt(uF.getDateFormat(strDate, DATE_FORMAT, "MM")) - 1);
			calCurrent.set(Calendar.YEAR, uF.parseToInt(uF.getDateFormat(strDate, DATE_FORMAT, "yyyy")));

			calCurrent.add(Calendar.DAY_OF_MONTH, -1);

			Calendar cal = GregorianCalendar.getInstance(TimeZone.getTimeZone(strTimeZone));
			cal.set(Calendar.DAY_OF_MONTH, uF.parseToInt(uF.getDateFormat(startDate, DATE_FORMAT, "dd")));
			cal.set(Calendar.MONTH, uF.parseToInt(uF.getDateFormat(startDate, DATE_FORMAT, "MM")) - 1);
			cal.set(Calendar.YEAR, uF.parseToInt(uF.getDateFormat(startDate, DATE_FORMAT, "yyyy")));

			StringBuilder sb = new StringBuilder();
			int nPayCycle = 0;

			int nDurationCount = 0;
			String dt1 = null;
			String dt2 = null;

			// java.util.Date strCurrentDate = calCurrent.getTime();
			java.util.Date strCurrentDate = uF.getDateFormatUtil(
					((calCurrent.get(Calendar.DAY_OF_MONTH) < 10) ? "0" + calCurrent.get(Calendar.DAY_OF_MONTH) : calCurrent.get(Calendar.DAY_OF_MONTH)) + "/"
							+ (((calCurrent.get(Calendar.MONTH)) < 10) ? "0" + (calCurrent.get(Calendar.MONTH)) : (calCurrent.get(Calendar.MONTH))) + "/"
							+ calCurrent.get(Calendar.YEAR), DATE_FORMAT);

			java.util.Date strCurrentPayCycleD1 = null;
			java.util.Date strCurrentPayCycleD2 = null;

			while (true) {
				sb = new StringBuilder();
				nPayCycle++;

				if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("M")) {
					nDurationCount = cal.getActualMaximum(Calendar.DAY_OF_MONTH) - 1;
				} else if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("F")) {
					nDurationCount = 15 - 1;
					if (cal.get(Calendar.DAY_OF_MONTH) == 16) {
						int nActual = cal.getActualMaximum(Calendar.DAY_OF_MONTH);
						nDurationCount = nActual - 15 - 1;
					}
				} else if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("BW")) {
					nDurationCount = 14 - 1;
				} else if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("W")) {
					nDurationCount = 7 - 1;
				} else {
					nDurationCount = cal.getMaximum(Calendar.DAY_OF_MONTH) - 1;
				}

				dt1 = ((cal.get(Calendar.DAY_OF_MONTH) < 10) ? "0" + cal.get(Calendar.DAY_OF_MONTH) : cal.get(Calendar.DAY_OF_MONTH)) + "/"
						+ (((cal.get(Calendar.MONTH) + 1) < 10) ? "0" + (cal.get(Calendar.MONTH) + 1) : (cal.get(Calendar.MONTH) + 1)) + "/"
						+ cal.get(Calendar.YEAR);
				cal.add(Calendar.DAY_OF_MONTH, nDurationCount);
				dt2 = ((cal.get(Calendar.DAY_OF_MONTH) < 10) ? "0" + cal.get(Calendar.DAY_OF_MONTH) : cal.get(Calendar.DAY_OF_MONTH)) + "/"
						+ (((cal.get(Calendar.MONTH) + 1) < 10) ? "0" + (cal.get(Calendar.MONTH) + 1) : (cal.get(Calendar.MONTH) + 1)) + "/"
						+ cal.get(Calendar.YEAR);

				if (nPayCycle < minCycle) {
					cal.add(Calendar.DAY_OF_MONTH, 1);
					continue;
				}

				sb.append("Pay Cycle " + nPayCycle + ", " + dt1 + " - " + dt2);

				strCurrentPayCycleD1 = uF.getDateFormatUtil(dt1, DATE_FORMAT);
				strCurrentPayCycleD2 = uF.getDateFormatUtil(dt2, DATE_FORMAT);

				if (strCurrentDate.equals(strCurrentPayCycleD1) || strCurrentDate.equals(strCurrentPayCycleD2)
						|| (strCurrentDate.after(strCurrentPayCycleD1) && strCurrentDate.before(strCurrentPayCycleD2))) {
					strPayCycleDate[0] = dt1;
					strPayCycleDate[1] = dt2;
					strPayCycleDate[2] = nPayCycle + "";
				}

				cal.add(Calendar.DAY_OF_MONTH, 1);

				if (nPayCycle >= maxCycle) {
					break;
				}

			}

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			db.closeResultSet(rs);
			db.closeStatements(pst);
			db.closeConnection(con);
		}
		return strPayCycleDate;
	}

	public String[] getCurrentPayCycle(String strTimeZone, CommonFunctions CF, HttpServletRequest request) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		UtilityFunctions uF = new UtilityFunctions();
		String[] strPayCycleDate = new String[3];
		Database db = new Database();
		db.setRequest(request);
		Connection con = null;
		try {

			String startDate = null;
			String strDisplayPaycycle = null;
			String strPaycycleDuration = null;

			con = db.makeConnection(con);
			// pst =
			// con.prepareStatement("select max (paycycle) as paycycle from payroll_generation where emp_id in (select emp_id from employee_official_details where org_id = ?)");
			pst = con.prepareStatement("select max (paycycle) as paycycle from payroll_generation");
			// pst.setInt(1, uF.parseToInt(orgId));
			rs = pst.executeQuery();
			int nPaidMaxPaycycle = 0;
			while (rs.next()) {
				nPaidMaxPaycycle = rs.getInt("paycycle");
			}
			rs.close();
			pst.close();
			// System.out.println("nPaidMaxPaycycle ===>> " + nPaidMaxPaycycle);
			nPaidMaxPaycycle = nPaidMaxPaycycle + 1;
			// System.out.println("nPaidMaxPaycycle+1 ===>> " +
			// nPaidMaxPaycycle);
			pst = con.prepareStatement(selectSettings);
			rs = pst.executeQuery();
			while (rs.next()) {
				if (rs.getString("options").equalsIgnoreCase(O_START_PAY_CLYCLE)) {
					startDate = rs.getString("value");
				}
				if (rs.getString("options").equalsIgnoreCase(O_DISPLAY_PAY_CLYCLE)) {
					strDisplayPaycycle = rs.getString("value");
				}
				if (rs.getString("options").equalsIgnoreCase(O_PAYCYCLE_DURATION)) {
					strPaycycleDuration = rs.getString("value");
				}
			}
			rs.close();
			pst.close();

			String[] arrDisplayPAycycle = null;
			int minCycle = 0;
			int maxCycle = 0;
			if (strDisplayPaycycle != null) {
				arrDisplayPAycycle = strDisplayPaycycle.split("-");
				minCycle = uF.parseToInt(arrDisplayPAycycle[0]);
				maxCycle = uF.parseToInt(arrDisplayPAycycle[1]);
			}

			Calendar calCurrent = GregorianCalendar.getInstance(TimeZone.getTimeZone((strTimeZone)));
			Calendar cal = GregorianCalendar.getInstance(TimeZone.getTimeZone(strTimeZone));
			cal.set(Calendar.DAY_OF_MONTH, uF.parseToInt(uF.getDateFormat(startDate, DATE_FORMAT, "dd")));
			cal.set(Calendar.MONTH, uF.parseToInt(uF.getDateFormat(startDate, DATE_FORMAT, "MM")) - 1);
			cal.set(Calendar.YEAR, uF.parseToInt(uF.getDateFormat(startDate, DATE_FORMAT, "yyyy")));

			StringBuilder sb = new StringBuilder();
			int nPayCycle = 0;

			int nDurationCount = 0;
			String dt1 = null;
			String dt2 = null;

			// java.util.Date strCurrentDate = calCurrent.getTime();
			java.util.Date strCurrentDate = uF.getDateFormatUtil(((calCurrent.get(Calendar.DAY_OF_MONTH) < 10)
					? "0" + calCurrent.get(Calendar.DAY_OF_MONTH)
					: calCurrent.get(Calendar.DAY_OF_MONTH))
					+ "/"
					+ (((calCurrent.get(Calendar.MONTH) + 1) < 10) ? "0" + (calCurrent.get(Calendar.MONTH) + 1) : (calCurrent.get(Calendar.MONTH) + 1))
					+ "/"
					+ calCurrent.get(Calendar.YEAR), DATE_FORMAT);

			java.util.Date strCurrentPayCycleD1 = null;
			java.util.Date strCurrentPayCycleD2 = null;

			while (true) {
				sb = new StringBuilder();
				nPayCycle++;

				if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("M")) {
					nDurationCount = cal.getActualMaximum(Calendar.DAY_OF_MONTH) - 1;
				} else if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("F")) {
					nDurationCount = 15 - 1;
					if (cal.get(Calendar.DAY_OF_MONTH) == 16) {
						int nActual = cal.getActualMaximum(Calendar.DAY_OF_MONTH);
						nDurationCount = nActual - 15 - 1;
					}
				} else if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("BW")) {
					nDurationCount = 14 - 1;
				} else if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("W")) {
					nDurationCount = 7 - 1;
				} else {
					nDurationCount = cal.getMaximum(Calendar.DAY_OF_MONTH) - 1;
				}

				dt1 = ((cal.get(Calendar.DAY_OF_MONTH) < 10) ? "0" + cal.get(Calendar.DAY_OF_MONTH) : cal.get(Calendar.DAY_OF_MONTH)) + "/"
						+ (((cal.get(Calendar.MONTH) + 1) < 10) ? "0" + (cal.get(Calendar.MONTH) + 1) : (cal.get(Calendar.MONTH) + 1)) + "/"
						+ cal.get(Calendar.YEAR);
				cal.add(Calendar.DAY_OF_MONTH, nDurationCount);
				dt2 = ((cal.get(Calendar.DAY_OF_MONTH) < 10) ? "0" + cal.get(Calendar.DAY_OF_MONTH) : cal.get(Calendar.DAY_OF_MONTH)) + "/"
						+ (((cal.get(Calendar.MONTH) + 1) < 10) ? "0" + (cal.get(Calendar.MONTH) + 1) : (cal.get(Calendar.MONTH) + 1)) + "/"
						+ cal.get(Calendar.YEAR);

				if (nPayCycle < minCycle) {
					cal.add(Calendar.DAY_OF_MONTH, 1);
					continue;
				}

				sb.append("Pay Cycle " + nPayCycle + ", " + dt1 + " - " + dt2);

				strCurrentPayCycleD1 = uF.getDateFormatUtil(dt1, DATE_FORMAT);
				strCurrentPayCycleD2 = uF.getDateFormatUtil(dt2, DATE_FORMAT);

				String strCurrDate = uF.getDateFormatUtil(strCurrentDate, DATE_FORMAT);
				int nCurrMonth = uF.parseToInt(uF.getDateFormat(strCurrDate, DATE_FORMAT, "MM"));
				int nPaycycleEndMonth = uF.parseToInt(uF.getDateFormat(dt2, DATE_FORMAT, "MM"));
				// if(nPayCycle > 70) {
				// System.out.println(" dt2 ===>> " + dt2 +
				// " -- strCurrDate ===>> " + strCurrDate);
				// System.out.println(" nCurrMonth ===>> " + nCurrMonth +
				// " -- nPaycycleEndMonth ===>> " + nPaycycleEndMonth);
				// System.out.println(" nPayCycle ===>> " + nPayCycle +
				// " -- nPaidMaxPaycycle ===>> " + nPaidMaxPaycycle);
				// }
				Map<String, String> hmFeatureStatus = getFeatureStatusMap(con, request);
				if (hmFeatureStatus != null && hmFeatureStatus.get(F_SELECT_PREV_PAYCYCLE) != null
						&& uF.parseToBoolean(hmFeatureStatus.get(F_SELECT_PREV_PAYCYCLE))) {
					if (strCurrentDate.after(strCurrentPayCycleD1) && strCurrentDate.after(strCurrentPayCycleD2) && nPayCycle == nPaidMaxPaycycle) { // &&
																																						// nCurrMonth
																																						// ==
																																						// nPaycycleEndMonth
					// System.out.println("in if nCurrMonth ===>> " + nCurrMonth
					// + " -- nPaycycleEndMonth ===>> " + nPaycycleEndMonth);
						strPayCycleDate[0] = dt1;
						strPayCycleDate[1] = dt2;
						strPayCycleDate[2] = nPayCycle + "";
					} else if (strCurrentDate.equals(strCurrentPayCycleD1) || strCurrentDate.equals(strCurrentPayCycleD2)
							|| (strCurrentDate.after(strCurrentPayCycleD1) && strCurrentDate.before(strCurrentPayCycleD2))) {
						// System.out.println("in if else nCurrMonth ===>> " +
						// nCurrMonth + " -- nPaycycleEndMonth ===>> " +
						// nPaycycleEndMonth);
						strPayCycleDate[0] = dt1;
						strPayCycleDate[1] = dt2;
						strPayCycleDate[2] = nPayCycle + "";
					}
				} else {
					if (strCurrentDate.equals(strCurrentPayCycleD1) || strCurrentDate.equals(strCurrentPayCycleD2)
							|| (strCurrentDate.after(strCurrentPayCycleD1) && strCurrentDate.before(strCurrentPayCycleD2))) {
						strPayCycleDate[0] = dt1;
						strPayCycleDate[1] = dt2;
						strPayCycleDate[2] = nPayCycle + "";
					}
				}
				cal.add(Calendar.DAY_OF_MONTH, 1);
				if (hmFeatureStatus != null && hmFeatureStatus.get(F_SELECT_PREV_PAYCYCLE) != null
						&& uF.parseToBoolean(hmFeatureStatus.get(F_SELECT_PREV_PAYCYCLE))) {
					if (nPayCycle >= maxCycle || (nPayCycle >= nPaidMaxPaycycle)) { // &&
																					// nCurrMonth
																					// ==
																					// nPaycycleEndMonth
						break;
					}
				} else {
					if (nPayCycle >= maxCycle) {
						break;
					}
				}

			}
			// System.out.println(" strPayCycleDate[2] ===>> " +
			// strPayCycleDate[2]);
		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return strPayCycleDate;

	}

	public String[] getCurrentPayCycle(Connection con, String strTimeZone, CommonFunctions CF) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		UtilityFunctions uF = new UtilityFunctions();
		String[] strPayCycleDate = new String[3];

		try {

			String startDate = null;
			String strDisplayPaycycle = null;
			String strPaycycleDuration = null;

			pst = con.prepareStatement(selectSettings);
			rs = pst.executeQuery();

			while (rs.next()) {
				if (rs.getString("options").equalsIgnoreCase(O_START_PAY_CLYCLE)) {
					startDate = rs.getString("value");
				}
				if (rs.getString("options").equalsIgnoreCase(O_DISPLAY_PAY_CLYCLE)) {
					strDisplayPaycycle = rs.getString("value");
				}
				if (rs.getString("options").equalsIgnoreCase(O_PAYCYCLE_DURATION)) {
					strPaycycleDuration = rs.getString("value");
				}
			}
			rs.close();
			pst.close();

			String[] arrDisplayPAycycle = null;
			int minCycle = 0;
			int maxCycle = 0;
			if (strDisplayPaycycle != null) {
				arrDisplayPAycycle = strDisplayPaycycle.split("-");
				minCycle = uF.parseToInt(arrDisplayPAycycle[0]);
				maxCycle = uF.parseToInt(arrDisplayPAycycle[1]);
			}

			Calendar calCurrent = GregorianCalendar.getInstance(TimeZone.getTimeZone((strTimeZone)));
			Calendar cal = GregorianCalendar.getInstance(TimeZone.getTimeZone(strTimeZone));
			cal.set(Calendar.DAY_OF_MONTH, uF.parseToInt(uF.getDateFormat(startDate, DATE_FORMAT, "dd")));
			cal.set(Calendar.MONTH, uF.parseToInt(uF.getDateFormat(startDate, DATE_FORMAT, "MM")) - 1);
			cal.set(Calendar.YEAR, uF.parseToInt(uF.getDateFormat(startDate, DATE_FORMAT, "yyyy")));

			StringBuilder sb = new StringBuilder();
			int nPayCycle = 0;

			int nDurationCount = 0;
			String dt1 = null;
			String dt2 = null;

			// java.util.Date strCurrentDate = calCurrent.getTime();
			java.util.Date strCurrentDate = uF.getDateFormatUtil(((calCurrent.get(Calendar.DAY_OF_MONTH) < 10)
					? "0" + calCurrent.get(Calendar.DAY_OF_MONTH)
					: calCurrent.get(Calendar.DAY_OF_MONTH))
					+ "/"
					+ (((calCurrent.get(Calendar.MONTH) + 1) < 10) ? "0" + (calCurrent.get(Calendar.MONTH) + 1) : (calCurrent.get(Calendar.MONTH) + 1))
					+ "/"
					+ calCurrent.get(Calendar.YEAR), DATE_FORMAT);

			java.util.Date strCurrentPayCycleD1 = null;
			java.util.Date strCurrentPayCycleD2 = null;

			while (true) {
				sb = new StringBuilder();
				nPayCycle++;

				if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("M")) {
					nDurationCount = cal.getActualMaximum(Calendar.DAY_OF_MONTH) - 1;
				} else if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("F")) {
					nDurationCount = 15 - 1;
					if (cal.get(Calendar.DAY_OF_MONTH) == 16) {
						int nActual = cal.getActualMaximum(Calendar.DAY_OF_MONTH);
						nDurationCount = nActual - 15 - 1;
					}
				} else if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("BW")) {
					nDurationCount = 14 - 1;
				} else if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("W")) {
					nDurationCount = 7 - 1;
				} else {
					nDurationCount = cal.getMaximum(Calendar.DAY_OF_MONTH) - 1;
				}

				dt1 = ((cal.get(Calendar.DAY_OF_MONTH) < 10) ? "0" + cal.get(Calendar.DAY_OF_MONTH) : cal.get(Calendar.DAY_OF_MONTH)) + "/"
						+ (((cal.get(Calendar.MONTH) + 1) < 10) ? "0" + (cal.get(Calendar.MONTH) + 1) : (cal.get(Calendar.MONTH) + 1)) + "/"
						+ cal.get(Calendar.YEAR);
				cal.add(Calendar.DAY_OF_MONTH, nDurationCount);
				dt2 = ((cal.get(Calendar.DAY_OF_MONTH) < 10) ? "0" + cal.get(Calendar.DAY_OF_MONTH) : cal.get(Calendar.DAY_OF_MONTH)) + "/"
						+ (((cal.get(Calendar.MONTH) + 1) < 10) ? "0" + (cal.get(Calendar.MONTH) + 1) : (cal.get(Calendar.MONTH) + 1)) + "/"
						+ cal.get(Calendar.YEAR);

				if (nPayCycle < minCycle) {
					cal.add(Calendar.DAY_OF_MONTH, 1);
					continue;
				}

				sb.append("Pay Cycle " + nPayCycle + ", " + dt1 + " - " + dt2);

				strCurrentPayCycleD1 = uF.getDateFormatUtil(dt1, DATE_FORMAT);
				strCurrentPayCycleD2 = uF.getDateFormatUtil(dt2, DATE_FORMAT);

				if (strCurrentDate.equals(strCurrentPayCycleD1) || strCurrentDate.equals(strCurrentPayCycleD2)
						|| (strCurrentDate.after(strCurrentPayCycleD1) && strCurrentDate.before(strCurrentPayCycleD2))) {
					strPayCycleDate[0] = dt1;
					strPayCycleDate[1] = dt2;
					strPayCycleDate[2] = nPayCycle + "";
				}

				cal.add(Calendar.DAY_OF_MONTH, 1);

				if (nPayCycle >= maxCycle) {
					break;
				}

			}

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return strPayCycleDate;

	}

	public String[] getCurrentPayCycle(String strTimeZone, java.util.Date strCurrentDate, CommonFunctions CF) {

		PreparedStatement pst = null;
		ResultSet rs = null;

		UtilityFunctions uF = new UtilityFunctions();
		String[] strPayCycleDate = new String[3];
		Database db = new Database();
		db.setRequest(request);
		Connection con = null;

		try {

			String startDate = null;
			String strDisplayPaycycle = null;
			String strPaycycleDuration = null;

			con = db.makeConnection(con);

			pst = con.prepareStatement(selectSettings);
			rs = pst.executeQuery();

			while (rs.next()) {
				if (rs.getString("options").equalsIgnoreCase(O_START_PAY_CLYCLE)) {
					startDate = rs.getString("value");
				}
				if (rs.getString("options").equalsIgnoreCase(O_DISPLAY_PAY_CLYCLE)) {
					strDisplayPaycycle = rs.getString("value");
				}
				if (rs.getString("options").equalsIgnoreCase(O_PAYCYCLE_DURATION)) {
					strPaycycleDuration = rs.getString("value");
				}
			}
			rs.close();
			pst.close();

			String[] arrDisplayPAycycle = null;
			int minCycle = 0;
			int maxCycle = 0;
			if (strDisplayPaycycle != null) {
				arrDisplayPAycycle = strDisplayPaycycle.split("-");
				minCycle = uF.parseToInt(arrDisplayPAycycle[0]);
				maxCycle = uF.parseToInt(arrDisplayPAycycle[1]);
			}

			Calendar calCurrent = GregorianCalendar.getInstance(TimeZone.getTimeZone((strTimeZone)));
			Calendar cal = GregorianCalendar.getInstance(TimeZone.getTimeZone(strTimeZone));
			cal.set(Calendar.DAY_OF_MONTH, uF.parseToInt(uF.getDateFormat(startDate, DATE_FORMAT, "dd")));
			cal.set(Calendar.MONTH, uF.parseToInt(uF.getDateFormat(startDate, DATE_FORMAT, "MM")) - 1);
			cal.set(Calendar.YEAR, uF.parseToInt(uF.getDateFormat(startDate, DATE_FORMAT, "yyyy")));

			StringBuilder sb = new StringBuilder();
			int nPayCycle = 0;

			int nDurationCount = 0;
			String dt1 = null;
			String dt2 = null;

			// java.util.Date strCurrentDate = calCurrent.getTime();

			java.util.Date strCurrentPayCycleD1 = null;
			java.util.Date strCurrentPayCycleD2 = null;

			while (true) {
				sb = new StringBuilder();
				nPayCycle++;

				if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("M")) {
					nDurationCount = cal.getActualMaximum(Calendar.DAY_OF_MONTH) - 1;
				} else if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("F")) {
					nDurationCount = 15 - 1;
					if (cal.get(Calendar.DAY_OF_MONTH) == 16) {
						int nActual = cal.getActualMaximum(Calendar.DAY_OF_MONTH);
						nDurationCount = nActual - 15 - 1;
					}
				} else if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("BW")) {
					nDurationCount = 14 - 1;
				} else if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("W")) {
					nDurationCount = 7 - 1;
				} else {
					nDurationCount = cal.getMaximum(Calendar.DAY_OF_MONTH) - 1;
				}

				dt1 = ((cal.get(Calendar.DAY_OF_MONTH) < 10) ? "0" + cal.get(Calendar.DAY_OF_MONTH) : cal.get(Calendar.DAY_OF_MONTH)) + "/"
						+ (((cal.get(Calendar.MONTH) + 1) < 10) ? "0" + (cal.get(Calendar.MONTH) + 1) : (cal.get(Calendar.MONTH) + 1)) + "/"
						+ cal.get(Calendar.YEAR);
				cal.add(Calendar.DAY_OF_MONTH, nDurationCount);
				dt2 = ((cal.get(Calendar.DAY_OF_MONTH) < 10) ? "0" + cal.get(Calendar.DAY_OF_MONTH) : cal.get(Calendar.DAY_OF_MONTH)) + "/"
						+ (((cal.get(Calendar.MONTH) + 1) < 10) ? "0" + (cal.get(Calendar.MONTH) + 1) : (cal.get(Calendar.MONTH) + 1)) + "/"
						+ cal.get(Calendar.YEAR);

				if (nPayCycle < minCycle) {
					cal.add(Calendar.DAY_OF_MONTH, 1);
					continue;
				}

				sb.append("Pay Cycle " + nPayCycle + ", " + dt1 + " - " + dt2);

				strCurrentPayCycleD1 = uF.getDateFormatUtil(dt1, DATE_FORMAT);
				strCurrentPayCycleD2 = uF.getDateFormatUtil(dt2, DATE_FORMAT);

				if (strCurrentDate.equals(strCurrentPayCycleD1) || strCurrentDate.equals(strCurrentPayCycleD2)
						|| (strCurrentDate.after(strCurrentPayCycleD1) && strCurrentDate.before(strCurrentPayCycleD2))) {
					strPayCycleDate[0] = dt1;
					strPayCycleDate[1] = dt2;
					strPayCycleDate[2] = nPayCycle + "";
				}

				cal.add(Calendar.DAY_OF_MONTH, 1);

				if (nPayCycle >= maxCycle) {
					break;
				}

			}

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			db.closeResultSet(rs);
			db.closeStatements(pst);
			db.closeConnection(con);
		}
		return strPayCycleDate;

	}

	public String[] getCurrentPayCycle(Connection con, String strTimeZone, java.util.Date strCurrentDate, CommonFunctions CF) {

		PreparedStatement pst = null;
		ResultSet rs = null;

		UtilityFunctions uF = new UtilityFunctions();
		String[] strPayCycleDate = new String[3];

		try {

			String startDate = null;
			String strDisplayPaycycle = null;
			String strPaycycleDuration = null;

			pst = con.prepareStatement(selectSettings);
			rs = pst.executeQuery();

			while (rs.next()) {
				if (rs.getString("options").equalsIgnoreCase(O_START_PAY_CLYCLE)) {
					startDate = rs.getString("value");
				}
				if (rs.getString("options").equalsIgnoreCase(O_DISPLAY_PAY_CLYCLE)) {
					strDisplayPaycycle = rs.getString("value");
				}
				if (rs.getString("options").equalsIgnoreCase(O_PAYCYCLE_DURATION)) {
					strPaycycleDuration = rs.getString("value");
				}
			}
			rs.close();
			pst.close();

			String[] arrDisplayPAycycle = null;
			int minCycle = 0;
			int maxCycle = 0;
			if (strDisplayPaycycle != null) {
				arrDisplayPAycycle = strDisplayPaycycle.split("-");
				minCycle = uF.parseToInt(arrDisplayPAycycle[0]);
				maxCycle = uF.parseToInt(arrDisplayPAycycle[1]);
			}

			Calendar calCurrent = GregorianCalendar.getInstance(TimeZone.getTimeZone((strTimeZone)));
			Calendar cal = GregorianCalendar.getInstance(TimeZone.getTimeZone(strTimeZone));
			cal.set(Calendar.DAY_OF_MONTH, uF.parseToInt(uF.getDateFormat(startDate, DATE_FORMAT, "dd")));
			cal.set(Calendar.MONTH, uF.parseToInt(uF.getDateFormat(startDate, DATE_FORMAT, "MM")) - 1);
			cal.set(Calendar.YEAR, uF.parseToInt(uF.getDateFormat(startDate, DATE_FORMAT, "yyyy")));

			StringBuilder sb = new StringBuilder();
			int nPayCycle = 0;

			int nDurationCount = 0;
			String dt1 = null;
			String dt2 = null;

			// java.util.Date strCurrentDate = calCurrent.getTime();

			java.util.Date strCurrentPayCycleD1 = null;
			java.util.Date strCurrentPayCycleD2 = null;

			while (true) {
				sb = new StringBuilder();
				nPayCycle++;

				if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("M")) {
					nDurationCount = cal.getActualMaximum(Calendar.DAY_OF_MONTH) - 1;
				} else if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("F")) {
					nDurationCount = 15 - 1;
					if (cal.get(Calendar.DAY_OF_MONTH) == 16) {
						int nActual = cal.getActualMaximum(Calendar.DAY_OF_MONTH);
						nDurationCount = nActual - 15 - 1;
					}
				} else if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("BW")) {
					nDurationCount = 14 - 1;
				} else if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("W")) {
					nDurationCount = 7 - 1;
				} else {
					nDurationCount = cal.getMaximum(Calendar.DAY_OF_MONTH) - 1;
				}

				dt1 = ((cal.get(Calendar.DAY_OF_MONTH) < 10) ? "0" + cal.get(Calendar.DAY_OF_MONTH) : cal.get(Calendar.DAY_OF_MONTH)) + "/"
						+ (((cal.get(Calendar.MONTH) + 1) < 10) ? "0" + (cal.get(Calendar.MONTH) + 1) : (cal.get(Calendar.MONTH) + 1)) + "/"
						+ cal.get(Calendar.YEAR);
				cal.add(Calendar.DAY_OF_MONTH, nDurationCount);
				dt2 = ((cal.get(Calendar.DAY_OF_MONTH) < 10) ? "0" + cal.get(Calendar.DAY_OF_MONTH) : cal.get(Calendar.DAY_OF_MONTH)) + "/"
						+ (((cal.get(Calendar.MONTH) + 1) < 10) ? "0" + (cal.get(Calendar.MONTH) + 1) : (cal.get(Calendar.MONTH) + 1)) + "/"
						+ cal.get(Calendar.YEAR);

				if (nPayCycle < minCycle) {
					cal.add(Calendar.DAY_OF_MONTH, 1);
					continue;
				}

				sb.append("Pay Cycle " + nPayCycle + ", " + dt1 + " - " + dt2);

				strCurrentPayCycleD1 = uF.getDateFormatUtil(dt1, DATE_FORMAT);
				strCurrentPayCycleD2 = uF.getDateFormatUtil(dt2, DATE_FORMAT);

				if (strCurrentDate.equals(strCurrentPayCycleD1) || strCurrentDate.equals(strCurrentPayCycleD2)
						|| (strCurrentDate.after(strCurrentPayCycleD1) && strCurrentDate.before(strCurrentPayCycleD2))) {
					strPayCycleDate[0] = dt1;
					strPayCycleDate[1] = dt2;
					strPayCycleDate[2] = nPayCycle + "";
				}

				cal.add(Calendar.DAY_OF_MONTH, 1);

				if (nPayCycle >= maxCycle) {
					break;
				}

			}

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return strPayCycleDate;

	}
	public void getSelectedPayCycle(Connection con, String strTimeZone, CommonFunctions CF, List<String> alInner, List<String> alInnerDates) {

		PreparedStatement pst = null;
		ResultSet rs = null;

		UtilityFunctions uF = new UtilityFunctions();

		try {

			String startDate = null;
			String strDisplayPaycycle = null;
			String strPaycycleDuration = null;

			pst = con.prepareStatement(selectSettings);
			rs = pst.executeQuery();

			while (rs.next()) {
				if (rs.getString("options").equalsIgnoreCase(O_START_PAY_CLYCLE)) {
					startDate = rs.getString("value");
				}
				if (rs.getString("options").equalsIgnoreCase(O_DISPLAY_PAY_CLYCLE)) {
					strDisplayPaycycle = rs.getString("value");
				}
				if (rs.getString("options").equalsIgnoreCase(O_PAYCYCLE_DURATION)) {
					strPaycycleDuration = rs.getString("value");
				}
			}
			rs.close();
			pst.close();

			String[] arrDisplayPAycycle = null;
			int minCycle = 0;
			int maxCycle = 0;
			if (strDisplayPaycycle != null) {
				arrDisplayPAycycle = strDisplayPaycycle.split("-");
				minCycle = uF.parseToInt(arrDisplayPAycycle[0]);
				maxCycle = uF.parseToInt(arrDisplayPAycycle[1]);
			}

			Calendar calCurrent = GregorianCalendar.getInstance(TimeZone.getTimeZone((CF.getStrTimeZone())));
			Calendar cal = GregorianCalendar.getInstance(TimeZone.getTimeZone(CF.getStrTimeZone()));
			cal.set(Calendar.DAY_OF_MONTH, uF.parseToInt(uF.getDateFormat(startDate, DATE_FORMAT, "dd")));
			cal.set(Calendar.MONTH, uF.parseToInt(uF.getDateFormat(startDate, DATE_FORMAT, "MM")) - 1);
			cal.set(Calendar.YEAR, uF.parseToInt(uF.getDateFormat(startDate, DATE_FORMAT, "yyyy")));

			StringBuilder sb = new StringBuilder();
			int nPayCycle = 0;

			int nDurationCount = 0;
			String dt1 = null;
			String dt2 = null;

			java.util.Date strCurrentDate = calCurrent.getTime();

			java.util.Date strCurrentPayCycleD1 = null;
			java.util.Date strCurrentPayCycleD2 = null;

			while (true) {
				sb = new StringBuilder();
				nPayCycle++;

				if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("M")) {
					nDurationCount = cal.getActualMaximum(Calendar.DAY_OF_MONTH) - 1;
				} else if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("F")) {
					nDurationCount = 15 - 1;
					if (cal.get(Calendar.DAY_OF_MONTH) == 16) {
						int nActual = cal.getActualMaximum(Calendar.DAY_OF_MONTH);
						nDurationCount = nActual - 15 - 1;
					}
				} else if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("BW")) {
					nDurationCount = 14 - 1;
				} else if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("W")) {
					nDurationCount = 7 - 1;
				} else {
					nDurationCount = cal.getMaximum(Calendar.DAY_OF_MONTH) - 1;
				}

				dt1 = ((cal.get(Calendar.DAY_OF_MONTH) < 10) ? "0" + cal.get(Calendar.DAY_OF_MONTH) : cal.get(Calendar.DAY_OF_MONTH)) + "/"
						+ (((cal.get(Calendar.MONTH) + 1) < 10) ? "0" + (cal.get(Calendar.MONTH) + 1) : (cal.get(Calendar.MONTH) + 1)) + "/"
						+ cal.get(Calendar.YEAR);
				cal.add(Calendar.DAY_OF_MONTH, nDurationCount);
				dt2 = ((cal.get(Calendar.DAY_OF_MONTH) < 10) ? "0" + cal.get(Calendar.DAY_OF_MONTH) : cal.get(Calendar.DAY_OF_MONTH)) + "/"
						+ (((cal.get(Calendar.MONTH) + 1) < 10) ? "0" + (cal.get(Calendar.MONTH) + 1) : (cal.get(Calendar.MONTH) + 1)) + "/"
						+ cal.get(Calendar.YEAR);

				if (nPayCycle < minCycle) {
					cal.add(Calendar.DAY_OF_MONTH, 1);
					continue;
				}

				sb.append("Pay Cycle " + nPayCycle + "<br>" + uF.getDateFormat(dt1, DATE_FORMAT, "dd MMM") + "-" + uF.getDateFormat(dt2, DATE_FORMAT, "dd MMM"));

				strCurrentPayCycleD1 = uF.getDateFormatUtil(dt1, DATE_FORMAT);
				strCurrentPayCycleD2 = uF.getDateFormatUtil(dt2, DATE_FORMAT);

				if (strCurrentDate.equals(strCurrentPayCycleD1) || strCurrentDate.equals(strCurrentPayCycleD2)
						|| (strCurrentDate.after(strCurrentPayCycleD1) && strCurrentDate.before(strCurrentPayCycleD2))) {
					// alInner.add("<a style=\"font-weight:bold;color:blue;\" href="
					// + request.getContextPath() +
					// "/EmployeeReportPayCycle.action?T=" + strPayCycleType +
					// "&PC=" + nPayCycle + "&D1=" + dt1 + "&D2=" + dt2 + " >" +
					// sb.toString() + "</a>");
					alInner.add(sb.toString());
					alInnerDates.add(dt1);
					alInnerDates.add(dt2);
				} else if (strCurrentDate.before(strCurrentPayCycleD2)) {
					alInner.add(sb.toString());
					alInnerDates.add(dt1);
					alInnerDates.add(dt2);
				} else {
					// alInner.add("<a href=" + request.getContextPath() +
					// "/EmployeeReportPayCycle.action?T=" + strPayCycleType +
					// "&PC=" + nPayCycle + "&D1=" + dt1 + "&D2=" + dt2 + " >" +
					// sb.toString() + "</a>");
					alInner.add(sb.toString());
					alInnerDates.add(dt1);
					alInnerDates.add(dt2);
				}

				cal.add(Calendar.DAY_OF_MONTH, 1);

				if (nPayCycle >= maxCycle) {
					break;
				}

			}

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

	}

	public boolean isRostered(Connection con, String strEmpId) {
		boolean isRoster = false;

		PreparedStatement pst = null;
		ResultSet rs = null;

		try {

			pst = con.prepareStatement(selectRosterClockDetails1);
			pst.setInt(1, uF.parseToInt(strEmpId));
			pst.setDate(2, uF.getCurrentDate(CF.getStrTimeZone()));
			pst.setDate(3, uF.getPrevDate(CF.getStrTimeZone()));
			rs = pst.executeQuery();

			while (rs.next()) {
				isRoster = true;
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

		return isRoster;
	}

	public boolean isCurrentRostered(Connection con, String strEmpId) {
		boolean isRoster = false;
		PreparedStatement pst = null;
		ResultSet rs = null;
		try {
			pst = con.prepareStatement(selectRosterClockDetails);
			pst.setInt(1, uF.parseToInt(strEmpId));
			pst.setDate(2, uF.getCurrentDate(CF.getStrTimeZone()));
			rs = pst.executeQuery();
			while (rs.next()) {
				isRoster = true;
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return isRoster;
	}

	public boolean isCurrentRostered(Connection con, String strEmpId, int nVal) {
		boolean isRoster = false;
		PreparedStatement pst = null;
		ResultSet rs = null;
		try {
			pst = con.prepareStatement(selectRosterClockDetails_N);
			pst.setInt(1, uF.parseToInt(strEmpId));
			pst.setDate(2, uF.getCurrentDate(CF.getStrTimeZone()));
			pst.setInt(3, nVal);
			rs = pst.executeQuery();
			while (rs.next()) {
				isRoster = true;
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

		return isRoster;
	}

	public Map<String, String> getNodes(Connection con) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmNodes = new HashMap<String, String>();

		try {

			pst = con.prepareStatement("select node_id,node_name from nodes");
			rs = pst.executeQuery();
			hmNodes.put("0", "Node Not Required");
			while (rs.next()) {
				hmNodes.put(rs.getString("node_id"), rs.getString("node_name"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

		return hmNodes;
	}

	public Map<String, String> getAttendanceDependency(Connection con) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmAttendanceDependent = new HashMap<String, String>();

		try {
			pst = con.prepareStatement(selectEmployeeDetails);
			rs = pst.executeQuery();

			while (rs.next()) {
				hmAttendanceDependent.put(rs.getString("emp_id"), rs.getString("is_attendance"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

		return hmAttendanceDependent;
	}

	public Map<String, String> getRosterDependency(Connection con) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmRosterDependent = new HashMap<String, String>();

		try {

			pst = con.prepareStatement(selectEmployeeDetails);
			rs = pst.executeQuery();

			while (rs.next()) {
				hmRosterDependent.put(rs.getString("emp_id"), rs.getString("is_roster"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

		return hmRosterDependent;
	}

	public boolean isRosterDependency(Connection con, String strEmpId) {
		boolean isRosterDependent = false;
		UtilityFunctions uF = new UtilityFunctions();

		PreparedStatement pst = null;
		ResultSet rs = null;

		try {

			pst = con.prepareStatement(selectEmployee2Details);
			pst.setInt(1, uF.parseToInt(strEmpId));
			rs = pst.executeQuery();

			while (rs.next()) {
				isRosterDependent = uF.parseToBoolean(rs.getString("is_roster"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

		return isRosterDependent;
	}

	public double getMinimumRateForPublicHolidays(Connection con, String strEmpId, String strDay) {
		UtilityFunctions uF = new UtilityFunctions();

		PreparedStatement pst = null;
		ResultSet rs = null;
		double dblMinRate = 0.0d;

		try {

			String strServiceId = null;

			pst = con.prepareStatement(selectEmployee2Details);
			pst.setInt(1, uF.parseToInt(strEmpId));
			rs = pst.executeQuery();

			while (rs.next()) {
				strServiceId = rs.getString("service_id");
			}
			rs.close();
			pst.close();

			if (strServiceId != null) {
				if (strServiceId.lastIndexOf(",") > 0) {
					strServiceId = strServiceId.substring(0, strServiceId.lastIndexOf(","));
				}
				// strServiceId = strServiceId.replace(",", "','");
			}

			pst = con.prepareStatement(selectPayrollPolicyV2 + " and service_id in (" + strServiceId + ")");
			pst.setInt(1, uF.parseToInt(strEmpId));

			// log.debug(strDay+" pst=====>"+pst);

			rs = pst.executeQuery();
			if (strDay != null) {
				strDay = strDay.toUpperCase();
			}
			while (rs.next()) {
				if (strDay != null && strDay.equalsIgnoreCase(SUNDAY)) {
					dblMinRate = rs.getDouble("sunamount");
					if (dblMinRate > 0) {
						dblMinRate = Math.min(dblMinRate, rs.getDouble("sunamount"));
					}
				} else if (strDay != null && strDay.equalsIgnoreCase(MONDAY)) {
					dblMinRate = rs.getDouble("monamount");
					if (dblMinRate > 0) {
						dblMinRate = Math.min(dblMinRate, rs.getDouble("monamount"));
					}
				} else if (strDay != null && strDay.equalsIgnoreCase(TUESDAY)) {
					dblMinRate = rs.getDouble("tuesamount");
					if (dblMinRate > 0) {
						dblMinRate = Math.min(dblMinRate, rs.getDouble("tuesamount"));
					}
				} else if (strDay != null && strDay.equalsIgnoreCase(WEDNESDAY)) {
					dblMinRate = rs.getDouble("wedamount");
					if (dblMinRate > 0) {
						dblMinRate = Math.min(dblMinRate, rs.getDouble("wedamount"));
					}
				} else if (strDay != null && strDay.equalsIgnoreCase(THURSDAY)) {
					dblMinRate = rs.getDouble("thursamount");
					if (dblMinRate > 0) {
						dblMinRate = Math.min(dblMinRate, rs.getDouble("thursamount"));
					}
				} else if (strDay != null && strDay.equalsIgnoreCase(FRIDAY)) {
					dblMinRate = rs.getDouble("friamount");
					if (dblMinRate > 0) {
						dblMinRate = Math.min(dblMinRate, rs.getDouble("friamount"));
					}
				} else if (strDay != null && strDay.equalsIgnoreCase(SATURDAY)) {
					dblMinRate = rs.getDouble("satamount");
					if (dblMinRate > 0) {
						dblMinRate = Math.min(dblMinRate, rs.getDouble("satamount"));
					}

				}
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return dblMinRate;
	}

	public Map<String, String> getTardyType(Connection con) {

		Map<String, String> hmTardyType = new HashMap<String, String>();

		PreparedStatement pst = null;
		ResultSet rs = null;

		try {

			pst = con.prepareStatement(selectTardyTime);
			pst.setString(1, "TARDY");
			rs = pst.executeQuery();

			while (rs.next()) {
				if ("IN".equalsIgnoreCase(rs.getString("mode"))) {
					hmTardyType.put("TARDY_IN", rs.getString("time_value"));
				} else {
					hmTardyType.put("TARDY_OUT", rs.getString("time_value"));
				}
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmTardyType;
	}

	public Map<String, String> getUserTypeMap(Connection con) {

		Map<String, String> hmUserTypeMap = new HashMap<String, String>();

		PreparedStatement pst = null;
		ResultSet rs = null;

		try {

			pst = con.prepareStatement(selectUserTypeR);
			rs = pst.executeQuery();

			while (rs.next()) {
				hmUserTypeMap.put(rs.getString("user_type_id"), rs.getString("user_type"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

		return hmUserTypeMap;
	}

	public Map<String, String> getEmployeeIdUserTypeIdMap(Connection con) {

		Map<String, String> hmEmployeeIdUserTypeIdMap = new HashMap<String, String>();

		PreparedStatement pst = null;
		ResultSet rs = null;

		try {
			pst = con.prepareStatement(selectUserR);
			rs = pst.executeQuery();

			while (rs.next()) {
				hmEmployeeIdUserTypeIdMap.put(rs.getString("emp_id"), rs.getString("user_type_id"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

		return hmEmployeeIdUserTypeIdMap;
	}

	public void getEmployeePaidMap(Connection con, String strEmpId, Map<String, String> hmEmployeePaidMap, Map<String, String> hmEmployeeCarryForwardMap) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		UtilityFunctions uF = new UtilityFunctions();

		try {
			pst = con.prepareStatement(selectLeaveType1);
			pst.setInt(1, uF.parseToInt(strEmpId));

			log.debug("pst==>" + pst);

			rs = pst.executeQuery();

			while (rs.next()) {

				if (hmEmployeePaidMap != null) {
					hmEmployeePaidMap.put(rs.getString("leave_type_name"), rs.getString("is_paid"));
				}

				if (hmEmployeeCarryForwardMap != null) {
					hmEmployeeCarryForwardMap.put(rs.getString("leave_type_name"), rs.getString("is_carryforward"));
				}
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
	}

	public Map<String, String> getLeaveCodeNameMap(Connection con, UtilityFunctions uF) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmLeaveCodeMap = new HashMap<String, String>();
		try {

			pst = con.prepareStatement(selectLeaveTypeR);
			rs = pst.executeQuery();

			while (rs.next()) {
				hmLeaveCodeMap.put(rs.getString("leave_type_code"), rs.getString("leave_type_name"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmLeaveCodeMap;

	}

	public Map<String, Map<String, String>> getWorkLocationMap(Connection con) {

		Map<String, Map<String, String>> hmWorkLocation = new HashMap<String, Map<String, String>>();

		PreparedStatement pst = null;
		ResultSet rs = null;
		// System.out.print("in CF:");
		try {
			pst = con.prepareStatement(selectWLocationR);
			rs = pst.executeQuery();

			/*
			 * cst =
			 * con.prepareStatement("{? = call sel_worklocation_details()}");
			 * cst.registerOutParameter(1, Types.OTHER); cst.execute(); rs =
			 * (ResultSet) cst.getObject(1);
			 */
			while (rs.next()) {
				Map<String, String> hm = new HashMap<String, String>();

				hm.put("WL_NAME", rs.getString("wlocation_name"));
				hm.put("WL_CODE", rs.getString("wloacation_code"));
				hm.put("WL_PINCODE", rs.getString("wlocation_pincode"));
				hm.put("WL_ADDRESS", rs.getString("wlocation_address"));
				hm.put("WL_CITY", rs.getString("wlocation_city"));
				hm.put("WL_COUNTRY", rs.getString("country_name"));
				hm.put("WL_CONTACT_NO", rs.getString("wlocation_contactno"));
				hm.put("WL_FAX_NO", rs.getString("wlocation_faxno"));

				hm.put("WL_PAN_NO", rs.getString("wlocation_pan_no"));
				hm.put("WL_TAN_NO", rs.getString("wlocation_tan_no"));
				hm.put("WL_REG_NO", rs.getString("wlocation_reg_no"));
				hm.put("WL_ECC1_NO", rs.getString("wlocation_ecc_code_1"));
				hm.put("WL_ECC2_NO", rs.getString("wlocation_ecc_code_2"));

				hm.put("WL_START_TIME", rs.getString("wlocation_start_time"));
				hm.put("WL_END_TIME", rs.getString("wlocation_end_time"));
				hm.put("WL_WEEKLY_OFF_1", rs.getString("wlocation_weeklyoff1"));
				hm.put("WL_WEEKLY_OFF_TYPE_1", rs.getString("wlocation_weeklyofftype1"));
				hm.put("WL_WEEKLY_OFF_2", rs.getString("wlocation_weeklyoff2"));
				hm.put("WL_WEEKLY_OFF_TYPE_2", rs.getString("wlocation_weeklyofftype2"));

				hmWorkLocation.put(rs.getString("wlocation_id"), hm);
				// System.out.print("hmWorkLocation in CF:"+hmWorkLocation);
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

		return hmWorkLocation;
	}

	public Map<String, Map<String, String>> getWorkLocationMapForBilling(Connection con) {

		Map<String, Map<String, String>> hmWorkLocation = new HashMap<String, Map<String, String>>();

		PreparedStatement pst = null;
		ResultSet rs = null;

		try {
			pst = con.prepareStatement(selectWLocationR1);
			rs = pst.executeQuery();

			/*
			 * cst =
			 * con.prepareStatement("{? = call sel_worklocation_details()}");
			 * cst.registerOutParameter(1, Types.OTHER); cst.execute(); rs =
			 * (ResultSet) cst.getObject(1);
			 */
			while (rs.next()) {
				Map<String, String> hm = new HashMap<String, String>();

				hm.put("WL_NAME", rs.getString("wlocation_name"));
				hm.put("WL_CODE", rs.getString("wloacation_code"));
				hm.put("WL_PINCODE", rs.getString("wlocation_billing_pincode"));
				hm.put("WL_ADDRESS", rs.getString("wlocation_billing_address"));
				hm.put("WL_CITY", rs.getString("wlocation_billing_city"));
				hm.put("WL_COUNTRY", rs.getString("country_name"));
				hm.put("WL_CONTACT_NO", rs.getString("wlocation_billing_contactno"));
				hm.put("WL_FAX_NO", rs.getString("wlocation_billing_faxno"));

				hm.put("WL_PAN_NO", rs.getString("wlocation_pan_no"));
				hm.put("WL_TAN_NO", rs.getString("wlocation_tan_no"));
				hm.put("WL_REG_NO", rs.getString("wlocation_reg_no"));
				hm.put("WL_ECC1_NO", rs.getString("wlocation_ecc_code_1"));
				hm.put("WL_ECC2_NO", rs.getString("wlocation_ecc_code_2"));

				hm.put("WL_START_TIME", rs.getString("wlocation_start_time"));
				hm.put("WL_END_TIME", rs.getString("wlocation_end_time"));
				hm.put("WL_WEEKLY_OFF_1", rs.getString("wlocation_weeklyoff1"));
				hm.put("WL_WEEKLY_OFF_TYPE_1", rs.getString("wlocation_weeklyofftype1"));
				hm.put("WL_WEEKLY_OFF_2", rs.getString("wlocation_weeklyoff2"));
				hm.put("WL_WEEKLY_OFF_TYPE_2", rs.getString("wlocation_weeklyofftype2"));

				hmWorkLocation.put(rs.getString("wlocation_id"), hm);
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

		return hmWorkLocation;
	}

	public Map<String, Map<String, String>> getWorkLocationMap(Connection con, int orgId) {

		Map<String, Map<String, String>> hmWorkLocation = new HashMap<String, Map<String, String>>();

		PreparedStatement pst = null;
		ResultSet rs = null;

		try {
			// pst = con.prepareStatement(selectWLocationR);
			// rs = pst.executeQuery();

			pst = con.prepareStatement("select * from work_location_info where org_id=?");
			pst.setInt(1, orgId);
			rs = pst.executeQuery();

			while (rs.next()) {
				Map<String, String> hm = new HashMap<String, String>();
				hm.put("WL_ID", rs.getString("wlocation_id"));
				hm.put("WL_NAME", rs.getString("wlocation_name"));
				hm.put("WL_CODE", rs.getString("wloacation_code"));
				hm.put("WL_PINCODE", rs.getString("wlocation_pincode"));
				hm.put("WL_ADDRESS", rs.getString("wlocation_address"));
				hm.put("WL_CITY", rs.getString("wlocation_city"));
				hm.put("WL_CONTACT_NO", rs.getString("wlocation_contactno"));
				hm.put("WL_FAX_NO", rs.getString("wlocation_faxno"));
				hm.put("WL_EMAIL_ID", rs.getString("wlocation_email"));

				hm.put("WL_PAN_NO", rs.getString("wlocation_pan_no"));
				hm.put("WL_TAN_NO", rs.getString("wlocation_tan_no"));
				hm.put("WL_REG_NO", rs.getString("wlocation_reg_no"));
				hm.put("WL_ECC1_NO", rs.getString("wlocation_ecc_code_1"));
				hm.put("WL_ECC2_NO", rs.getString("wlocation_ecc_code_2"));

				hm.put("WL_START_TIME", rs.getString("wlocation_start_time"));
				hm.put("WL_END_TIME", rs.getString("wlocation_end_time"));

				hm.put("WL_WEEKLY_OFF_1", rs.getString("wlocation_weeklyoff1"));
				String wlocation_weeklyofftype1 = rs.getString("wlocation_weeklyofftype1") != null && !rs.getString("wlocation_weeklyofftype1").equals("") ? rs
						.getString("wlocation_weeklyofftype1").equals("HD") ? "Half Day" : "Full Day" : "";
				hm.put("WL_WEEKLY_OFF_TYPE_1", wlocation_weeklyofftype1);
				String wlocation_weeknos1 = "All";
				if (rs.getString("wlocation_weeknos1") != null && !rs.getString("wlocation_weeknos1").equals("")) {
					String[] arr = rs.getString("wlocation_weeknos1").split(",");
					for (int i = 0; i < arr.length; i++) {
						if (i == 0) {
							wlocation_weeknos1 = uF.getDigitPosition(uF.parseToInt(arr[i]));
						} else {
							wlocation_weeknos1 += "," + uF.getDigitPosition(uF.parseToInt(arr[i]));
						}
					}
				}
				hm.put("WL_WEEK_No_1", wlocation_weeknos1);

				hm.put("WL_WEEKLY_OFF_2", rs.getString("wlocation_weeklyoff2"));
				String wlocation_weeklyofftype2 = rs.getString("wlocation_weeklyofftype2") != null && !rs.getString("wlocation_weeklyofftype2").equals("") ? rs
						.getString("wlocation_weeklyofftype2").equals("HD") ? "Half Day" : "Full Day" : "";
				hm.put("WL_WEEKLY_OFF_TYPE_2", wlocation_weeklyofftype2);
				String wlocation_weeknos2 = "All";
				if (rs.getString("wlocation_weeknos2") != null && !rs.getString("wlocation_weeknos2").equals("")) {
					String[] arr = rs.getString("wlocation_weeknos2").split(",");
					for (int i = 0; i < arr.length; i++) {
						if (i == 0) {
							wlocation_weeknos2 = uF.getDigitPosition(uF.parseToInt(arr[i]));
						} else {
							wlocation_weeknos2 += "," + uF.getDigitPosition(uF.parseToInt(arr[i]));
						}
					}
				}
				hm.put("WL_WEEK_No_2", wlocation_weeknos2);

				hm.put("WL_WEEKLY_OFF_3", rs.getString("wlocation_weeklyoff3"));
				String wlocation_weeklyofftype3 = rs.getString("wlocation_weeklyofftype3") != null && !rs.getString("wlocation_weeklyofftype3").equals("") ? rs
						.getString("wlocation_weeklyofftype3").equals("HD") ? "Half Day" : "Full Day" : "";
				hm.put("WL_WEEKLY_OFF_TYPE_3", wlocation_weeklyofftype3);
				String wlocation_weeknos3 = "All";
				if (rs.getString("wlocation_weeknos3") != null && !rs.getString("wlocation_weeknos3").equals("")) {
					String[] arr = rs.getString("wlocation_weeknos3").split(",");
					for (int i = 0; i < arr.length; i++) {
						if (i == 0) {
							wlocation_weeknos3 = uF.getDigitPosition(uF.parseToInt(arr[i]));
						} else {
							wlocation_weeknos3 += "," + uF.getDigitPosition(uF.parseToInt(arr[i]));
						}
					}
				}
				hm.put("WL_WEEK_No_3", wlocation_weeknos3);

				hm.put("WL_BOIMETRIC_INFO", rs.getString("biometric_info"));
				hm.put("WL_PT_REG_NO", rs.getString("wlocation_ptreg_no"));
				hm.put("WL_PT_RC_EC", rs.getString("wlocation_pt_rcec"));

				hmWorkLocation.put(rs.getString("wlocation_id"), hm);
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

		return hmWorkLocation;
	}

	public void getEmpWlocationMap(Connection con, Map<String, String> hmEmpStateMap, Map<String, String> hmEmpWlocationMap, Map<String, String> hmEmpMertoMap) {
		PreparedStatement pst = null;
		ResultSet rs = null;

		try {
			pst = con.prepareStatement(selectMetroWLocationR);
			rs = pst.executeQuery();

			while (rs.next()) {
				if (hmEmpStateMap != null)
					hmEmpStateMap.put(rs.getString("emp_id"), rs.getString("state_id"));
				if (hmEmpWlocationMap != null)
					hmEmpWlocationMap.put(rs.getString("emp_id"), rs.getString("wlocation_id"));
				if (hmEmpMertoMap != null)
					hmEmpMertoMap.put(rs.getString("emp_id"), rs.getString("ismetro"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

	}

	public void getEmpWlocationMap(Connection con, Map<String, String> hmEmpStateMap, Map<String, String> hmEmpWlocationMap, Map<String, String> hmEmpMertoMap,
			Map<String, String> hmEmpOrgMap) {
		PreparedStatement pst = null;
		ResultSet rs = null;

		try {
			pst = con.prepareStatement(selectMetroWLocationR);
			rs = pst.executeQuery();

			while (rs.next()) {
				if (hmEmpStateMap != null)
					hmEmpStateMap.put(rs.getString("emp_id"), rs.getString("state_id"));
				if (hmEmpWlocationMap != null)
					hmEmpWlocationMap.put(rs.getString("emp_id"), rs.getString("wlocation_id"));
				if (hmEmpOrgMap != null)
					hmEmpOrgMap.put(rs.getString("emp_id"), rs.getString("org_id"));
				if (hmEmpMertoMap != null)
					hmEmpMertoMap.put(rs.getString("emp_id"), rs.getString("ismetro"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

	}

	public void getLeavesColour(Connection con, Map<String, String> hmLeavesColour) {

		PreparedStatement pst = null;
		ResultSet rs = null;

		try {

			pst = con.prepareStatement(selectLeaveTypeF);
			rs = pst.executeQuery();

			while (rs.next()) {
				// hmLeavesColour.put(rs.getString("leave_type_name"),
				// rs.getString("leave_type_colour"));
				hmLeavesColour.put(rs.getString("leave_type_id"), rs.getString("leave_type_colour"));
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
	}

	public void getBreakColour(Connection con, Map<String, String> hmBreakColour) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		try {
			pst = con.prepareStatement(selectBreakTypeF);
			rs = pst.executeQuery();
			while (rs.next()) {
				hmBreakColour.put(rs.getString("break_type_id"), rs.getString("break_type_colour"));
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
	}

	public void getLeavesAttributes(Connection con, UtilityFunctions uF, Map<String, String> hmLeavesColour, Map<String, String> hmLeavesName) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		try {
			pst = con.prepareStatement(selectLeaveTypeF);
			rs = pst.executeQuery();

			while (rs.next()) {
				if (hmLeavesColour != null) {
					hmLeavesColour.put(rs.getString("leave_type_code"), rs.getString("leave_type_colour"));
				}
				if (hmLeavesName != null) {
					hmLeavesName.put(rs.getString("leave_type_code"), rs.getString("leave_type_name"));
				}
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
	}

	public Map<String, String> getLeaveTypeMap(Connection con) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmLeaveTypeMap = new HashMap<String, String>();

		try {
			pst = con.prepareStatement(selectLeaveTypeF);
			rs = pst.executeQuery();

			while (rs.next()) {
				hmLeaveTypeMap.put(rs.getString("leave_type_id"), rs.getString("leave_type_name"));
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmLeaveTypeMap;
	}

	public Map<String, String> getBreakTypeMap(Connection con) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmBreakTypeMap = new HashMap<String, String>();

		try {
			pst = con.prepareStatement(selectBreakTypeF);
			rs = pst.executeQuery();

			while (rs.next()) {
				hmBreakTypeMap.put(rs.getString("break_type_id"), rs.getString("break_type_name"));
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmBreakTypeMap;
	}

	public Map<String, String> getBalanceLeaveMap(Connection con, String strEmpId, CommonFunctions CF) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmBalance = new HashMap<String, String>();

		try {
			if (strEmpId != null) {

				pst = con.prepareStatement("select * from leave_register1 where emp_id =? and _date<= ? limit 1");
				pst.setInt(1, uF.parseToInt(strEmpId));
				pst.setDate(2, uF.getCurrentDate(CF.getStrTimeZone()));
				rs = pst.executeQuery();

				while (rs.next()) {
					hmBalance.put(rs.getString("emp_id") + "_" + rs.getString("leave_type_id"), rs.getString("balance"));
				}
				rs.close();
				pst.close();
			} else {
				pst = con.prepareStatement("select * from leave_register1 where _date<= ? limit 1");
				pst.setDate(1, uF.getCurrentDate(CF.getStrTimeZone()));
				rs = pst.executeQuery();

				while (rs.next()) {
					hmBalance.put(rs.getString("emp_id") + "_" + rs.getString("leave_type_id"), rs.getString("balance"));
				}
				rs.close();
				pst.close();
			}

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmBalance;
	}

	public List<String> getDesignationList(Connection con) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		List<String> alDesignation = new ArrayList<String>();

		try {

			pst = con.prepareStatement("select designation_name from employee_official_details");
			rs = pst.executeQuery();

			while (rs.next()) {
				if (rs.getString("designation_name") != null && !alDesignation.contains("\"" + rs.getString("designation_name") + "\"")) {
					alDesignation.add("\"" + rs.getString("designation_name") + "\"");
				}
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return alDesignation;
	}

	private Map<String, String> getLeavesMap(String strDateFrom, String strDateTo, String strLeaveType, Map<String, String> hmLeaveMap,
			Map<String, String> hmLeaveDatesType, CommonFunctions CF, boolean isHalfDay, List<String> alPresentList, Map<String, String> hmEmpLevelMap,
			Map<String, String> hmBalanceLeaveMap, String strEmpId, String strLeaveTypeId, Map<String, String> hmMonthlyLeaves, List<String> alCancelledLeaves) {

		UtilityFunctions uF = new UtilityFunctions();
		boolean isBreak = false;

		try {

			Calendar cal = GregorianCalendar.getInstance(TimeZone.getTimeZone(CF.getStrTimeZone()));
			// Calendar cal = GregorianCalendar.getInstance();
			String strDate = null;
			Map<String, String> hmLeaveCount = new HashMap<String, String>();

			cal.set(Calendar.DATE, uF.parseToInt(uF.getDateFormat(strDateFrom, DATE_FORMAT, "dd")));
			cal.set(Calendar.MONTH, uF.parseToInt(uF.getDateFormat(strDateFrom, DATE_FORMAT, "MM")) - 1);
			cal.set(Calendar.YEAR, uF.parseToInt(uF.getDateFormat(strDateFrom, DATE_FORMAT, "yyyy")));

			for (int x = 0; x < 10000; x++) { // This loop is used to avoid
												// infinite loop. However, it
												// needs to have an added logic.
				// for(;;){

				strDate = ((cal.get(Calendar.DATE) < 10) ? "0" + cal.get(Calendar.DATE) : cal.get(Calendar.DATE)) + "/"
						+ (((cal.get(Calendar.MONTH) + 1) < 10) ? "0" + (cal.get(Calendar.MONTH) + 1) : (cal.get(Calendar.MONTH) + 1)) + "/"
						+ cal.get(Calendar.YEAR);

				if (strDate != null && !strDate.equals(strDateTo)) {
					cal.add(Calendar.DATE, 1);
				} else {
					isBreak = true;
				}

				// System.out.println("strDate="+strDate+" strDateTo="+strDateTo);

				// log.debug("strDate="+strDate+" strDateTo="+strDateTo+" strDateFrom="+strDateFrom);

				// if(alPresentList!=null && !alPresentList.contains(strDate)){
				hmLeaveMap.put(strDate, strLeaveType);
				// }

				if (hmLeaveDatesType != null && !alCancelledLeaves.contains(strDate + "_" + strLeaveType + "_" + strEmpId)) {
					// double dblLeaveCount =
					// uF.parseToDouble(hmLeaveDatesType.get("COUNT"));
					double dblLeaveCount = uF.parseToDouble(hmLeaveCount.get("COUNT"));

					if (isHalfDay && !hmLeaveDatesType.containsKey(strDate)) {
						hmLeaveDatesType.put(strDate, "H");
						dblLeaveCount += 0.5;
					} else if ((alPresentList == null || (alPresentList != null && !alPresentList.contains(strDate))) && !hmLeaveDatesType.containsKey(strDate)) {
						hmLeaveDatesType.put(strDate, "F");
						dblLeaveCount++;
					}

					double dblBalanceCount = uF.parseToDouble(hmBalanceLeaveMap.get(strEmpId + "_" + strLeaveTypeId));

					if (dblLeaveCount >= dblBalanceCount) {
						dblLeaveCount = dblBalanceCount;
					}

					hmLeaveCount.put("COUNT", dblLeaveCount + "");
					// hmLeaveDatesType.put("COUNT", dblLeaveCount + "");

					if (hmMonthlyLeaves != null) {
						hmMonthlyLeaves.put(strEmpId + "_" + strLeaveTypeId, dblLeaveCount + "");
					}

				}

				if (isBreak) {
					break;
				}
			}

			// double dblLeaveCount =
			// uF.parseToDouble(hmLeaveCount.get("COUNT"));
			double dblLeaveCount1 = 0;
			if (hmLeaveDatesType != null) {
				dblLeaveCount1 = uF.parseToDouble(hmLeaveDatesType.get("COUNT"));

				// hmLeaveDatesType.put("COUNT", (dblLeaveCount +
				// dblLeaveCount1) + "");
				hmLeaveDatesType.put("COUNT", (dblLeaveCount1) + "");
			}

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		}

		return hmLeaveMap;
	}

	public Map<String, Map<String, String>> getLeaveDates(Connection con, String strD1, String strD2, CommonFunctions CF,
			Map<String, Map<String, String>> hmLeaveDatesType, boolean isPaid, Map<String, String> hmMonthlyLeaves) {

		Map<String, Map<String, String>> hmLeaveDates = new HashMap<String, Map<String, String>>();
		UtilityFunctions uF = new UtilityFunctions();

		PreparedStatement pst = null;
		ResultSet rs = null;

		try {
			String strLeaveD1 = null;
			String strLeaveD2 = null;

			// con.prepareStatement("select *, (leave_carryforward - monthly_leaves + accrued_leaves) as balance from leave_register where from_date<= ? and to_date>= ?");

			// pst =
			// con.prepareStatement("select sum(leave_no) as paid_leaves, emp_id, leave_type_id from leave_application_register where _date between ? and ? and _type = ? and is_paid = ? group by emp_id, leave_type_id");
			pst = con
					.prepareStatement("select sum(leave_no) as paid_leaves, emp_id from leave_application_register where _date between ? and ? and _type = ? and is_paid = ? and is_modify= false and leave_type_id not in (select leave_type_id from leave_type where is_compensatory = true) group by emp_id");
			pst.setDate(1, uF.getDateFormat(strD1, DATE_FORMAT));
			pst.setDate(2, uF.getDateFormat(strD2, DATE_FORMAT));
			pst.setBoolean(3, true);
			pst.setBoolean(4, true);
			rs = pst.executeQuery();
			Map<String, String> hmBalanceLeaveTakenMap = new HashMap<String, String>();
			while (rs.next()) {
				hmBalanceLeaveTakenMap.put(rs.getString("emp_id"), rs.getString("paid_leaves"));
			}
			rs.close();
			pst.close();

			/*
			 * 
			 * pst = con .prepareStatement(
			 * "select * from leave_register1 lr,(select max(_date) as _date, leave_type_id, emp_id from leave_register1 where _date<= ? group by leave_type_id, emp_id ) lr1 where lr1._date= lr._date and lr.emp_id = lr1.emp_id and lr.leave_type_id = lr1.leave_type_id"
			 * ); pst.setDate(1, uF.getDateFormat(strD2, DATE_FORMAT)); //
			 * pst.setDate(2, uF.getDateFormat(strD2, DATE_FORMAT));
			 * 
			 * rs = pst.executeQuery(); Map<String, String> hmBalanceLeaveMap =
			 * new HashMap<String, String>(); while (rs.next()) { //
			 * hmBalanceLeaveMap.put(rs.getString("emp_id") + "_" +
			 * rs.getString("leave_type_id"), rs.getString("balance"));
			 * hmBalanceLeaveMap.put(rs.getString("emp_id") + "_" +
			 * rs.getString("leave_type_id"),
			 * (uF.parseToDouble(rs.getString("taken_paid")) -
			 * uF.parseToDouble(hmBalanceLeaveTakenMap
			 * .get(rs.getString("emp_id") + "_" +
			 * rs.getString("leave_type_id"))))+"");
			 * 
			 * }
			 */

			// ===================== NEW COMMENT =======================
			Map<String, String> hmEmpLevelMap = getEmpLevelMap(con);

			pst = con.prepareStatement("select * from attendance_details where to_date(in_out_timestamp::text, 'YYYY-MM-DD') between ? and ? order by emp_id");
			pst.setDate(1, uF.getDateFormat(strD1, DATE_FORMAT));
			pst.setDate(2, uF.getDateFormat(strD2, DATE_FORMAT));
			rs = pst.executeQuery();

			// System.out.println("pst===>"+pst);

			Map<String, List<String>> hmPresentMap = new HashMap<String, List<String>>();
			List<String> alPresentDates = new ArrayList<String>();
			String strEmpIdNew = null;
			String strEmpIdOld = null;
			while (rs.next()) {
				strEmpIdNew = rs.getString("emp_id");
				if (strEmpIdNew != null && !strEmpIdNew.equalsIgnoreCase(strEmpIdOld)) {
					alPresentDates = new ArrayList<String>();
				}
				alPresentDates.add(uF.getDateFormat(rs.getString("in_out_timestamp"), DBTIMESTAMP, DATE_FORMAT));
				hmPresentMap.put(rs.getString("emp_id"), alPresentDates);
				strEmpIdOld = strEmpIdNew;
			}
			rs.close();
			pst.close();

			pst = con.prepareStatement("select * from leave_application_register where is_modify = true and _date between ? and ? order by emp_id");
			pst.setDate(1, uF.getDateFormat(strD1, DATE_FORMAT));
			pst.setDate(2, uF.getDateFormat(strD2, DATE_FORMAT));
			rs = pst.executeQuery();
			List<String> alCancelledLeaves = new ArrayList<String>();
			while (rs.next()) {
				alCancelledLeaves.add(rs.getString("_date") + "_" + rs.getString("leave_type_id") + "_" + rs.getString("emp_id"));
			}
			rs.close();
			pst.close();

			if (isPaid) {
				// pst = con.prepareStatement(selectLeaveDatesPaid);
				pst = con
						.prepareStatement("select * from emp_leave_entry ele, leave_type lt where ele.leave_type_id = lt.leave_type_id "
								+ "and to_date(approval_from::text,'yyyy-MM-dd') >=? and to_date(approval_from::text,'yyyy-MM-dd') <=? and is_approved = 1 and ispaid= true and is_compensate = false and (is_modify is null or is_modify = false) ");
			} else {
				// pst = con.prepareStatement(selectLeaveDates);
				pst = con
						.prepareStatement("select * from emp_leave_entry ele, leave_type lt where ele.leave_type_id = lt.leave_type_id "
								+ "and to_date(approval_from::text,'yyyy-MM-dd') >=? and to_date(approval_from::text,'yyyy-MM-dd') <=? and is_approved = 1 and is_compensate = false and (is_modify is null or is_modify = false)");
			}
			// pst.setString(1, uF.getDateFormat(strD1, DATE_FORMAT, DBDATE));
			// pst.setString(2, uF.getDateFormat(strD2, DATE_FORMAT, DBDATE));
			pst.setDate(1, uF.getDateFormat(strD1, DATE_FORMAT));
			pst.setDate(2, uF.getDateFormat(strD2, DATE_FORMAT));
			// System.out.println("pst=====>"+pst);
			rs = pst.executeQuery();

			String strLeaveFrom = null;
			String strLeaveTo = null;
			// String strLeaveType = null;
			String strLeaveTypeId = null;
			String strLeaveTypeCode = null;
			String strEmpId = null;

			boolean isHalfDay = false;
			// int count=0;
			while (rs.next()) {

				strLeaveFrom = uF.getDateFormat(rs.getString("approval_from"), DBDATE, DATE_FORMAT);
				strLeaveTo = uF.getDateFormat(rs.getString("approval_to_date"), DBDATE, DATE_FORMAT);
				// strLeaveType = rs.getString("leave_type_name");
				strLeaveTypeId = rs.getString("leave_type_id");
				strLeaveTypeCode = rs.getString("leave_type_code");
				strEmpId = rs.getString("emp_id");
				isHalfDay = rs.getBoolean("ishalfday");

				if (strD1 != null
						&& (uF.getDateFormat(strD1, DATE_FORMAT).after(uF.getDateFormat(strLeaveFrom, DATE_FORMAT)) || uF.getDateFormat(strD1, DATE_FORMAT)
								.equals(uF.getDateFormat(strLeaveFrom, DATE_FORMAT)))
						&& (uF.getDateFormat(strD2, DATE_FORMAT).before(uF.getDateFormat(strLeaveTo, DATE_FORMAT)) || uF.getDateFormat(strD2, DATE_FORMAT)
								.equals(uF.getDateFormat(strLeaveTo, DATE_FORMAT)))) {
					strLeaveD1 = strD1;
				} else if (strD1 != null
						&& (uF.getDateFormat(strD1, DATE_FORMAT).after(uF.getDateFormat(strLeaveFrom, DATE_FORMAT)) || uF.getDateFormat(strD1, DATE_FORMAT)
								.equals(uF.getDateFormat(strLeaveFrom, DATE_FORMAT)))
						&& (uF.getDateFormat(strLeaveTo, DATE_FORMAT).before(uF.getDateFormat(strD2, DATE_FORMAT)) || uF.getDateFormat(strLeaveTo, DATE_FORMAT)
								.equals(uF.getDateFormat(strD2, DATE_FORMAT)))) {
					strLeaveD1 = strD1;
				} else {
					strLeaveD1 = strLeaveFrom;
				}

				if (strD2 != null
						&& (uF.getDateFormat(strD2, DATE_FORMAT).before(uF.getDateFormat(strLeaveTo, DATE_FORMAT)) || uF.getDateFormat(strD2, DATE_FORMAT)
								.equals(uF.getDateFormat(strLeaveTo, DATE_FORMAT)))) {
					strLeaveD2 = strD2;
				} else {
					strLeaveD2 = strLeaveTo;
				}

				Map<String, String> hmTemp = (Map<String, String>) hmLeaveDates.get(strEmpId);
				Map<String, String> hmTempType = null;

				if (hmLeaveDatesType != null) {
					hmTempType = (Map<String, String>) hmLeaveDatesType.get(strEmpId);
				}

				if (hmTemp == null) {
					hmTemp = new HashMap<String, String>();
					hmTempType = new HashMap<String, String>();
				}

				List<String> alPresentList = hmPresentMap.get(strEmpId);
				getLeavesMap(strLeaveD1, strLeaveD2, strLeaveTypeCode, hmTemp, hmTempType, CF, isHalfDay, alPresentList, hmEmpLevelMap, hmBalanceLeaveTakenMap,
						strEmpId, strLeaveTypeId, hmMonthlyLeaves, alCancelledLeaves);

				if (hmTempType != null) {
					hmTempType.put("COUNT", hmBalanceLeaveTakenMap.get(rs.getString("emp_id")) + "");
				}

				hmLeaveDates.put(strEmpId, hmTemp);

				if (hmLeaveDatesType != null) {
					hmLeaveDatesType.put(strEmpId, hmTempType);
				}
			}
			rs.close();
			pst.close();

			// ===================== NEW COMMENT =======================

			/*
			 * pst = con.prepareStatement(
			 * "select * from leave_application_register where _date between ? and ? and is_modify=false and leave_type_id not in (select leave_type_id from leave_type where is_compensatory = true) order by emp_id"
			 * ); pst.setDate(1, uF.getDateFormat(strLeaveD1, DATE_FORMAT));
			 * pst.setDate(2, uF.getDateFormat(strLeaveD2, DATE_FORMAT));
			 * ResultSet rs1= pst.executeQuery(); while(rs.next()){
			 * 
			 * Map<String, String> hmTemp = (Map<String, String>)
			 * hmLeaveDates.get(rs.getString("emp_id")); Map<String, String>
			 * hmTempType = null;
			 * 
			 * if (hmLeaveDatesType != null) { hmTempType = (Map<String,
			 * String>) hmLeaveDatesType.get(rs.getString("emp_id")); }
			 * 
			 * if (hmTemp == null) { hmTemp = new HashMap<String, String>();
			 * hmTempType = new HashMap<String, String>(); }
			 * 
			 * 
			 * 
			 * hmTemp.put(uF.getDateFormat(rs1.getString("_date"), DBDATE,
			 * DATE_FORMAT), "CL");
			 * if(uF.parseToDouble(rs1.getString("leave_no"))>0.5){
			 * hmTempType.put(uF.getDateFormat(rs1.getString("_date"), DBDATE,
			 * DATE_FORMAT), "F"); }else{
			 * hmTempType.put(uF.getDateFormat(rs1.getString("_date"), DBDATE,
			 * DATE_FORMAT), "H"); }
			 * 
			 * if(hmTempType!=null){ hmTempType.put("COUNT",
			 * hmBalanceLeaveTakenMap.get(rs.getString("emp_id"))+ ""); }
			 * hmLeaveDates.put(rs.getString("emp_id"), hmTemp);
			 * 
			 * if (hmLeaveDatesType != null) {
			 * hmLeaveDatesType.put(rs.getString("emp_id"), hmTempType); } }
			 */

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

		return hmLeaveDates;
	}

	public Map<String, Map<String, String>> getLeaveDates(Connection con, String strD1, String strD2, CommonFunctions CF,
			Map<String, Map<String, String>> hmLeaveDatesType, String strEmpId, String strLeaveId, Map<String, String> hmMonthlyLeaves) {

		Map<String, Map<String, String>> hmLeaveDates = new HashMap<String, Map<String, String>>();
		UtilityFunctions uF = new UtilityFunctions();

		PreparedStatement pst = null;
		ResultSet rs = null;

		try {
			// pst =
			// con.prepareStatement("select * from leave_register where from_date<= ? and to_date>= ?");
			pst = con
					.prepareStatement("select * from leave_register1 lr,(select max(_date) as _date, leave_type_id, emp_id from leave_register1 where _date<= ? group by leave_type_id, emp_id ) lr1 where lr1._date= lr._date and lr.emp_id = lr1.emp_id and lr.leave_type_id = lr1.leave_type_id");
			// pst.setDate(1, uF.getDateFormat(strD1, DATE_FORMAT));
			pst.setDate(1, uF.getDateFormat(strD2, DATE_FORMAT));

			rs = pst.executeQuery();
			Map<String, String> hmBalanceLeaveMap = new HashMap<String, String>();
			while (rs.next()) {
				hmBalanceLeaveMap.put(rs.getString("emp_id") + "_" + rs.getString("leave_type_id"), rs.getString("balance"));
			}
			rs.close();
			pst.close();

			Map<String, String> hmEmpLevelMap = getEmpLevelMap(con);

			pst = con.prepareStatement("select * from attendance_details where to_date(in_out_timestamp::text, 'YYYY-MM-DD') between ? and ?  order by emp_id");
			pst.setDate(1, uF.getDateFormat(strD1, DATE_FORMAT));
			pst.setDate(2, uF.getDateFormat(strD2, DATE_FORMAT));
			rs = pst.executeQuery();

			Map<String, List<String>> hmPresentMap = new HashMap<String, List<String>>();
			List<String> alPresentDates = new ArrayList<String>();
			String strEmpIdNew = null;
			String strEmpIdOld = null;
			while (rs.next()) {
				strEmpIdNew = rs.getString("emp_id");
				if (strEmpIdNew != null && !strEmpIdNew.equalsIgnoreCase(strEmpIdOld)) {
					alPresentDates = new ArrayList<String>();
				}
				alPresentDates.add(uF.getDateFormat(rs.getString("in_out_timestamp"), DBTIMESTAMP, DATE_FORMAT));
				hmPresentMap.put(rs.getString("emp_id"), alPresentDates);
				strEmpIdOld = strEmpIdNew;
			}
			rs.close();
			pst.close();

			pst = con.prepareStatement("select * from leave_application_register where is_modify = true and _date between ? and ? order by emp_id");
			pst.setDate(1, uF.getDateFormat(strD1, DATE_FORMAT));
			pst.setDate(2, uF.getDateFormat(strD2, DATE_FORMAT));
			rs = pst.executeQuery();
			List<String> alCancelledLeaves = new ArrayList<String>();
			while (rs.next()) {
				alCancelledLeaves.add(rs.getString("_date") + "_" + rs.getString("leave_type_id") + "_" + rs.getString("emp_id"));
			}
			rs.close();
			pst.close();

			String strLeaveD1 = null;
			String strLeaveD2 = null;

			pst = con.prepareStatement(selectEmpLeaveDates);
			pst.setString(1, uF.getDateFormat(strD1, DATE_FORMAT, DBDATE));
			pst.setString(2, uF.getDateFormat(strD2, DATE_FORMAT, DBDATE));
			pst.setInt(3, uF.parseToInt(strEmpId));
			pst.setInt(4, uF.parseToInt(strLeaveId));

			rs = pst.executeQuery();

			String strLeaveFrom = null;
			String strLeaveTo = null;
			// String strLeaveType = null;
			String strLeaveTypeCode = null;
			String strLeaveTypeId = null;

			boolean isHalfDay = false;
			while (rs.next()) {
				strLeaveFrom = uF.getDateFormat(rs.getString("approval_from"), DBDATE, DATE_FORMAT);
				strLeaveTo = uF.getDateFormat(rs.getString("approval_to_date"), DBDATE, DATE_FORMAT);
				// strLeaveType = rs.getString("leave_type_name");
				strLeaveTypeCode = rs.getString("leave_type_code");
				strLeaveTypeId = rs.getString("leave_type_id");
				strEmpId = rs.getString("emp_id");
				isHalfDay = rs.getBoolean("ishalfday");

				if (strD1 != null
						&& (uF.getDateFormat(strD1, DATE_FORMAT).after(uF.getDateFormat(strLeaveFrom, DATE_FORMAT)) || uF.getDateFormat(strD1, DATE_FORMAT)
								.equals(uF.getDateFormat(strLeaveFrom, DATE_FORMAT)))
						&& (uF.getDateFormat(strD2, DATE_FORMAT).before(uF.getDateFormat(strLeaveTo, DATE_FORMAT)) || uF.getDateFormat(strD2, DATE_FORMAT)
								.equals(uF.getDateFormat(strLeaveTo, DATE_FORMAT)))) {
					strLeaveD1 = strD1;
				} else {
					strLeaveD1 = strLeaveFrom;
				}

				if (strD2 != null
						&& (uF.getDateFormat(strD2, DATE_FORMAT).before(uF.getDateFormat(strLeaveTo, DATE_FORMAT)) || uF.getDateFormat(strD2, DATE_FORMAT)
								.equals(uF.getDateFormat(strLeaveTo, DATE_FORMAT)))) {
					strLeaveD2 = strD2;
				} else {
					strLeaveD2 = strLeaveTo;
				}

				Map<String, String> hmTemp = (Map<String, String>) hmLeaveDates.get(strEmpId);
				Map<String, String> hmTempType = null;

				if (hmLeaveDatesType != null) {
					hmTempType = (Map<String, String>) hmLeaveDatesType.get(strEmpId);
				}

				if (hmTemp == null) {
					hmTemp = new HashMap<String, String>();
					hmTempType = new HashMap<String, String>();
				}

				// System.out.println("strEmpId==>"+strEmpId+" strLeaveD1====>"+strLeaveD1+" strLeaveD2===>"+strLeaveD2);

				List<String> alPresentList = hmPresentMap.get(strEmpId);
				getLeavesMap(strLeaveD1, strLeaveD2, strLeaveTypeCode, hmTemp, hmTempType, CF, isHalfDay, alPresentList, hmEmpLevelMap, hmBalanceLeaveMap,
						strEmpId, strLeaveTypeId, hmMonthlyLeaves, alCancelledLeaves);
				hmLeaveDates.put(strEmpId, hmTemp);

				if (hmLeaveDatesType != null) {
					hmLeaveDatesType.put(strEmpId, hmTempType);
				}
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

		return hmLeaveDates;
	}

	public Map<String, String> getServiceDesc(Connection con) {

		Map<String, String> hmServiceDesc = new HashMap<String, String>();

		PreparedStatement pst = null;
		ResultSet rs = null;

		try {

			pst = con.prepareStatement(selectService);
			rs = pst.executeQuery();

			while (rs.next()) {
				hmServiceDesc.put(rs.getString("service_id"), rs.getString("service_desc"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

		return hmServiceDesc;
	}

	public Map<String, String> getServiceColour(Connection con) {

		Map<String, String> hmServiceColour = new HashMap<String, String>();

		PreparedStatement pst = null;
		ResultSet rs = null;

		try {

			pst = con.prepareStatement(selectService);
			rs = pst.executeQuery();

			while (rs.next()) {
				hmServiceColour.put(rs.getString("service_id"), rs.getString("service_colour"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

		return hmServiceColour;
	}

	public int getLeavesCount(String strJoiningtDate, String strStartDate, int nNumberOfLeaves, boolean isCaryForward, CommonFunctions CF) {
		double leaveCount = 0;

		UtilityFunctions uF = new UtilityFunctions();

		try {

			String strCurrentDate = uF.getDateFormat(uF.getCurrentDate(CF.getStrTimeZone()) + "", DBDATE, DATE_FORMAT);

			String strDate = null;

			Date dtStartDate = uF.getDateFormat(strStartDate, DATE_FORMAT);
			Date dtJoiningDate = uF.getDateFormat(strJoiningtDate, DATE_FORMAT);
			// Date dtCurrentDate = uF.getDateFormat(strCurrentDate,
			// DATE_FORMAT);

			if (dtJoiningDate != null && dtJoiningDate.after(dtStartDate)) {
				strDate = strJoiningtDate;
			} else if (dtJoiningDate != null) {
				strDate = strStartDate;
			}

			log.debug("strDate===" + strDate);

			if (strDate == null) {
				return 0;
			}

			Calendar calendar1 = Calendar.getInstance();
			Calendar calendar2 = Calendar.getInstance();

			calendar1.set(uF.parseToInt(uF.getDateFormat(strDate, DATE_FORMAT, "yyyy")), uF.parseToInt(uF.getDateFormat(strDate, DATE_FORMAT, "MM")) - 1,
					uF.parseToInt(uF.getDateFormat(strDate, DATE_FORMAT, "dd")));
			calendar2.set(uF.parseToInt(uF.getDateFormat(strCurrentDate, DATE_FORMAT, "yyyy")),
					uF.parseToInt(uF.getDateFormat(strCurrentDate, DATE_FORMAT, "MM")) - 1, uF.parseToInt(uF.getDateFormat(strCurrentDate, DATE_FORMAT, "dd")));
			long milliseconds1 = calendar1.getTimeInMillis();
			long milliseconds2 = calendar2.getTimeInMillis();
			long diff = milliseconds2 - milliseconds1;
			// long diffSeconds = diff / 1000;
			// long diffMinutes = diff / (60 * 1000);
			// long diffHours = diff / (60 * 60 * 1000);
			long diffDays = diff / (24 * 60 * 60 * 1000);

			// System.out.println("strDate=="+strDate);
			// System.out.println("diffDays=="+diffDays);

			// log.debug("\nThe Date Different Example");
			// log.debug("Time in milliseconds: " + diff + " milliseconds.");
			// log.debug("Time in seconds: " + diffSeconds + " seconds.");
			// log.debug("Time in minutes: " + diffMinutes + " minutes.");
			// log.debug("Time in hours: " + diffHours + " hours.");
			// log.debug("Time in days: " + diffDays + " days.");

			double days = 0;

			if (nNumberOfLeaves > 0) {
				days = 365 * 1.0 / nNumberOfLeaves;
			}

			while (true) {
				if (diffDays > 365 && !isCaryForward) {
					diffDays = diffDays - 365;
				} else {
					break;
				}
			}

			if (days > 0) {
				leaveCount = diffDays / days;
			}

			// System.out.println("leaveCount=="+leaveCount+" diffDays=="+diffDays+" days=="+days+" nNumberOfLeaves=="+nNumberOfLeaves);

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		}

		return (int) leaveCount;
	}

	public String converIntoHtml(String strText, String nullText) {

		if (strText != null) {
			strText = strText.replaceAll("\n", "<br />");

			return strText;
		} else {
			return nullText;
		}
	}

	public String getApproveDenyFlag(int nFlag, boolean isHtml) {
		switch (nFlag) {
			case 1 :
				return ((isHtml) ? "<font color=\"green\">" : "") + "Approved" + ((isHtml) ? "</font>" : "");
			case -1 :
				return ((isHtml) ? "<font color=\"red\">" : "") + "Denied" + ((isHtml) ? "</font>" : "");
			default :
				return ((isHtml) ? "<font color=\"orange\">" : "") + "Waiting for Approval" + ((isHtml) ? "</font>" : "");
		}

	}

	public String getLeaveStartDate(String strDateType) {

		if (strDateType != null && strDateType.equalsIgnoreCase("JD")) {
			return "Joining date";
		} else if (strDateType != null && strDateType.equalsIgnoreCase("CY")) {
			return "Calendar Year";
		} else if (strDateType != null && strDateType.equalsIgnoreCase("FY")) {
			return "Financial Year";
		} else if (strDateType != null && strDateType.equalsIgnoreCase("CMY")) {
			return "Calendar Mid-Year";
		} else if (strDateType != null && strDateType.equalsIgnoreCase("FMY")) {
			return "Financial Mid-Year";
		} else {
			return "";
		}
	}

	public Map<String, String> getDeptMap(Connection con) {

		//
		ResultSet rs = null;
		Map<String, String> hmDept = new HashMap<String, String>();
		PreparedStatement pst = null;

		try {

			//
			// cst =
			// con.prepareStatement("{? = call sel_department_details()}");
			// cst.registerOutParameter(1, Types.OTHER);
			// cst.execute();
			// rs = (ResultSet) cst.getObject(1);

			pst = con.prepareStatement(selectDepartment);
			rs = pst.executeQuery();
			while (rs.next()) {
				hmDept.put(rs.getString("dept_id"), rs.getString("dept_name"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmDept;
	}

	public Map<String, String> getSalaryHeadsMap(Connection con) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmSalaryHeadsMap = new LinkedHashMap<String, String>();

		try {
			pst = con.prepareStatement(selectSalaryDetails1);
			rs = pst.executeQuery();
			List<String> salHeadList = new ArrayList<String>();
			hmSalaryHeadsMap.put(NET+"", "Net Salary");
			while (rs.next()) {
				hmSalaryHeadsMap.put(rs.getString("salary_head_id"), rs.getString("salary_head_name"));
				if (!salHeadList.contains(rs.getString("salary_head_id"))
						&& (rs.getInt("salary_head_id") == EMPLOYEE_EPF || rs.getInt("salary_head_id") == EMPLOYEE_ESI || rs.getInt("salary_head_id") == EMPLOYEE_LWF)) {
					salHeadList.add(rs.getString("salary_head_id"));
				}
			}
			rs.close();
			pst.close();
			if (salHeadList != null && salHeadList.contains(EMPLOYEE_EPF + "")) {
				hmSalaryHeadsMap.put(EMPLOYER_EPF + "", "Employer PF");
			}
			if (salHeadList != null && salHeadList.contains(EMPLOYEE_ESI + "")) {
				hmSalaryHeadsMap.put(EMPLOYER_ESI + "", "Employer ESI");
			}
			if (salHeadList != null && salHeadList.contains(EMPLOYEE_LWF + "")) {
				hmSalaryHeadsMap.put(EMPLOYER_LWF + "", "Employer LWF");
			}

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmSalaryHeadsMap;
	}

	public Map<String, String> getSalaryHeadsMap(Connection con, int nLevelId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmSalaryHeadsMap = new LinkedHashMap<String, String>();
		try {
			pst = con.prepareStatement(selectSalaryDetails11);
			pst.setInt(1, nLevelId);
			rs = pst.executeQuery();
			List<String> salHeadList = new ArrayList<String>();
			while (rs.next()) {
				hmSalaryHeadsMap.put(rs.getString("salary_head_id"), rs.getString("salary_head_name"));
				if (!salHeadList.contains(rs.getString("salary_head_id"))
						&& (rs.getInt("salary_head_id") == EMPLOYEE_EPF || rs.getInt("salary_head_id") == EMPLOYEE_ESI || rs.getInt("salary_head_id") == EMPLOYEE_LWF)) {
					salHeadList.add(rs.getString("salary_head_id"));
				}
			}
			rs.close();
			pst.close();
			if (salHeadList != null && salHeadList.contains(EMPLOYEE_EPF + "")) {
				hmSalaryHeadsMap.put(EMPLOYER_EPF + "", "Employer PF");
			}
			if (salHeadList != null && salHeadList.contains(EMPLOYEE_ESI + "")) {
				hmSalaryHeadsMap.put(EMPLOYER_ESI + "", "Employer ESI");
			}
			if (salHeadList != null && salHeadList.contains(EMPLOYEE_LWF + "")) {
				hmSalaryHeadsMap.put(EMPLOYER_LWF + "", "Employer LWF");
			}

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmSalaryHeadsMap;
	}

	public Map<String, String> getLevelMap(Connection con) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmLevelMap = new HashMap<String, String>();

		try {
			pst = con.prepareStatement(selectLevel);
			rs = pst.executeQuery();

			while (rs.next()) {
				hmLevelMap.put(rs.getString("level_id"), rs.getString("level_name"));//Created By Dattatray Date : 05-10-21
//				hmLevelMap.put(rs.getString("level_id"), rs.getString("level_name") + " [" + rs.getString("level_code") + "]");
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmLevelMap;
	}

	public Map<String, String> getGradeMap(Connection con) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmGradeMap = new HashMap<String, String>();

		try {
			pst = con.prepareStatement(selectGrade);
			rs = pst.executeQuery();

			while (rs.next()) {
				hmGradeMap.put(rs.getString("grade_id"), rs.getString("grade_code"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmGradeMap;
	}

	public Map<String, String> getEmpGradeMap(Connection con) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmEmpGradeMap = new HashMap<String, String>();

		try {

			pst = con.prepareStatement(selectEmployeeR6);
			rs = pst.executeQuery();

			while (rs.next()) {
				hmEmpGradeMap.put(rs.getString("emp_id"), rs.getString("grade_id"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmEmpGradeMap;
	}

	public Map<String, String> getEmpLevelMap(Connection con) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmEmpLevelMap = new HashMap<String, String>();

		try {
			pst = con.prepareStatement(selectEmpLevelDetails);
			rs = pst.executeQuery();

			while (rs.next()) {
				hmEmpLevelMap.put(rs.getString("emp_id"), rs.getString("level_id"));
				hmEmpLevelMap.put(rs.getString("emp_id") + "_SWH", rs.getString("standard_working_hours"));
				hmEmpLevelMap.put(rs.getString("emp_id") + "_SOH", rs.getString("standard_overtime_hours"));
				hmEmpLevelMap.put(rs.getString("emp_id") + "_FLAT_TDS_DEDEC", rs.getString("flat_deduction"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmEmpLevelMap;
	}

	public Map<String, String> getEmpEmploymentStatusMap(Connection con) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmEmpEmploymentStatusMap = new HashMap<String, String>();

		try {
			pst = con.prepareStatement(selectEmployeeR6);
			rs = pst.executeQuery();

			while (rs.next()) {
				hmEmpEmploymentStatusMap.put(rs.getString("emp_id"), rs.getString("emptype"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmEmpEmploymentStatusMap;
	}

	public Map<String, String> getEmpWlocationMap(Connection con) {

		ResultSet rs = null;
		Map<String, String> hmEmpWlocationMap = new HashMap<String, String>();
		PreparedStatement pst = null;

		try {
			pst = con.prepareStatement(selectEmployeeR3);

			rs = pst.executeQuery();

			while (rs.next()) {
				hmEmpWlocationMap.put(rs.getString("emp_id"), rs.getString("wlocation_id"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmEmpWlocationMap;

	}

	public Map<String, String> getEmpWlocationMap() {

		Connection con = null;
		// CallableStatement cst = null;
		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmEmpWlocationMap = new HashMap<String, String>();
		Database db = new Database();
		db.setRequest(request);

		try {
			con = db.makeConnection(con);
			pst = con.prepareStatement(selectEmployeeR3);

			rs = pst.executeQuery();

			while (rs.next()) {
				hmEmpWlocationMap.put(rs.getString("emp_id"), rs.getString("wlocation_id"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			db.closeResultSet(rs);
			db.closeStatements(pst);
			db.closeConnection(con);
		}
		return hmEmpWlocationMap;

	}

	public Map<String, String> getSpecificSalaryData(Connection con, int nSalaryType) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmSalaryData = new HashMap<String, String>();
		try {

			pst = con.prepareStatement("select * from emp_salary_details where salary_head_id = ?");
			pst.setInt(1, nSalaryType);
			rs = pst.executeQuery();

			while (rs.next()) {
				hmSalaryData.put(rs.getString("emp_id"), rs.getString("amount"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

		return hmSalaryData;

	}

	public Map<String, Map<String, String>> getSalaryCalculation(Connection con, int nEmpId, double dblPresent, double dblAbsent, double dblBreaks,
			int nTotalNumberOfDays, double dblIncrementBasic, double dblIncrementDA, String strLevelId, UtilityFunctions uF, CommonFunctions CF, String strD2) {
		// System.out.println("strD2 =====> "+strD2);
		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, Map<String, String>> hmSalaryHeadReCalculatedMap = new LinkedHashMap<String, Map<String, String>>();
		Map<String, Map<String, String>> hmSalaryHeadMap = new LinkedHashMap<String, Map<String, String>>();
		try {
			Map<String, String> hmSalaryEarningDeduction = new HashMap<String, String>();

			// pst =
			// con.prepareStatement("select * from salary_details where level_id = 0 or level_id = -1 or level_id = ? order by salary_head_id, salary_id");
			pst = con.prepareStatement("select * from salary_details where level_id = ? order by salary_head_id, salary_id");
			pst.setInt(1, uF.parseToInt(strLevelId));
			rs = pst.executeQuery();

//			System.out.println("CF/6850--pst===sal==>"+pst);
			Map<String, Map<String, String>> hmSalaryDetails = new HashMap<String, Map<String, String>>();

			while (rs.next()) {

				Map<String, String> hmInnerSal = new HashMap<String, String>();

				hmInnerSal.put("SALARY_HEAD_ID", rs.getString("salary_head_id"));
				hmInnerSal.put("EARNING_DEDUCTION", rs.getString("earning_deduction"));
				hmInnerSal.put("SALARY_AMOUNT_TYPE", rs.getString("salary_head_amount_type"));
				hmInnerSal.put("SUB_SALARY_HEAD_ID", rs.getString("sub_salary_head_id"));
				hmInnerSal.put("SALARY_HEAD_AMOUNT", rs.getString("salary_head_amount"));

				hmSalaryDetails.put(rs.getString("salary_head_id"), hmInnerSal);

				hmSalaryEarningDeduction.put(rs.getString("salary_head_id"), rs.getString("earning_deduction"));

			}
			rs.close();
			pst.close();

			// pst =
			// con.prepareStatement("select * from (select *, 1 as aa from emp_salary_details where emp_id = ? and effective_date = (select max(effective_date) from emp_salary_details where emp_id =? and effective_date <= ? and is_approved=true)  and salary_head_id not in (12) order by earning_deduction desc, salary_head_id, emp_salary_id ) ac union (  select *, 2 as aa from emp_salary_details where emp_id = ? and effective_date = (select max(effective_date)  from emp_salary_details where emp_id =? and effective_date <= ? and is_approved=true) and salary_head_id in (12) order by earning_deduction desc, salary_head_id, emp_salary_id	) order by aa, earning_deduction desc, salary_head_id, emp_salary_id");

			pst = con
					.prepareStatement("select * from (	select *, 0 as aa from emp_salary_details where emp_id = ?	and effective_date = (select max(effective_date) from emp_salary_details where emp_id =? and effective_date <= ? and is_approved=true)  and salary_head_id in ("
							+ DA1
							+ ", "
							+ GROSS
							+ " ) order by earning_deduction desc, salary_head_id, emp_salary_id ) ac1 union  select * from (select *, 1 as aa from emp_salary_details where emp_id = ? and effective_date = (select max(effective_date) from emp_salary_details where emp_id =? and effective_date <= ? and is_approved=true)  and salary_head_id not in ("
							+ TDS
							+ ","
							+ DA1
							+ ", "
							+ GROSS
							+ ") order by earning_deduction desc, salary_head_id, emp_salary_id ) ac union (  select *, 2 as aa from emp_salary_details where emp_id = ? and effective_date = (select max(effective_date)  from emp_salary_details where emp_id =? and effective_date <= ? and is_approved=true) and salary_head_id in ("
							+ TDS
							+ ") order by earning_deduction desc, salary_head_id, emp_salary_id	) order by aa, earning_deduction desc, salary_head_id, emp_salary_id");
			pst.setInt(1, nEmpId);
			pst.setInt(2, nEmpId);
			pst.setDate(3, uF.getDateFormat(strD2, DBDATE));
			pst.setInt(4, nEmpId);
			pst.setInt(5, nEmpId);
			pst.setDate(6, uF.getDateFormat(strD2, DBDATE));
			pst.setInt(7, nEmpId);
			pst.setInt(8, nEmpId);
			pst.setDate(9, uF.getDateFormat(strD2, DBDATE));
//			System.out.println("CF/6897---pst="+pst);
			rs = pst.executeQuery();
			double dblBasicDA = 0;
			// boolean isGross = false;
			while (rs.next()) {
				Map<String, String> hmSalaryInner = new HashMap<String, String>();
				Map<String, String> hmInner = new HashMap<String, String>();
				double dblAmount = 0;

				if (!rs.getBoolean("isdisplay")) {
					continue;
				}

				String strSalaryHeadId = rs.getString("salary_head_id");
				String strEarningDeduction = hmSalaryEarningDeduction.get(rs.getString("salary_head_id"));

				// if(uF.parseToInt(strSalaryHeadId)==GROSS){
				// isGross = true;
				// }

				String strAmount = rs.getString("amount");
				dblAmount = uF.parseToDouble(strAmount);

				if (dblIncrementBasic > 0 && (uF.parseToInt(strSalaryHeadId) == BASIC || uF.parseToInt(strSalaryHeadId) == GROSS)) {
					dblAmount = dblAmount + dblIncrementBasic;
				}

				if (uF.parseToInt(strSalaryHeadId) == BASIC || uF.parseToInt(strSalaryHeadId) == GROSS || uF.parseToInt(strSalaryHeadId) == DA
						|| uF.parseToInt(strSalaryHeadId) == DA1) {
					dblBasicDA += dblAmount;
				}

				Map<String, String> hmInnerSal = hmSalaryDetails.get(strSalaryHeadId);
				if (hmInnerSal == null)
					hmInnerSal = new HashMap<String, String>();

				String strSubSalAmount = hmInnerSal.get("SALARY_HEAD_AMOUNT");
				String strSubSalAmountType = hmInnerSal.get("SALARY_AMOUNT_TYPE");
				String strSubSalId = hmInnerSal.get("SUB_SALARY_HEAD_ID");

				// boolean isFixed = false;
				if (strSubSalAmountType != null && strSubSalAmountType.equalsIgnoreCase("P")) {

					Map<String, String> hmEmpSalaryInner = hmSalaryHeadMap.get(strSubSalId);

					if (hmEmpSalaryInner == null)
						hmEmpSalaryInner = new HashMap<String, String>();
					String strEmpSalAmount = hmEmpSalaryInner.get("AMOUNT");

					if ((uF.parseToInt(strSubSalId) == BASIC || uF.parseToInt(strSubSalId) == GROSS)
							&& (uF.parseToInt(strSalaryHeadId) != DA && uF.parseToInt(strSalaryHeadId) != DA1)) {
						strEmpSalAmount = dblBasicDA + "";
					}

					double dblSalAmount = uF.parseToDouble(strEmpSalAmount);
					double dblSubSalAmount = uF.parseToDouble(strSubSalAmount);

					double dblTotalAmount = dblSalAmount * dblSubSalAmount / 100;

					if (dblIncrementDA > 0 && (uF.parseToInt(strSalaryHeadId) == DA || uF.parseToInt(strSalaryHeadId) == DA1)) {
						dblTotalAmount = dblTotalAmount + dblIncrementDA;
					}

					dblAmount = dblTotalAmount * (dblPresent / nTotalNumberOfDays);
					/**
					 * ----- Customised for Lift and Shift ---- Policy of HRA =
					 * 10% (Basic + DA) or 500 whichever is less 29/07/2013 --
					 * Vipin
					 */

					/*
					 * if(dblAmount>=500 && uF.parseToInt(strSalaryHeadId) ==
					 * HRA){ dblAmount = 500; }
					 * if(uF.parseToInt(strSalaryHeadId) == HRA){
					 * dblAmount=Math.round(dblAmount); }
					 */

					// hmInner.put("AMOUNT",
					// uF.formatIntoTwoDecimal(dblTotalAmount));
					hmInner.put("AMOUNT", uF.formatIntoTwoDecimal(dblAmount));

					if (uF.parseToInt(strSalaryHeadId) == BREAKS) {
						dblAmount = dblTotalAmount * dblBreaks * nTotalNumberOfDays;
						hmInner.put("AMOUNT", uF.formatIntoTwoDecimal(dblAmount));
					}

				} else if (uF.parseToInt(strSalaryHeadId) != BASIC && uF.parseToInt(strSalaryHeadId) != GROSS && uF.parseToInt(strSalaryHeadId) != DA
						&& uF.parseToInt(strSalaryHeadId) != DA1 && !"D".equalsIgnoreCase(rs.getString("earning_deduction"))) {
					// dblAmount = dblAmount * (dblPresent /
					// nTotalNumberOfDays);

					if (strSubSalAmountType != null && strSubSalAmountType.equalsIgnoreCase("P") && uF.parseToInt(strSubSalId) == BASIC) {
						dblAmount = dblBasicDA * (dblPresent / nTotalNumberOfDays);
					} else {
						dblAmount = dblAmount * (dblPresent / nTotalNumberOfDays);
					}

					hmInner.put("AMOUNT", uF.formatIntoTwoDecimal(dblAmount));
				} else {

					if (strEarningDeduction != null && strEarningDeduction.equalsIgnoreCase("E")) {
						dblAmount = dblAmount * (dblPresent / nTotalNumberOfDays);
					}
					hmInner.put("AMOUNT", uF.formatIntoTwoDecimal(dblAmount));
				}

				// hmInner.put("AMOUNT", uF.formatIntoTwoDecimal(dblAmount));

				hmInner.put("SALARY_HEAD_ID", strSalaryHeadId);
				hmInner.put("EARNING_DEDUCTION", strEarningDeduction);

				hmSalaryHeadMap.put(strSalaryHeadId, hmInner);

				/*
				 * if(!isGross){
				 * 
				 * if (dblIncrementBasic > 0 && uF.parseToInt(strSalaryHeadId)
				 * == BASIC) { dblAmount = uF.parseToDouble(
				 * hmInner.get("AMOUNT")); dblAmount = dblAmount * (dblPresent /
				 * nTotalNumberOfDays); } else if (dblIncrementDA > 0 &&
				 * (uF.parseToInt(strSalaryHeadId) == DA ||
				 * uF.parseToInt(strSalaryHeadId) == DA1)) { dblAmount =
				 * uF.parseToDouble( hmInner.get("AMOUNT")); dblAmount =
				 * dblAmount * (dblPresent / nTotalNumberOfDays); } else { if
				 * (strEarningDeduction != null &&
				 * strEarningDeduction.equalsIgnoreCase("E")) { dblAmount =
				 * uF.parseToDouble( hmInner.get("AMOUNT")); if
				 * (uF.parseToInt(strSalaryHeadId) == BASIC ||
				 * uF.parseToInt(strSalaryHeadId) == DA ||
				 * uF.parseToInt(strSalaryHeadId) == DA1 || (strSubSalAmountType
				 * != null && strSubSalAmountType.equalsIgnoreCase("P"))) {
				 * dblAmount = dblAmount * (dblPresent / nTotalNumberOfDays); }
				 * 
				 * if(strSubSalAmountType != null &&
				 * !strSubSalAmountType.equalsIgnoreCase("P")){ dblAmount =
				 * uF.parseToDouble( hmInner.get("AMOUNT")); }
				 * 
				 * 
				 * } else { dblAmount = uF.parseToDouble(
				 * hmInner.get("AMOUNT")); } } }
				 */

				if (strEarningDeduction != null) {
					hmSalaryInner.put("EARNING_DEDUCTION", strEarningDeduction);
					hmSalaryInner.put("AMOUNT", dblAmount + "");
					hmSalaryHeadReCalculatedMap.put(strSalaryHeadId, hmSalaryInner);
				}

			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

		return hmSalaryHeadReCalculatedMap;

	}

	public Map<String, Map<String, String>> getSalaryCalculation(Connection con, Map<String, Map<String, String>> hmInnerisDisplay, int nEmpId,
			double dblPresent, double dblAbsent, double dblBreaks, int nTotalNumberOfDays, double dblIncrementBasic, double dblIncrementDA, String strLevelId,
			UtilityFunctions uF, CommonFunctions CF, String strD2, Map<String, Map<String, String>> hmSalaryDetails, String strEmpVDAAmount,
			String strSalCalStatus) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, Map<String, String>> hmSalaryHeadReCalculatedMap = new LinkedHashMap<String, Map<String, String>>();

		try {
			
			/*if(nEmpId==320){
				System.out.println("CF/7088---hmSalaryDetails=="+hmSalaryDetails);
			}*/
			int cnt = 0;
			StringBuilder sbQuery = new StringBuilder();
			sbQuery.append("select * from (select *, 1 as aa from emp_salary_details where emp_id=? and effective_date=(select max(effective_date) from emp_salary_details "
					+ "where emp_id=? and effective_date<=? and is_approved=true) and salary_head_id not in ("
					+ CTC
					+ ","
					+ TDS
					+ ","
					+ DA1
					+ ","
					+ GROSS
					+ ") and is_approved=true "
					+ "and salary_head_id in (select salary_head_id from salary_details where (is_delete is null or is_delete=false) and org_id in (select org_id from "
					+ "employee_personal_details epd, employee_official_details eod where epd.emp_per_id=eod.emp_id and eod.emp_id=?) and level_id=?) order by earning_deduction desc, "
					+ "salary_head_id, emp_salary_id ) ac "
					+ " union "
					+ "(select *, 2 as aa from emp_salary_details where emp_id=? and effective_date=(select max(effective_date) from emp_salary_details where emp_id=? "
					+ "and effective_date<=? and is_approved=true) and salary_head_id in ("
					+ TDS
					+ ") and salary_head_id not in ("
					+ CTC
					+ ") and salary_head_id in "
					+ "(select salary_head_id from salary_details where (is_delete is null or is_delete=false) and org_id in (select org_id from employee_personal_details epd, "
					+ "employee_official_details eod where epd.emp_per_id=eod.emp_id and eod.emp_id=?) and level_id=?) order by earning_deduction desc, salary_head_id, emp_salary_id) "
					+ "order by aa, earning_deduction desc, salary_head_id, emp_salary_id");
			pst = con.prepareStatement(sbQuery.toString());
			pst.setInt(1, nEmpId);
			pst.setInt(2, nEmpId);
			pst.setDate(3, uF.getDateFormat(strD2, DATE_FORMAT));
			pst.setInt(4, nEmpId);
			pst.setInt(5, uF.parseToInt(strLevelId));
			pst.setInt(6, nEmpId);
			pst.setInt(7, nEmpId);
			pst.setDate(8, uF.getDateFormat(strD2, DATE_FORMAT));
			pst.setInt(9, nEmpId);
			pst.setInt(10, uF.parseToInt(strLevelId));
			// if(nEmpId==181){
			cnt++;
//			 System.out.println("CF/7124---cnt ===>> " + cnt + " -- pst ========> " +pst);
			// }
			
			rs = pst.executeQuery();
			while (rs.next()) {
				String strSalaryHeadId = rs.getString("salary_head_id");
				String strAmount = rs.getString("amount");
				double dblAmount = uF.parseToDouble(strAmount);
				
				if (uF.parseToInt(strSalaryHeadId) == VDA && !uF.parseToBoolean(strSalCalStatus)) {
					dblAmount = uF.parseToDouble(strEmpVDAAmount);
					// System.out.println("dblAmount ===>> " + dblAmount);
					
				}
				
				Map<String, String> hmInnerSal = hmSalaryDetails.get(strSalaryHeadId);
				
				if (hmInnerSal == null)
					hmInnerSal = new HashMap<String, String>();
				
				String strSalPercentage = hmInnerSal.get("SALARY_HEAD_AMOUNT");
				String strSalAmountType = hmInnerSal.get("SALARY_AMOUNT_TYPE");
				String isCTCVariable = hmInnerSal.get("IS_CTC_VARIABLE");
				String strMultipleCalculation = hmInnerSal.get("MULTIPLE_CALCULATION");
				String isAlignWithPerk = hmInnerSal.get("IS_ALIGN_WITH_PERK");
				String isDefaultCalAllowance = hmInnerSal.get("IS_DEFAULT_CAL_ALLOWANCE");
				
				String strEarningDeduction = hmInnerSal.get("EARNING_DEDUCTION");
				String strSalaryType = hmInnerSal.get("SALARY_TYPE");
				
				if (strSalaryType != null && strSalaryType.equalsIgnoreCase("F")) {
					// dblAmount = dblAmount;
				} else if (strSalaryType != null && strSalaryType.equalsIgnoreCase("D")) {
					dblAmount = dblAmount * dblPresent;
					
				} else {
					dblAmount = dblAmount * (dblPresent / nTotalNumberOfDays);
				}
				
				if (strEarningDeduction != null) {
					Map<String, String> hmSalaryInner = new HashMap<String, String>();
					hmSalaryInner.put("EARNING_DEDUCTION", strEarningDeduction);
					hmSalaryInner.put("AMOUNT", uF.getRoundOffValue(uF.parseToInt(CF.getRoundOffCondtion()), dblAmount));
					hmSalaryInner.put("SALARY_AMOUNT_TYPE", strSalAmountType);
					hmSalaryInner.put("MULTIPLE_CALCULATION", strMultipleCalculation);
					hmSalaryInner.put("IS_ALIGN_WITH_PERK", isAlignWithPerk);
					hmSalaryInner.put("SALARY_PERCENTAGE", strSalPercentage);
					hmSalaryInner.put("IS_DEFAULT_CAL_ALLOWANCE", isDefaultCalAllowance);
					hmSalaryInner.put("AMOUNT_ACTUAL", uF.getRoundOffValue(uF.parseToInt(CF.getRoundOffCondtion()), uF.parseToDouble(strAmount)));
					
					if (rs.getBoolean("isdisplay") && uF.parseToBoolean(isCTCVariable)) {
						hmInnerisDisplay.put(strSalaryHeadId, hmSalaryInner);
						
					} else if (rs.getBoolean("isdisplay") && !uF.parseToBoolean(isCTCVariable)) {
						hmSalaryHeadReCalculatedMap.put(strSalaryHeadId, hmSalaryInner);
						/*if(nEmpId==646 && (strSalaryHeadId.equals("311") || strSalaryHeadId.equals("310"))){
							System.out.println("CF/7182---hmSalaryInner=="+hmSalaryInner.get("AMOUNT"));
						}*/
					}
				}
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmSalaryHeadReCalculatedMap;

	}

	// public Map<String, Map<String, String>> getSalaryCalculation(Connection
	// con,Map<String, Map<String, String>> hmInnerisDisplay, int nEmpId, double
	// dblPresent, double dblAbsent, double dblBreaks, int nTotalNumberOfDays,
	// double dblIncrementBasic, double dblIncrementDA,
	// String strLevelId, UtilityFunctions uF, CommonFunctions CF, String strD2)
	// {
	//
	// PreparedStatement pst = null;
	// ResultSet rs = null;
	// Map<String, Map<String, String>> hmSalaryHeadReCalculatedMap = new
	// LinkedHashMap<String, Map<String, String>>();
	//
	// Map<String, Map<String, String>> hmSalaryHeadMap = new
	// LinkedHashMap<String, Map<String, String>>();
	// try {
	// String orgId = CF.getEmpOrgId(con, uF, ""+nEmpId);
	// String[] strPayCycleDate = CF.getPayCycleFromDate(con, strD2,
	// CF.getStrTimeZone(), CF, orgId);
	//
	// String[] strFinancialYear = CF.getFinancialYear(con, strD2, CF, uF);
	// double dblReimbursementCTC = CF.getReimbursementCTCHeadTotalAmount(con,
	// uF, nEmpId, strFinancialYear[0], strFinancialYear[1], strPayCycleDate[0],
	// strPayCycleDate[1], strPayCycleDate[2], uF.parseToInt(orgId),
	// uF.parseToInt(strLevelId));
	//
	// Map<String, String> hmSalaryEarningDeduction = new
	// HashMap<String,String>();
	// Map<String, String> hmSalaryType = new HashMap<String,String>();
	// pst =
	// con.prepareStatement("select * from salary_details where level_id = ? and (is_delete is null or is_delete=false) order by salary_head_id, salary_id");
	// pst.setInt(1, uF.parseToInt(strLevelId));
	// rs = pst.executeQuery();
	// if(nEmpId==459){
	// // System.out.println("pst===sal==>"+pst);
	// }
	// Map<String,Map<String,String>> hmSalaryDetails = new
	// HashMap<String,Map<String,String>>();
	// while (rs.next()) {
	//
	// Map<String, String> hmInnerSal = new HashMap<String, String>();
	//
	// hmInnerSal.put("SALARY_HEAD_ID", rs.getString("salary_head_id"));
	// hmInnerSal.put("EARNING_DEDUCTION", rs.getString("earning_deduction"));
	// hmInnerSal.put("SALARY_AMOUNT_TYPE",
	// rs.getString("salary_head_amount_type"));
	// hmInnerSal.put("SUB_SALARY_HEAD_ID", rs.getString("sub_salary_head_id"));
	// hmInnerSal.put("SALARY_HEAD_AMOUNT", rs.getString("salary_head_amount"));
	// hmInnerSal.put("IS_CTC_VARIABLE",
	// ""+uF.parseToBoolean(rs.getString("is_ctc_variable")));
	// hmInnerSal.put("MULTIPLE_CALCULATION",
	// rs.getString("multiple_calculation"));
	// hmInnerSal.put("IS_ALIGN_WITH_PERK",
	// ""+uF.parseToBoolean(rs.getString("is_align_with_perk")));
	//
	// hmSalaryDetails.put(rs.getString("salary_head_id"), hmInnerSal);
	//
	// hmSalaryEarningDeduction.put(rs.getString("salary_head_id"),
	// rs.getString("earning_deduction"));
	// hmSalaryType.put(rs.getString("salary_head_id"),
	// rs.getString("salary_type"));
	// }
	// rs.close();
	// pst.close();
	//
	// // if(nEmpId==181){
	// // System.out.println("hmSalaryDetails========>"+hmSalaryDetails);
	// // }
	//
	// pst =
	// con.prepareStatement("select * from emp_salary_details where emp_id = ? and effective_date = (select max(effective_date) "
	// +
	// "from emp_salary_details where emp_id =? and effective_date <= ? and is_approved=true) and salary_head_id in ("+CTC+") "
	// +
	// "and salary_head_id in (select salary_head_id from salary_details where (is_delete is null or is_delete=false) "
	// +
	// "and org_id in (select org_id from employee_personal_details epd, employee_official_details eod "
	// +
	// "where epd.emp_per_id=eod.emp_id and eod.emp_id=?) and level_id = ?)");
	// pst.setInt(1, nEmpId);
	// pst.setInt(2, nEmpId);
	// pst.setDate(3, uF.getDateFormat(strD2, DATE_FORMAT));
	// pst.setInt(4, nEmpId);
	// pst.setInt(5, uF.parseToInt(strLevelId));
	// // if(nEmpId==279){
	// // System.out.println("pst========>"+pst);
	// // }
	// rs = pst.executeQuery();
	// boolean isCtc = false;
	// double dblCTC = 0.0d;
	// while(rs.next()){
	// isCtc = true;
	// dblCTC = uF.parseToDouble(rs.getString("amount"));
	// }
	// rs.close();
	// pst.close();
	// // if(nEmpId==181){
	// // System.out.println("dblCTC========>"+dblCTC);
	// // }
	//
	// StringBuilder sbQuery = new StringBuilder();
	// sbQuery.append("select * from (	select *, 0 as aa from emp_salary_details where emp_id = ? and effective_date = (select max(effective_date) "
	// +
	// "from emp_salary_details where emp_id =? and effective_date <= ? and is_approved=true) and salary_head_id in ("+DA1+", "+GROSS+") "
	// +
	// "and salary_head_id not in ("+CTC+") and salary_head_id in (select salary_head_id from salary_details where (is_delete is null or is_delete=false) "
	// +
	// "and org_id in (select org_id from employee_personal_details epd, employee_official_details eod where epd.emp_per_id=eod.emp_id "
	// +
	// "and eod.emp_id=?) and level_id = ?) order by earning_deduction desc, salary_head_id, emp_salary_id ) ac1"
	// +
	// " union " +
	// "select * from (select *, 1 as aa from emp_salary_details where emp_id = ? and effective_date = (select max(effective_date) "
	// +
	// "from emp_salary_details where emp_id =? and effective_date <= ? and is_approved=true) and salary_head_id not in ("+CTC+","+TDS+","+DA1+","+GROSS+") "
	// +
	// "and is_approved=true and salary_head_id in (select salary_head_id from salary_details where (is_delete is null or is_delete=false) "
	// +
	// "and org_id in (select org_id from employee_personal_details epd, employee_official_details eod where epd.emp_per_id=eod.emp_id "
	// +
	// "and eod.emp_id=?) and level_id = ?) order by earning_deduction desc, salary_head_id, emp_salary_id ) ac"
	// +
	// " union " +
	// "(select *, 2 as aa from emp_salary_details where emp_id = ? and effective_date = (select max(effective_date) from emp_salary_details "
	// +
	// "where emp_id =? and effective_date <= ? and is_approved=true) and salary_head_id in ("+TDS+") and salary_head_id not in ("+CTC+") "
	// +
	// "and salary_head_id in (select salary_head_id from salary_details where (is_delete is null or is_delete=false) "
	// +
	// "and org_id in (select org_id from employee_personal_details epd, employee_official_details eod where epd.emp_per_id=eod.emp_id "
	// +
	// "and eod.emp_id=?) and level_id = ?) order by earning_deduction desc, salary_head_id, emp_salary_id) order by aa, earning_deduction desc, salary_head_id, emp_salary_id");
	// pst = con.prepareStatement(sbQuery.toString());
	// pst.setInt(1, nEmpId);
	// pst.setInt(2, nEmpId);
	// pst.setDate(3, uF.getDateFormat(strD2, DATE_FORMAT));
	// pst.setInt(4, nEmpId);
	// pst.setInt(5, uF.parseToInt(strLevelId));
	// pst.setInt(6, nEmpId);
	// pst.setInt(7, nEmpId);
	// pst.setDate(8, uF.getDateFormat(strD2, DATE_FORMAT));
	// pst.setInt(9, nEmpId);
	// pst.setInt(10, uF.parseToInt(strLevelId));
	// pst.setInt(11, nEmpId);
	// pst.setInt(12, nEmpId);
	// pst.setDate(13, uF.getDateFormat(strD2, DATE_FORMAT));
	// pst.setInt(14, nEmpId);
	// pst.setInt(15, uF.parseToInt(strLevelId));
	// // if(nEmpId==279){
	// // System.out.println("pst========>"+pst);
	// // }
	// rs = pst.executeQuery();
	//
	// double dblBasicDA = 0;
	// boolean isGross = false;
	// boolean isHRAll = false;
	// Map<String, String> hmMainTotal = new HashMap<String, String>();
	// while (rs.next()) {
	// Map<String, String> hmSalaryInner = new HashMap<String, String>();
	// Map<String, String> hmInner = new HashMap<String, String>();
	// double dblAmount = 0;
	//
	// String strSalaryHeadId = rs.getString("salary_head_id");
	// String strEarningDeduction =
	// hmSalaryEarningDeduction.get(rs.getString("salary_head_id"));
	// String strSalaryType = hmSalaryType.get(rs.getString("salary_head_id"));
	//
	// if(uF.parseToInt(strSalaryHeadId)==GROSS){
	// isGross = true;
	// }
	//
	// isHRAll = false;
	// // if(uF.parseToInt(strSalaryHeadId)==211){
	// // isHRAll = true;
	// // }
	//
	// String strAmount = rs.getString("amount");
	// dblAmount = uF.parseToDouble(strAmount);
	//
	// Map<String,String> hmInnerSal = hmSalaryDetails.get(strSalaryHeadId);
	// if (hmInnerSal == null) hmInnerSal = new HashMap<String,String>();
	//
	// String strSubSalAmount = hmInnerSal.get("SALARY_HEAD_AMOUNT");
	// String strSubSalAmountType = hmInnerSal.get("SALARY_AMOUNT_TYPE");
	// String strSubSalId = hmInnerSal.get("SUB_SALARY_HEAD_ID");
	// String isCTCVariable = hmInnerSal.get("IS_CTC_VARIABLE");
	// String strMultipleCalculation = hmInnerSal.get("MULTIPLE_CALCULATION");
	// String isAlignWithPerk = hmInnerSal.get("IS_ALIGN_WITH_PERK");
	//
	// if(isCtc){
	// if (strSubSalAmountType != null &&
	// strSubSalAmountType.equalsIgnoreCase("P")) {
	// Map<String, String> hmEmpSalaryInner = hmSalaryHeadMap.get(strSubSalId);
	// if (hmEmpSalaryInner == null) hmEmpSalaryInner = new
	// HashMap<String,String>();
	// String strEmpSalAmount = hmEmpSalaryInner.get("AMOUNT");
	//
	// if(uF.parseToInt(strSubSalId) == CTC){
	//
	// // double dblSalAmount = uF.parseToDouble(strEmpSalAmount);
	// double dblSalAmount = uF.parseToDouble(strSubSalAmount);
	// // double dblSubSalAmount = uF.parseToDouble(strSubSalAmount);
	// double dblSubSalAmount = dblCTC;
	// double dblTotalAmount = dblSalAmount * dblSubSalAmount / 100;
	//
	//
	// // if(nEmpId==668){
	// // System.out.println("dblCTC=="+dblCTC);
	// // System.out.println("strSalaryHeadId=="+strSalaryHeadId);
	// // System.out.println("dblSalAmount=="+dblSalAmount);
	// // System.out.println("strSubSalAmount=="+strSubSalAmount);
	// // System.out.println("dblTotalAmount=="+dblTotalAmount);
	// // System.out.println("dblPresent=="+dblPresent);
	// // System.out.println("nTotalNumberOfDays=="+nTotalNumberOfDays);
	// // }
	//
	// if (dblIncrementBasic > 0 && (uF.parseToInt(strSalaryHeadId) == BASIC ||
	// uF.parseToInt(strSalaryHeadId) == GROSS)) {
	// dblAmount = dblAmount + dblIncrementBasic;
	// }
	//
	// hmMainTotal.put(strSalaryHeadId, ""+dblAmount);
	//
	// if (!isGross && isHRAll) {
	// dblBasicDA = dblAmount;
	// }
	//
	// if (!isGross && (uF.parseToInt(strSalaryHeadId) == BASIC ||
	// uF.parseToInt(strSalaryHeadId) == DA || uF.parseToInt(strSalaryHeadId) ==
	// DA1)) {
	// dblBasicDA += dblAmount;
	// }
	//
	// if (uF.parseToInt(strSalaryHeadId) == GROSS) {
	// dblBasicDA = dblAmount;
	// }
	//
	// if(strSalaryType!=null && strSalaryType.equalsIgnoreCase("F")){
	// dblAmount = dblTotalAmount;
	// }else if(strSalaryType!=null && strSalaryType.equalsIgnoreCase("D")){
	// dblAmount = dblTotalAmount * dblPresent;
	// }else{
	// dblAmount = dblTotalAmount * (dblPresent / nTotalNumberOfDays);
	// }
	//
	// // if(nEmpId==668){
	// // System.out.println("dblAmount=="+dblAmount);
	// // System.out.println("dblBasicDA=="+dblBasicDA);
	// // }
	//
	// hmInner.put("AMOUNT",
	// uF.getRoundOffValue(uF.parseToInt(CF.getRoundOffCondtion()),dblAmount));
	//
	// if(uF.parseToInt(strSalaryHeadId) == BREAKS){
	// dblAmount = dblTotalAmount * dblBreaks;
	// hmInner.put("AMOUNT",
	// uF.getRoundOffValue(uF.parseToInt(CF.getRoundOffCondtion()),dblAmount));
	// }
	//
	// } else if (strSubSalAmountType != null &&
	// strSubSalAmountType.equalsIgnoreCase("P")) {
	// if ((uF.parseToInt(strSubSalId) == BASIC || uF.parseToInt(strSubSalId) ==
	// GROSS ) && (uF.parseToInt(strSalaryHeadId) != DA &&
	// uF.parseToInt(strSalaryHeadId) != DA1)) {
	// strEmpSalAmount = ""+dblBasicDA;
	// } else if(uF.parseToInt(strSubSalId) == REIMBURSEMENT_CTC){
	// strEmpSalAmount = ""+dblReimbursementCTC;
	// } else {
	// strEmpSalAmount = hmMainTotal.get(""+strSubSalId);
	// }
	//
	// double dblSalAmount = uF.parseToDouble(strEmpSalAmount);
	// double dblSubSalAmount = uF.parseToDouble(strSubSalAmount);
	// double dblTotalAmount = dblSalAmount * dblSubSalAmount / 100;
	//
	// if (dblIncrementDA > 0 && (uF.parseToInt(strSalaryHeadId) == DA ||
	// uF.parseToInt(strSalaryHeadId) == DA1)) {
	// dblTotalAmount = dblTotalAmount + dblIncrementDA;
	// }
	//
	// hmMainTotal.put(strSalaryHeadId, ""+dblTotalAmount);
	//
	// if(strSalaryType!=null && strSalaryType.equalsIgnoreCase("F")){
	// dblAmount = dblTotalAmount;
	// }else if(strSalaryType!=null && strSalaryType.equalsIgnoreCase("D")){
	// dblAmount = dblTotalAmount * dblPresent;
	// }else{
	// dblAmount = dblTotalAmount * (dblPresent / nTotalNumberOfDays);
	// }
	//
	// hmInner.put("AMOUNT",
	// uF.getRoundOffValue(uF.parseToInt(CF.getRoundOffCondtion()),dblAmount));
	//
	// if(uF.parseToInt(strSalaryHeadId) == BREAKS){
	// dblAmount = dblTotalAmount * dblBreaks;
	// hmInner.put("AMOUNT",
	// uF.getRoundOffValue(uF.parseToInt(CF.getRoundOffCondtion()),dblAmount));
	// }
	//
	//
	//
	// } else if (uF.parseToInt(strSalaryHeadId) != BASIC &&
	// uF.parseToInt(strSalaryHeadId) != GROSS && uF.parseToInt(strSalaryHeadId)
	// != DA && uF.parseToInt(strSalaryHeadId) != DA1 &&
	// !"D".equalsIgnoreCase(rs.getString("earning_deduction"))) {
	// // System.out.println("2 else if==");
	// if(strSubSalAmountType != null &&
	// strSubSalAmountType.equalsIgnoreCase("P") &&
	// uF.parseToInt(strSubSalId)==BASIC){
	// if(strSalaryType!=null && strSalaryType.equalsIgnoreCase("F")){
	// dblAmount = dblBasicDA;
	// }else if(strSalaryType!=null && strSalaryType.equalsIgnoreCase("D")){
	// dblAmount = dblBasicDA * dblPresent;
	// }else{
	// dblAmount = dblBasicDA * (dblPresent / nTotalNumberOfDays);
	// }
	// }else{
	// if(strSalaryType!=null && strSalaryType.equalsIgnoreCase("F")){
	// // dblAmount = dblAmount;
	// }else if(strSalaryType!=null && strSalaryType.equalsIgnoreCase("D")){
	// dblAmount = dblAmount * dblPresent;
	// }else{
	// dblAmount = dblAmount * (dblPresent / nTotalNumberOfDays);
	// }
	// }
	//
	// if (!isGross && (uF.parseToInt(strSalaryHeadId) == BASIC ||
	// uF.parseToInt(strSalaryHeadId) == DA || uF.parseToInt(strSalaryHeadId) ==
	// DA1)) {
	// dblBasicDA += dblAmount;
	// }
	//
	// // if(nEmpId==668){
	// // System.out.println("dblCTC=="+dblCTC);
	// // System.out.println("strSalaryHeadId=="+strSalaryHeadId);
	// // System.out.println("strSubSalAmountType=="+strSubSalAmountType);
	// // System.out.println("strSubSalAmount=="+strSubSalAmount);
	// // System.out.println("strSubSalId=="+strSubSalId);
	// // System.out.println("strSalaryType=="+strSalaryType);
	// // System.out.println("dblPresent=="+dblPresent);
	// // System.out.println("nTotalNumberOfDays=="+nTotalNumberOfDays);
	// // }
	//
	// hmInner.put("AMOUNT",
	// uF.getRoundOffValue(uF.parseToInt(CF.getRoundOffCondtion()),dblAmount));
	// }else{
	// if(strSalaryType!=null && strSalaryType.equalsIgnoreCase("F")){
	// // dblAmount = dblAmount;
	// }else if(strSalaryType!=null && strSalaryType.equalsIgnoreCase("D")){
	// dblAmount = dblAmount * dblPresent;
	// }else{
	// dblAmount = dblAmount * (dblPresent / nTotalNumberOfDays);
	// }
	// if (!isGross && (uF.parseToInt(strSalaryHeadId) == BASIC ||
	// uF.parseToInt(strSalaryHeadId) == DA || uF.parseToInt(strSalaryHeadId) ==
	// DA1)) {
	// dblBasicDA += dblAmount;
	// }
	// hmInner.put("AMOUNT",
	// uF.getRoundOffValue(uF.parseToInt(CF.getRoundOffCondtion()),dblAmount));
	// }
	//
	//
	// } else if (uF.parseToInt(strSalaryHeadId) != BASIC &&
	// uF.parseToInt(strSalaryHeadId) != GROSS && uF.parseToInt(strSalaryHeadId)
	// != DA && uF.parseToInt(strSalaryHeadId) != DA1 &&
	// !"D".equalsIgnoreCase(rs.getString("earning_deduction"))) {
	// if(strSubSalAmountType != null &&
	// strSubSalAmountType.equalsIgnoreCase("P") &&
	// uF.parseToInt(strSubSalId)==BASIC){
	// if(strSalaryType!=null && strSalaryType.equalsIgnoreCase("F")){
	// dblAmount = dblBasicDA;
	// }else if(strSalaryType!=null && strSalaryType.equalsIgnoreCase("D")){
	// dblAmount = dblBasicDA * dblPresent;
	// }else{
	// dblAmount = dblBasicDA * (dblPresent / nTotalNumberOfDays);
	// }
	// }else{
	// if(strSalaryType!=null && strSalaryType.equalsIgnoreCase("F")){
	// // dblAmount = dblAmount;
	// }else if(strSalaryType!=null && strSalaryType.equalsIgnoreCase("D")){
	// dblAmount = dblAmount * dblPresent;
	// }else{
	// dblAmount = dblAmount * (dblPresent / nTotalNumberOfDays);
	// }
	// }
	//
	// if (!isGross && (uF.parseToInt(strSalaryHeadId) == BASIC ||
	// uF.parseToInt(strSalaryHeadId) == DA || uF.parseToInt(strSalaryHeadId) ==
	// DA1)) {
	// dblBasicDA += dblAmount;
	// }
	//
	// // if(nEmpId==668){
	// // System.out.println("dblCTC=="+dblCTC);
	// // System.out.println("strSalaryHeadId=="+strSalaryHeadId);
	// // System.out.println("strSubSalAmountType=="+strSubSalAmountType);
	// // System.out.println("strSubSalAmount=="+strSubSalAmount);
	// // System.out.println("strSubSalId=="+strSubSalId);
	// // System.out.println("strSalaryType=="+strSalaryType);
	// // System.out.println("dblPresent=="+dblPresent);
	// // System.out.println("nTotalNumberOfDays=="+nTotalNumberOfDays);
	// // }
	//
	// hmInner.put("AMOUNT",
	// uF.getRoundOffValue(uF.parseToInt(CF.getRoundOffCondtion()),dblAmount));
	// }else{
	// if(strSalaryType!=null && strSalaryType.equalsIgnoreCase("F")){
	// // dblAmount = dblAmount;
	// }else if(strSalaryType!=null && strSalaryType.equalsIgnoreCase("D")){
	// dblAmount = dblAmount * dblPresent;
	// }else{
	// dblAmount = dblAmount * (dblPresent / nTotalNumberOfDays);
	// }
	//
	// if (!isGross && (uF.parseToInt(strSalaryHeadId) == BASIC ||
	// uF.parseToInt(strSalaryHeadId) == DA || uF.parseToInt(strSalaryHeadId) ==
	// DA1)) {
	// dblBasicDA += dblAmount;
	// }
	//
	// hmInner.put("AMOUNT",
	// uF.getRoundOffValue(uF.parseToInt(CF.getRoundOffCondtion()),dblAmount));
	// }
	//
	// hmInner.put("SALARY_HEAD_ID", strSalaryHeadId);
	// hmInner.put("EARNING_DEDUCTION", strEarningDeduction);
	// hmInner.put("SALARY_AMOUNT_TYPE", strSubSalAmountType);
	// hmInner.put("MULTIPLE_CALCULATION", strMultipleCalculation);
	// hmInner.put("IS_ALIGN_WITH_PERK", isAlignWithPerk);
	//
	// hmSalaryHeadMap.put(strSalaryHeadId, hmInner);
	//
	// if (strEarningDeduction != null) {
	// hmSalaryInner.put("EARNING_DEDUCTION", strEarningDeduction);
	// hmSalaryInner.put("AMOUNT",
	// uF.getRoundOffValue(uF.parseToInt(CF.getRoundOffCondtion()),dblAmount));
	// hmSalaryInner.put("SALARY_AMOUNT_TYPE", strSubSalAmountType);
	// hmSalaryInner.put("MULTIPLE_CALCULATION", strMultipleCalculation);
	// hmSalaryInner.put("IS_ALIGN_WITH_PERK", isAlignWithPerk);
	//
	// // if (!rs.getBoolean("isdisplay") && uF.parseToBoolean(isCTCVariable)) {
	// if (rs.getBoolean("isdisplay") && uF.parseToBoolean(isCTCVariable)) {
	// hmInnerisDisplay.put(strSalaryHeadId, hmSalaryInner);
	// // } else if (rs.getBoolean("isdisplay")){
	// } else if (rs.getBoolean("isdisplay") &&
	// !uF.parseToBoolean(isCTCVariable)){
	// hmSalaryHeadReCalculatedMap.put(strSalaryHeadId, hmSalaryInner);
	// }
	// }
	//
	// } else {
	//
	// if (dblIncrementBasic > 0 && (uF.parseToInt(strSalaryHeadId) == BASIC ||
	// uF.parseToInt(strSalaryHeadId) == GROSS)) {
	// dblAmount = dblAmount + dblIncrementBasic;
	// }
	//
	// if (!isGross && isHRAll) {
	// dblBasicDA = dblAmount;
	// }
	//
	// if (!isGross && (uF.parseToInt(strSalaryHeadId) == BASIC ||
	// uF.parseToInt(strSalaryHeadId) == DA || uF.parseToInt(strSalaryHeadId) ==
	// DA1)) {
	// dblBasicDA += dblAmount;
	// }
	//
	// if (uF.parseToInt(strSalaryHeadId) == GROSS) {
	// dblBasicDA = dblAmount;
	// }
	//
	//
	// // boolean isFixed = false;
	// if (strSubSalAmountType != null &&
	// strSubSalAmountType.equalsIgnoreCase("P")) {
	// Map<String, String> hmEmpSalaryInner = hmSalaryHeadMap.get(strSubSalId);
	// if (hmEmpSalaryInner == null) hmEmpSalaryInner = new
	// HashMap<String,String>();
	// String strEmpSalAmount = hmEmpSalaryInner.get("AMOUNT");
	//
	// if ((uF.parseToInt(strSubSalId) == BASIC || uF.parseToInt(strSubSalId) ==
	// GROSS ) && (uF.parseToInt(strSalaryHeadId) != DA &&
	// uF.parseToInt(strSalaryHeadId) != DA1)) {
	// strEmpSalAmount = dblBasicDA + "";
	// } else if(uF.parseToInt(strSubSalId) == REIMBURSEMENT_CTC){
	// strEmpSalAmount = ""+dblReimbursementCTC;
	// }
	//
	// double dblSalAmount = uF.parseToDouble(strEmpSalAmount);
	// double dblSubSalAmount = uF.parseToDouble(strSubSalAmount);
	// double dblTotalAmount = dblSalAmount * dblSubSalAmount / 100;
	//
	// if (dblIncrementDA > 0 && (uF.parseToInt(strSalaryHeadId) == DA ||
	// uF.parseToInt(strSalaryHeadId) == DA1)) {
	// dblTotalAmount = dblTotalAmount + dblIncrementDA;
	// }
	//
	// if(strSalaryType!=null && strSalaryType.equalsIgnoreCase("F")){
	// dblAmount = dblTotalAmount;
	// }else if(strSalaryType!=null && strSalaryType.equalsIgnoreCase("D")){
	// dblAmount = dblTotalAmount * dblPresent;
	// }else{
	// dblAmount = dblTotalAmount * (dblPresent / nTotalNumberOfDays);
	// }
	//
	// /**
	// * ----- Customised for Lift and Shift ----
	// * Policy of HRA = 10% (Basic + DA) or 500 whichever is less
	// * 29/07/2013
	// * -- Vipin
	// */
	//
	// /*if(dblAmount>=500 && uF.parseToInt(strSalaryHeadId) == HRA){
	// dblAmount = 500;
	// }
	// if(uF.parseToInt(strSalaryHeadId) == HRA){
	// dblAmount=Math.round(dblAmount);
	// }*/
	//
	// // hmInner.put("AMOUNT", uF.formatIntoTwoDecimal(dblTotalAmount));
	// hmInner.put("AMOUNT",
	// uF.getRoundOffValue(uF.parseToInt(CF.getRoundOffCondtion()),dblAmount));
	//
	// if(uF.parseToInt(strSalaryHeadId) == BREAKS){
	// dblAmount = dblTotalAmount * dblBreaks;
	// hmInner.put("AMOUNT",
	// uF.getRoundOffValue(uF.parseToInt(CF.getRoundOffCondtion()),dblAmount));
	// }
	//
	//
	//
	// } else if (uF.parseToInt(strSalaryHeadId) != BASIC &&
	// uF.parseToInt(strSalaryHeadId) != GROSS && uF.parseToInt(strSalaryHeadId)
	// != DA && uF.parseToInt(strSalaryHeadId) != DA1 &&
	// !"D".equalsIgnoreCase(rs.getString("earning_deduction"))) {
	//
	// if(strSubSalAmountType != null &&
	// strSubSalAmountType.equalsIgnoreCase("P") &&
	// uF.parseToInt(strSubSalId)==BASIC){
	// if(strSalaryType!=null && strSalaryType.equalsIgnoreCase("F")){
	// dblAmount = dblBasicDA;
	// }else if(strSalaryType!=null && strSalaryType.equalsIgnoreCase("D")){
	// dblAmount = dblBasicDA * dblPresent;
	// }else{
	// dblAmount = dblBasicDA * (dblPresent / nTotalNumberOfDays);
	// }
	// }else{
	// if(strSalaryType!=null && strSalaryType.equalsIgnoreCase("F")){
	// // dblAmount = dblAmount;
	// }else if(strSalaryType!=null && strSalaryType.equalsIgnoreCase("D")){
	// dblAmount = dblAmount * dblPresent;
	// }else{
	// dblAmount = dblAmount * (dblPresent / nTotalNumberOfDays);
	// }
	// }
	//
	// hmInner.put("AMOUNT",
	// uF.getRoundOffValue(uF.parseToInt(CF.getRoundOffCondtion()),dblAmount));
	// }else{
	// if(strSalaryType!=null && strSalaryType.equalsIgnoreCase("F")){
	// // dblAmount = dblAmount;
	// }else if(strSalaryType!=null && strSalaryType.equalsIgnoreCase("D")){
	// dblAmount = dblAmount * dblPresent;
	// }else{
	// dblAmount = dblAmount * (dblPresent / nTotalNumberOfDays);
	// }
	// hmInner.put("AMOUNT",
	// uF.getRoundOffValue(uF.parseToInt(CF.getRoundOffCondtion()),dblAmount));
	// }
	//
	//
	// hmInner.put("SALARY_HEAD_ID", strSalaryHeadId);
	// hmInner.put("EARNING_DEDUCTION", strEarningDeduction);
	// hmInner.put("SALARY_AMOUNT_TYPE", strSubSalAmountType);
	// hmInner.put("MULTIPLE_CALCULATION", strMultipleCalculation);
	// hmInner.put("IS_ALIGN_WITH_PERK", isAlignWithPerk);
	//
	// hmSalaryHeadMap.put(strSalaryHeadId, hmInner);
	//
	// if (strEarningDeduction != null) {
	// hmSalaryInner.put("EARNING_DEDUCTION", strEarningDeduction);
	// hmSalaryInner.put("AMOUNT",
	// uF.getRoundOffValue(uF.parseToInt(CF.getRoundOffCondtion()),dblAmount));
	// hmSalaryInner.put("SALARY_AMOUNT_TYPE", strSubSalAmountType);
	// hmSalaryInner.put("MULTIPLE_CALCULATION", strMultipleCalculation);
	// hmSalaryInner.put("IS_ALIGN_WITH_PERK", isAlignWithPerk);
	//
	// // if (!rs.getBoolean("isdisplay") && uF.parseToBoolean(isCTCVariable)) {
	// if (rs.getBoolean("isdisplay") && uF.parseToBoolean(isCTCVariable)) {
	// hmInnerisDisplay.put(strSalaryHeadId, hmSalaryInner);
	// // } else if (rs.getBoolean("isdisplay")){
	// } else if (rs.getBoolean("isdisplay") &&
	// !uF.parseToBoolean(isCTCVariable)){
	// hmSalaryHeadReCalculatedMap.put(strSalaryHeadId, hmSalaryInner);
	// }
	// }
	// }
	// }
	// rs.close();
	// pst.close();
	//
	//
	// // if(nEmpId==279){
	// // System.out.println("hmSalaryHeadMap=="+hmSalaryHeadMap);
	// //
	// System.out.println("hmSalaryHeadReCalculatedMap=="+hmSalaryHeadReCalculatedMap);
	// // }
	//
	// } catch (Exception e) {
	// e.printStackTrace();
	// } finally {
	// if(rs != null) {
	// try {
	// rs.close();
	// } catch (SQLException e1) {
	// e1.printStackTrace();
	// }
	// }
	// if(pst != null) {
	// try {
	// pst.close();
	// } catch (SQLException e1) {
	// e1.printStackTrace();
	// }
	// }
	// }
	// return hmSalaryHeadReCalculatedMap;
	//
	// }

	public Map<String, Map<String, String>> getPaidSalary(Connection con, String strFinancialYearStart, String strFinancialYearEnd, String strPC) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, Map<String, String>> hmEmpPaidSalary = new HashMap<String, Map<String, String>>();
		UtilityFunctions uF = new UtilityFunctions();
		try {
			if (strFinancialYearStart != null) {
				pst = con
						.prepareStatement("select salary_head_id, sum(amount) as amount, emp_id from payroll_generation where financial_year_from_date=? and financial_year_to_date =? and paycycle = ? group by salary_head_id, emp_id order by emp_id");
				pst.setDate(1, uF.getDateFormat(strFinancialYearStart, DATE_FORMAT));
				pst.setDate(2, uF.getDateFormat(strFinancialYearEnd, DATE_FORMAT));
				pst.setInt(3, uF.parseToInt(strPC));
			} else {
				/**
				 * This else condition is use for calculating gratuity amount
				 * where whole paid amount for an employee is used.
				 * */
				pst = con
						.prepareStatement("select salary_head_id, sum(amount) as amount, emp_id from payroll_generation group by salary_head_id, emp_id order by emp_id");
			}
			// System.out.println("pst===>"+pst);
			rs = pst.executeQuery();
			String strEmpIdNew = null;
			String strEmpIdOld = null;
			Map<String, String> hmInner = new HashMap<String, String>();
			while (rs.next()) {
				strEmpIdNew = rs.getString("emp_id");

				if (strEmpIdNew != null && !strEmpIdNew.equalsIgnoreCase(strEmpIdOld)) {
					hmInner = new HashMap<String, String>();
				}

				hmInner.put(rs.getString("salary_head_id"), rs.getString("amount"));

				hmEmpPaidSalary.put(rs.getString("emp_id"), hmInner);

				strEmpIdOld = strEmpIdNew;
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmEmpPaidSalary;

	}

	public Map<String, Map<String, String>> getCurrentSalary(Connection con) {
		PreparedStatement pst = null;
		ResultSet rs = null;

		Map<String, Map<String, String>> hmSalaryHeadMap = new HashMap<String, Map<String, String>>();
		try {

			pst = con.prepareStatement(selectEmployeeCurrentSalary);
			rs = pst.executeQuery();

			Map<String, String> hmSalaryInner = new HashMap<String, String>();

			String strEmpIdNew = null;
			String strEmpIdOld = null;

			while (rs.next()) {

				strEmpIdNew = rs.getString("emp_id");

				if (strEmpIdNew != null && !strEmpIdNew.equalsIgnoreCase(strEmpIdOld)) {
					hmSalaryInner = new HashMap<String, String>();
				}

				hmSalaryInner.put(rs.getString("salary_head_id"), rs.getString("amount"));
				hmSalaryHeadMap.put(strEmpIdNew, hmSalaryInner);

				strEmpIdOld = strEmpIdNew;
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

		return hmSalaryHeadMap;

	}

	public Map<String, String> getIncrementAmount(Connection con, double dblAmount) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmIncrementMap = new HashMap<String, String>();

		try {

			pst = con.prepareStatement(selectIncrementAmount);
			pst.setDouble(1, dblAmount);
			pst.setDouble(2, dblAmount);
			rs = pst.executeQuery();

			while (rs.next()) {
				hmIncrementMap.put("INCREMENT_AMOUNT", rs.getString("increment_amount"));
				hmIncrementMap.put("DUE_MONTH", rs.getString("due_month"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

		return hmIncrementMap;

	}

	public Map<String, Map<String, String>> getOverTimeMap(Connection con, CommonFunctions CF) {

		PreparedStatement pst = null;
		ResultSet rs = null;

		UtilityFunctions uF = new UtilityFunctions();
		Map<String, Map<String, String>> hmOverTimeMap = new HashMap<String, Map<String, String>>();

		try {

			pst = con.prepareStatement("select * from overtime_details where date_from>=? and date_to<=?");
			pst.setDate(1, uF.getDateFormat(CF.getStrFinancialYearFrom(), DATE_FORMAT));
			pst.setDate(2, uF.getDateFormat(CF.getStrFinancialYearTo(), DATE_FORMAT));
			rs = pst.executeQuery();

			Map<String, String> hmInner = new HashMap<String, String>();
			while (rs.next()) {
				hmInner = new HashMap<String, String>();

				hmInner.put("SALARY_HEAD_ID", rs.getString("salaryhead_id"));
				hmInner.put("PAYMENT_TYPE", rs.getString("overtime_payment_type"));
				hmInner.put("PAYMENT_AMOUNT", rs.getString("overtime_payment_amount"));

				hmOverTimeMap.put("LEVEL_" + rs.getString("level_id") + "_TYPE_" + rs.getString("overtime_type"), hmInner);
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

		return hmOverTimeMap;

	}

	public String selectSkills(Connection con, int EmpId, List<List<String>> alSkills) {

		PreparedStatement pst = null;
		ResultSet rs = null;

		StringBuilder sb = new StringBuilder();
		String str = "";
		try {

			pst = con.prepareStatement(selectskills);
			pst.setInt(1, EmpId);
			rs = pst.executeQuery();
			int count = 0;

			while (rs.next()) {

				List<String> alInner1 = new ArrayList<String>();
				alInner1.add(rs.getInt("skills_id") + "");
				if (count == 0) {
					alInner1.add(rs.getString("skills_name"));
				} else {
					alInner1.add(rs.getString("skills_name"));
				}
				alInner1.add(rs.getString("skills_value"));
				alInner1.add(rs.getInt("emp_id") + "");

				if (alSkills != null) {
					alSkills.add(alInner1);
				}

				sb.append(rs.getString("skills_name") + ((count == 0) ? " [Pri]" : "") + ", ");

				count++;
			}
			rs.close();
			pst.close();

			int index = sb.lastIndexOf(",");
			if (index > 0) {
				str = sb.substring(0, index);
			}

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

		return str;

	}

	public List<List<String>> selectHobbies(Connection con, int empId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		List<List<String>> alHobbies = new ArrayList<List<String>>();

		try {

			pst = con.prepareStatement(selectHobbies);
			pst.setInt(1, empId);
			rs = pst.executeQuery();
			while (rs.next()) {
				List<String> alInner1 = new ArrayList<String>();
				alInner1.add(rs.getInt("hobbies_id") + "");
				alInner1.add(rs.getString("hobbies_name"));
				alInner1.add(rs.getInt("emp_id") + "");
				alHobbies.add(alInner1);
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

		return alHobbies;

	}

	public Map<String, String> getStateMap(Connection con) {

		PreparedStatement pst = null;
		ResultSet rs = null;

		Map<String, String> hmStates = new HashMap<String, String>();
		try {
			//
			pst = con.prepareStatement("SELECT * FROM state");
			rs = pst.executeQuery();
			while (rs.next()) {
				hmStates.put(rs.getString("state_id"), rs.getString("state_name"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmStates;
	}

	public Map<String, String> getBankAccNoMap(Connection con, UtilityFunctions uF) {

		PreparedStatement pst = null;
		ResultSet rs = null;

		Map<String, String> hmBankAccMap = new HashMap<String, String>();
		try {
			pst = con
					.prepareStatement("SELECT bbd.bank_account_no,bbd.branch_id,bd.bank_name,bbd.bank_branch FROM bank_details bd, branch_details bbd where bbd.bank_id  = bd.bank_id");
			rs = pst.executeQuery();
			while (rs.next()) {
				hmBankAccMap.put(rs.getString("branch_id"),
						rs.getString("bank_account_no") + ", " + rs.getString("bank_name") + ", " + uF.showData(rs.getString("bank_branch"), ""));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmBankAccMap;
	}

	public Map<String, String> getBankNameMap(Connection con, UtilityFunctions uF) {

		PreparedStatement pst = null;
		ResultSet rs = null;

		Map<String, String> hmBankNameMap = new HashMap<String, String>();
		try {
			pst = con
					.prepareStatement("SELECT bbd.branch_id, bd.bank_name,bbd.bank_branch  FROM bank_details bd, branch_details bbd where bbd.bank_id  = bd.bank_id");
			rs = pst.executeQuery();
			while (rs.next()) {
				hmBankNameMap.put(rs.getString("branch_id"), rs.getString("bank_name") + " " + uF.showData(rs.getString("bank_branch"), ""));
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmBankNameMap;
	}

	public Map<String, String> getCountryMap(Connection con) {

		PreparedStatement pst = null;
		ResultSet rs = null;

		Map<String, String> hmCountry = new HashMap<String, String>();
		try {
			//
			pst = con.prepareStatement("SELECT * FROM country");
			rs = pst.executeQuery();
			while (rs.next()) {
				hmCountry.put(rs.getString("country_id"), rs.getString("country_name"));
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmCountry;
	}

	public List<List<String>> selectEducation(Connection con, int empId) {

		PreparedStatement pst = null;
		ResultSet rs = null;

		List<List<String>> alEducation = new ArrayList<List<String>>();

		try {

			pst = con.prepareStatement("SELECT * FROM education_details WHERE emp_id = ? order by completion_year desc");
			pst.setInt(1, empId);
			log.debug("pst=>" + pst);
			rs = pst.executeQuery();

			while (rs.next()) {

				List<String> alInner = new ArrayList<String>();
				alInner.add(rs.getString("degree_id"));
				alInner.add(getDegreeNameByDegreeId(con, rs.getString("education_id")));
				alInner.add(rs.getString("degree_duration"));
				alInner.add(rs.getString("completion_year"));
				alInner.add(rs.getString("grade"));
				alInner.add(rs.getString("inst_name"));

				alEducation.add(alInner);
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return alEducation;
	}

	public Map<String, List<String>> selectEducationDocument(Connection con, int empId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, List<String>> hmDegreeDocs = new LinkedHashMap<String, List<String>>();
		try {
			pst = con.prepareStatement("SELECT * FROM emp_degree_certificate_details WHERE emp_id = ? order by degree_id");
			pst.setInt(1, empId);
			log.debug("pst=>" + pst);
			rs = pst.executeQuery();

			while (rs.next()) {

				List<String> alInner = hmDegreeDocs.get(rs.getString("degree_id"));
				if (alInner == null)
					alInner = new ArrayList<String>();
				alInner.add(rs.getString("degree_certificate_name"));

				hmDegreeDocs.put(rs.getString("degree_id"), alInner);
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmDegreeDocs;
	}

	public List<List<Object>> selectDocuments(Connection con, int empId, String filePath) {

		PreparedStatement pst = null;
		ResultSet rs = null;

		List<List<Object>> alDocuments = new ArrayList<List<Object>>();
		Map<String, String> hmEmpCodeName = getExistingEmpNameMap(con);
		try {

			pst = con.prepareStatement(selectDocuments);
			pst.setInt(1, empId);
			rs = pst.executeQuery();

			while (rs.next()) {

				ArrayList<Object> alInner1 = new ArrayList<Object>();
				alInner1.add(rs.getInt("documents_id") + "");
				alInner1.add(uF.showData(rs.getString("documents_name"), ""));
				alInner1.add(rs.getString("documents_type"));
				alInner1.add(rs.getInt("emp_id") + "");

				// File fileName = new
				// File(rs.getString("documents_file_name"));
				// alInner1.add(fileName);
				alInner1.add(rs.getString("documents_file_name"));
				alInner1.add(uF.getDateFormat(rs.getString("entry_date"), DBDATE, DATE_FORMAT));
				alInner1.add(uF.showData(hmEmpCodeName.get(rs.getString("added_by")), "-"));
				alDocuments.add(alInner1);
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

		return alDocuments;

	}

	public List<List<String>> selectPrevEmploment(Connection con, int empId) {

		PreparedStatement pst = null;
		ResultSet rs = null;

		List<List<String>> alPrevEmployment = new ArrayList<List<String>>();

		try {
			pst = con.prepareStatement("SELECT * FROM emp_prev_employment WHERE emp_id = ? order by from_date");
			pst.setInt(1, empId);
			rs = pst.executeQuery();
			Map<String, String> hmStateName = getStateMap(con);
			Map<String, String> hmCountryName = getCountryMap(con);
			while (rs.next()) {
				List<String> alInner = new ArrayList<String>();
				alInner.add(rs.getString("company_id"));			//0
				alInner.add(rs.getString("company_name"));			//1
				alInner.add(rs.getString("company_location"));		//2
				alInner.add(rs.getString("company_city"));			//3
				alInner.add(hmStateName.get(rs.getString("company_state")));	//4
				alInner.add(hmCountryName.get(rs.getString("company_country")));	//5
				alInner.add(rs.getString("company_contact_no"));		//6
				alInner.add(rs.getString("reporting_to"));				//7
				alInner.add(uF.getDateFormat(rs.getString("from_date"), DBDATE, getStrReportDateFormat()));	//8
				alInner.add(uF.getDateFormat(rs.getString("to_date"), DBDATE, getStrReportDateFormat()));	//9
				alInner.add(rs.getString("designation"));				//10
				alInner.add(rs.getString("responsibilities"));			//11
				alInner.add(rs.getString("skills"));					//12
				alInner.add(rs.getString("report_manager_ph_no"));		//13
				alInner.add(rs.getString("hr_manager"));				//14
				alInner.add(rs.getString("hr_manager_ph_no"));			//15
			//===start parvez date: 08-08-2022===
				alInner.add(rs.getString("emp_esic_no"));				//16
				alInner.add(rs.getString("uan_no"));					//17
			//===end parvez date: 08-08-2022===	
				alPrevEmployment.add(alInner);
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

		return alPrevEmployment;
	}

	public List<List<String>> selectEmpActivityDetails(Connection con, int empId, UtilityFunctions uF, CommonFunctions CF) {

		PreparedStatement pst = null;
		ResultSet rs = null;

		List<List<String>> alEmpActivityDetails = new ArrayList<List<String>>();
		final CommonFunctions CF1 = CF;
		final UtilityFunctions uF1 = uF;
		try {

			// pst =
			// con.prepareStatement("select a.emp_activity_id as a_emp_activity_id, a.wlocation_id as a_wlocation_id, a.department_id as a_department_id, "
			// +
			// "a.desig_id as a_desig_id, a.grade_id as a_grade_id, a.activity_name as a_activity_name, a.reason as a_reason, "
			// +
			// "a.effective_date as a_effective_date, a.entry_date as a_entry_date, a.user_id as a_user_id, a.emp_status_code as a_emp_status_code "
			// +
			// "from (select * from (SELECT * FROM employee_activity_details WHERE emp_id = ? and effective_date <= ?) aad JOIN activity_details ad "
			// +
			// "ON aad.activity_id = ad.activity_id order by effective_date desc, emp_activity_id desc) a where emp_activity_id not "
			// +
			// "in (select emp_activity_id from document_activities where emp_id = ?  and effective_date <= ? and emp_activity_id > 0) order by a.effective_date desc");
			// pst.setInt(1, empId);
			// pst.setDate(2, uF.getCurrentDate(CF.getStrTimeZone()));
			// pst.setInt(3, empId);
			// pst.setDate(4, uF.getCurrentDate(CF.getStrTimeZone()));
			// // System.out.println("pst=======>"+pst);
			// rs = pst.executeQuery();

	//===start parvez date: 29-06-2022 Note. added a.document_file_name===		
			pst = con
					.prepareStatement("select a.emp_activity_id as a_emp_activity_id, a.wlocation_id as a_wlocation_id, a.department_id as a_department_id, "
							+ "a.desig_id as a_desig_id, a.grade_id as a_grade_id, a.activity_name as a_activity_name, a.reason as a_reason, "
							+ "a.effective_date as a_effective_date, a.entry_date as a_entry_date, a.user_id as a_user_id, a.emp_status_code as a_emp_status_code, "
							+ "a.a_activity_id,a.extend_probation_period,a.document_file_name from (select * from (SELECT activity_id as a_activity_id,* FROM employee_activity_details WHERE emp_id = ? and effective_date <= ?) aad JOIN activity_details ad "
							+ "ON aad.activity_id = ad.activity_id order by effective_date desc, emp_activity_id desc) a  order by a.effective_date desc");
	//===end parvez date: 29-06-2022===		
			pst.setInt(1, empId);
			pst.setDate(2, uF.getCurrentDate(CF.getStrTimeZone()));
//			System.out.println("CF/8560---pst=======>"+pst);
			rs = pst.executeQuery();
			while (rs.next()) {

				if (rs.getString("a_emp_activity_id") != null) {
					List<String> alInner = new ArrayList<String>();
					alInner.add(rs.getString("a_emp_activity_id"));
					alInner.add(rs.getString("a_wlocation_id"));
					alInner.add(rs.getString("a_department_id"));
					alInner.add(rs.getString("a_desig_id"));
					alInner.add(rs.getString("a_grade_id"));
					alInner.add(rs.getString("a_activity_name"));
					alInner.add(rs.getString("a_reason"));
					alInner.add(uF.getDateFormat(rs.getString("a_effective_date"), DBDATE, CF.getStrReportDateFormat()));
					alInner.add(uF.getDateFormat(rs.getString("a_entry_date"), DBDATE, CF.getStrReportDateFormat()));
					alInner.add(rs.getString("a_user_id"));
					alInner.add(rs.getString("a_emp_status_code"));
					alInner.add("0");
					alInner.add("" + uF.parseToInt(rs.getString("a_activity_id")));
					alInner.add("" + uF.parseToInt(rs.getString("extend_probation_period")));
			//===start parvez date: 29-06-2022===		
					alInner.add(rs.getString("document_file_name"));
			//===end parvez date: 29-06-2022===		

					alEmpActivityDetails.add(alInner);
				}
			}
			rs.close();
			pst.close();

		//===start parvez date: 29-06-2022 Note. added a.document_file_name===	
			/*pst = con.prepareStatement("select b.document_id as b_document_id, b.document_name as b_document_name,b.document_content as b_document_content,"
					+ "b.effective_date as b_effective_date, b.entry_date as b_entry_date, b.user_id as b_user_id, b.emp_id as b_emp_id, "
					+ "b.mail_subject as b_mail_subject ,b.mail_body as mail_body,b.emp_activity_id as b_emp_activity_id, a.a_activity_id,"
					+ "a.extend_probation_period from (select * from (SELECT activity_id as a_activity_id,* FROM employee_activity_details "
					+ "WHERE emp_id = ? and effective_date <= ?) aad JOIN activity_details ad ON aad.activity_id = ad.activity_id "
					+ "order by effective_date desc, emp_activity_id desc) a,document_activities b where a.emp_id = b.emp_id "
					+ "and a.effective_date = b.effective_date and a.emp_activity_id=b.emp_activity_id order by b.effective_date desc");*/
			pst = con.prepareStatement("select b.document_id as b_document_id, b.document_name as b_document_name,b.document_content as b_document_content,"
					+ "b.effective_date as b_effective_date, b.entry_date as b_entry_date, b.user_id as b_user_id, b.emp_id as b_emp_id, "
					+ "b.mail_subject as b_mail_subject ,b.mail_body as mail_body,b.emp_activity_id as b_emp_activity_id, a.a_activity_id,"
					+ "a.extend_probation_period,a.document_file_name from (select * from (SELECT activity_id as a_activity_id,* FROM employee_activity_details "
					+ "WHERE emp_id = ? and effective_date <= ?) aad JOIN activity_details ad ON aad.activity_id = ad.activity_id "
					+ "order by effective_date desc, emp_activity_id desc) a,document_activities b where a.emp_id = b.emp_id "
					+ "and a.effective_date = b.effective_date and a.emp_activity_id=b.emp_activity_id order by b.effective_date desc");
		//===end parvez date: 29-06-2022===	
			pst.setInt(1, empId);
			pst.setDate(2, uF.getCurrentDate(CF.getStrTimeZone()));
//			 System.out.println("CF/8608---pst=======>"+pst);
			rs = pst.executeQuery();

			while (rs.next()) {

				if (rs.getString("b_document_name") != null) {
					List<String> alInner = new ArrayList<String>();
					alInner.add(rs.getString("b_emp_activity_id"));			//0
					alInner.add("");		//1
					alInner.add("");		//2
					alInner.add("");		//3	
					alInner.add("");		//4
					alInner.add(rs.getString("b_document_name") + " sent ");	//5
					alInner.add("");		//6
					alInner.add(uF.getDateFormat(rs.getString("b_effective_date"), DBDATE, CF.getStrReportDateFormat()));		//7
					alInner.add(uF.getDateFormat(rs.getString("b_entry_date"), DBDATE, CF.getStrReportDateFormat()));			//8
					alInner.add(rs.getString("b_user_id"));			//9
					alInner.add("");								//10
					alInner.add(rs.getString("b_document_id"));		//11
					alInner.add("" + uF.parseToInt(rs.getString("a_activity_id")));			//12
					alInner.add("" + uF.parseToInt(rs.getString("extend_probation_period")));		//13
			//===start parvez date: 29-06-2022===		
					alInner.add(rs.getString("document_file_name"));		//14
			//===end parvez date: 29-06-2022===		
					
					alEmpActivityDetails.add(alInner);
				}

			}
			rs.close();
			pst.close();

			Collections.sort(alEmpActivityDetails, Collections.reverseOrder(new Comparator<List<String>>() {
				@Override
				public int compare(List<String> al, List<String> al1) {
					Integer nEmpActvityId1 = uF1.parseToInt(al.get(0));
					Integer nEmpActvityId2 = uF1.parseToInt(al1.get(0));

					return nEmpActvityId1.compareTo(nEmpActvityId2);
				}
			}));

			Collections.sort(alEmpActivityDetails, Collections.reverseOrder(new Comparator<List<String>>() {
				@Override
				public int compare(List<String> al, List<String> al1) {
					String stDate1 = al.get(7);
					String stDate2 = al1.get(7);

					Date date1 = uF1.getDateFormat(stDate1, CF1.getStrReportDateFormat());
					Date date2 = uF1.getDateFormat(stDate2, CF1.getStrReportDateFormat());
					return date1.compareTo(date2);
				}
			}));
		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

		return alEmpActivityDetails;
	}

	public Map<String, String> getSettingsMap(Connection con) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmSettings = new HashMap<String, String>();

		try {

			pst = con.prepareStatement("SELECT * FROM settings");
			rs = pst.executeQuery();
			while (rs.next()) {
				hmSettings.put(rs.getString("options"), rs.getString("value"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmSettings;
	}

	public List<List<Object>> getReminderDetailsList(Connection con) {

		List<List<Object>> alReminderDetails = new ArrayList<List<Object>>();

		PreparedStatement pst = null;
		ResultSet rs = null;

		try {

			pst = con.prepareStatement("SELECT * FROM reminder_details order by _date");
			rs = pst.executeQuery();

			while (rs.next()) {
				List<Object> al = new ArrayList<Object>();

				al.add(rs.getString("reminder_id"));
				al.add(rs.getObject("_date"));
				al.add(rs.getString("emp_id"));
				al.add(rs.getString("reminder_type"));

				alReminderDetails.add(al);
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

		return alReminderDetails;
	}

	public Map<String, String> getShiftMap() {

		Map<String, String> hmShiftMap = new HashMap<String, String>();

		PreparedStatement pst = null;
		ResultSet rs = null;
		Connection con = null;
		Database db = new Database();
		db.setRequest(request);

		try {
			con = db.makeConnection(con);
			pst = con.prepareStatement("Select * from shift_details ");
			rs = pst.executeQuery();

			while (rs.next()) {
				hmShiftMap.put(rs.getString("shift_id"), rs.getString("shift_code"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			db.closeResultSet(rs);
			db.closeStatements(pst);
			db.closeConnection(con);
		}

		return hmShiftMap;
	}

	public Map<String, String> getShiftMap(Connection con) {

		Map<String, String> hmShiftMap = new HashMap<String, String>();

		PreparedStatement pst = null;
		ResultSet rs = null;

		try {

			pst = con.prepareStatement("Select * from shift_details ");
			rs = pst.executeQuery();

			while (rs.next()) {
				hmShiftMap.put(rs.getString("shift_id"), rs.getString("shift_code"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

		return hmShiftMap;
	}

	public Map<String, Map<String, String>> getShiftTime(Connection con) {

		Map<String, Map<String, String>> hmShiftTime = new HashMap<String, Map<String, String>>();

		PreparedStatement pst = null;
		ResultSet rs = null;

		try {

			pst = con.prepareStatement("Select * from shift_details ");
			rs = pst.executeQuery();

			while (rs.next()) {
				Map<String, String> hm = new HashMap<String, String>();

				hm.put("SHIFT_ID", rs.getString("shift_id"));
				hm.put("FROM", rs.getString("_from"));
				hm.put("TO", rs.getString("_to"));
				hm.put("BSTART", rs.getString("break_start"));
				hm.put("BEND", rs.getString("break_end"));

				hmShiftTime.put(rs.getString("shift_id"), hm);
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

		return hmShiftTime;
	}

	public Map<String, Map<String, String>> getShiftTime() {

		Map<String, Map<String, String>> hmShiftTime = new HashMap<String, Map<String, String>>();

		PreparedStatement pst = null;
		ResultSet rs = null;
		Connection con = null;
		Database db = new Database();
		db.setRequest(request);

		try {
			con = db.makeConnection(con);
			pst = con.prepareStatement("Select * from shift_details ");
			rs = pst.executeQuery();

			while (rs.next()) {
				Map<String, String> hm = new HashMap<String, String>();

				hm.put("SHIFT_ID", rs.getString("shift_id"));
				hm.put("FROM", rs.getString("_from"));
				hm.put("TO", rs.getString("_to"));
				hm.put("BSTART", rs.getString("break_start"));
				hm.put("BEND", rs.getString("break_end"));

				hmShiftTime.put(rs.getString("shift_id"), hm);
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			db.closeResultSet(rs);
			db.closeStatements(pst);
			db.closeConnection(con);
		}

		return hmShiftTime;
	}

	public void insertLeaveRegisterNewEmployee(Connection con, String strLevel, String strEmpId, CommonFunctions CF) {

		PreparedStatement pst = null, pst1 = null;
		ResultSet rs = null;
		UtilityFunctions uF = new UtilityFunctions();

		try {
			// Map<String, String> hmEmpLeaveStartDateMap =
			// CF.getEmpJoiningDateMap(con, uF);
			// Map<String, String> hmEmpLeaveStartDateMap =
			// CF.getEmpProbationEndDateMap(con, uF);

			int orgId = 0;
			int wLocationId = 0;
			String joiningDate = "";
			pst = con.prepareStatement("select wlocation_id,org_id,joining_date from employee_personal_details epd, "
					+ "employee_official_details eod where emp_id = ? and epd.emp_per_id = eod.emp_id");
			pst.setInt(1, uF.parseToInt(strEmpId));

			rs = pst.executeQuery();
			while (rs.next()) {
				wLocationId = rs.getInt("wlocation_id");
				orgId = rs.getInt("org_id");
				joiningDate = uF.getDateFormat(rs.getString("joining_date"), DBDATE, DATE_FORMAT);
			}
			rs.close();
			pst.close();

			pst = con
					.prepareStatement("select * from emp_leave_type elt, leave_type lt where level_id = ? and wlocation_id = ? and elt.org_id = ? and elt.leave_type_id = lt.leave_type_id");
			// pst =
			// con.prepareStatement("select * from emp_leave_type where level_id=?");
			pst.setInt(1, uF.parseToInt(strLevel));
			pst.setInt(2, wLocationId);
			pst.setInt(3, orgId);

			rs = pst.executeQuery();
			while (rs.next()) {

				double dblTotal = 0;
				if (uF.parseToBoolean(rs.getString("is_prorata"))) {
					if ("CY".equalsIgnoreCase(rs.getString("effective_date_type"))) {
						dblTotal = CF.getLeavesCount1(joiningDate, uF.getDateFormat("31/12/" + uF.getYear(), DATE_FORMAT, DATE_FORMAT),
								rs.getDouble("no_of_leave"), rs.getBoolean("is_carryforward"), CF);
					} else if ("FY".equalsIgnoreCase(rs.getString("effective_date_type"))) {
						dblTotal = CF.getLeavesCount1(joiningDate, CF.getStrFinancialYearTo(), rs.getDouble("no_of_leave"), rs.getBoolean("is_carryforward"),
								CF);
					} else {
						dblTotal = CF.getLeavesCount1(joiningDate, uF.getDateFormat("31/12/" + uF.getYear(), DATE_FORMAT, DATE_FORMAT),
								rs.getDouble("no_of_leave"), rs.getBoolean("is_carryforward"), CF);
					}
				} else {
					dblTotal = rs.getDouble("no_of_leave");
				}
				if (rs.getInt("leave_type_id") > 0 && dblTotal > 0) {
					boolean flag = checkExistLeaveType(con, rs.getString("leave_type_id"), strEmpId, CF);
					if (!flag) {
						pst1 = con.prepareStatement("insert into leave_register1(emp_id,_date,balance,leave_type_id,_type)values(?,?,?,?,?)");
						pst1.setInt(1, uF.parseToInt(strEmpId));
						pst1.setDate(2, uF.getCurrentDate(CF.getStrTimeZone()));
						pst1.setDouble(3, dblTotal);
						pst1.setInt(4, rs.getInt("leave_type_id"));
						pst1.setString(5, "C");
						// System.out.println("pst=====> " + pst);
						pst1.execute();
						pst1.close();
					}
				}
				// System.out.println("Inserting leave........");
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst1 != null) {
				try {
					pst1.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
	}

	private double getLeavesCount1(String strJoiningtDate, String strYearEndDate, double nNumberOfLeaves, boolean isCaryForward, CommonFunctions cF) {

		UtilityFunctions uF = new UtilityFunctions();
		double empAnnualyLeaveBal = 0;
		try {
			// System.out.println("strJoiningtDate=>"+strJoiningtDate+"--strYearEndDate=>"+strYearEndDate);
			double monthDiffCount = uF.getMonthsDifference(uF.getDateFormatUtil(strJoiningtDate, DATE_FORMAT),
					uF.getDateFormatUtil(strYearEndDate, DATE_FORMAT));
			double monthlyLeaveBal = nNumberOfLeaves / 12;

			empAnnualyLeaveBal = monthlyLeaveBal * monthDiffCount;
//			 System.out.println("nNumberOfLeaves=>"+nNumberOfLeaves+"--monthDiffCount=>"+monthDiffCount+"--monthlyLeaveBal==>"+monthlyLeaveBal+"--empAnnualyLeaveBal==>"+empAnnualyLeaveBal);
		} catch (Exception e) {
			e.printStackTrace();
		}

		// return Math.round(empAnnualyLeaveBal);
		return empAnnualyLeaveBal;
	}
	
	private double getLeavesCount11(String strJoiningtDate, String strYearEndDate, double nNumberOfLeaves, double nJoiningNumberOfLeaves, boolean isCaryForward, CommonFunctions cF) {

		UtilityFunctions uF = new UtilityFunctions();
		double empAnnualyLeaveBal = 0;
		try {
			// System.out.println("strJoiningtDate=>"+strJoiningtDate+"--strYearEndDate=>"+strYearEndDate);
			double monthDiffCount = uF.getMonthsDifference(uF.getDateFormatUtil(strJoiningtDate, DATE_FORMAT),
					uF.getDateFormatUtil(strYearEndDate, DATE_FORMAT));
			double monthlyLeaveBal = nNumberOfLeaves / 12;

			empAnnualyLeaveBal = monthlyLeaveBal * monthDiffCount;
			empAnnualyLeaveBal = (empAnnualyLeaveBal-monthlyLeaveBal)+nJoiningNumberOfLeaves;
//			 System.out.println("nNumberOfLeaves=>"+nNumberOfLeaves+"--monthDiffCount=>"+monthDiffCount+"--monthlyLeaveBal==>"+monthlyLeaveBal+"--empAnnualyLeaveBal==>"+empAnnualyLeaveBal);
		} catch (Exception e) {
			e.printStackTrace();
		}

		// return Math.round(empAnnualyLeaveBal);
		return empAnnualyLeaveBal;
	}

	public void updateNewEmployeeLeaveRegister(Connection con, UtilityFunctions uF, String strEmpId, CommonFunctions CF) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		try {
			pst = con
					.prepareStatement("select * from emp_leave_type where level_id=(select ld.level_id from grades_details gd, designation_details dd, level_details ld where ld.level_id = dd.level_id and dd.designation_id = gd.designation_id and gd.grade_id = (select grade_id from employee_official_details where emp_id = ?))");
			pst.setInt(1, uF.parseToInt(strEmpId));
			rs = pst.executeQuery();
			// System.out.println("pst+++++>"+pst);
			while (rs.next()) {
				updateLeaveRegister(con, rs.getString("leave_type_id"), rs.getString("no_of_leave"), rs.getString("effective_date"),
						rs.getString("effective_date_type"), rs.getBoolean("is_carryforward"), CF);
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
	}

	public Map<String, String> getPerkMap(Connection con) {
		PreparedStatement pst = null;
		Map<String, String> hmPerkMap = new HashMap<String, String>();
		ResultSet rs = null;
		try {
			pst = con.prepareStatement("select * from perk_details");
			rs = pst.executeQuery();

			while (rs.next()) {
				hmPerkMap.put(rs.getString("perk_id"), rs.getString("perk_name"));
			}

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmPerkMap;
	}

	public Map<String, String> getProjectClientMap(Connection con, UtilityFunctions uF) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmPprojectClientMap = new HashMap<String, String>();

		try {

			//
			pst = con.prepareStatement("select * from client_details");
			rs = pst.executeQuery();

			while (rs.next()) {
				hmPprojectClientMap.put(rs.getString("client_id"), rs.getString("client_name"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmPprojectClientMap;
	}

	public Map<String, String> getEmpGrossSalary(UtilityFunctions uF, CommonFunctions CF, Connection con, String strDate, String strType) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmEmpGrossAmountMap = new HashMap<String, String>();

		try {

			pst = con.prepareStatement("select org_id, calculation_type,days,artical_days from cost_calculation_settings ");
			// System.out.println("pst ===> " + pst);
			rs = pst.executeQuery();
			Map<String, String> hmOrgCalType = new HashMap<String, String>();
			while (rs.next()) {
				hmOrgCalType.put(rs.getString("org_id"), rs.getString("calculation_type"));
				hmOrgCalType.put(rs.getString("org_id") + "_DAYS", rs.getString("days"));
				hmOrgCalType.put("ARTICAL_DAYS", rs.getString("artical_days"));
			}
			rs.close();
			pst.close();

			Map<String, String> hmEmpEmpType = getEmpTypeMap(con);
			// con.prepareStatement("select emp_id, sum(amount) as gross from ( select sd.emp_id, amount from emp_salary_details sd, ( select max(entry_date) as entry_date, emp_id from emp_salary_details where entry_date <= ? group by emp_id) a where sd.emp_id = a.emp_id and sd.entry_date = a.entry_date and salary_head_id in (select salary_head_id from salary_details where earning_deduction = 'E' and isdisplay= true) order by sd.emp_id) b group by emp_id ");
			// pst =
			// con.prepareStatement("select emp_id, sum(amount) as gross from ( select sd.emp_id, amount from emp_salary_details sd, ( select max(effective_date) as effective_date, emp_id from emp_salary_details where effective_date <= ? and is_approved = true group by emp_id) a where sd.emp_id = a.emp_id and sd.effective_date = a.effective_date and earning_deduction = 'E' order by sd.emp_id) b group by emp_id ");
			pst = con.prepareStatement("select emp_id, month_ctc, org_id from employee_official_details");
			// pst.setDate(1, uF.getDateFormat(strDate, DBDATE));
			rs = pst.executeQuery();
			while (rs.next()) {
				String empType = hmEmpEmpType.get(rs.getString("emp_id"));
				double nTotalNumberOfDays = 30;
				if (uF.parseToInt(hmOrgCalType.get("CAL_TYPE")) == 3 && empType!=null && empType.equals("AT")) {
					nTotalNumberOfDays = uF.parseToDouble(hmOrgCalType.get("ARTICAL_DAYS"));
				} else if (uF.parseToInt(hmOrgCalType.get("CAL_TYPE")) == 3) {
					nTotalNumberOfDays = uF.parseToDouble(hmOrgCalType.get("DAYS"));
				}

				if (strType != null && strType.equalsIgnoreCase("D")) {
					hmEmpGrossAmountMap.put(rs.getString("emp_id"),
							uF.formatIntoTwoDecimal(CF.getDailyAmount(uF.parseToDouble(rs.getString("month_ctc")), nTotalNumberOfDays, CF)));
				} else if (strType != null && strType.equalsIgnoreCase("H")) {
					hmEmpGrossAmountMap.put(rs.getString("emp_id"),
							uF.formatIntoTwoDecimal(CF.getHourlyAmount(uF.parseToDouble(rs.getString("month_ctc")), nTotalNumberOfDays, CF)));
				} else {
					hmEmpGrossAmountMap.put(rs.getString("emp_id"),
							uF.formatIntoTwoDecimal(CF.getHourlyAmount(uF.parseToDouble(rs.getString("month_ctc")), nTotalNumberOfDays, CF)));
				}
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmEmpGrossAmountMap;
	}

	public double getHourlyAmount(double dblGrossAmount, double nTotalNumberOfDays, CommonFunctions CF) {

		// double nTotalNumberOfDays = 30;
		// System.out.println("CF.getStrStandardHrs() ===>> " +
		// CF.getStrStandardHrs());
		// System.out.println("nTotalNumberOfDays ===>> " + nTotalNumberOfDays);

		double nTotalNumberOfHours = uF.parseToDouble(CF.getStrStandardHrs());
		if (nTotalNumberOfHours < 1) {
			nTotalNumberOfHours = 8;
		}
		double dblHourlySalary = (dblGrossAmount / nTotalNumberOfDays) / nTotalNumberOfHours;

		return dblHourlySalary;
	}

	public double getDailyAmount(double dblGrossAmount, double nTotalNumberOfDays, CommonFunctions CF) {

		// double nTotalNumberOfDays = 30;
		// double nTotalNumberOfHours =
		// uF.parseToDouble(CF.getStrStandardHrs());
		double dblDailySalary = dblGrossAmount / nTotalNumberOfDays;

		return dblDailySalary;
	}

	public Map<String, String> getReimbursementAmount(Connection con, String strType, String groupType, boolean isComplete, String strStartDate,
			String strEndDate, UtilityFunctions uF) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmReimbursementAmountMap = new HashMap<String, String>();

		try {

			StringBuilder sbQuery = new StringBuilder();

			if (strType != null && strType.equalsIgnoreCase("P")) {

				if (groupType != null && groupType.equalsIgnoreCase("P")) {
					sbQuery.append("select sum(reimbursement_amount) as reimbursement_amount, pro_id as group_type from emp_reimbursement where approval_2 = 1 and pro_id in (select pmc.pro_id from projectmntnc pmc, activity_info ai where ai.pro_id = pmc.pro_id ");
					if (isComplete) {
						sbQuery.append(" and pmc.approve_status = 'approved'");
					} else {
						sbQuery.append(" and pmc.approve_status = 'n'");
					}
					if (strStartDate != null && strEndDate != null && !strStartDate.equalsIgnoreCase(LABEL_FROM_DATE)
							&& !strEndDate.equalsIgnoreCase(LABEL_TO_DATE) && !strStartDate.equalsIgnoreCase("") && !strEndDate.equalsIgnoreCase("")) {
						sbQuery.append(" and from_date between '" + uF.getDateFormat(strStartDate, DATE_FORMAT, DBDATE) + "' and '"
								+ uF.getDateFormat(strEndDate, DATE_FORMAT, DBDATE) + "' ");
					}
					sbQuery.append(" ) and reimbursement_type1 = 'P' group by pro_id");
				} else if (groupType != null && groupType.equalsIgnoreCase("WL")) {
					sbQuery.append("select sum(reimbursement_amount) as reimbursement_amount, wlocation_id as group_type from emp_reimbursement a, employee_official_details b where a.emp_id = b.emp_id and  approval_2 = 1 and a.pro_id in ( select pmc.pro_id from projectmntnc pmc, activity_info ai where ai.pro_id = pmc.pro_id");
					if (isComplete) {
						sbQuery.append(" and pmc.approve_status = 'approved'");
					} else {
						sbQuery.append(" and pmc.approve_status = 'n'");
					}
					if (strStartDate != null && strEndDate != null && strStartDate.equalsIgnoreCase(LABEL_FROM_DATE)
							&& strEndDate.equalsIgnoreCase(LABEL_TO_DATE) && !strStartDate.equalsIgnoreCase("") && !strEndDate.equalsIgnoreCase("")) {
						sbQuery.append(" and from_date between '" + uF.getDateFormat(strStartDate, DATE_FORMAT, DBDATE) + "' and '"
								+ uF.getDateFormat(strEndDate, DATE_FORMAT, DBDATE) + "' ");
					}
					sbQuery.append(" ) and reimbursement_type1 = 'P'  group by wlocation_id");
				} else if (groupType != null && groupType.equalsIgnoreCase("S")) {
					sbQuery.append("select sum(reimbursement_amount) as reimbursement_amount, service as group_type from emp_reimbursement er, projectmntnc pmc, activity_info ai where er.emp_id = ai.emp_id and ai.pro_id = pmc.pro_id and reimbursement_type1 = 'P'");
					if (isComplete) {
						sbQuery.append(" and pmc.approve_status = 'approved'");
					} else {
						sbQuery.append(" and pmc.approve_status = 'n'");
					}
					if (strStartDate != null && strEndDate != null && strStartDate.equalsIgnoreCase(LABEL_FROM_DATE)
							&& strEndDate.equalsIgnoreCase(LABEL_TO_DATE) && !strStartDate.equalsIgnoreCase("") && !strEndDate.equalsIgnoreCase("")) {
						sbQuery.append(" and er.from_date between '" + uF.getDateFormat(strStartDate, DATE_FORMAT, DBDATE) + "' and '"
								+ uF.getDateFormat(strEndDate, DATE_FORMAT, DBDATE) + "' ");
					}
					sbQuery.append(" group by service");
				}
			}

			// System.out.println("sbQuery.toString()===>"+sbQuery.toString());
			pst = con.prepareStatement(sbQuery.toString());
			// System.out.println("pst===>"+pst);
			rs = pst.executeQuery();
			while (rs.next()) {
				String arr[] = null;
				if (rs.getString("group_type") != null) {
					arr = rs.getString("group_type").split(",");
					hmReimbursementAmountMap.put(arr[0], rs.getString("reimbursement_amount"));
				}
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmReimbursementAmountMap;
	}

	private void updateLeaveRegister(Connection con, String strLevel, String strNoOfLeave, String strApprovalDate, String strLeaveType, boolean isCarryForward,
			CommonFunctions CF) {

		PreparedStatement pst = null, pst1 = null;
		ResultSet rs = null;
		UtilityFunctions uF = new UtilityFunctions();

		try {

			// Map<String, String> hmEmpLeaveStartDateMap =
			// CF.getEmpJoiningDateMap(con, uF);
			Map<String, String> hmEmpLeaveStartDateMap = CF.getEmpProbationEndDateMap(con, uF);

			pst = con.prepareStatement("select * from leave_type where leave_type_id = ?");
			pst.setInt(1, uF.parseToInt(strLeaveType));
			rs = pst.executeQuery();
			boolean isCompensatory = false;
			// boolean isDocumentRequired = false;
			while (rs.next()) {
				isCompensatory = uF.parseToBoolean(rs.getString("is_compensatory"));
				// isDocumentRequired =
				// uF.parseToBoolean(rs.getString("is_document_required"));

			}
			rs.close();
			pst.close();

			// System.out.println("pst== 1 =>"+pst);

			if (!isCompensatory) {
				pst = con
						.prepareStatement("select * from employee_official_details eod, employee_personal_details epd where epd.emp_per_id = eod.emp_id and eod.grade_id in (select grade_id from grades_details gd, designation_details dd, level_details ld where gd.designation_id = dd.designation_id and ld.level_id  = dd.level_id and ld.level_id = ?) and emp_id>0 and epd.is_alive=true");
				pst.setInt(1, uF.parseToInt(strLevel));
				rs = pst.executeQuery();

				// System.out.println("pst== 2 =>"+pst);

				while (rs.next()) {

					if (strNoOfLeave != null) {
						pst1 = con
								.prepareStatement("update leave_register set assigned_leaves=?, accrued_leaves=?, leave_balance=(accrued_leaves-monthly_leaves) where emp_id=? and leave_type_id=? and from_date<=? and to_date>=?");
						pst1.setInt(1, uF.parseToInt(strNoOfLeave));
						int nTotal = 0;

						if (strApprovalDate.contains("CY")) {
							nTotal = CF.getLeavesCount(hmEmpLeaveStartDateMap.get(rs.getString("emp_id")),
									uF.getDateFormat("01/01/" + uF.getYear(), DATE_FORMAT, DATE_FORMAT), uF.parseToInt(strNoOfLeave), isCarryForward, CF);
						} else if (strApprovalDate.contains("FY")) {
							nTotal = CF.getLeavesCount(hmEmpLeaveStartDateMap.get(rs.getString("emp_id")),
									uF.getDateFormat(CF.getStrFinancialYearFrom() + "", DATE_FORMAT, DATE_FORMAT), uF.parseToInt(strNoOfLeave), isCarryForward,
									CF);
						} else {
							nTotal = CF.getLeavesCount(hmEmpLeaveStartDateMap.get(rs.getString("emp_id")),
									uF.getDateFormat("01/01/" + uF.getYear(), DATE_FORMAT, DATE_FORMAT), uF.parseToInt(strNoOfLeave), isCarryForward, CF);
						}

						pst1.setInt(2, nTotal);

						pst1.setInt(3, rs.getInt("emp_id"));
						pst1.setInt(4, uF.parseToInt(strLeaveType));

						if (strApprovalDate.contains("CY")) {
							pst1.setDate(5, uF.getDateFormat("01/01/" + uF.getYear() + "", DATE_FORMAT));
						} else if (strApprovalDate.contains("FY")) {
							pst1.setDate(5, uF.getDateFormat(CF.getStrFinancialYearFrom() + "", DATE_FORMAT));
						} else {
							pst1.setDate(5, uF.getDateFormat("01/01/" + uF.getYear() + "", DATE_FORMAT));
						}

						if (strApprovalDate.contains("CY")) {
							pst1.setDate(6, uF.getDateFormat("31/12/" + uF.getYear() + "", DATE_FORMAT));
						} else if (strApprovalDate.contains("FY")) {
							pst1.setDate(6, uF.getDateFormat(CF.getStrFinancialYearTo() + "", DATE_FORMAT));
						} else {
							pst1.setDate(6, uF.getDateFormat("31/12/" + uF.getYear() + "", DATE_FORMAT));
						}

						updateLeaveRegister1(con, CF, uF, 0, nTotal, strLeaveType, rs.getString("emp_id"));

					} else {
						pst1 = con
								.prepareStatement("update leave_register set balance_leaves=?, from_date=?, to_date=?, leave_balance=(accrued_leaves-monthly_leaves) where emp_id=?, leave_type_id=?");
						int nTotal = 0;
						if (strApprovalDate.contains("CY")) {
							nTotal = CF.getLeavesCount(hmEmpLeaveStartDateMap.get(rs.getString("emp_id")),
									uF.getDateFormat("01/01/" + uF.getYear(), DBDATE, DATE_FORMAT), rs.getInt("no_of_leave"), isCarryForward, CF);
						} else if (strApprovalDate.contains("FY")) {
							nTotal = CF.getLeavesCount(hmEmpLeaveStartDateMap.get(rs.getString("emp_id")),
									uF.getDateFormat(CF.getStrFinancialYearFrom() + "", DBDATE, DATE_FORMAT), rs.getInt("no_of_leave"), isCarryForward, CF);
						} else {
							nTotal = CF.getLeavesCount(hmEmpLeaveStartDateMap.get(rs.getString("emp_id")),
									uF.getDateFormat("01/01/" + uF.getYear(), DBDATE, DATE_FORMAT), rs.getInt("no_of_leave"), isCarryForward, CF);
						}

						pst1.setInt(1, nTotal);

						if (strApprovalDate.contains("CY")) {
							pst1.setDate(2, uF.getDateFormat("01/01/" + uF.getYear() + "", DATE_FORMAT));
						} else if (strApprovalDate.contains("FY")) {
							pst1.setDate(2, uF.getDateFormat(CF.getStrFinancialYearFrom() + "", DATE_FORMAT));
						} else {
							pst1.setDate(2, uF.getDateFormat("01/01/" + uF.getYear() + "", DATE_FORMAT));
						}

						if (strApprovalDate.contains("CY")) {
							pst1.setDate(3, uF.getDateFormat("31/12/" + uF.getYear() + "", DATE_FORMAT));
						} else if (strApprovalDate.contains("FY")) {
							pst1.setDate(3, uF.getDateFormat(CF.getStrFinancialYearTo() + "", DATE_FORMAT));
						} else {
							pst1.setDate(3, uF.getDateFormat("31/12/" + uF.getYear() + "", DATE_FORMAT));
						}

						pst1.setInt(4, rs.getInt("emp_id"));
						pst1.setInt(5, uF.parseToInt(strLeaveType));

						updateLeaveRegister1(con, CF, uF, 0, nTotal, strLeaveType, rs.getString("emp_id"));
					}

					// System.out.println("pst1===>"+pst1);

					int x = pst1.executeUpdate();
					pst1.close();

					if (x == 0) {
						insertLeaveRegister(con, strLevel, strNoOfLeave, strApprovalDate, strLeaveType, isCarryForward, CF);
					}
				}
				rs.close();
				pst.close();
			}

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst1 != null) {
				try {
					pst1.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
	}

	public void updateLeaveRegister1(Connection con, CommonFunctions CF, UtilityFunctions uF, double dblLeavesApproved, double dblAccreuedLeave,
			String strTypeOfLeave, String strEmpId) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		try {

			// System.out.println("CF dblLeavesApproved====>"+dblLeavesApproved);

			pst = con
					.prepareStatement("select emp_per_id,empcode,org_id,service_id,wlocation_id from employee_personal_details epd,employee_official_details eod where epd.emp_per_id=eod.emp_id and eod.emp_id=?");
			pst.setInt(1, uF.parseToInt(strEmpId));
			int org_id = 0;
			int wlocation = 0;
			rs = pst.executeQuery();
			while (rs.next()) {
				org_id = uF.parseToInt(rs.getString("org_id"));
				wlocation = uF.parseToInt(rs.getString("wlocation_id"));
			}
			rs.close();
			pst.close();

			/*
			 * pst = con .prepareStatement(
			 * "select * from emp_leave_type where level_id = (select level_id from designation_details dd, grades_details gd where gd.designation_id = dd.designation_id and grade_id = (select grade_id from employee_official_details where emp_id = ?)) and leave_type_id = ? and effective_date = (select max(effective_date) from emp_leave_type where leave_type_id = ? and level_id = (select level_id from designation_details dd, grades_details gd where gd.designation_id = dd.designation_id and grade_id = (select grade_id from employee_official_details where emp_id = ?)))"
			 * ); pst.setInt(1, uF.parseToInt(strEmpId)); pst.setInt(2,
			 * uF.parseToInt(strTypeOfLeave)); pst.setInt(3,
			 * uF.parseToInt(strTypeOfLeave)); pst.setInt(4,
			 * uF.parseToInt(strEmpId)); rs = pst.executeQuery();
			 */
			pst = con.prepareStatement("select * from emp_leave_type where leave_type_id=? and level_id = (select level_id from "
					+ "designation_details dd, grades_details gd where gd.designation_id = dd.designation_id and "
					+ "grade_id = (select grade_id from employee_official_details where emp_id = ?))  and org_id=? and wlocation_id=?");
			pst.setInt(1, uF.parseToInt(strTypeOfLeave));
			pst.setInt(2, uF.parseToInt(strEmpId));
			pst.setInt(3, org_id);
			pst.setInt(4, wlocation);
			rs = pst.executeQuery();
			boolean isPaid = false;
			double dblMontlyLimit = 0;
			while (rs.next()) {
				isPaid = uF.parseToBoolean(rs.getString("is_paid"));
				dblMontlyLimit = uF.parseToDouble(rs.getString("monthly_limit"));
			}
			rs.close();
			pst.close();
			// System.out.println("CF isPaid====>"+isPaid);
			// System.out.println("CF dblMontlyLimit====>"+dblMontlyLimit);
			pst = con.prepareStatement("select * from leave_register1 where emp_id = ? and leave_type_id=? and _date <= ? order by register_id desc limit 1");
			pst.setInt(1, uF.parseToInt(strEmpId));
			pst.setInt(2, uF.parseToInt(strTypeOfLeave));
			pst.setDate(3, uF.getCurrentDate(CF.getStrTimeZone()));
			rs = pst.executeQuery();
			double dblTakenPaid = 0;
			double dblTakenUnPaid = 0;
			double dblBalance = 0;
			double dblTotalBalance = 0;
			double dblTotalAccrued = 0;
			while (rs.next()) {
				dblBalance = uF.parseToDouble(rs.getString("balance"));
				dblTotalBalance = uF.parseToDouble(rs.getString("balance"));
				dblTakenPaid = uF.parseToDouble(rs.getString("taken_paid"));
				dblTakenUnPaid = uF.parseToDouble(rs.getString("taken_unpaid"));
				dblTotalAccrued = uF.parseToDouble(rs.getString("accrued"));
			}
			rs.close();
			pst.close();
			// System.out.println("CF dblBalance====>"+dblBalance);
			// System.out.println("CF dblTotalBalance====>"+dblTotalBalance);
			// System.out.println("CF dblTakenPaid====>"+dblTakenPaid);
			// System.out.println("CF dblTakenUnPaid====>"+dblTakenUnPaid);
			// System.out.println("CF dblTotalAccrued====>"+dblTotalAccrued);
			double dblLeavesPaid = 0;
			double dblLeavesUnPaid = 0;
			if (dblBalance >= dblLeavesApproved && dblMontlyLimit >= dblLeavesApproved && isPaid) {
				// System.out.println("if====>");
				dblLeavesPaid = dblLeavesApproved + dblTakenPaid;
				dblLeavesUnPaid = dblTakenUnPaid;
				dblTotalBalance = dblBalance - dblLeavesApproved;

			} else if (dblBalance >= dblLeavesApproved && isPaid && dblMontlyLimit > 0) {
				// System.out.println("else if 1====>");
				dblLeavesPaid = dblMontlyLimit + dblTakenPaid;
				dblLeavesUnPaid = dblTakenUnPaid + (dblLeavesApproved - dblMontlyLimit);
				dblTotalBalance = dblBalance - dblMontlyLimit;

			} else if (isPaid) {
				// System.out.println("else if 2====>");
				if (dblBalance <= dblLeavesApproved) {
					// System.out.println("else if 2 else if====>");
					dblLeavesPaid = ((dblLeavesApproved <= dblBalance) ? dblLeavesApproved : dblBalance) + dblTakenPaid;
					dblLeavesUnPaid = dblLeavesApproved - dblBalance + dblTakenUnPaid;
					dblTotalBalance = (dblBalance - dblLeavesApproved) > 0.0 ? (dblBalance - dblLeavesApproved) : 0;
				} else {
					// System.out.println("else if 2 else====>");
					// dblLeavesPaid = dblBalance + dblTakenPaid;
					dblLeavesPaid = dblLeavesApproved + dblTakenPaid;
					// dblLeavesUnPaid = dblLeavesApproved - dblBalance +
					// dblTakenUnPaid;
					dblLeavesUnPaid = dblTakenUnPaid;
					// dblTotalBalance = 0;
					dblTotalBalance = (dblBalance - dblLeavesApproved) > 0.0 ? (dblBalance - dblLeavesApproved) : 0;
				}

			} else {
				// System.out.println("else====>");
				dblLeavesUnPaid = dblTakenUnPaid + dblLeavesApproved;
			}

			if (dblTotalAccrued < dblAccreuedLeave) {
				// System.out.println("check if====>");
				// dblTotalBalance = dblBalance + dblAccreuedLeave +
				// dblTotalAccrued;
				dblTotalBalance = dblBalance + dblAccreuedLeave - dblTotalAccrued;
				// dblTotalAccrued += dblAccreuedLeave;

				dblTotalAccrued = dblAccreuedLeave;
			}
			// System.out.println("CF dblBalance====>"+dblBalance);
			// System.out.println("CF dblAccreuedLeave====>"+dblAccreuedLeave);
			// System.out.println("CF dblLeavesPaid====>"+dblLeavesPaid);
			// System.out.println("CF dblLeavesUnPaid====>"+dblLeavesUnPaid);
			// System.out.println("CF dblTotalBalance====>"+dblTotalBalance);
			// System.out.println("CF dblTotalAccrued====>"+dblLeavesApproved);

			/*
			 * pst = con.prepareStatement(
			 * "update leave_register1 set taken_paid=?, taken_unpaid=?, balance=? , accrued =? where emp_id = ? and leave_type_id=? and _date = ?"
			 * ); pst.setDouble(1, dblLeavesPaid); pst.setDouble(2,
			 * dblLeavesUnPaid); pst.setDouble(3, dblTotalBalance);
			 * pst.setDouble(4, dblTotalAccrued); pst.setInt(5,
			 * uF.parseToInt(strEmpId)); pst.setInt(6,
			 * uF.parseToInt(strTypeOfLeave)); pst.setDate(7,
			 * uF.getCurrentDate(CF.getStrTimeZone())); int x =
			 * pst.executeUpdate(); if (x == 0) {
			 */
			pst = con
					.prepareStatement("insert into leave_register1 (taken_paid, taken_unpaid, balance, emp_id,leave_type_id, _date, accrued) values (?,?,?,?,?,?,?)");
			pst.setDouble(1, dblLeavesPaid);
			pst.setDouble(2, dblLeavesUnPaid);
			pst.setDouble(3, dblTotalBalance);
			pst.setInt(4, uF.parseToInt(strEmpId));
			pst.setInt(5, uF.parseToInt(strTypeOfLeave));
			pst.setDate(6, uF.getCurrentDate(CF.getStrTimeZone()));
			pst.setDouble(7, dblTotalAccrued);
			System.out.println("CF/9657---pst="+pst);
			pst.execute();
			pst.close();
			// }

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
	}

	public void updateCompLeaveRegister1(Connection con, CommonFunctions CF, UtilityFunctions uF, double dblLeavesApproved, double dblAccreuedLeave,
			String strTypeOfLeave, String strEmpId) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		try {

			// PreparedStatement pst = con
			// .prepareStatement("select * from emp_leave_type where level_id = (select level_id from designation_details dd, grades_details gd where gd.designation_id = dd.designation_id and grade_id = (select grade_id from employee_official_details where emp_id = ?)) and leave_type_id = ? and effective_date = (select max(effective_date) from emp_leave_type where leave_type_id = ? and level_id = (select level_id from designation_details dd, grades_details gd where gd.designation_id = dd.designation_id and grade_id = (select grade_id from employee_official_details where emp_id = ?)))");
			// pst.setInt(1, uF.parseToInt(strEmpId));
			// pst.setInt(2, uF.parseToInt(strTypeOfLeave));
			// pst.setInt(3, uF.parseToInt(strTypeOfLeave));
			// pst.setInt(4, uF.parseToInt(strEmpId));
			// ResultSet rs = pst.executeQuery();
			//
			// // boolean isPaid = false;
			// // double dblMontlyLimit = 0;
			// while (rs.next()) {
			// isPaid = uF.parseToBoolean(rs.getString("is_paid"));
			// dblMontlyLimit = uF.parseToDouble(rs.getString("monthly_limit"));
			// }

			pst = con.prepareStatement("select * from leave_register1 where emp_id = ? and leave_type_id=? and _date <= ? order by register_id desc limit 1");
			pst.setInt(1, uF.parseToInt(strEmpId));
			pst.setInt(2, uF.parseToInt(strTypeOfLeave));
			pst.setDate(3, uF.getCurrentDate(CF.getStrTimeZone()));
			rs = pst.executeQuery();
			// double dblTakenPaid = 0;
			// double dblTakenUnPaid = 0;
			double dblBalance = 0;
			double dblTotalBalance = 0;
			double dblTotalAccrued = 0;
			while (rs.next()) {
				dblBalance = uF.parseToDouble(rs.getString("balance"));
				dblTotalBalance = uF.parseToDouble(rs.getString("balance"));
				// dblTakenPaid = uF.parseToDouble(rs.getString("taken_paid"));
				// dblTakenUnPaid =
				// uF.parseToDouble(rs.getString("taken_unpaid"));
				dblTotalAccrued = uF.parseToDouble(rs.getString("accrued"));
			}
			rs.close();
			pst.close();

			double dblLeavesPaid = 0;
			double dblLeavesUnPaid = 0;

			dblTotalBalance = dblBalance + dblLeavesApproved;
			dblTotalAccrued = dblTotalAccrued + dblLeavesApproved;

			pst = con
					.prepareStatement("update leave_register1 set taken_paid=?, taken_unpaid=?, balance=? , accrued =? where emp_id = ? and leave_type_id=? and _date = ?");
			pst.setDouble(1, dblLeavesPaid);
			pst.setDouble(2, dblLeavesUnPaid);
			pst.setDouble(3, dblTotalBalance);
			pst.setDouble(4, dblTotalAccrued);
			pst.setInt(5, uF.parseToInt(strEmpId));
			pst.setInt(6, uF.parseToInt(strTypeOfLeave));
			pst.setDate(7, uF.getCurrentDate(CF.getStrTimeZone()));
			int x = pst.executeUpdate();
			pst.close();
			if (x == 0) {
				pst = con
						.prepareStatement("insert into leave_register1 (taken_paid, taken_unpaid, balance, emp_id,leave_type_id, _date, accrued) values (?,?,?,?,?,?,?)");
				pst.setDouble(1, dblLeavesPaid);
				pst.setDouble(2, dblLeavesUnPaid);
				pst.setDouble(3, dblTotalBalance);
				pst.setInt(4, uF.parseToInt(strEmpId));
				pst.setInt(5, uF.parseToInt(strTypeOfLeave));
				pst.setDate(6, uF.getCurrentDate(CF.getStrTimeZone()));
				pst.setDouble(7, dblTotalAccrued);
				pst.execute();
				pst.close();
			}

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
	}

	public void updateLeaveRegisterForCompensatoryLeaves(Connection con, CommonFunctions CF, UtilityFunctions uF, String strDate, String strEmpId) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		try {

			pst = con
					.prepareStatement("select level_id, wlocation_id from  designation_details dd, grades_details gd, employee_official_details eod where gd.designation_id = dd.designation_id and gd.grade_id  = eod.grade_id and emp_id = ?");
			pst.setInt(1, uF.parseToInt(strEmpId));
			rs = pst.executeQuery();
			int nLevelId = 0;
			int nWlocationId = 0;
			while (rs.next()) {
				nLevelId = uF.parseToInt(rs.getString("level_id"));
				nWlocationId = uF.parseToInt(rs.getString("wlocation_id"));
			}
			rs.close();
			pst.close();

			pst = con
					.prepareStatement("select * from holidays where wlocation_id = ? and _date = ? and (is_optional_holiday is null or is_optional_holiday=false)");
			pst.setInt(1, nWlocationId);
			pst.setDate(2, uF.getDateFormat(strDate, DATE_FORMAT));
			rs = pst.executeQuery();
			boolean isHoliday = false;
			while (rs.next()) {
				isHoliday = true;
			}
			rs.close();
			pst.close();

			pst = con.prepareStatement("select * from work_location_info where wlocation_id = ?");
			pst.setInt(1, nWlocationId);
			rs = pst.executeQuery();
			boolean isWeeklyOff = false;
			while (rs.next()) {
				if (strDate != null
						&& (uF.getDateFormat(strDate, DATE_FORMAT, "EEEE").toUpperCase().equalsIgnoreCase(rs.getString("wlocation_weeklyoff1")) || uF
								.getDateFormat(strDate, DATE_FORMAT, "EEEE").toUpperCase().equalsIgnoreCase(rs.getString("wlocation_weeklyoff2")))) {
					isWeeklyOff = true;
				}
			}
			rs.close();
			pst.close();

			boolean isWeeklyOffCompensation = false;
			boolean isHolidayCompensation = false;
			int nLeaveId = 0;
			if (isHoliday || isWeeklyOff) {
				pst = con
						.prepareStatement("select * from emp_leave_type where level_id = ? and leave_type_id in (select leave_type_id from leave_type where is_compensatory = true)");
				pst.setInt(1, nLevelId);
				rs = pst.executeQuery();
				while (rs.next()) {
					isHolidayCompensation = uF.parseToBoolean(rs.getString("is_holiday_compensation"));
					isWeeklyOffCompensation = uF.parseToBoolean(rs.getString("is_weekly_compensation"));
					nLeaveId = uF.parseToInt(rs.getString("leave_type_id"));
				}
			}
			rs.close();
			pst.close();

			if ((isHoliday && isHolidayCompensation) || (isWeeklyOff && isWeeklyOffCompensation)) {

				// System.out.println("Year FROM=>"+CF.getStrFinancialYearFrom());

				pst = con.prepareStatement("select * from leave_register where from_date=? and to_date=? and emp_id=? and leave_type_id=?");
				pst.setDate(1, uF.getDateFormat(CF.getStrFinancialYearFrom(), DATE_FORMAT));
				pst.setDate(2, uF.getDateFormat(CF.getStrFinancialYearTo(), DATE_FORMAT));
				pst.setInt(3, uF.parseToInt(strEmpId));
				pst.setInt(4, nLeaveId);
				rs = pst.executeQuery();
				double dblAccruedLeave = 0;
				while (rs.next()) {
					dblAccruedLeave = uF.parseToDouble(rs.getString("accrued_leaves"));
				}
				rs.close();
				pst.close();

				dblAccruedLeave++;

				pst = con
						.prepareStatement("update leave_register set assigned_leaves=?, accrued_leaves=?, from_date=?, to_date=? where emp_id=? and leave_type_id=?");
				pst.setDouble(1, dblAccruedLeave);
				pst.setDouble(2, dblAccruedLeave);
				pst.setDate(3, uF.getDateFormat(CF.getStrFinancialYearFrom(), DATE_FORMAT));
				pst.setDate(4, uF.getDateFormat(CF.getStrFinancialYearTo(), DATE_FORMAT));
				pst.setInt(5, uF.parseToInt(strEmpId));
				pst.setInt(6, nLeaveId);
				int x = pst.executeUpdate();
				pst.close();
				// System.out.println("pst===>"+pst);

				if (x == 0) {
					pst = con
							.prepareStatement("insert into leave_register (assigned_leaves, accrued_leaves, from_date, to_date, emp_id, leave_type_id) values (?,?,?,?,?,?)");
					pst.setDouble(1, dblAccruedLeave);
					pst.setDouble(2, dblAccruedLeave);
					pst.setDate(3, uF.getDateFormat(CF.getStrFinancialYearFrom(), DATE_FORMAT));
					pst.setDate(4, uF.getDateFormat(CF.getStrFinancialYearTo(), DATE_FORMAT));
					pst.setInt(5, uF.parseToInt(strEmpId));
					pst.setInt(6, nLeaveId);
					pst.execute();
					pst.close();

					// System.out.println("pst===>"+pst);
				}

			}

			// System.out.println("======updating leave register======");

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
	}

	public Map<String, Map<String, String>> getArearDetails(Connection con, UtilityFunctions uF, CommonFunctions CF, String strD2) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, Map<String, String>> hmArearAmountMap = new HashMap<String, Map<String, String>>();

		try {

			pst = con.prepareStatement("select * from arear_details where effective_date <= ? and is_paid = false and (arrear_type is null or arrear_type=0)");
			pst.setDate(1, uF.getDateFormat(strD2, DATE_FORMAT));
			rs = pst.executeQuery();

			while (rs.next()) {
				Map<String, String> hmInner = new HashMap<String, String>();

				hmInner.put("AMOUNT_PAID", rs.getString("total_amount_paid"));
				hmInner.put("AMOUNT_BALANCE", rs.getString("arear_amount_balance"));
				hmInner.put("TOTAL_AMOUNT", rs.getString("arear_amount"));
				hmInner.put("DURATION", rs.getString("duration_months"));
				hmInner.put("MONTHLY_AREAR", rs.getString("monthly_arear"));
				hmInner.put("AREAR_ID", rs.getString("arear_id"));

				hmInner.put("BASIC_AMOUNT", rs.getString("basic_amount"));

				hmArearAmountMap.put(rs.getString("emp_id"), hmInner);

			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmArearAmountMap;
	}

	public Map<String, String> getIncentivesMap(Connection con, UtilityFunctions uF, CommonFunctions CF, String strPC, String strD1, String strD2) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmIncentiveAmountMap = new HashMap<String, String>();

		try {

			pst = con.prepareStatement("select * from incentive_details where  paid_from = ? and paid_to=? and pay_paycycle = ? and is_approved = 1");
			pst.setDate(1, uF.getDateFormat(strD1, DATE_FORMAT));
			pst.setDate(2, uF.getDateFormat(strD2, DATE_FORMAT));
			pst.setInt(3, uF.parseToInt(strPC));
			rs = pst.executeQuery();
			while (rs.next()) {
				hmIncentiveAmountMap.put(rs.getString("emp_id"), uF.formatIntoTwoDecimal(uF.parseToDouble(rs.getString("pay_amount"))));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmIncentiveAmountMap;
	}

	public Map<String, String> getIndividualBonusMap(Connection con, UtilityFunctions uF, CommonFunctions CF, String strPaycycle) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmIndividualBonusAmountMap = new HashMap<String, String>();

		try {

			pst = con.prepareStatement("select * from bonus_individual_details where pay_paycycle = ? and is_approved = 1");
			pst.setInt(1, uF.parseToInt(strPaycycle));
			rs = pst.executeQuery();

			while (rs.next()) {
				hmIndividualBonusAmountMap.put(rs.getString("emp_id"), uF.formatIntoOneDecimalWithOutComma(uF.parseToDouble(rs.getString("pay_amount"))));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmIndividualBonusAmountMap;
	}

	public Map<String, String> getIndividualOtherDeductionMap(Connection con, UtilityFunctions uF, CommonFunctions CF, String strPaycycle) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmIndividualOtherDeductionAmountMap = new HashMap<String, String>();

		try {

			// pst =
			// con.prepareStatement("select * from otherdeduction_individual_details where pay_paycycle = ? and is_approved = 1");
			// pst.setInt(1, uF.parseToInt(strPaycycle));
			// rs = pst.executeQuery();
			// while (rs.next()) {
			// hmIndividualOtherDeductionAmountMap.put(rs.getString("emp_id"),
			// uF.formatIntoOneDecimalWithOutComma(uF.parseToDouble(rs.getString("pay_amount"))));
			// }
			pst = con.prepareStatement("select * from otherearning_individual_details where pay_paycycle = ? and is_approved = 1 and salary_head_id = ?");
			pst.setInt(1, uF.parseToInt(strPaycycle));
			pst.setInt(2, OTHER_DEDUCTION);
			rs = pst.executeQuery();
			while (rs.next()) {
				hmIndividualOtherDeductionAmountMap.put(rs.getString("emp_id"),
						uF.formatIntoOneDecimalWithOutComma(uF.parseToDouble(rs.getString("pay_amount"))));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmIndividualOtherDeductionAmountMap;
	}

	public Map<String, String> getEmpServiceTax(Connection con, UtilityFunctions uF, CommonFunctions CF) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmEmpServiceTaxMap = new HashMap<String, String>();

		try {

			pst = con.prepareStatement("select is_service_tax, emp_id from employee_official_details where is_service_tax = true;");
			rs = pst.executeQuery();
			while (rs.next()) {
				hmEmpServiceTaxMap.put(rs.getString("emp_id"), rs.getString("is_service_tax"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmEmpServiceTaxMap;
	}
	public Map<String, String> getIndividualOtherEarningMap(Connection con, UtilityFunctions uF, CommonFunctions CF, String strPaycycle) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmIndividualOtherEarningAmountMap = new HashMap<String, String>();

		try {

			pst = con.prepareStatement("select * from otherearning_individual_details where pay_paycycle = ? and is_approved = 1 and salary_head_id = ?");
			pst.setInt(1, uF.parseToInt(strPaycycle));
			pst.setInt(2, OTHER_EARNING);
			rs = pst.executeQuery();

			while (rs.next()) {
				hmIndividualOtherEarningAmountMap
						.put(rs.getString("emp_id"), uF.formatIntoOneDecimalWithOutComma(uF.parseToDouble(rs.getString("pay_amount"))));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmIndividualOtherEarningAmountMap;
	}

	public Map<String, String> getIndividualOvertimeMap(Connection con, UtilityFunctions uF, CommonFunctions CF, String strPaycycle) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmIndividualOvertimeAmountMap = new HashMap<String, String>();

		try {

			pst = con.prepareStatement("select * from overtime_individual_details where pay_paycycle = ? and is_approved = 1");
			pst.setInt(1, uF.parseToInt(strPaycycle));
			rs = pst.executeQuery();

			while (rs.next()) {
				hmIndividualOvertimeAmountMap.put(rs.getString("emp_id"), uF.formatIntoOneDecimalWithOutComma(uF.parseToDouble(rs.getString("pay_amount"))));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmIndividualOvertimeAmountMap;
	}

	public Map<String, String> getIndividualMobileReimbursementMap(Connection con, UtilityFunctions uF, CommonFunctions CF, String strPaycycle, String strD1,
			String strD2) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmIndividualMobileReimbursementMap = new HashMap<String, String>();

		try {

			// pst =
			// con.prepareStatement("select * from mobile_reimbursement_individual_details where paid_from = ? and paid_to=? and pay_paycycle = ? and is_approved = 1");
			// pst.setDate(1, uF.getDateFormat(strD1, DATE_FORMAT));
			// pst.setDate(2, uF.getDateFormat(strD2, DATE_FORMAT));
			// pst.setInt(3, uF.parseToInt(strPaycycle));
			// rs = pst.executeQuery();
			//
			// while (rs.next()) {
			// hmIndividualMobileReimbursementMap.put(rs.getString("emp_id"),
			// uF.formatIntoOneDecimalWithOutComma(uF.parseToDouble(rs.getString("pay_amount"))));
			// }

			pst = con.prepareStatement("select * from otherearning_individual_details where pay_paycycle = ? and is_approved = 1 and salary_head_id = ?");
			pst.setInt(1, uF.parseToInt(strPaycycle));
			pst.setInt(2, MOBILE_REIMBURSEMENT);
			rs = pst.executeQuery();
			while (rs.next()) {
				hmIndividualMobileReimbursementMap.put(rs.getString("emp_id"),
						uF.formatIntoOneDecimalWithOutComma(uF.parseToDouble(rs.getString("pay_amount"))));
			}
			rs.close();
			pst.close();

			// pst =
			// con.prepareStatement("select sum(reimbursement_amount) as pay_amount, emp_id from ( (select * from emp_reimbursement where reimbursement_type in ('Mobile Bill') and ispaid = false and approval_2=1  and entry_date<=?) ) a group by emp_id");
			/*
			 * pst = con.prepareStatement(
			 * "select sum(reimbursement_amount) as pay_amount, emp_id from ( (select * from emp_reimbursement where reimbursement_info in ('Mobile Bill') and ispaid = false and approval_2=1  and entry_date<=?) ) a group by emp_id"
			 * ); pst.setDate(1, uF.getDateFormat(strD2, DATE_FORMAT));
			 */
			/*
			 * pst = con.prepareStatement(
			 * "select sum(reimbursement_amount) as pay_amount, emp_id from ( (select * from emp_reimbursement where "
			 * +
			 * "reimbursement_info in ('Mobile Bill') and ispaid = false and approval_2=1  and (from_date, to_date) "
			 * +
			 * "overlaps(to_date(?::text, 'YYYY-MM-DD'),to_date(?::text, 'YYYY-MM-DD')))) as a  group by emp_id"
			 * );
			 */
			pst = con.prepareStatement("select sum(reimbursement_amount) as pay_amount, emp_id from (select * from emp_reimbursement where "
					+ "reimbursement_info in ('Mobile Bill') and ispaid = false and approval_2=1  and from_date=? and to_date=?) as a  group by emp_id");
			pst.setDate(1, uF.getDateFormat(strD1, DATE_FORMAT));
			pst.setDate(2, uF.getDateFormat(strD2, DATE_FORMAT));

			rs = pst.executeQuery();

			while (rs.next()) {
				// hmIndividualMobileReimbursementMap.put(rs.getString("emp_id"),
				// uF.formatIntoOneDecimalWithOutComma(uF.parseToDouble(rs.getString("pay_amount"))));
				double dblAmount = uF.parseToDouble(hmIndividualMobileReimbursementMap.get(rs.getString("emp_id")));
				dblAmount += uF.parseToDouble(rs.getString("pay_amount"));
				hmIndividualMobileReimbursementMap.put(rs.getString("emp_id"), uF.formatIntoOneDecimalWithOutComma(dblAmount));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmIndividualMobileReimbursementMap;
	}

	public Map<String, String> getIndividualTravelReimbursementMap(Connection con, UtilityFunctions uF, CommonFunctions CF, String strPaycycle, String strD1,
			String strD2) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmIndividualTravelReimbursementMap = new HashMap<String, String>();

		try {
			// pst =
			// con.prepareStatement("select sum(reimbursement_amount) as pay_amount, emp_id from ( (select * from emp_reimbursement where reimbursement_type in ('Conveyance Bill', 'Travel') and ispaid = false and approval_2=1) union (select * from emp_reimbursement where reimbursement_type1 in ('T') and  ispaid = false and approval_2=1 and entry_date<=?)) a group by emp_id");
			/*
			 * pst = con.prepareStatement(
			 * "select sum(reimbursement_amount) as pay_amount, emp_id from ( (select * from emp_reimbursement where reimbursement_info in ('Conveyance Bill', 'Travel') and ispaid = false and approval_2=1  and entry_date<=?)) a group by emp_id"
			 * ); pst.setDate(1, uF.getDateFormat(strD2, DATE_FORMAT));
			 */
			/*
			 * pst = con.prepareStatement(
			 * "select sum(reimbursement_amount) as pay_amount, emp_id from ((select * from emp_reimbursement "
			 * +
			 * " where reimbursement_info in ('Conveyance Bill', 'Travel') and ispaid = false and approval_2=1 and (from_date, to_date) "
			 * +
			 * "overlaps(to_date(?::text, 'YYYY-MM-DD'),to_date(?::text, 'YYYY-MM-DD')))) as a  group by emp_id"
			 * ); pst.setDate(1, uF.getDateFormat(strD1, DATE_FORMAT));
			 * pst.setDate(2, uF.getDateFormat(strD2, DATE_FORMAT));
			 */
			pst = con.prepareStatement("select sum(reimbursement_amount) as pay_amount, emp_id from (select * from emp_reimbursement "
					+ " where reimbursement_info in ('Conveyance Bill', 'Travel') and ispaid = false and approval_2=1 and from_date=? and to_date=? )"
					+ " as a  group by emp_id");
			pst.setDate(1, uF.getDateFormat(strD1, DATE_FORMAT));
			pst.setDate(2, uF.getDateFormat(strD2, DATE_FORMAT));
			rs = pst.executeQuery();

			while (rs.next()) {
				hmIndividualTravelReimbursementMap.put(rs.getString("emp_id"),
						uF.formatIntoOneDecimalWithOutComma(uF.parseToDouble(rs.getString("pay_amount"))));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmIndividualTravelReimbursementMap;
	}

	public Map<String, String> getIndividualOtherReimbursementMap(Connection con, UtilityFunctions uF, CommonFunctions CF, String strPaycycle, String strD1,
			String strD2) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmIndividualOtherReimbursementMap = new HashMap<String, String>();

		try {
			// pst =
			// con.prepareStatement("select sum(reimbursement_amount) as pay_amount, emp_id from emp_reimbursement where reimbursement_id not in (select reimbursement_id from ( (select * from emp_reimbursement where reimbursement_type in ('Conveyance Bill', 'Travel') and ispaid = false and approval_2=1) union (select * from emp_reimbursement where reimbursement_type1 in ('T') and  ispaid = false and approval_2=1) union (select * from emp_reimbursement where reimbursement_type in ('Mobile Bill') and  ispaid = false and approval_2=1 and entry_date<=?) ) a) and ispaid = false and approval_2=1 group by emp_id ");
			/*
			 * pst = con.prepareStatement(
			 * "select sum(reimbursement_amount) as pay_amount, emp_id from emp_reimbursement where reimbursement_id not in (select reimbursement_id from ( (select * from emp_reimbursement where reimbursement_info in  ('Conveyance Bill', 'Travel', 'Mobile Bill') and ispaid = false and approval_2=1) ) a) and ispaid = false and approval_2=1  and entry_date <= ? group by emp_id "
			 * ); pst.setDate(1, uF.getDateFormat(strD2, DATE_FORMAT));
			 */
			/*
			 * pst = con.prepareStatement(
			 * "select sum(reimbursement_amount) as pay_amount, emp_id from emp_reimbursement where reimbursement_id not in "
			 * +
			 * "(select reimbursement_id from ((select * from emp_reimbursement where reimbursement_info in "
			 * +
			 * "('Conveyance Bill', 'Travel', 'Mobile Bill') and ispaid = false and approval_2=1)) a) and ispaid = false "
			 * + "and approval_2=1  and (from_date, to_date) " +
			 * "overlaps(to_date(?::text, 'YYYY-MM-DD'),to_date(?::text, 'YYYY-MM-DD'))  group by emp_id"
			 * );
			 */
			pst = con.prepareStatement("select sum(reimbursement_amount) as pay_amount, emp_id from emp_reimbursement where reimbursement_id not in "
					+ "(select reimbursement_id from ((select * from emp_reimbursement where reimbursement_info in "
					+ "('Conveyance Bill', 'Travel', 'Mobile Bill') and ispaid = false and approval_2=1)) a) and ispaid = false "
					+ "and approval_2=1  and from_date=? and to_date=? group by emp_id");
			pst.setDate(1, uF.getDateFormat(strD1, DATE_FORMAT));
			pst.setDate(2, uF.getDateFormat(strD2, DATE_FORMAT));
			rs = pst.executeQuery();

			while (rs.next()) {
				hmIndividualOtherReimbursementMap
						.put(rs.getString("emp_id"), uF.formatIntoOneDecimalWithOutComma(uF.parseToDouble(rs.getString("pay_amount"))));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmIndividualOtherReimbursementMap;
	}

	public Map<String, String> getIndividualMobileRecoveryMap(Connection con, UtilityFunctions uF, CommonFunctions CF, String strPaycycle) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmIndividualMobileRecoveryMap = new HashMap<String, String>();

		try {

			// pst =
			// con.prepareStatement("select * from mobile_recovery_individual_details where pay_paycycle = ? and is_approved = 1");
			// pst.setInt(1, uF.parseToInt(strPaycycle));
			// rs = pst.executeQuery();
			//
			// while (rs.next()) {
			// hmIndividualMobileRecoveryMap.put(rs.getString("emp_id"),
			// uF.formatIntoOneDecimalWithOutComma(uF.parseToDouble(rs.getString("pay_amount"))));
			// }
			pst = con.prepareStatement("select * from otherearning_individual_details where pay_paycycle = ? and is_approved = 1 and salary_head_id = ?");
			pst.setInt(1, uF.parseToInt(strPaycycle));
			pst.setInt(2, MOBILE_RECOVERY);
			rs = pst.executeQuery();
			while (rs.next()) {
				hmIndividualMobileRecoveryMap.put(rs.getString("emp_id"), uF.formatIntoOneDecimalWithOutComma(uF.parseToDouble(rs.getString("pay_amount"))));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmIndividualMobileRecoveryMap;
	}

	public Map<String, String> getReimbursementMap(Connection con, UtilityFunctions uF, CommonFunctions CF, String strD1, String strD2) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmReimbursementAmountMap = new HashMap<String, String>();

		try {

			// pst =
			// con.prepareStatement("select sum(reimbursement_amount) as reimbursement_amount, emp_id  from emp_reimbursement where approval_2_date between ? and ? and ispaid = false  group by emp_id");
			// pst.setDate(1, uF.getDateFormat(strD1, DATE_FORMAT));
			// pst.setDate(2, uF.getDateFormat(strD2, DATE_FORMAT));

			// Removed the date conditions as per the custumisation part from
			// KPCA -- VIpin 22/01/2013

			/*
			 * pst = con.prepareStatement(
			 * "select sum(reimbursement_amount) as reimbursement_amount, emp_id  from emp_reimbursement where ispaid = false and approval_2=1  and entry_date<=? group by emp_id"
			 * ); pst.setDate(1, uF.getDateFormat(strD2, DATE_FORMAT));
			 */
			/*
			 * pst = con.prepareStatement(
			 * "select sum(reimbursement_amount) as reimbursement_amount, emp_id  from emp_reimbursement where "
			 * + "ispaid = false and approval_2=1 and (from_date, to_date) " +
			 * "overlaps(to_date(?::text, 'YYYY-MM-DD'),to_date(?::text, 'YYYY-MM-DD'))  group by emp_id"
			 * );
			 */
			pst = con.prepareStatement("select sum(reimbursement_amount) as reimbursement_amount, emp_id  from emp_reimbursement where "
					+ "ispaid = false and approval_2=1 and from_date=? and to_date=?  group by emp_id");
			pst.setDate(1, uF.getDateFormat(strD1, DATE_FORMAT));
			pst.setDate(2, uF.getDateFormat(strD2, DATE_FORMAT));

			rs = pst.executeQuery();

			while (rs.next()) {
				hmReimbursementAmountMap.put(rs.getString("emp_id"),
						uF.formatIntoOneDecimalWithOutComma(uF.parseToDouble(rs.getString("reimbursement_amount"))));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmReimbursementAmountMap;
	}

	public Map<String, String> getSectionMap(Connection con, String strFinancialYearStart, String strFinancialYearEnd) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmSectionMap = new HashMap<String, String>();
		UtilityFunctions uF = new UtilityFunctions();
		try {

			pst = con.prepareStatement("SELECT * FROM section_details where financial_year_start=? and financial_year_end=? order by section_code");
			pst.setDate(1, uF.getDateFormat(strFinancialYearStart, DATE_FORMAT));
			pst.setDate(2, uF.getDateFormat(strFinancialYearEnd, DATE_FORMAT));
			rs = pst.executeQuery();

			while (rs.next()) {
				hmSectionMap.put(rs.getString("section_id"), rs.getString("section_code"));
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmSectionMap;
	}

	public void insertLeaveRegister(Connection con, String strLevel, String strNoOfLeave, String strApprovalDate, String strLeaveType, boolean isCarryForward,
			CommonFunctions CF) {

		PreparedStatement pst = null, pst1 = null;
		ResultSet rs = null;

		UtilityFunctions uF = new UtilityFunctions();

		try {

			// Map<String, String> hmEmpLeaveStartDateMap =
			// CF.getEmpJoiningDateMap(con, uF);
			Map<String, String> hmEmpLeaveStartDateMap = CF.getEmpProbationEndDateMap(con, uF);

			pst = con
					.prepareStatement("select * from employee_official_details eod, employee_personal_details epd where epd.emp_per_id = eod.emp_id and eod.grade_id in (select grade_id from grades_details gd, designation_details dd, level_details ld where gd.designation_id = dd.designation_id and ld.level_id  = dd.level_id and ld.level_id = ?) and emp_id>0 and epd.is_alive=true");
			pst.setInt(1, uF.parseToInt(strLevel));
			rs = pst.executeQuery();
			while (rs.next()) {

				if (strNoOfLeave != null) {
					pst1 = con
							.prepareStatement("insert into leave_register (assigned_leaves,accrued_leaves,from_date,to_date,emp_id,leave_type_id) values (?,?,?,?,?,?)");
					pst1.setInt(1, uF.parseToInt(strNoOfLeave));
					int nTotal = 0;

					if (strApprovalDate.contains("CY")) {
						nTotal = CF.getLeavesCount(hmEmpLeaveStartDateMap.get(rs.getString("emp_id")),
								uF.getDateFormat("01/01/" + uF.getYear(), DATE_FORMAT, DATE_FORMAT), uF.parseToInt(strNoOfLeave), isCarryForward, CF);
					} else if (strApprovalDate.contains("FY")) {
						nTotal = CF.getLeavesCount(hmEmpLeaveStartDateMap.get(rs.getString("emp_id")),
								uF.getDateFormat(CF.getStrFinancialYearFrom() + "", DATE_FORMAT, DATE_FORMAT), uF.parseToInt(strNoOfLeave), isCarryForward, CF);
					} else {
						nTotal = CF.getLeavesCount(hmEmpLeaveStartDateMap.get(rs.getString("emp_id")),
								uF.getDateFormat("01/01/" + uF.getYear(), DATE_FORMAT, DATE_FORMAT), uF.parseToInt(strNoOfLeave), isCarryForward, CF);
					}

					pst1.setInt(2, nTotal);

					if (strApprovalDate.contains("CY")) {
						pst1.setDate(3, uF.getDateFormat("01/01/" + uF.getYear() + "", DATE_FORMAT));
					} else if (strApprovalDate.contains("FY")) {
						pst1.setDate(3, uF.getDateFormat(CF.getStrFinancialYearFrom() + "", DATE_FORMAT));
					} else {
						pst1.setDate(3, uF.getDateFormat("01/01/" + uF.getYear() + "", DATE_FORMAT));
					}

					if (strApprovalDate.contains("CY")) {
						pst1.setDate(4, uF.getDateFormat("31/12/" + uF.getYear() + "", DATE_FORMAT));
					} else if (strApprovalDate.contains("FY")) {
						pst1.setDate(4, uF.getDateFormat(CF.getStrFinancialYearTo() + "", DATE_FORMAT));
					} else {
						pst1.setDate(4, uF.getDateFormat("31/12/" + uF.getYear() + "", DATE_FORMAT));
					}

					pst1.setInt(5, rs.getInt("emp_id"));
					pst1.setInt(6, uF.parseToInt(strLeaveType));

					pst1.execute();
					pst1.close();
				}

			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst1 != null) {
				try {
					pst1.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

	}

	public void insertNewActivity(Connection con, CommonFunctions CF, UtilityFunctions uF, int nActivityId, String strEmpId, String strSessionEmpId,
			String strReason) {

		PreparedStatement pst = null;
		ResultSet rs = null;

		try {

			int nWLocation = 0;
			int nDepartment = 0;
			int nLevel = 0;
			int nDesignation = 0;
			int nGrade = 0;
			// int nActivity = 0;
			int nNoticePeriod = 0;
			int nProbationPeriod = 0;

			pst = con.prepareStatement(selectEmpActivityDetails1);
			pst.setInt(1, uF.parseToInt(strEmpId));
			pst.setInt(2, uF.parseToInt(strEmpId));
			rs = pst.executeQuery();

			while (rs.next()) {
				nWLocation = rs.getInt("wlocation_id");
				nDepartment = rs.getInt("department_id");
				nLevel = rs.getInt("level_id");
				nDesignation = rs.getInt("desig_id");
				nGrade = rs.getInt("grade_id");
				// nActivity = rs.getInt("activity_id");
				nNoticePeriod = rs.getInt("notice_period");
				nProbationPeriod = rs.getInt("probation_period");
			}
			rs.close();
			pst.close();

			pst = con.prepareStatement(insertEmpActivity);
			pst.setInt(1, nWLocation);
			pst.setInt(2, nDepartment);
			pst.setInt(3, nLevel);
			pst.setInt(4, nDesignation);
			pst.setInt(5, nGrade);
			pst.setString(6, "FT");
			pst.setInt(7, nActivityId);
			pst.setString(8, strReason);
			pst.setDate(9, uF.getCurrentDate(CF.getStrTimeZone()));
			pst.setDate(10, uF.getCurrentDate(CF.getStrTimeZone()));
			pst.setInt(11, uF.parseToInt(strSessionEmpId));
			pst.setInt(12, uF.parseToInt(strEmpId));
			pst.setInt(13, nNoticePeriod);
			pst.setInt(14, nProbationPeriod);
			pst.execute();
			pst.close();

			/**
			 * Nodes aligned for the document to be sent on this action.
			 * 
			 * */

			SendDocument objSend = new SendDocument();
			// objSend.setServletRequest(request);
			objSend.setStrEmpId(strEmpId);
			objSend.setStrSubject("");
			int nNodeId = objSend.getNodeIdFromActivity(con, uF, nActivityId + "");
			List<String> alDoc = objSend.getDocIdFromNode(con, uF, nNodeId + "");
			for (int i = 0; alDoc != null && i < alDoc.size(); i++) {
				objSend.setDoc_id(alDoc.get(i));
				objSend.execute();
			}

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

	}

	public boolean getAccess(HttpSession session, HttpServletRequest request, UtilityFunctions uF) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		boolean isView = false;
		Database db = new Database();
		db.setRequest(request);
		Connection con = null;

		try {
			con = db.makeConnection(con);

			String strAction = request.getServletPath();
			if (strAction != null) {
				strAction = strAction.replace("/", "");
			}

			Map<String, String> hmNavigation = (Map<String, String>) session.getAttribute("hmNavigation");
			String strNavId = hmNavigation.get(strAction);

			pst = con.prepareStatement("select * from navigation_acl where user_id=? and navigation_id=?");
			if (uF.parseToInt((String) session.getAttribute(PRODUCT_TYPE)) == 3) {
				pst.setInt(1, uF.parseToInt((String) session.getAttribute(BASEUSERTYPEID)));
			} else {
				pst.setInt(1, uF.parseToInt((String) session.getAttribute(USERTYPEID)));
			}
			pst.setInt(2, uF.parseToInt(strNavId));
			// System.out.println("pst======>"+pst);
			rs = pst.executeQuery();
			while (rs.next()) {
				isView = uF.parseToBoolean(rs.getString("is_view"));

				request.setAttribute(VIEW_ACCESS, rs.getString("is_view"));
				request.setAttribute(DELETE_ACCESS, rs.getString("is_delete"));
				request.setAttribute(ADD_ACCESS, rs.getString("is_add"));
				request.setAttribute(UPDATE_ACCESS, rs.getString("is_update"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

		return isView;

	}

	public void getOrgLogo(Connection con, HttpSession session, CommonFunctions CF) {

		PreparedStatement pst = null;
		ResultSet rs = null;

		try {

			pst = con.prepareStatement(selectSettings);
			rs = pst.executeQuery();
			while (rs.next()) {
				if (rs.getString("options").equalsIgnoreCase(O_ORG_LOGO)) {
					session.setAttribute("ORG_LOGO", rs.getString("Value"));
				} else if (rs.getString("options").equalsIgnoreCase(O_DOC_RETRIVE_LOCATION)) {
					CF.setStrDocRetriveLocation(rs.getString("value"));
					session.setAttribute("SUBDOMAIN", rs.getString("Value"));
				}
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

	}

	public String getOrgLogo(HttpServletRequest request, CommonFunctions CF) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Connection con = null;
		Database db = new Database();
		db.setRequest(request);
		String strLogo = null;
		try {
			con = db.makeConnection(con);
			pst = con.prepareStatement(selectSettings);
			rs = pst.executeQuery();
			while (rs.next()) {
				if (rs.getString("options").equalsIgnoreCase(O_ORG_LOGO)) {
					strLogo = rs.getString("value");
				} else if (rs.getString("options").equalsIgnoreCase(O_DOC_RETRIVE_LOCATION)) {
					CF.setStrDocRetriveLocation(rs.getString("value"));
				} else if (rs.getString("options").equalsIgnoreCase(O_TIME_ZONE)) {
					CF.setStrTimeZone(rs.getString("value"));
				} else if (rs.getString("options").equalsIgnoreCase(O_TIME_FORMAT)) {
					CF.setStrReportTimeFormat(rs.getString("value"));
				} else if (rs.getString("options").equalsIgnoreCase(O_ORG_LOGO_SMALL)) {
					strLogo = rs.getString("value");
				}
				if (rs.getString("options").equalsIgnoreCase(O_UI_THEME)) {
					CF.setStrUI_Theme(rs.getString("value"));
				}
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			db.closeResultSet(rs);
			db.closeStatements(pst);
			db.closeConnection(con);
		}
		return strLogo;

	}

	public String getOrgLogoSmall(HttpServletRequest request, CommonFunctions CF) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Connection con = null;
		Database db = new Database();
		db.setRequest(request);
		String strLogoSmall = null;
		try {
			con = db.makeConnection(con);
			pst = con.prepareStatement(selectSettings);
			rs = pst.executeQuery();
			while (rs.next()) {
				if (rs.getString("options").equalsIgnoreCase(O_ORG_LOGO_SMALL)) {
					strLogoSmall = rs.getString("value");
				}
				if (rs.getString("options").equalsIgnoreCase(O_UI_THEME)) {
					CF.setStrUI_Theme(rs.getString("value"));
				}
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			db.closeResultSet(rs);
			db.closeStatements(pst);
			db.closeConnection(con);
		}
		return strLogoSmall;

	}
	public void getOrgLogo(Connection con, HttpSession session) {

		PreparedStatement pst = null;
		ResultSet rs = null;

		try {

			pst = con.prepareStatement(selectSettings);
			rs = pst.executeQuery();
			while (rs.next()) {
				if (rs.getString("options").equalsIgnoreCase(O_ORG_LOGO)) {
					session.setAttribute("ORG_LOGO", rs.getString("value"));
				} else if (rs.getString("options").equalsIgnoreCase(O_DOC_RETRIVE_LOCATION)) {
					session.setAttribute("SUBDOMAIN", rs.getString("value"));
				}
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

	}

	public void getProjectHolidayCalculation(Connection con, UtilityFunctions uF, CommonFunctions CF, Map<String, String> hmEmpGrossAmountMap,
			Map<String, String> hmActualCostMap, Map<String, String> hmActualTimeMap, String strD1, String strD2) {

		PreparedStatement pst = null;
		ResultSet rs = null;

		try {

			// Map<String, Map<String, String>> hmLeaveDatesType = new
			// HashMap<String,Map<String, String>>();
			// Map<String, String> hmMonthlyLeaves = new
			// HashMap<String,String>();

			// Map<String, Map<String, String>> hmLeaves =
			// CF.getLeaveDates(con,strD1, strD2, CF, hmLeaveDatesType, true,
			// hmMonthlyLeaves);

			Map<String, Map<String, String>> hmWLocationHolidaysWeekEnd = new HashMap<String, Map<String, String>>();
			Map<String, Map<String, String>> hmWLocationHolidaysColour = new HashMap<String, Map<String, String>>();
			Map<String, Map<String, String>> hmWLocationHolidaysName = new HashMap<String, Map<String, String>>();

			CF.getWLocationHolidayList(con, uF, strD1, strD2, CF, hmWLocationHolidaysColour, hmWLocationHolidaysName, hmWLocationHolidaysWeekEnd);

			/*
			 * pst = con.prepareStatement("select * from project_actual_hours");
			 * rs = pst.executeQuery();
			 * 
			 * List<String> alEmployees = new ArrayList<String>(); Map
			 * hmEmpTaskDate = new HashMap<String,String>(); List alTaskDate =
			 * new ArrayList();
			 * 
			 * 
			 * while(rs.next()){
			 * 
			 * double dblActualHours =
			 * uF.parseToDouble(rs.getString("actual_calculated_hours")) ;
			 * double dblAmountTemp =
			 * uF.parseToDouble(hmActualCostMap.get(rs.getString("pro_id")));
			 * double dblTimeTemp =
			 * uF.parseToDouble(hmActualTimeMap.get(rs.getString("pro_id")));
			 * 
			 * if(rs.getString("pay_type")!=null &&
			 * rs.getString("pay_type").equalsIgnoreCase("A")){ double dblAmount
			 * = dblActualHours *
			 * uF.parseToDouble(hmEmpGrossAmountMap.get(rs.getString
			 * ("emp_id"))); hmActualCostMap.put(rs.getString("pro_id"),
			 * uF.formatIntoTwoDecimal(dblAmountTemp + dblAmount)); }else
			 * if(rs.getString("pay_type")!=null &&
			 * rs.getString("pay_type").equalsIgnoreCase("O")){ double dblAmount
			 * = dblActualHours *
			 * uF.parseToDouble(hmEmpGrossAmountMap.get(rs.getString
			 * ("emp_id"))); hmActualCostMap.put(rs.getString("pro_id"),
			 * uF.formatIntoTwoDecimal(dblAmountTemp + dblAmount)); }
			 * 
			 * hmActualTimeMap.put(rs.getString("pro_id"),
			 * uF.formatIntoTwoDecimal(dblTimeTemp + dblActualHours));
			 * if(!alEmployees.contains(rs.getString("emp_id"))){
			 * alEmployees.add(rs.getString("emp_id")); }
			 * 
			 * 
			 * alTaskDate = hmEmpTaskDate.get(rs.getString("emp_id"));
			 * if(alTaskDate==null)alTaskDate=new ArrayList();
			 * if(!alTaskDate.contains(rs.getString("task_date"))){
			 * alTaskDate.add(uF.getDateFormat(rs.getString("task_date"),
			 * DBDATE, DATE_FORMAT)); }
			 * hmEmpTaskDate.put(rs.getString("emp_id"), alTaskDate);
			 * 
			 * }
			 */

			Calendar cal = Calendar.getInstance(TimeZone.getTimeZone(CF.getStrTimeZone()));
			cal.set(Calendar.DATE, uF.parseToInt(uF.getDateFormat(strD1, DATE_FORMAT, "dd")));
			cal.set(Calendar.MONTH, uF.parseToInt(uF.getDateFormat(strD1, DATE_FORMAT, "MM")) - 1);
			cal.set(Calendar.YEAR, uF.parseToInt(uF.getDateFormat(strD1, DATE_FORMAT, "yyyy")));

			List<String> alHolidays = new ArrayList<String>();
			for (int i = 0; i < 1000; i++) {
				String strDate = uF.getDateFormat(cal.get(Calendar.DATE) + "/" + (cal.get(Calendar.MONTH) + 1) + "/" + cal.get(Calendar.YEAR), DATE_FORMAT,
						DATE_FORMAT);
				if (strDate != null && strDate.equalsIgnoreCase(strD2)) {
					break;
				}

				cal.add(Calendar.DATE, 1);
				alHolidays.add(strDate);
			}

			Map<String, String> hmWeekEndListDates = new HashMap<String, String>();
			Map<String, String> hmWeekEndList = CF.getWeekEndList(con);

			pst = con.prepareStatement("select * from work_location_info");
			rs = pst.executeQuery();
			while (rs.next()) {
				if (uF.parseToInt(rs.getString("wlocation_id")) > 0) {
					uF.getWeekEndCount(hmWeekEndList, hmWeekEndListDates, uF, rs.getString("wlocation_id"), strD1, strD2);
				}
			}
			rs.close();
			pst.close();

			Map<String, Map<String, Map<String, String>>> hmProjectHolidayDetailsMap = new HashMap<String, Map<String, Map<String, String>>>();
			Map<String, List<String>> hmProjectHolidayListMap = new HashMap<String, List<String>>();

			Set<String> set0 = hmWeekEndListDates.keySet();
			Iterator<String> it0 = set0.iterator();

			StringBuilder sbDate = new StringBuilder();

			while (it0.hasNext()) {
				sbDate.append(it0.next());
				Map<String, String> hmProjectCost = new HashMap<String, String>();
				Map<String, Map<String, String>> hmProjectHolidayMap = new HashMap<String, Map<String, String>>();

				List<String> alProjectList = new ArrayList<String>();

				// System.out.println("sbDate==>"+sbDate.toString());

				pst = con
						.prepareStatement("select pro_id, count(distinct pro_id) as pro_count, ai.emp_id from task_activity ta, activity_info ai where ai.task_id= ta.activity_id and ai.start_date <= ? and ai.deadline >= ? group by pro_id, ai.emp_id");
				pst.setDate(1, uF.getDateFormat(sbDate.toString(), DATE_FORMAT));
				pst.setDate(2, uF.getDateFormat(sbDate.toString(), DATE_FORMAT));
				rs = pst.executeQuery();

				while (rs.next()) {

					int count = uF.parseToInt(rs.getString("pro_count"));
					double dblAmountTemp = uF.parseToDouble(hmActualCostMap.get(rs.getString("pro_id")));

					hmProjectCost.put(rs.getString("pro_id"), uF.formatIntoTwoDecimal(dblAmountTemp));
					hmProjectCost.put("COUNT", count + "");

					hmProjectHolidayMap.put(sbDate.toString(), hmProjectCost);

					alProjectList.add(rs.getString("pro_id"));

					hmProjectHolidayListMap.put(sbDate.toString(), alProjectList);
					hmProjectHolidayDetailsMap.put(rs.getString("emp_id"), hmProjectHolidayMap);
				}
				rs.close();
				pst.close();

				sbDate.replace(0, sbDate.length(), "");
			}

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

	}

	public void getDayThought(Connection con, UtilityFunctions uF, CommonFunctions CF, HttpServletRequest request) {

		PreparedStatement pst = null;
		ResultSet rs = null;

		try {

			Calendar cal = GregorianCalendar.getInstance(TimeZone.getTimeZone(CF.getStrTimeZone()));

			pst = con.prepareStatement(selectThought);
			pst.setInt(1, cal.get(Calendar.DAY_OF_YEAR));
			rs = pst.executeQuery();
			String strThought = null;
			String strThoughtBy = null;
			while (rs.next()) {
				strThought = rs.getString("thought_text");
				strThoughtBy = rs.getString("thought_by");
			}
			rs.close();
			pst.close();
			request.setAttribute("DAY_THOUGHT_TEXT", strThought);
			request.setAttribute("DAY_THOUGHT_BY", strThoughtBy);

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
	}

	public void getUpcomingEvents(Connection con, UtilityFunctions uF, CommonFunctions CF, HttpServletRequest request) {

		PreparedStatement pst = null;
		ResultSet rs = null;

		try {

			// String strToday1 =
			// uF.getDateFormat(uF.getCurrentDate(CF.getStrTimeZone())+"",
			// DBDATE, "MM-dd");
			// String strTomorrow =
			// uF.getDateFormat(uF.getFutureDate(CF.getStrTimeZone(), 1)+"",
			// DBDATE, "MM-dd");
			// String strDayAfterTomorrow =
			// uF.getDateFormat(uF.getFutureDate(CF.getStrTimeZone(), 2)+"",
			// DBDATE, "MM-dd");

			pst = con.prepareStatement(selectUpcomingEventsDashboard);
			pst.setDate(1, uF.getCurrentDate(CF.getStrTimeZone()));
			rs = pst.executeQuery();

			List<String> alEvents = new ArrayList<String>();
			while (rs.next()) {
				String strEventDate = uF.getDateFormat(rs.getString("event_date"), DBDATE, "MM-dd");
				alEvents.add(strEventDate + ": " + rs.getString("event_title"));
			}
			rs.close();
			pst.close();
			request.setAttribute("alEvents", alEvents);

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
	}

	public Map<String, Map<String, String>> getEmpOverTimeHours(Connection con, CommonFunctions CF, UtilityFunctions uF, String strD1, String strD2,
			String strPC) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, Map<String, String>> hmEmpOverTimeHours = new HashMap<String, Map<String, String>>();
		try {

			pst = con.prepareStatement("select * from overtime_hours where paycle=? and to_date(paycycle_from::text,'yyyy-MM-dd')=? "
					+ "and to_date(paycycle_to::text,'yyyy-MM-dd')=?");
			pst.setInt(1, uF.parseToInt(strPC));
			pst.setDate(2, uF.getDateFormat(strD1, DATE_FORMAT));
			pst.setDate(3, uF.getDateFormat(strD2, DATE_FORMAT));
			rs = pst.executeQuery();
			while (rs.next()) {
				Map<String, String> hmEmpOvertime = hmEmpOverTimeHours.get(rs.getString("emp_id"));
				if (hmEmpOvertime == null)
					hmEmpOvertime = new HashMap<String, String>();

				hmEmpOvertime.put(uF.getDateFormat(rs.getString("_date"), DBDATE, DATE_FORMAT), "" + uF.parseToDouble(rs.getString("approved_ot_hours")));

				hmEmpOverTimeHours.put(rs.getString("emp_id"), hmEmpOvertime);
			}

			if (pst != null) {
				pst.close();
				pst = null;
			}
			if (rs != null) {
				rs.close();
				rs = null;
			}
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

		return hmEmpOverTimeHours;
	}

	public Map<String, Map<String, String>> getEmpOverTimeLevelPolicy(Connection con, CommonFunctions CF, UtilityFunctions uF, String strD1, String strD2,
			String strPC) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, Map<String, String>> hmEmpOverTimeLevelPolicy = new HashMap<String, Map<String, String>>();
		try {

			pst = con
					.prepareStatement("select * from overtime_details where (date_from,date_to) overlaps (to_date(?::text,'yyyy-MM-dd'),to_date(?::text,'yyyy-MM-dd'))");
			pst.setDate(1, uF.getDateFormat(strD1, DATE_FORMAT));
			pst.setDate(2, uF.getDateFormat(strD2, DATE_FORMAT));
			rs = pst.executeQuery();
			while (rs.next()) {
				Map<String, String> hmEmpOverTimePolicy = new HashMap<String, String>();

				hmEmpOverTimePolicy.put("OVERTIME_ID", rs.getString("overtime_id"));
				hmEmpOverTimePolicy.put("OVERTIME_CODE", rs.getString("overtime_code"));
				hmEmpOverTimePolicy.put("OVERTIME_DESCRIPTION", rs.getString("overtime_description"));
				hmEmpOverTimePolicy.put("LEVEL_ID", rs.getString("level_id"));
				hmEmpOverTimePolicy.put("OVERTIME_TYPE", rs.getString("overtime_type"));
				hmEmpOverTimePolicy.put("OVERTIME_PAYMENT_TYPE", rs.getString("overtime_payment_type"));
				hmEmpOverTimePolicy.put("DATE_FROM", uF.getDateFormat(rs.getString("date_from"), DBDATE, DATE_FORMAT));
				hmEmpOverTimePolicy.put("DATE_TO", uF.getDateFormat(rs.getString("date_to"), DBDATE, DATE_FORMAT));
				hmEmpOverTimePolicy.put("OVERTIME_PAYMENT_AMOUNT", rs.getString("overtime_payment_amount"));
				hmEmpOverTimePolicy.put("DAY_CALCULATION", rs.getString("day_calculation"));
				hmEmpOverTimePolicy.put("FIXED_DAY_CALCULATION", rs.getString("fixed_day_calculation"));
				hmEmpOverTimePolicy.put("STANDARD_WKG_HOURS", rs.getString("standard_wkg_hours"));
				hmEmpOverTimePolicy.put("FIXED_STWKG_HOURS", rs.getString("fixed_stwkg_hrs"));
				hmEmpOverTimePolicy.put("STANDARD_TIME", rs.getString("standard_time"));
				hmEmpOverTimePolicy.put("BUFFER_STANDARD_TIME", rs.getString("buffer_standard_time"));
				hmEmpOverTimePolicy.put("OVERTIME_HOURS", rs.getString("over_time_hrs"));
				hmEmpOverTimePolicy.put("FIXED_OVERTIME_HOURS", rs.getString("fixed_overtime_hrs"));
				hmEmpOverTimePolicy.put("MIN_OVER_TIME", rs.getString("min_over_time"));
				hmEmpOverTimePolicy.put("OVERTIME_TYPE", rs.getString("overtime_type"));
				hmEmpOverTimePolicy.put("ORG_ID", rs.getString("org_id"));
				hmEmpOverTimePolicy.put("SALARY_HEAD_ID", rs.getString("salaryhead_id"));
				hmEmpOverTimePolicy.put("CAL_BASIS", rs.getString("calculation_basis"));

				hmEmpOverTimeLevelPolicy.put(rs.getString("level_id") + "_" + rs.getString("overtime_type"), hmEmpOverTimePolicy);

			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmEmpOverTimeLevelPolicy;
	}

	public void getBirthday(Connection con, UtilityFunctions uF, CommonFunctions CF, Map<String, String> hmEmployeeMap, HttpServletRequest request) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		try {
			HttpSession session = request.getSession(true);
			String strToday1 = uF.getDateFormat(uF.getCurrentDate(CF.getStrTimeZone()) + "", DBDATE, "MM-dd");
			String strTomorrow = uF.getDateFormat(uF.getFutureDate(CF.getStrTimeZone(), 1) + "", DBDATE, "MM-dd");
			String strDayAfterTomorrow = uF.getDateFormat(uF.getFutureDate(CF.getStrTimeZone(), 2) + "", DBDATE, "MM-dd");

			String yrs = uF.getDateFormat(uF.getCurrentDate(CF.getStrTimeZone()) + "", DBDATE, "yyyy");
			String strMinMax = uF.getCurrentMonthMinMaxDate("01/02/" + yrs, DATE_FORMAT);
			String[] tmpMinMax = strMinMax.split("::::");
			String[] tmpMaxDay = tmpMinMax[1].split("/");
			pst = con.prepareStatement(selectBirthDay);
			if (uF.parseToInt(tmpMaxDay[0]) == 29) {
				pst.setDate(1, uF.getFutureDate(CF.getStrTimeZone(), 366));
			} else {
				pst.setDate(1, uF.getFutureDate(CF.getStrTimeZone(), 365));
			}
			rs = pst.executeQuery();

			// System.out.println("pst====>"+pst);

			List<String> alBirthDays = new ArrayList<String>();
			while (rs.next()) {
				String strBDate = uF.getDateFormat(rs.getString("emp_date_of_birth"), DBDATE, "MM-dd");

				if (strBDate != null && strBDate.equals(strToday1)) {
					strBDate = " <span>today</span>";
					alBirthDays.add("Its " + hmEmployeeMap.get(rs.getString("emp_per_id")) + "'s birthday " + strBDate);
				} else if (strBDate != null && strBDate.equals(strTomorrow)) {
					strBDate = " <span>tomorrow</span>";
					alBirthDays.add("Its " + hmEmployeeMap.get(rs.getString("emp_per_id")) + "'s birthday " + strBDate);
				} else if (strBDate != null && strBDate.equals(strDayAfterTomorrow)) {
					strBDate = " on " + uF.getDateFormat(rs.getString("emp_date_of_birth"), DBDATE, "dd MMM");
					strBDate = "<span>" + strBDate.toLowerCase() + "</span>";
					alBirthDays.add("Its " + hmEmployeeMap.get(rs.getString("emp_per_id")) + "'s birthday " + strBDate);
				}
			}
			rs.close();
			pst.close();
			request.setAttribute("alBirthDays", alBirthDays);

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
	}

	public List<String> getBirthday(Connection con, UtilityFunctions uF, CommonFunctions CF, Map<String, String> hmEmployeeMap, HttpServletRequest request,
			List<String> alBirthDates, List<String> alEmpIds) {

		PreparedStatement pst = null;
		ResultSet rs = null;

		try {

			String strToday1 = uF.getDateFormat(uF.getCurrentDate(CF.getStrTimeZone()) + "", DBDATE, "MM-dd");
			String strTomorrow = uF.getDateFormat(uF.getFutureDate(CF.getStrTimeZone(), 1) + "", DBDATE, "MM-dd");
			String strDayAfterTomorrow = uF.getDateFormat(uF.getFutureDate(CF.getStrTimeZone(), 2) + "", DBDATE, "MM-dd");

			String yrs = uF.getDateFormat(uF.getCurrentDate(CF.getStrTimeZone()) + "", DBDATE, "yyyy");
			String strMinMax = uF.getCurrentMonthMinMaxDate("01/02/" + yrs, DATE_FORMAT);
			String[] tmpMinMax = strMinMax.split("::::");
			String[] tmpMaxDay = tmpMinMax[1].split("/");
			pst = con.prepareStatement(selectBirthDay);
			if (uF.parseToInt(tmpMaxDay[0]) == 29) {
				pst.setDate(1, uF.getFutureDate(CF.getStrTimeZone(), 366));
			} else {
				pst.setDate(1, uF.getFutureDate(CF.getStrTimeZone(), 365));
			}
			rs = pst.executeQuery();

			// System.out.println("pst====>"+pst);

			List<String> alBirthDays = new ArrayList<String>();
			while (rs.next()) {
				String strBDate = uF.getDateFormat(rs.getString("emp_date_of_birth"), DBDATE, "MM-dd");

				if (strBDate != null && strBDate.equals(strToday1)) {
					strBDate = " <span>today</span>";
					alBirthDays.add("Its " + hmEmployeeMap.get(rs.getString("emp_per_id")) + "'s birthday " + strBDate);
				} else if (strBDate != null && strBDate.equals(strTomorrow)) {
					strBDate = " <span>tomorrow</span>";
					alBirthDays.add("Its " + hmEmployeeMap.get(rs.getString("emp_per_id")) + "'s birthday " + strBDate);
				} else if (strBDate != null && strBDate.equals(strDayAfterTomorrow)) {
					strBDate = " on " + uF.getDateFormat(rs.getString("emp_date_of_birth"), DBDATE, "dd MMM");
					strBDate = "<span>" + strBDate.toLowerCase() + "</span>";
					alBirthDays.add("Its " + hmEmployeeMap.get(rs.getString("emp_per_id")) + "'s birthday " + strBDate);
				}
				alBirthDates.add(rs.getString("emp_date_of_birth"));
				alEmpIds.add(rs.getString("emp_per_id"));
			}
			rs.close();
			pst.close();

			request.setAttribute("alBirthDays", alBirthDays);

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return alBirthDates;
	}

	public void getAchievements(Connection con, String strEmpName, int nId, UtilityFunctions uF, List<String> alAchievements, String effectiveDate,
			String strNewGrade, String strNewDesignation) {
		try {
			switch (nId) {
				case 1 :
					alAchievements.add("An <strong>increment</strong> is given to " + strEmpName + " since <strong>" + effectiveDate + "</strong>.");
					break;
				case 2 :
					alAchievements.add(strEmpName + " got <strong>double increment</strong> since <strong>" + effectiveDate + "</strong>.");
					break;
				case 5 :
					alAchievements.add(strEmpName + "'s grade was revised to <strong>" + uF.showData(strNewGrade, "Na") + "</strong> since <strong>"
							+ effectiveDate + "</strong>.");
					break;
				case 6 :
					alAchievements.add(strEmpName + " are given a <strong>promotion</strong> since <strong>" + effectiveDate + "</strong>.");
					break;
				case 9 :
					alAchievements.add(strEmpName + " has been marked <strong>permanent</strong> since <strong>" + effectiveDate + "</strong>.");
					break;
			}

		} catch (Exception e) {
			e.printStackTrace();
		}

	}

	public String[] getFinancialYear(Connection con, String strDate, CommonFunctions CF, UtilityFunctions uF) {

		String[] arr = new String[2];
		PreparedStatement pst = null;
		ResultSet rs = null;
		try {

			pst = con.prepareStatement("select * from financial_year_details where financial_year_from <= ? and financial_year_to >= ? ");
			pst.setDate(1, uF.getDateFormat(strDate, DATE_FORMAT));
			pst.setDate(2, uF.getDateFormat(strDate, DATE_FORMAT));
			rs = pst.executeQuery();
			while (rs.next()) {
				arr[0] = uF.getDateFormat(rs.getString("financial_year_from"), DBDATE, DATE_FORMAT);
				arr[1] = uF.getDateFormat(rs.getString("financial_year_to"), DBDATE, DATE_FORMAT);
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return arr;
	}

	public String[] getFinancialYear(String strDate, CommonFunctions CF, UtilityFunctions uF) {
		Connection con = null;
		String[] arr = new String[2];
		PreparedStatement pst = null;
		ResultSet rs = null;
		Database db = new Database();
		db.setRequest(request);
		try {
			con = db.makeConnection(con);
			pst = con.prepareStatement("select * from financial_year_details where financial_year_from <= ? and financial_year_to >= ? ");
			pst.setDate(1, uF.getDateFormat(strDate, DATE_FORMAT));
			pst.setDate(2, uF.getDateFormat(strDate, DATE_FORMAT));
			rs = pst.executeQuery();
			while (rs.next()) {
				arr[0] = uF.getDateFormat(rs.getString("financial_year_from"), DBDATE, DATE_FORMAT);
				arr[1] = uF.getDateFormat(rs.getString("financial_year_to"), DBDATE, DATE_FORMAT);
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			db.closeResultSet(rs);
			db.closeStatements(pst);
			db.closeConnection(con);
		}
		return arr;
	}

	public Map<String, String> getOrientationValue(Connection con) {
		Map<String, String> hmOrientationMap = new HashMap<String, String>();
		PreparedStatement pst = null;
		ResultSet rs = null;
		try {
			pst = con.prepareStatement("select * from apparisal_orientation");
			rs = pst.executeQuery();
			while (rs.next()) {
				hmOrientationMap.put(rs.getString("apparisal_orientation_id"), rs.getString("orientation_name"));
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmOrientationMap;
	}

	public String getStrTimeZone() {
		return strTimeZone;
	}

	public void setStrTimeZone(String strTimeZone) {
		this.strTimeZone = strTimeZone;
	}

	public String getStrReportDateFormat() {
		return strReportDateFormat;
	}

	public void setStrReportDateFormat(String strReportDateFormat) {
		this.strReportDateFormat = strReportDateFormat;
	}

	public String getStrCURRENCY_FULL() {
		return strCURRENCY_FULL;
	}

	public void setStrCURRENCY_FULL(String strCURRENCY_FULL) {
		// if(strCURRENCY_FULL!=null && (
		// strCURRENCY_FULL.equalsIgnoreCase("RS.") ||
		// strCURRENCY_FULL.equalsIgnoreCase("RS") ||
		// strCURRENCY_FULL.equalsIgnoreCase("INR"))){
		// strCURRENCY_FULL = "<span class=\"rupee\">`</span>";
		// }
		this.strCURRENCY_FULL = strCURRENCY_FULL;
	}

	public String getStrCURRENCY_SHORT() {
		return strCURRENCY_SHORT;
	}

	public void setStrCURRENCY_SHORT(String strCURRENCY_SHORT) {
		if (strCURRENCY_SHORT != null
				&& (strCURRENCY_SHORT.equalsIgnoreCase("RS.") || strCURRENCY_SHORT.equalsIgnoreCase("RS") || strCURRENCY_SHORT.equalsIgnoreCase("INR"))) {
			strCURRENCY_SHORT = "<span class=\"rupee\">`</span>";
		}
		this.strCURRENCY_SHORT = strCURRENCY_SHORT;
	}

	public String getStrReportDayFormat() {
		return strReportDayFormat;
	}
	public void setStrReportDayFormat(String strReportDayFormat) {
		this.strReportDayFormat = strReportDayFormat;
	}
	public String getStrReportTimeFormat() {
		return strReportTimeFormat;
	}
	public void setStrReportTimeFormat(String strReportTimeFormat) {
		this.strReportTimeFormat = strReportTimeFormat;
	}
	public String getStrReportTimeAM_PMFormat() {
		return strReportTimeAM_PMFormat;
	}
	public void setStrReportTimeAM_PMFormat(String strReportTimeAM_PMFormat) {
		this.strReportTimeAM_PMFormat = strReportTimeAM_PMFormat;
	}
	public String getStrPaycycleDuration() {
		return strPaycycleDuration;
	}
	public void setStrPaycycleDuration(String strPaycycleDuration) {
		this.strPaycycleDuration = strPaycycleDuration;
	}
	public String getStrDisplayPayCycle() {
		return strDisplayPayCycle;
	}
	public void setStrDisplayPayCycle(String strDisplayPayCycle) {
		this.strDisplayPayCycle = strDisplayPayCycle;
	}
	public String getStrFinancialYearFrom() {
		return strFinancialYearFrom;
	}
	public void setStrFinancialYearFrom(String strFinancialYearFrom) {
		this.strFinancialYearFrom = strFinancialYearFrom;
	}
	public String getStrFinancialYearTo() {
		return strFinancialYearTo;
	}
	public void setStrFinancialYearTo(String strFinancialYearTo) {
		this.strFinancialYearTo = strFinancialYearTo;
	}
	public String getStrOrgName() {
		return strOrgName;
	}
	public void setStrOrgName(String strOrgName) {
		this.strOrgName = strOrgName;
	}
	public String getStrOrgLogo() {
		return strOrgLogo;
	}
	public void setStrOrgLogo(String strOrgLogo) {
		this.strOrgLogo = strOrgLogo;
	}

	public String getStrOrgLogoSmall() {
		return strOrgLogoSmall;
	}

	public void setStrOrgLogoSmall(String strOrgLogoSmall) {
		this.strOrgLogoSmall = strOrgLogoSmall;
	}

	public String getStrOEmpCodeAlpha() {
		return strOEmpCodeAlpha;
	}
	public void setStrOEmpCodeAlpha(String strOEmpCodeAlpha) {
		this.strOEmpCodeAlpha = strOEmpCodeAlpha;
	}
	public String getStrOContractorCodeAlpha() {
		return strOContractorCodeAlpha;
	}
	public void setStrOContractorCodeAlpha(String strOContractorCodeAlpha) {
		this.strOContractorCodeAlpha = strOContractorCodeAlpha;
	}
	public String getStrOrgAddress() {
		return strOrgAddress;
	}
	public void setStrOrgAddress(String strOrgAddress) {
		this.strOrgAddress = strOrgAddress;
	}
	public String getStrMaxEmployee() {
		return strMaxEmployee;
	}
	public void setStrMaxEmployee(String strMaxEmployee) {
		this.strMaxEmployee = strMaxEmployee;
	}
	public String getStrMaxLocations() {
		return strMaxLocations;
	}
	public void setStrMaxLocations(String strMaxLocations) {
		this.strMaxLocations = strMaxLocations;
	}
	public String getStrOSalaryCalculationType() {
		return strOSalaryCalculationType;
	}
	public void setStrOSalaryCalculationType(String strOSalaryCalculationType) {
		this.strOSalaryCalculationType = strOSalaryCalculationType;
	}
	public String getStrMaxAdmin() {
		return strMaxAdmin;
	}
	public void setStrMaxAdmin(String strMaxAdmin) {
		this.strMaxAdmin = strMaxAdmin;
	}
	public String[] getArrEnabledModules() {
		return arrEnabledModules;
	}
	public void setArrEnabledModules(String[] arrEnabledModules) {
		this.arrEnabledModules = arrEnabledModules;
	}
	public String getStrMaxUserLevels() {
		return strMaxUserLevels;
	}
	public void setStrMaxUserLevels(String strMaxUserLevels) {
		this.strMaxUserLevels = strMaxUserLevels;
	}
	public boolean isTrial() {
		return isTrial;
	}
	public void setTrial(boolean isTrial) {
		this.isTrial = isTrial;
	}
	public boolean isTermsCondition() {
		return isTermsCondition;
	}
	public void setTermsCondition(boolean isTermsCondition) {
		this.isTermsCondition = isTermsCondition;
	}
	public String getStrEmailLocalHost() {
		return strEmailLocalHost;
	}
	public void setStrEmailLocalHost(String strEmailLocalHost) {
		this.strEmailLocalHost = strEmailLocalHost;
	}
	public String getStrStandardHrs() {
		return strStandardHrs;
	}
	public void setStrStandardHrs(String strStandardHrs) {
		this.strStandardHrs = strStandardHrs;
	}
	public String getStrAttendanceIntegratedWithActivity() {
		return strAttendanceIntegratedWithActivity;
	}
	public void setStrAttendanceIntegratedWithActivity(String strAttendanceIntegratedWithActivity) {
		this.strAttendanceIntegratedWithActivity = strAttendanceIntegratedWithActivity;
	}
	public String getStrUserNameFormat() {
		return strUserNameFormat;
	}
	public void setStrUserNameFormat(String strUserNameFormat) {
		this.strUserNameFormat = strUserNameFormat;
	}
	public String getStrCommonAttendanceFormat() {
		return strCommonAttendanceFormat;
	}
	public void setStrCommonAttendanceFormat(String strCommonAttendanceFormat) {
		this.strCommonAttendanceFormat = strCommonAttendanceFormat;
	}
	public String getStrOrgSubTitle() {
		return strOrgSubTitle;
	}
	public void setStrOrgSubTitle(String strOrgSubTitle) {
		this.strOrgSubTitle = strOrgSubTitle;
	}
	public boolean isForcePassword() {
		return isForcePassword;
	}
	public void setForcePassword(boolean isForcePassword) {
		this.isForcePassword = isForcePassword;
	}
	public String getStrEmpOrgLogo() {
		return strEmpOrgLogo;
	}
	public void setStrEmpOrgLogo(String strEmpOrgLogo) {
		this.strEmpOrgLogo = strEmpOrgLogo;
	}

	public String getStrEmpOrgLogoSmall() {
		return strEmpOrgLogoSmall;
	}

	public void setStrEmpOrgLogoSmall(String strEmpOrgLogoSmall) {
		this.strEmpOrgLogoSmall = strEmpOrgLogoSmall;
	}

	public String getIsWorkFlow() {
		return isWorkFlow;
	}
	public void setIsWorkFlow(String isWorkFlow) {
		this.isWorkFlow = isWorkFlow;
	}
	public String getIsBonusPaidWithPayroll() {
		return isBonusPaidWithPayroll;
	}
	public void setIsBonusPaidWithPayroll(String isBonusPaidWithPayroll) {
		this.isBonusPaidWithPayroll = isBonusPaidWithPayroll;
	}
	public String getStrMaxOrganisation() {
		return strMaxOrganisation;
	}
	public void setStrMaxOrganisation(String strMaxOrganisation) {
		this.strMaxOrganisation = strMaxOrganisation;
	}
	public String getIsSpecificEmp() {
		return isSpecificEmp;
	}
	public void setIsSpecificEmp(String isSpecificEmp) {
		this.isSpecificEmp = isSpecificEmp;
	}
	public String getBackUpLocation() {
		return backUpLocation;
	}

	public void setBackUpLocation(String backUpLocation) {
		this.backUpLocation = backUpLocation;
	}
	public String getDumpLocation() {
		return dumpLocation;
	}
	public void setDumpLocation(String dumpLocation) {
		this.dumpLocation = dumpLocation;
	}
	public String[] getArrAllModules() {
		return arrAllModules;
	}
	public void setArrAllModules(String[] arrAllModules) {
		this.arrAllModules = arrAllModules;
	}

	public String getIsPaycycleAdjustment() {
		return isPaycycleAdjustment;
	}

	public void setIsPaycycleAdjustment(String isPaycycleAdjustment) {
		this.isPaycycleAdjustment = isPaycycleAdjustment;
	}
	public String getStrDocSaveLocation() {
		return strDocSaveLocation;
	}

	public void setStrDocSaveLocation(String strDocSaveLocation) {
		this.strDocSaveLocation = strDocSaveLocation;
	}

	public String getStrDocRetriveLocation() {
		return strDocRetriveLocation;
	}

	public void setStrDocRetriveLocation(String strDocRetriveLocation) {
		this.strDocRetriveLocation = strDocRetriveLocation;
	}

	public boolean getIsRemoteLocation() {
		return isRemoteLocation;
	}

	public void setIsRemoteLocation(boolean isRemoteLocation) {
		this.isRemoteLocation = isRemoteLocation;
	}

	public boolean isEPF_Condition1() {
		return isEPF_Condition1;
	}

	public void setEPF_Condition1(boolean isEPF_Condition1) {
		this.isEPF_Condition1 = isEPF_Condition1;
	}

	public void setRemoteLocation(boolean isRemoteLocation) {
		this.isRemoteLocation = isRemoteLocation;
	}

	String strDbName;
	public void setDbName(String strDbName) {
		this.strDbName = strDbName;
	}
	public String getDbName() {
		return strDbName;
	}

	public String getRoundOffCondtion() {
		return roundOffCondtion;
	}

	public void setRoundOffCondtion(String roundOffCondtion) {
		this.roundOffCondtion = roundOffCondtion;
	}

	public Map<String, String> getEmpDesigMapId(Connection con) {
		Map<String, String> hmEmpCodeDesig = new HashMap<String, String>();

		PreparedStatement pst = null;
		ResultSet rs = null;
		try {
			pst = con.prepareStatement(selectEmployeeDesig);
			rs = pst.executeQuery();
			while (rs.next()) {
				hmEmpCodeDesig.put(rs.getString("emp_id"), rs.getString("designation_id"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmEmpCodeDesig;
	}

	public List<List<String>> selectSkills(Connection con, int EmpId) {

		PreparedStatement pst = null;
		ResultSet rs = null;

		// StringBuilder sb = new StringBuilder();
		// String str = "";
		List<List<String>> alSkills = new ArrayList<List<String>>();
		try {
			pst = con.prepareStatement(selectskills);
			pst.setInt(1, EmpId);
			rs = pst.executeQuery();
			// System.out.println("pst ===>>>> " + pst);

			// int count = 0;
			while (rs.next()) {
				List<String> alInner1 = new ArrayList<String>();
				alInner1.add(rs.getInt("skill_id") + "");
				alInner1.add(getSkillNameBySkillId(con, rs.getString("skill_id")));
				alInner1.add(rs.getString("skills_value"));
				alInner1.add(rs.getInt("emp_id") + "");
				if (alSkills != null) {
					alSkills.add(alInner1);
				}
				// sb.append(rs.getString("skills_name") + ((count == 0) ?
				// " [Pri]" : "") + ", ");
				// count++;
			}
			rs.close();
			pst.close();
			// int index = sb.lastIndexOf(",");
			// if (index > 0) {
			// str = sb.substring(0, index);
			// }
			// System.out.println("alSkills ===>> " +alSkills);

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return alSkills;
	}

	public List<String> selectEmpSkills(Connection con, int EmpId) {

		PreparedStatement pst = null;
		ResultSet rs = null;

		// StringBuilder sb = new StringBuilder();
		// String str = "";
		List<String> alSkills = new ArrayList<String>();
		try {
			pst = con.prepareStatement(selectskills);
			pst.setInt(1, EmpId);
			rs = pst.executeQuery();
			int count = 0;
			while (rs.next()) {
				if (count == 0) {
					alSkills.add(getSkillNameBySkillId(con, rs.getString("skill_id")) + " [Pri]");
				} else {
					alSkills.add(getSkillNameBySkillId(con, rs.getString("skill_id")));
				}
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return alSkills;
	}

	public List<List<String>> selectLanguages(Connection con, UtilityFunctions uF, int empId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		List<List<String>> alLanguages = new ArrayList<List<String>>();
		try {
			pst = con.prepareStatement("SELECT * FROM languages_details WHERE emp_id = ?");
			pst.setInt(1, empId);
			log.debug("pst=>" + pst);
			rs = pst.executeQuery();
			while (rs.next()) {
				List<String> alInner = new ArrayList<String>();
				alInner.add(rs.getString("language_id"));
				alInner.add(rs.getString("language_name"));
				alInner.add(rs.getString("language_read"));
				alInner.add(rs.getString("language_write"));
				alInner.add(rs.getString("language_speak"));
				alInner.add(uF.showData(rs.getString("language_mothertounge"), ""));
				alLanguages.add(alInner);
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

		return alLanguages;

	}

	public Map<String, String> getUsersMap(Connection con) {

		PreparedStatement pst = null;
		ResultSet rs = null;

		Map<String, String> hmUsers = new HashMap<String, String>();

		try {
			pst = con.prepareStatement("SELECT * FROM user_details");
			rs = pst.executeQuery();
			while (rs.next()) {
				hmUsers.put(rs.getString("user_id"), rs.getString("username"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

		return hmUsers;

	}

	public Map<String, String> getEmpIdUserNameMap(Connection con) {

		PreparedStatement pst = null;
		ResultSet rs = null;

		Map<String, String> hmUsers = new HashMap<String, String>();

		try {
			pst = con.prepareStatement("SELECT * FROM user_details");
			rs = pst.executeQuery();
			while (rs.next()) {
				hmUsers.put(rs.getString("emp_id"), rs.getString("username") + " " + rs.getString("password"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

		return hmUsers;

	}

	public Map<String, Map<String, String>> getDailyRatesService(Connection con, String strEmpId) {
		Map<String, Map<String, String>> hmPayrollPolicy = new HashMap<String, Map<String, String>>();

		PreparedStatement pst = null;
		ResultSet rs = null;

		try {
			pst = con.prepareStatement(selectPayrollPolicy2);
			pst.setInt(1, uF.parseToInt(strEmpId));
			rs = pst.executeQuery();

			Map<String, String> hm = new HashMap<String, String>();
			while (rs.next()) {
				hm = new HashMap<String, String>();

				hm.put("MONDAY", rs.getString("monamount"));
				hm.put("TUESDAY", rs.getString("tuesamount"));
				hm.put("WEDNESDAY", rs.getString("wedamount"));
				hm.put("THURSDAY", rs.getString("thursamount"));
				hm.put("FRIDAY", rs.getString("friamount"));
				hm.put("SATURDAY", rs.getString("satamount"));
				hm.put("SUNDAY", rs.getString("sunamount"));
				hm.put("FIXED", rs.getString("fxdamount"));
				hm.put("PAYMODE", rs.getString("paymode"));
				hm.put("LOADING", rs.getString("loading"));

				hm.put("MON_LOADING", rs.getString("loading_mon"));
				hm.put("TUE_LOADING", rs.getString("loading_tue"));
				hm.put("WED_LOADING", rs.getString("loading_wed"));
				hm.put("THURS_LOADING", rs.getString("loading_thurs"));
				hm.put("FRI_LOADING", rs.getString("loading_fri"));
				hm.put("SAT_LOADING", rs.getString("loading_sat"));
				hm.put("SUN_LOADING", rs.getString("loading_sun"));

				hmPayrollPolicy.put(rs.getString("service_id"), hm);
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmPayrollPolicy;
	}
	public List<List<String>> selectFamilyMembers(Connection con, int empId) {

		PreparedStatement pst = null;
		ResultSet rs = null;

		List<List<String>> alFamilyMembers = new ArrayList<List<String>>();

		try {
			pst = con.prepareStatement("SELECT * FROM emp_family_members WHERE emp_id = ? order by member_type");
			pst.setInt(1, empId);
			rs = pst.executeQuery();

			while (rs.next()) {
				List<String> alInner = new ArrayList<String>();
				alInner.add(rs.getString("member_id"));
				alInner.add(uF.showData(rs.getString("member_name"), ""));
				alInner.add(uF.getDateFormat(rs.getString("member_dob"), DBDATE, getStrReportDateFormat()));
				alInner.add(uF.showData(rs.getString("member_education"), ""));
				alInner.add(uF.showData(rs.getString("member_occupation"), ""));
				alInner.add(uF.showData(rs.getString("member_contact_no"), ""));
				alInner.add(uF.showData(rs.getString("member_email_id"), ""));
				alInner.add(uF.charMappingMaleFemale(rs.getString("member_gender")));
				alInner.add(uF.showData(rs.getString("member_type"), ""));
				alInner.add(uF.getMaritalStatus(uF.showData(rs.getString("member_marital"), "")));
				alInner.add(uF.showData(rs.getString("mrd_no"), ""));

				alFamilyMembers.add(alInner);
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

		return alFamilyMembers;

	}

	public Map<String, Map<String, String>> getDailyRates(Connection con, Map<String, Map<String, String>> hmPayrollFT,
			Map<String, Map<String, String>> hmPayrollPT) {
		Map<String, Map<String, String>> hmPayrollPolicy = new HashMap<String, Map<String, String>>();

		Map<String, String> hm = new HashMap<String, String>();

		PreparedStatement pst = null;
		ResultSet rs = null;

		try {

			pst = con.prepareStatement(selectPayrollPolicy1);
			rs = pst.executeQuery();

			while (rs.next()) {
				hm = new HashMap<String, String>();

				hm.put("PP_ID", rs.getString("payroll_policy_id"));
				hm.put("MONDAY", rs.getString("monamount"));
				hm.put("TUESDAY", rs.getString("tuesamount"));
				hm.put("WEDNESDAY", rs.getString("wedamount"));
				hm.put("THURSDAY", rs.getString("thursamount"));
				hm.put("FRIDAY", rs.getString("friamount"));
				hm.put("SATURDAY", rs.getString("satamount"));
				hm.put("SUNDAY", rs.getString("sunamount"));
				hm.put("FIXED", rs.getString("fxdamount"));
				hm.put("PAYMODE", rs.getString("paymode"));
				hm.put("LOADING", rs.getString("loading"));

				hm.put("MON_LOADING", rs.getString("loading_mon"));
				hm.put("TUE_LOADING", rs.getString("loading_tue"));
				hm.put("WED_LOADING", rs.getString("loading_wed"));
				hm.put("THURS_LOADING", rs.getString("loading_thurs"));
				hm.put("FRI_LOADING", rs.getString("loading_fri"));
				hm.put("SAT_LOADING", rs.getString("loading_sat"));
				hm.put("SUN_LOADING", rs.getString("loading_sun"));

				hmPayrollPolicy.put(rs.getString("desig_id"), hm);

				hmPayrollFT.put("D" + rs.getString("desig_id") + "S" + rs.getString("service_id"), hm);
				hmPayrollFT.put("D" + rs.getString("desig_id") + "S", hm);
				hmPayrollPT.put("D" + rs.getString("desig_id") + "S" + rs.getString("service_id"), hm);

			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmPayrollPolicy;
	}

	public Map<String, String> getEmpAgeMap(Connection con, CommonFunctions CF) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmEmpAgeMap = new HashMap<String, String>();
		UtilityFunctions uF = new UtilityFunctions();

		try {
			pst = con.prepareStatement(selectEmpDetails);
			rs = pst.executeQuery();

			while (rs.next()) {

				String strDays = uF.dateDifference(rs.getString("emp_date_of_birth"), DBDATE, uF.getCurrentDate(CF.getStrTimeZone()) + "", DBDATE,
						CF.getStrTimeZone());
				double dblYears = uF.parseToDouble(strDays) / 365;
				hmEmpAgeMap.put(rs.getString("emp_per_id"), dblYears + "");
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmEmpAgeMap;
	}

	public boolean isCurrentRostered(Connection con, CommonFunctions CF, String strEmpId, int nVal) {
		boolean isRoster = false;
		PreparedStatement pst = null;
		ResultSet rs = null;

		try {

			pst = con.prepareStatement(selectRosterClockDetails_N);
			pst.setInt(1, uF.parseToInt(strEmpId));
			pst.setDate(2, uF.getCurrentDate(CF.getStrTimeZone()));
			pst.setInt(3, nVal);
			rs = pst.executeQuery();

			while (rs.next()) {
				isRoster = true;
			}
			rs.close();
			pst.close();

			log.debug("selectRosterClockDetails = " + pst);

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

		return isRoster;
	}

	public Map<String, String> getWLocationMap(Connection con, String strUserType, String strEmpId) {
		Map<String, String> hmEmpWLocation = new HashMap<String, String>();

		//
		PreparedStatement pst = null;
		ResultSet rs = null;
		UtilityFunctions uF = new UtilityFunctions();

		try {

			if (strUserType != null && (strUserType.equalsIgnoreCase(ADMIN) || strUserType.equalsIgnoreCase(CEO) || strUserType.equalsIgnoreCase(CFO))) {
				pst = con.prepareStatement(selectWLocation);

			} else if (strUserType != null && (strUserType.equalsIgnoreCase(HRMANAGER) || strUserType.equalsIgnoreCase(ACCOUNTANT))) {
				pst = con.prepareStatement(selectWLocation_HRManager);
				pst.setInt(1, uF.parseToInt(strEmpId));

			} else {
				pst = con.prepareStatement(selectWLocation);
			}

			rs = pst.executeQuery();
			while (rs.next()) {
				hmEmpWLocation.put(rs.getString("wlocation_id"), rs.getString("wlocation_name"));
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmEmpWLocation;
	}

	public Map<String, String> getDepartmentMap(Connection con, String struserType, String strEmpId) {
		Map<String, String> hmDepartment = new HashMap<String, String>();

		PreparedStatement pst = null;
		ResultSet rs = null;

		try {

			if (struserType != null && (struserType.equalsIgnoreCase(ADMIN) || struserType.equalsIgnoreCase(CEO) || struserType.equalsIgnoreCase(CFO))) {
				pst = con.prepareStatement(selectDepartment);
			} else if (struserType != null && (struserType.equalsIgnoreCase(HRMANAGER) || struserType.equalsIgnoreCase(ACCOUNTANT))) {
				pst = con.prepareStatement(selectDepartment_HRManager);
				pst.setInt(1, uF.parseToInt(strEmpId));
			} else {
				pst = con.prepareStatement(selectDepartment);
			}

			rs = pst.executeQuery();
			while (rs.next()) {
				hmDepartment.put(rs.getString("dept_id"), rs.getString("dept_name"));

			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmDepartment;
	}

	public String[] getPrevPayCycle(Connection con, String strDate, String strTimeZone, CommonFunctions CF, HttpServletRequest request) {

		PreparedStatement pst = null;
		ResultSet rs = null;

		UtilityFunctions uF = new UtilityFunctions();
		String[] strPayCycleDate = new String[3];

		try {

			String startDate = null;
			String strDisplayPaycycle = null;
			String strPaycycleDuration = null;

			pst = con.prepareStatement(selectSettings);
			rs = pst.executeQuery();

			while (rs.next()) {
				if (rs.getString("options").equalsIgnoreCase(O_START_PAY_CLYCLE)) {
					startDate = rs.getString("value");
				}
				if (rs.getString("options").equalsIgnoreCase(O_DISPLAY_PAY_CLYCLE)) {
					strDisplayPaycycle = rs.getString("value");
				}
				if (rs.getString("options").equalsIgnoreCase(O_PAYCYCLE_DURATION)) {
					strPaycycleDuration = rs.getString("value");
				}
			}
			rs.close();
			pst.close();

			String[] arrDisplayPAycycle = null;
			int minCycle = 0;
			int maxCycle = 0;
			if (strDisplayPaycycle != null) {
				arrDisplayPAycycle = strDisplayPaycycle.split("-");
				minCycle = uF.parseToInt(arrDisplayPAycycle[0]);
				maxCycle = uF.parseToInt(arrDisplayPAycycle[1]);
			}

			Calendar calCurrent = GregorianCalendar.getInstance(TimeZone.getTimeZone((strTimeZone)));
			calCurrent.set(Calendar.DAY_OF_MONTH, uF.parseToInt(uF.getDateFormat(strDate, DATE_FORMAT, "dd")));
			calCurrent.set(Calendar.MONTH, uF.parseToInt(uF.getDateFormat(strDate, DATE_FORMAT, "MM")) - 1);
			calCurrent.set(Calendar.YEAR, uF.parseToInt(uF.getDateFormat(strDate, DATE_FORMAT, "yyyy")));

			calCurrent.add(Calendar.DAY_OF_MONTH, -1);

			Calendar cal = GregorianCalendar.getInstance(TimeZone.getTimeZone(strTimeZone));
			cal.set(Calendar.DAY_OF_MONTH, uF.parseToInt(uF.getDateFormat(startDate, DATE_FORMAT, "dd")));
			cal.set(Calendar.MONTH, uF.parseToInt(uF.getDateFormat(startDate, DATE_FORMAT, "MM")) - 1);
			cal.set(Calendar.YEAR, uF.parseToInt(uF.getDateFormat(startDate, DATE_FORMAT, "yyyy")));

			StringBuilder sb = new StringBuilder();
			int nPayCycle = 0;

			int nDurationCount = 0;
			String dt1 = null;
			String dt2 = null;

			List<String> alInner = new ArrayList<String>();
			// java.util.Date strCurrentDate = calCurrent.getTime();
			java.util.Date strCurrentDate = uF.getDateFormatUtil(
					((calCurrent.get(Calendar.DAY_OF_MONTH) < 10) ? "0" + calCurrent.get(Calendar.DAY_OF_MONTH) : calCurrent.get(Calendar.DAY_OF_MONTH)) + "/"
							+ (((calCurrent.get(Calendar.MONTH)) < 10) ? "0" + (calCurrent.get(Calendar.MONTH)) : (calCurrent.get(Calendar.MONTH))) + "/"
							+ calCurrent.get(Calendar.YEAR), DATE_FORMAT);

			java.util.Date strCurrentPayCycleD1 = null;
			java.util.Date strCurrentPayCycleD2 = null;

			while (true) {
				sb = new StringBuilder();
				nPayCycle++;

				if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("M")) {
					nDurationCount = cal.getActualMaximum(Calendar.DAY_OF_MONTH) - 1;
				} else if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("F")) {
					nDurationCount = 15 - 1;
					if (cal.get(Calendar.DAY_OF_MONTH) == 16) {
						int nActual = cal.getActualMaximum(Calendar.DAY_OF_MONTH);
						nDurationCount = nActual - 15 - 1;
					}
				} else if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("BW")) {
					nDurationCount = 14 - 1;
				} else if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("W")) {
					nDurationCount = 7 - 1;
				} else {
					nDurationCount = cal.getMaximum(Calendar.DAY_OF_MONTH) - 1;
				}

				dt1 = ((cal.get(Calendar.DAY_OF_MONTH) < 10) ? "0" + cal.get(Calendar.DAY_OF_MONTH) : cal.get(Calendar.DAY_OF_MONTH)) + "/"
						+ (((cal.get(Calendar.MONTH) + 1) < 10) ? "0" + (cal.get(Calendar.MONTH) + 1) : (cal.get(Calendar.MONTH) + 1)) + "/"
						+ cal.get(Calendar.YEAR);
				cal.add(Calendar.DAY_OF_MONTH, nDurationCount);
				dt2 = ((cal.get(Calendar.DAY_OF_MONTH) < 10) ? "0" + cal.get(Calendar.DAY_OF_MONTH) : cal.get(Calendar.DAY_OF_MONTH)) + "/"
						+ (((cal.get(Calendar.MONTH) + 1) < 10) ? "0" + (cal.get(Calendar.MONTH) + 1) : (cal.get(Calendar.MONTH) + 1)) + "/"
						+ cal.get(Calendar.YEAR);

				if (nPayCycle < minCycle) {
					cal.add(Calendar.DAY_OF_MONTH, 1);
					continue;
				}

				sb.append("Pay Cycle " + nPayCycle + ", " + dt1 + " - " + dt2);

				strCurrentPayCycleD1 = uF.getDateFormatUtil(dt1, DATE_FORMAT);
				strCurrentPayCycleD2 = uF.getDateFormatUtil(dt2, DATE_FORMAT);

				log.debug("nPayCycle===>" + nPayCycle);

				if (strCurrentDate.equals(strCurrentPayCycleD1) || strCurrentDate.equals(strCurrentPayCycleD2)
						|| (strCurrentDate.after(strCurrentPayCycleD1) && strCurrentDate.before(strCurrentPayCycleD2))) {
					strPayCycleDate[0] = dt1;
					strPayCycleDate[1] = dt2;
					strPayCycleDate[2] = nPayCycle + "";

					log.debug("nPayCycle= E ==>" + nPayCycle);
				}

				cal.add(Calendar.DAY_OF_MONTH, 1);

				if (nPayCycle >= maxCycle) {
					break;
				}

			}

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return strPayCycleDate;
	}

	public boolean getEmpFilledStatus(Connection con, String empId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		UtilityFunctions uF = new UtilityFunctions();
		boolean isFilledStatus = true;

		try {
			pst = con.prepareStatement("select emp_filled_flag from employee_personal_details WHERE emp_per_id = ?");
			pst.setInt(1, uF.parseToInt(empId));
			rs = pst.executeQuery();
			while (rs.next()) {
				isFilledStatus = rs.getBoolean("emp_filled_flag");
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return isFilledStatus;
	}

	public String[] getPayCycleFromDate(Connection con, String strDate, String strTimeZone, CommonFunctions CF, String orgId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		UtilityFunctions uF = new UtilityFunctions();
		String[] strPayCycleDate = new String[3];

		try {

			String startDate = null;
			String strDisplayPaycycle = null;
			String strPaycycleDuration = null;

			pst = con.prepareStatement("select * from org_details where org_id=?");
			pst.setInt(1, uF.parseToInt(orgId));
			rs = pst.executeQuery();

			while (rs.next()) {
				startDate = uF.getDateFormat(rs.getString("start_paycycle"), DBDATE, DATE_FORMAT);
				strDisplayPaycycle = rs.getString("display_paycycle");
				strPaycycleDuration = rs.getString("duration_paycycle");
			}
			rs.close();
			pst.close();

			if (startDate == null || startDate.trim().equals("") || startDate.trim().equalsIgnoreCase("NULL") || startDate.trim().equals("-")) {
				return null;
			}

			String[] arrDisplayPAycycle = null;
			int minCycle = 0;
			int maxCycle = 0;
			if (strDisplayPaycycle != null) {
				arrDisplayPAycycle = strDisplayPaycycle.split("-");
				minCycle = uF.parseToInt(arrDisplayPAycycle[0]);
				maxCycle = uF.parseToInt(arrDisplayPAycycle[1]);
			}

			Calendar calCurrent = GregorianCalendar.getInstance(TimeZone.getTimeZone((strTimeZone)));
			calCurrent.set(Calendar.DAY_OF_MONTH, uF.parseToInt(uF.getDateFormat(strDate, DATE_FORMAT, "dd")));
			calCurrent.set(Calendar.MONTH, uF.parseToInt(uF.getDateFormat(strDate, DATE_FORMAT, "MM")) - 1);
			calCurrent.set(Calendar.YEAR, uF.parseToInt(uF.getDateFormat(strDate, DATE_FORMAT, "yyyy")));

			// calCurrent.add(Calendar.DAY_OF_MONTH, -1);

			Calendar cal = GregorianCalendar.getInstance(TimeZone.getTimeZone(strTimeZone));
			cal.set(Calendar.DAY_OF_MONTH, uF.parseToInt(uF.getDateFormat(startDate, DATE_FORMAT, "dd")));
			cal.set(Calendar.MONTH, uF.parseToInt(uF.getDateFormat(startDate, DATE_FORMAT, "MM")) - 1);
			cal.set(Calendar.YEAR, uF.parseToInt(uF.getDateFormat(startDate, DATE_FORMAT, "yyyy")));

			StringBuilder sb = new StringBuilder();
			int nPayCycle = 0;

			int nDurationCount = 0;
			String dt1 = null;
			String dt2 = null;

			// List<String> alInner = new ArrayList<String>();
			// java.util.Date strCurrentDate = calCurrent.getTime();
			java.util.Date strCurrentDate = uF.getDateFormatUtil(((calCurrent.get(Calendar.DAY_OF_MONTH) < 10)
					? "0" + calCurrent.get(Calendar.DAY_OF_MONTH)
					: calCurrent.get(Calendar.DAY_OF_MONTH))
					+ "/"
					+ (((calCurrent.get(Calendar.MONTH) + 1) < 10) ? "0" + (calCurrent.get(Calendar.MONTH) + 1) : (calCurrent.get(Calendar.MONTH) + 1))
					+ "/"
					+ calCurrent.get(Calendar.YEAR), DATE_FORMAT);

			java.util.Date strCurrentPayCycleD1 = null;
			java.util.Date strCurrentPayCycleD2 = null;

			while (true) {
				sb = new StringBuilder();
				nPayCycle++;

				if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("M")) {
					nDurationCount = cal.getActualMaximum(Calendar.DAY_OF_MONTH) - 1;
				} else if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("F")) {
					nDurationCount = 15 - 1;
					if (cal.get(Calendar.DAY_OF_MONTH) == 16) {
						int nActual = cal.getActualMaximum(Calendar.DAY_OF_MONTH);
						nDurationCount = nActual - 15 - 1;
					}
				} else if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("BW")) {
					nDurationCount = 14 - 1;
				} else if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("W")) {
					nDurationCount = 7 - 1;
				} else {
					nDurationCount = cal.getMaximum(Calendar.DAY_OF_MONTH) - 1;
				}

				dt1 = ((cal.get(Calendar.DAY_OF_MONTH) < 10) ? "0" + cal.get(Calendar.DAY_OF_MONTH) : cal.get(Calendar.DAY_OF_MONTH)) + "/"
						+ (((cal.get(Calendar.MONTH) + 1) < 10) ? "0" + (cal.get(Calendar.MONTH) + 1) : (cal.get(Calendar.MONTH) + 1)) + "/"
						+ cal.get(Calendar.YEAR);
				cal.add(Calendar.DAY_OF_MONTH, nDurationCount);
				dt2 = ((cal.get(Calendar.DAY_OF_MONTH) < 10) ? "0" + cal.get(Calendar.DAY_OF_MONTH) : cal.get(Calendar.DAY_OF_MONTH)) + "/"
						+ (((cal.get(Calendar.MONTH) + 1) < 10) ? "0" + (cal.get(Calendar.MONTH) + 1) : (cal.get(Calendar.MONTH) + 1)) + "/"
						+ cal.get(Calendar.YEAR);

				if (nPayCycle < minCycle) {
					cal.add(Calendar.DAY_OF_MONTH, 1);
					continue;
				}

				sb.append("Pay Cycle " + nPayCycle + ", " + dt1 + " - " + dt2);

				strCurrentPayCycleD1 = uF.getDateFormatUtil(dt1, DATE_FORMAT);
				strCurrentPayCycleD2 = uF.getDateFormatUtil(dt2, DATE_FORMAT);

				// System.out.println("strCurrentPayCycleD1==>" +
				// strCurrentPayCycleD1+ "--strCurrentPayCycleD2==>" +
				// strCurrentPayCycleD2);

				if (strCurrentDate.equals(strCurrentPayCycleD1) || strCurrentDate.equals(strCurrentPayCycleD2)
						|| (strCurrentDate.after(strCurrentPayCycleD1) && strCurrentDate.before(strCurrentPayCycleD2))) {
					strPayCycleDate[0] = dt1;
					strPayCycleDate[1] = dt2;
					strPayCycleDate[2] = nPayCycle + "";

					// System.out.println("Pay Cycle " + nPayCycle + ", " + dt1
					// + " - " + dt2);

				}

				cal.add(Calendar.DAY_OF_MONTH, 1);

				if (nPayCycle >= maxCycle) {
					break;
				}

			}

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return strPayCycleDate;
	}

	public String getEmpOrgId(Connection con, UtilityFunctions uF, String strEmpId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		String orgId = null;

		try {
			pst = con.prepareStatement("select org_id from employee_official_details WHERE emp_id = ?");
			pst.setInt(1, uF.parseToInt(strEmpId));
			rs = pst.executeQuery();
			while (rs.next()) {
				orgId = rs.getString("org_id");
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return orgId;
	}

	public String getURLInfo(HttpServletRequest request) {
		String strValue = null;
		if (request != null) {
			strValue = request.getServerName().split("\\.")[0] + " = " + request.getContextPath();
		} else {
			strValue = "";
		}
		return strValue;
	}

	public Map<String, Map<String, String>> getSalaryCalculationforArrears(Connection con, String empId, double dblPresent, String strLevelId,
			UtilityFunctions uF, CommonFunctions CF, String startArrearDate, String endArrearDate, int nTotalNumberOfDays, double dblBreaks,
			double dblIncrementBasic, double dblIncrementDA, HttpServletRequest request, int monthCount) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, Map<String, String>> hmSalaryHeadReCalculatedMap = new LinkedHashMap<String, Map<String, String>>();
		Map<String, Map<String, String>> hmSalaryHeadMap = new LinkedHashMap<String, Map<String, String>>();
		Map<String, Map<String, String>> hmPrevSalaryHeadReCalculatedMap = new LinkedHashMap<String, Map<String, String>>();
		Map<String, Map<String, String>> hmPrevSalaryHeadMap = new LinkedHashMap<String, Map<String, String>>();
		Map<String, Map<String, String>> hmArrearSalaryHeadMap = new LinkedHashMap<String, Map<String, String>>();

		String orgId = CF.getEmpOrgId(con, uF, empId);

		try {

			Map<String, String> hmSalaryEarningDeduction = new HashMap<String, String>();
			Map<String, String> hmSalaryType = new HashMap<String, String>();

			int nEmpId = uF.parseToInt(empId);

			String[] currArr = null;
			currArr = CF.getCurrentPayCycleByOrg(con, CF.getStrTimeZone(), CF, orgId);

			/*
			 * pst = con.prepareStatement(
			 * "select * from salary_details where level_id = ? order by salary_head_id, salary_id"
			 * ); pst.setInt(1, uF.parseToInt(strLevelId));
			 */

			pst = con.prepareStatement("select * from salary_details where level_id=-1 order by salary_head_id, salary_id");
			rs = pst.executeQuery();
			Map<String, Map<String, String>> hmSalaryDetails = new HashMap<String, Map<String, String>>();

			while (rs.next()) {

				Map<String, String> hmInnerSal = new HashMap<String, String>();

				hmInnerSal.put("SALARY_HEAD_ID", rs.getString("salary_head_id"));
				hmInnerSal.put("EARNING_DEDUCTION", rs.getString("earning_deduction"));
				hmInnerSal.put("SALARY_AMOUNT_TYPE", rs.getString("salary_head_amount_type"));
				hmInnerSal.put("SUB_SALARY_HEAD_ID", rs.getString("sub_salary_head_id"));
				hmInnerSal.put("SALARY_HEAD_AMOUNT", rs.getString("salary_head_amount"));

				hmSalaryDetails.put(rs.getString("salary_head_id"), hmInnerSal);

				hmSalaryEarningDeduction.put(rs.getString("salary_head_id"), rs.getString("earning_deduction"));
				hmSalaryType.put(rs.getString("salary_head_id"), rs.getString("salary_type"));
			}
			rs.close();
			pst.close();

			/*
			 * Map<String,String> hmPaidSalary=new HashMap<String, String>();
			 * pst=con.prepareStatement(
			 * "select salary_head_id,sum(amount) as amount from payroll_generation where emp_id = ? "
			 * +
			 * " and paid_from>=? and paid_to<=? group by salary_head_id order by salary_head_id"
			 * ); pst.setInt(1, nEmpId); pst.setDate(2,
			 * uF.getDateFormat(startArrearDate, DATE_FORMAT)); pst.setDate(3,
			 * uF.getDateFormat(endArrearDate, DATE_FORMAT));
			 * rs=pst.executeQuery(); while(rs.next()){
			 * hmPaidSalary.put(rs.getString("salary_head_id"),
			 * rs.getString("amount")); }
			 * System.out.println("hmPaidSalary=======>"+hmPaidSalary);
			 */

			// pst =
			// con.prepareStatement("select * from (	select *, 0 as aa from emp_salary_details where emp_id = ?	and effective_date = (select max(effective_date) from emp_salary_details where emp_id =? and effective_date <= ? and is_approved=true)  and salary_head_id in ("+DA1+", "+GROSS+") order by earning_deduction desc, salary_head_id, emp_salary_id ) ac1 union  select * from (select *, 1 as aa from emp_salary_details where emp_id = ? and effective_date = (select max(effective_date) from emp_salary_details where emp_id =? and effective_date <= ? and is_approved=true)  and salary_head_id not in ("+TDS+","+DA1+", "+GROSS+") and is_approved=true  order by earning_deduction desc, salary_head_id, emp_salary_id ) ac union (  select *, 2 as aa from emp_salary_details where emp_id = ? and effective_date = (select max(effective_date)  from emp_salary_details where emp_id =? and effective_date <= ? and is_approved=true) and salary_head_id in ("+TDS+") order by earning_deduction desc, salary_head_id, emp_salary_id	) order by aa, earning_deduction desc, salary_head_id, emp_salary_id");
			pst = con
					.prepareStatement("select * from (	select *, 0 as aa from emp_salary_details where emp_id =? and effective_date = (select max(effective_date) from emp_salary_details where emp_id =?  and effective_date <= ? and is_approved=true and salary_head_id in (select salary_head_id from salary_details where level_id=-1)) and salary_head_id in ("
							+ DA1
							+ ", "
							+ GROSS
							+ ") and salary_head_id in (select salary_head_id from salary_details where level_id=-1) order by earning_deduction desc, salary_head_id, emp_salary_id ) ac1 union  select * from (select *, 1 as aa from emp_salary_details where emp_id = ? and effective_date = (select max(effective_date) from emp_salary_details where emp_id =? and effective_date <=? and is_approved=true and salary_head_id in (select salary_head_id from salary_details where level_id=-1)) and salary_head_id not in ("
							+ TDS
							+ ","
							+ DA1
							+ ", "
							+ GROSS
							+ ") and is_approved=true and salary_head_id in (select salary_head_id from salary_details where level_id=-1)  order by earning_deduction desc, salary_head_id, emp_salary_id ) ac union (select *, 2 as aa from emp_salary_details where emp_id = ? and effective_date = (select max(effective_date) from emp_salary_details where emp_id =? and effective_date <= ? and is_approved=true and salary_head_id in (select salary_head_id from salary_details where level_id=-1)) and salary_head_id in ("
							+ TDS
							+ ") and salary_head_id in (select salary_head_id from salary_details where level_id=-1) order by earning_deduction desc, salary_head_id, emp_salary_id) order by aa, earning_deduction desc, salary_head_id, emp_salary_id");
			pst.setInt(1, nEmpId);
			pst.setInt(2, nEmpId);
			pst.setDate(3, uF.getDateFormat(currArr[1], DATE_FORMAT));
			pst.setInt(4, nEmpId);
			pst.setInt(5, nEmpId);
			pst.setDate(6, uF.getDateFormat(currArr[1], DATE_FORMAT));
			pst.setInt(7, nEmpId);
			pst.setInt(8, nEmpId);
			pst.setDate(9, uF.getDateFormat(currArr[1], DATE_FORMAT));
			rs = pst.executeQuery();
			// System.out.println("pst========>"+pst);
			// log.debug("pst====>" + pst);
			double dblBasicDA = 0;
			boolean isGross = false;
			boolean isHRAll = false;
			List<String> salaryIdList = new ArrayList<String>();
			while (rs.next()) {
				Map<String, String> hmSalaryInner = new HashMap<String, String>();
				Map<String, String> hmInner = new HashMap<String, String>();
				double dblAmount = 0;

				if (!rs.getBoolean("isdisplay")) {
					continue;
				}

				String strSalaryHeadId = rs.getString("salary_head_id");
				String strEarningDeduction = hmSalaryEarningDeduction.get(rs.getString("salary_head_id"));
				String strSalaryType = hmSalaryType.get(rs.getString("salary_head_id"));

				hmInner.put("SALARY_TYPE", strSalaryType);
				hmInner.put("IS_DISPLAY", "" + rs.getBoolean("isdisplay"));

				if (!salaryIdList.contains(rs.getString("salary_head_id"))) {
					salaryIdList.add(rs.getString("salary_head_id"));
				}

				if (uF.parseToInt(strSalaryHeadId) == GROSS) {
					isGross = true;
				}

				isHRAll = false;
				if (uF.parseToInt(strSalaryHeadId) == 211) {
					isHRAll = true;
				}

				String strAmount = rs.getString("amount");
				dblAmount = uF.parseToDouble(strAmount);

				if (dblIncrementBasic > 0 && (uF.parseToInt(strSalaryHeadId) == BASIC || uF.parseToInt(strSalaryHeadId) == GROSS)) {
					dblAmount = dblAmount + dblIncrementBasic;
				}

				if (!isGross && isHRAll) {
					dblBasicDA = dblAmount;
				}

				if (!isGross && (uF.parseToInt(strSalaryHeadId) == BASIC || uF.parseToInt(strSalaryHeadId) == DA || uF.parseToInt(strSalaryHeadId) == DA1)) {
					dblBasicDA += dblAmount;
				}

				if (uF.parseToInt(strSalaryHeadId) == GROSS) {
					dblBasicDA = dblAmount;
				}

				Map<String, String> hmInnerSal = hmSalaryDetails.get(strSalaryHeadId);
				if (hmInnerSal == null)
					hmInnerSal = new HashMap<String, String>();

				String strSubSalAmount = hmInnerSal.get("SALARY_HEAD_AMOUNT");
				String strSubSalAmountType = hmInnerSal.get("SALARY_AMOUNT_TYPE");
				String strSubSalId = hmInnerSal.get("SUB_SALARY_HEAD_ID");

				// boolean isFixed = false;
				if (strSubSalAmountType != null && strSubSalAmountType.equalsIgnoreCase("P")) {

					Map<String, String> hmEmpSalaryInner = hmSalaryHeadMap.get(strSubSalId);

					if (hmEmpSalaryInner == null)
						hmEmpSalaryInner = new HashMap<String, String>();
					String strEmpSalAmount = hmEmpSalaryInner.get("AMOUNT");

					if ((uF.parseToInt(strSubSalId) == BASIC || uF.parseToInt(strSubSalId) == GROSS)
							&& (uF.parseToInt(strSalaryHeadId) != DA && uF.parseToInt(strSalaryHeadId) != DA1)) {
						strEmpSalAmount = dblBasicDA + "";
					}

					double dblSalAmount = uF.parseToDouble(strEmpSalAmount);
					double dblSubSalAmount = uF.parseToDouble(strSubSalAmount);

					double dblTotalAmount = dblSalAmount * dblSubSalAmount / 100;

					if (dblIncrementDA > 0 && (uF.parseToInt(strSalaryHeadId) == DA || uF.parseToInt(strSalaryHeadId) == DA1)) {
						dblTotalAmount = dblTotalAmount + dblIncrementDA;
					}

					if (strSalaryType != null && strSalaryType.equalsIgnoreCase("F")) {
						dblAmount = dblTotalAmount;
					} else if (strSalaryType != null && strSalaryType.equalsIgnoreCase("D")) {
						dblAmount = dblTotalAmount * dblPresent;
					} else {
						dblAmount = dblTotalAmount * (dblPresent / nTotalNumberOfDays);
					}

					/**
					 * ----- Customised for Lift and Shift ---- Policy of HRA =
					 * 10% (Basic + DA) or 500 whichever is less 29/07/2013 --
					 * Vipin
					 */

					/*
					 * if(dblAmount>=500 && uF.parseToInt(strSalaryHeadId) ==
					 * HRA){ dblAmount = 500; }
					 * if(uF.parseToInt(strSalaryHeadId) == HRA){
					 * dblAmount=Math.round(dblAmount); }
					 */

					hmInner.put("AMOUNT", uF.formatIntoTwoDecimal(dblAmount));

					if (uF.parseToInt(strSalaryHeadId) == BREAKS) {
						dblAmount = dblTotalAmount * dblBreaks;
						hmInner.put("AMOUNT", uF.formatIntoTwoDecimal(dblAmount));
					}

				} else if (uF.parseToInt(strSalaryHeadId) != BASIC && uF.parseToInt(strSalaryHeadId) != GROSS && uF.parseToInt(strSalaryHeadId) != DA
						&& uF.parseToInt(strSalaryHeadId) != DA1 && !"D".equalsIgnoreCase(rs.getString("earning_deduction"))) {

					if (strSubSalAmountType != null && strSubSalAmountType.equalsIgnoreCase("P") && uF.parseToInt(strSubSalId) == BASIC) {
						if (strSalaryType != null && strSalaryType.equalsIgnoreCase("F")) {
							dblAmount = dblBasicDA;
						} else if (strSalaryType != null && strSalaryType.equalsIgnoreCase("D")) {
							dblAmount = dblBasicDA * dblPresent;
						} else {
							dblAmount = dblBasicDA * (dblPresent / nTotalNumberOfDays);
						}
					} else {
						if (strSalaryType != null && strSalaryType.equalsIgnoreCase("F")) {
							// dblAmount = dblAmount;
						} else if (strSalaryType != null && strSalaryType.equalsIgnoreCase("D")) {
							dblAmount = dblAmount * dblPresent;
						} else {
							dblAmount = dblAmount * (dblPresent / nTotalNumberOfDays);
						}
					}

					hmInner.put("AMOUNT", uF.formatIntoTwoDecimal(dblAmount));
				} else {

					if (strSalaryType != null && strSalaryType.equalsIgnoreCase("F")) {
						// dblAmount = dblAmount;
					} else if (strSalaryType != null && strSalaryType.equalsIgnoreCase("D")) {
						dblAmount = dblAmount * dblPresent;
					} else {
						dblAmount = dblAmount * (dblPresent / nTotalNumberOfDays);
					}
					hmInner.put("AMOUNT", uF.formatIntoTwoDecimal(dblAmount));
				}

				hmInner.put("SALARY_HEAD_ID", strSalaryHeadId);
				// hmInner.put("EARNING_DEDUCTION", strEarningDeduction);
				hmInner.put("EARNING_DEDUCTION", rs.getString("earning_deduction"));

				hmSalaryHeadMap.put(strSalaryHeadId, hmInner);

				if (strEarningDeduction != null) {
					hmSalaryInner.put("EARNING_DEDUCTION", strEarningDeduction);
					hmSalaryInner.put("AMOUNT", dblAmount + "");
					hmSalaryHeadReCalculatedMap.put(strSalaryHeadId, hmSalaryInner);
				}

			}
			rs.close();
			pst.close();

			// System.out.println("hmSalaryHeadMap======>"+hmSalaryHeadMap);
			// System.out.println("hmSalaryHeadReCalculatedMap======>"+hmSalaryHeadReCalculatedMap);

			String salaryIds = "";
			for (int i = 0; salaryIdList != null && i < salaryIdList.size(); i++) {
				if (i == 0) {
					salaryIds = salaryIdList.get(i);
				} else {
					salaryIds += "," + salaryIdList.get(i);
				}
			}

			/*
			 * Calculate previous month salary *
			 */
			// Calendar calW = GregorianCalendar.getInstance();
			// calW.set(Calendar.DATE,
			// uF.parseToInt(uF.getDateFormat("26/11/2013", "dd/MM/yyyy",
			// "dd")));
			// calW.set(Calendar.MONTH,
			// uF.parseToInt(uF.getDateFormat("26/11/2013", "dd/MM/yyyy",
			// "MM"))-1);
			// calW.set(Calendar.YEAR,
			// uF.parseToInt(uF.getDateFormat("26/11/2013", "dd/MM/yyyy",
			// "yyyy")));
			// calW.add(Calendar.MONTH, -1);
			//
			// String strPrevMonthDate =
			// uF.getDateFormat(calW.get(Calendar.DAY_OF_MONTH)+"/"+(calW.get(Calendar.MONTH)+1)+"/"+calW.get(Calendar.YEAR),
			// "dd/MM/yyyy", "dd/MM/yyyy");
			//
			String[] arr = null;
			arr = CF.getPayCycleFromDate(con, uF.getDateFormat(endArrearDate, DATE_FORMAT, DATE_FORMAT), CF.getStrTimeZone(), CF, orgId);

			pst = con.prepareStatement("select *  from payroll_generation where emp_id=? and paid_from=? and paid_to=? and paycycle=? and salary_head_id in ("
					+ salaryIds + ") ");
			pst.setInt(1, nEmpId);
			pst.setDate(2, uF.getDateFormat(arr[0], DATE_FORMAT));
			pst.setDate(3, uF.getDateFormat(arr[1], DATE_FORMAT));
			pst.setInt(4, uF.parseToInt(arr[2]));
			rs = pst.executeQuery();
			// System.out.println("pst========>"+pst);
			// double dblBasicDA1 = 0;
			// boolean isGross1 = false;
			// boolean isHRAll1 = false;
			while (rs.next()) {
				Map<String, String> hmSalaryInner = new HashMap<String, String>();
				Map<String, String> hmInner = new HashMap<String, String>();

				String strSalaryHeadId = rs.getString("salary_head_id");
				String strEarningDeduction = hmSalaryEarningDeduction.get(rs.getString("salary_head_id"));
				String strSalaryType = hmSalaryType.get(rs.getString("salary_head_id"));

				hmInner.put("SALARY_TYPE", strSalaryType);
				hmInner.put("IS_DISPLAY", "true");
				hmInner.put("AMOUNT", rs.getString("amount"));
				hmInner.put("SALARY_HEAD_ID", strSalaryHeadId);
				hmInner.put("EARNING_DEDUCTION", rs.getString("earning_deduction"));

				hmPrevSalaryHeadMap.put(strSalaryHeadId, hmInner);

				if (strEarningDeduction != null) {
					hmSalaryInner.put("EARNING_DEDUCTION", strEarningDeduction);
					hmSalaryInner.put("AMOUNT", rs.getString("amount"));
					hmPrevSalaryHeadReCalculatedMap.put(strSalaryHeadId, hmSalaryInner);
				}

			}
			rs.close();
			pst.close();

			// System.out.println("hmPrevSalaryHeadMap======>"+hmPrevSalaryHeadMap);
			// System.out.println("hmPrevSalaryHeadReCalculatedMap======>"+hmPrevSalaryHeadReCalculatedMap);

			Iterator<String> it = hmSalaryHeadMap.keySet().iterator();

			while (it.hasNext()) {
				String salaryHeadId = it.next();
				Map<String, String> hmInner = hmSalaryHeadMap.get(salaryHeadId);
				// System.out.println("hmInner======>"+hmInner);

				Map<String, String> hmPrevInner = hmPrevSalaryHeadMap.get(salaryHeadId);
				if (hmPrevInner == null)
					hmPrevInner = new HashMap<String, String>();
				// System.out.println("hmPrevInner======>"+hmPrevInner);

				Map<String, String> hmArrearInner = new HashMap<String, String>();

				double dblAmount = uF.parseToDouble(hmInner.get("AMOUNT"));
				double dblPrevAmount = uF.parseToDouble(hmPrevInner.get("AMOUNT"));
				double dblArrearAmount = dblAmount - dblPrevAmount;
				dblArrearAmount = dblArrearAmount * monthCount;
				if (dblArrearAmount < 0) {
					dblArrearAmount = dblArrearAmount * -1;
				}
				hmArrearInner.put("IS_DISPLAY", hmInner.get("IS_DISPLAY"));
				hmArrearInner.put("SALARY_TYPE", hmInner.get("SALARY_TYPE"));
				hmArrearInner.put("SALARY_HEAD_ID", hmInner.get("SALARY_HEAD_ID"));
				hmArrearInner.put("EARNING_DEDUCTION", hmInner.get("EARNING_DEDUCTION"));
				hmArrearInner.put("AMOUNT", uF.formatIntoTwoDecimal(dblArrearAmount));

				hmArrearSalaryHeadMap.put(salaryHeadId, hmArrearInner);

			}

			// System.out.println("hmArrearSalaryHeadMap=====>"+hmArrearSalaryHeadMap);

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmArrearSalaryHeadMap;

	}

	public boolean getMaternityFrequency(Connection con, HttpServletRequest request, int nLevelId, int nEmpId, int nOrgId, int nLocationId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		UtilityFunctions uF = new UtilityFunctions();

		try {

			int totalMaternityTaken = 0;
			pst = con.prepareStatement("select count(*) as leavecnt from emp_leave_entry where emp_id=? and leave_type_id "
					+ "in(select leave_type_id from leave_type where is_maternity=true) group by emp_id ");
			pst.setInt(1, nEmpId);
			rs = pst.executeQuery();
			while (rs.next()) {
				totalMaternityTaken = uF.parseToInt(rs.getString("leavecnt"));
			}
			rs.close();
			pst.close();

			pst = con.prepareStatement("SELECT * FROM leave_type lt, emp_leave_type elt where is_maternity=true and lt.leave_type_id = elt.leave_type_id "
					+ " and level_id=? and lt.org_id=? and wlocation_id=? and effective_date =(select max(effective_date) from emp_leave_type "
					+ " where level_id = ?  and lt.org_id=? and wlocation_id=?  and is_compensatory = false ) and lt.is_compensatory = false ");
			// pst.setBoolean(1, true);
			// pst = con.prepareStatement(query.toString());
			pst.setInt(1, nLevelId);
			pst.setInt(2, nOrgId);
			pst.setInt(3, nLocationId);
			pst.setInt(4, nLevelId);
			pst.setInt(5, nOrgId);
			pst.setInt(6, nLocationId);
			// rs = pst.executeQuery();
			rs = pst.executeQuery();

			StringBuilder sbDocumentCondition = new StringBuilder();
			int count = 0;
			while (rs.next()) {
				count += uF.parseToInt(rs.getString("maternity_type_frequency"));
			}
			rs.close();
			pst.close();

			if (count <= totalMaternityTaken) {
				return false;
			}

			request.setAttribute("idDocCondition", sbDocumentCondition.toString());

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

		return true;
	}

	public String[] getCurrentPayCycleByOrg(Connection con, String strTimeZone, CommonFunctions CF, String f_org) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		UtilityFunctions uF = new UtilityFunctions();
		String[] strPayCycleDate = new String[3];

		try {

			String startDate = null;
			String strDisplayPaycycle = null;
			String strPaycycleDuration = null;

			pst = con
					.prepareStatement("select max (paycycle) as paycycle from payroll_generation where emp_id in (select emp_id from employee_official_details where org_id = ?)");
			pst.setInt(1, uF.parseToInt(f_org));
			rs = pst.executeQuery();
			int nPaidMaxPaycycle = 0;
			while (rs.next()) {
				nPaidMaxPaycycle = rs.getInt("paycycle");
			}
			rs.close();
			pst.close();
			nPaidMaxPaycycle = nPaidMaxPaycycle + 1;

			pst = con.prepareStatement("select * from org_details where org_id=? ");
			pst.setInt(1, uF.parseToInt(f_org));
			rs = pst.executeQuery();

			while (rs.next()) {
				startDate = rs.getString("start_paycycle");
				strDisplayPaycycle = rs.getString("display_paycycle");
				strPaycycleDuration = rs.getString("duration_paycycle");
			}
			rs.close();
			pst.close();

			String[] arrDisplayPAycycle = null;
			int minCycle = 0;
			int maxCycle = 0;
			if (strDisplayPaycycle != null) {
				arrDisplayPAycycle = strDisplayPaycycle.split("-");
				minCycle = uF.parseToInt(arrDisplayPAycycle[0]);
				maxCycle = uF.parseToInt(arrDisplayPAycycle[1]);
			}

			Calendar calCurrent = GregorianCalendar.getInstance(TimeZone.getTimeZone((strTimeZone)));
			Calendar cal = GregorianCalendar.getInstance(TimeZone.getTimeZone(strTimeZone));
			cal.set(Calendar.DAY_OF_MONTH, uF.parseToInt(uF.getDateFormat(startDate, DBDATE, "dd")));
			cal.set(Calendar.MONTH, uF.parseToInt(uF.getDateFormat(startDate, DBDATE, "MM")) - 1);
			cal.set(Calendar.YEAR, uF.parseToInt(uF.getDateFormat(startDate, DBDATE, "yyyy")));

			StringBuilder sb = new StringBuilder();
			int nPayCycle = 0;

			int nDurationCount = 0;
			String dt1 = null;
			String dt2 = null;

			// java.util.Date strCurrentDate = calCurrent.getTime();
			java.util.Date strCurrentDate = uF.getDateFormatUtil(((calCurrent.get(Calendar.DAY_OF_MONTH) < 10)
					? "0" + calCurrent.get(Calendar.DAY_OF_MONTH)
					: calCurrent.get(Calendar.DAY_OF_MONTH))
					+ "/"
					+ (((calCurrent.get(Calendar.MONTH) + 1) < 10) ? "0" + (calCurrent.get(Calendar.MONTH) + 1) : (calCurrent.get(Calendar.MONTH) + 1))
					+ "/"
					+ calCurrent.get(Calendar.YEAR), DATE_FORMAT);

			java.util.Date strCurrentPayCycleD1 = null;
			java.util.Date strCurrentPayCycleD2 = null;

			while (true) {
				sb = new StringBuilder();
				nPayCycle++;

				if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("M")) {
					nDurationCount = cal.getActualMaximum(Calendar.DAY_OF_MONTH) - 1;
				} else if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("F")) {
					nDurationCount = 15 - 1;
					if (cal.get(Calendar.DAY_OF_MONTH) == 16) {
						int nActual = cal.getActualMaximum(Calendar.DAY_OF_MONTH);
						nDurationCount = nActual - 15 - 1;
					}
				} else if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("BW")) {
					nDurationCount = 14 - 1;
				} else if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("W")) {
					nDurationCount = 7 - 1;
				} else {
					nDurationCount = cal.getMaximum(Calendar.DAY_OF_MONTH) - 1;
				}

				dt1 = ((cal.get(Calendar.DAY_OF_MONTH) < 10) ? "0" + cal.get(Calendar.DAY_OF_MONTH) : cal.get(Calendar.DAY_OF_MONTH)) + "/"
						+ (((cal.get(Calendar.MONTH) + 1) < 10) ? "0" + (cal.get(Calendar.MONTH) + 1) : (cal.get(Calendar.MONTH) + 1)) + "/"
						+ cal.get(Calendar.YEAR);
				cal.add(Calendar.DAY_OF_MONTH, nDurationCount);
				dt2 = ((cal.get(Calendar.DAY_OF_MONTH) < 10) ? "0" + cal.get(Calendar.DAY_OF_MONTH) : cal.get(Calendar.DAY_OF_MONTH)) + "/"
						+ (((cal.get(Calendar.MONTH) + 1) < 10) ? "0" + (cal.get(Calendar.MONTH) + 1) : (cal.get(Calendar.MONTH) + 1)) + "/"
						+ cal.get(Calendar.YEAR);

				if (nPayCycle < minCycle) {
					cal.add(Calendar.DAY_OF_MONTH, 1);
					continue;
				}

				sb.append("Pay Cycle " + nPayCycle + ", " + dt1 + " - " + dt2);

				strCurrentPayCycleD1 = uF.getDateFormatUtil(dt1, DATE_FORMAT);
				strCurrentPayCycleD2 = uF.getDateFormatUtil(dt2, DATE_FORMAT);

				String strCurrDate = uF.getDateFormatUtil(strCurrentDate, DATE_FORMAT);
				int nCurrMonth = uF.parseToInt(uF.getDateFormat(strCurrDate, DATE_FORMAT, "MM"));
				int nPaycycleEndMonth = uF.parseToInt(uF.getDateFormat(dt2, DATE_FORMAT, "MM"));

				Map<String, String> hmFeatureStatus = getFeatureStatusMap(con);
				if (hmFeatureStatus != null && hmFeatureStatus.get(F_SELECT_PREV_PAYCYCLE) != null
						&& uF.parseToBoolean(hmFeatureStatus.get(F_SELECT_PREV_PAYCYCLE))) {
					if (strCurrentDate.after(strCurrentPayCycleD1) && strCurrentDate.after(strCurrentPayCycleD2) && nPayCycle == nPaidMaxPaycycle) { // &&
																																						// nCurrMonth
																																						// ==
																																						// nPaycycleEndMonth
						strPayCycleDate[0] = dt1;
						strPayCycleDate[1] = dt2;
						strPayCycleDate[2] = nPayCycle + "";
					} else if (strCurrentDate.equals(strCurrentPayCycleD1) || strCurrentDate.equals(strCurrentPayCycleD2)
							|| (strCurrentDate.after(strCurrentPayCycleD1) && strCurrentDate.before(strCurrentPayCycleD2))) {
						strPayCycleDate[0] = dt1;
						strPayCycleDate[1] = dt2;
						strPayCycleDate[2] = nPayCycle + "";
					}
				} else {
					if (strCurrentDate.equals(strCurrentPayCycleD1) || strCurrentDate.equals(strCurrentPayCycleD2)
							|| (strCurrentDate.after(strCurrentPayCycleD1) && strCurrentDate.before(strCurrentPayCycleD2))) {
						strPayCycleDate[0] = dt1;
						strPayCycleDate[1] = dt2;
						strPayCycleDate[2] = nPayCycle + "";
					}
				}
				cal.add(Calendar.DAY_OF_MONTH, 1);
				if (hmFeatureStatus != null && hmFeatureStatus.get(F_SELECT_PREV_PAYCYCLE) != null
						&& uF.parseToBoolean(hmFeatureStatus.get(F_SELECT_PREV_PAYCYCLE))) {
					if (nPayCycle >= maxCycle || (nPayCycle >= nPaidMaxPaycycle)) { // &&
																					// nCurrMonth
																					// ==
																					// nPaycycleEndMonth
						break;
					}
				} else {
					if (nPayCycle >= maxCycle) {
						break;
					}
				}

			}

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return strPayCycleDate;

	}

	public String[] getCurrentPayCycleUsingDurationByOrg(Connection con, String strTimeZone, CommonFunctions CF, String f_org, String paycycleDuration,
			HttpServletRequest request) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		UtilityFunctions uF = new UtilityFunctions();
		String[] strPayCycleDate = new String[3];

		try {

			String startDate = null;
			String strDisplayPaycycle = null;
			String strPaycycleDuration = null;

			pst = con
					.prepareStatement("select max (paycycle) as paycycle from payroll_generation where emp_id in (select emp_id from employee_official_details where org_id = ?)");
			pst.setInt(1, uF.parseToInt(f_org));
			rs = pst.executeQuery();
			int nPaidMaxPaycycle = 0;
			while (rs.next()) {
				nPaidMaxPaycycle = rs.getInt("paycycle");
			}
			rs.close();
			pst.close();
			nPaidMaxPaycycle = nPaidMaxPaycycle + 1;

			pst = con.prepareStatement("select * from org_details where org_id=? ");
			pst.setInt(1, uF.parseToInt(f_org));
			rs = pst.executeQuery();

			while (rs.next()) {
				startDate = rs.getString("start_paycycle");
				strDisplayPaycycle = rs.getString("display_paycycle");
				strPaycycleDuration = rs.getString("duration_paycycle");
			}
			rs.close();
			pst.close();

			if (paycycleDuration != null && !paycycleDuration.trim().equals("") && !paycycleDuration.trim().equalsIgnoreCase("NULL")) {
				strPaycycleDuration = paycycleDuration;
			}

			String[] arrDisplayPAycycle = null;
			int minCycle = 0;
			int maxCycle = 0;
			if (strDisplayPaycycle != null) {
				arrDisplayPAycycle = strDisplayPaycycle.split("-");
				minCycle = uF.parseToInt(arrDisplayPAycycle[0]);
				maxCycle = uF.parseToInt(arrDisplayPAycycle[1]);
			}

			Calendar calCurrent = GregorianCalendar.getInstance(TimeZone.getTimeZone((strTimeZone)));
			Calendar cal = GregorianCalendar.getInstance(TimeZone.getTimeZone(strTimeZone));
			cal.set(Calendar.DAY_OF_MONTH, uF.parseToInt(uF.getDateFormat(startDate, DBDATE, "dd")));
			cal.set(Calendar.MONTH, uF.parseToInt(uF.getDateFormat(startDate, DBDATE, "MM")) - 1);
			cal.set(Calendar.YEAR, uF.parseToInt(uF.getDateFormat(startDate, DBDATE, "yyyy")));

			StringBuilder sb = new StringBuilder();
			int nPayCycle = 0;

			int nDurationCount = 0;
			String dt1 = null;
			String dt2 = null;

			// java.util.Date strCurrentDate = calCurrent.getTime();
			java.util.Date strCurrentDate = uF.getDateFormatUtil(((calCurrent.get(Calendar.DAY_OF_MONTH) < 10)
					? "0" + calCurrent.get(Calendar.DAY_OF_MONTH)
					: calCurrent.get(Calendar.DAY_OF_MONTH))
					+ "/"
					+ (((calCurrent.get(Calendar.MONTH) + 1) < 10) ? "0" + (calCurrent.get(Calendar.MONTH) + 1) : (calCurrent.get(Calendar.MONTH) + 1))
					+ "/"
					+ calCurrent.get(Calendar.YEAR), DATE_FORMAT);

			java.util.Date strCurrentPayCycleD1 = null;
			java.util.Date strCurrentPayCycleD2 = null;

			while (true) {
				sb = new StringBuilder();
				nPayCycle++;

				if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("M")) {
					nDurationCount = cal.getActualMaximum(Calendar.DAY_OF_MONTH) - 1;
				} else if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("F")) {
					nDurationCount = 15 - 1;
					if (cal.get(Calendar.DAY_OF_MONTH) == 16) {
						int nActual = cal.getActualMaximum(Calendar.DAY_OF_MONTH);
						nDurationCount = nActual - 15 - 1;
					}
				} else if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("BW")) {
					nDurationCount = 14 - 1;
				} else if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("W")) {
					nDurationCount = 7 - 1;
				} else {
					nDurationCount = cal.getMaximum(Calendar.DAY_OF_MONTH) - 1;
				}

				dt1 = ((cal.get(Calendar.DAY_OF_MONTH) < 10) ? "0" + cal.get(Calendar.DAY_OF_MONTH) : cal.get(Calendar.DAY_OF_MONTH)) + "/"
						+ (((cal.get(Calendar.MONTH) + 1) < 10) ? "0" + (cal.get(Calendar.MONTH) + 1) : (cal.get(Calendar.MONTH) + 1)) + "/"
						+ cal.get(Calendar.YEAR);
				cal.add(Calendar.DAY_OF_MONTH, nDurationCount);
				dt2 = ((cal.get(Calendar.DAY_OF_MONTH) < 10) ? "0" + cal.get(Calendar.DAY_OF_MONTH) : cal.get(Calendar.DAY_OF_MONTH)) + "/"
						+ (((cal.get(Calendar.MONTH) + 1) < 10) ? "0" + (cal.get(Calendar.MONTH) + 1) : (cal.get(Calendar.MONTH) + 1)) + "/"
						+ cal.get(Calendar.YEAR);

				if (nPayCycle < minCycle) {
					cal.add(Calendar.DAY_OF_MONTH, 1);
					continue;
				}

				sb.append("Pay Cycle " + nPayCycle + ", " + dt1 + " - " + dt2);

				strCurrentPayCycleD1 = uF.getDateFormatUtil(dt1, DATE_FORMAT);
				strCurrentPayCycleD2 = uF.getDateFormatUtil(dt2, DATE_FORMAT);

				String strCurrDate = uF.getDateFormatUtil(strCurrentDate, DATE_FORMAT);
				int nCurrMonth = uF.parseToInt(uF.getDateFormat(strCurrDate, DATE_FORMAT, "MM"));
				int nPaycycleEndMonth = uF.parseToInt(uF.getDateFormat(dt2, DATE_FORMAT, "MM"));

				Map<String, String> hmFeatureStatus = getFeatureStatusMap(con, request);
				if (hmFeatureStatus != null && hmFeatureStatus.get(F_SELECT_PREV_PAYCYCLE) != null
						&& uF.parseToBoolean(hmFeatureStatus.get(F_SELECT_PREV_PAYCYCLE))) {
					if (strCurrentDate.after(strCurrentPayCycleD1) && strCurrentDate.after(strCurrentPayCycleD2) && nPayCycle == nPaidMaxPaycycle) { // &&
																																						// nCurrMonth
																																						// ==
																																						// nPaycycleEndMonth
						strPayCycleDate[0] = dt1;
						strPayCycleDate[1] = dt2;
						strPayCycleDate[2] = nPayCycle + "";
					} else if (strCurrentDate.equals(strCurrentPayCycleD1) || strCurrentDate.equals(strCurrentPayCycleD2)
							|| (strCurrentDate.after(strCurrentPayCycleD1) && strCurrentDate.before(strCurrentPayCycleD2))) {
						strPayCycleDate[0] = dt1;
						strPayCycleDate[1] = dt2;
						strPayCycleDate[2] = nPayCycle + "";
					}
				} else {
					if (strCurrentDate.equals(strCurrentPayCycleD1) || strCurrentDate.equals(strCurrentPayCycleD2)
							|| (strCurrentDate.after(strCurrentPayCycleD1) && strCurrentDate.before(strCurrentPayCycleD2))) {
						strPayCycleDate[0] = dt1;
						strPayCycleDate[1] = dt2;
						strPayCycleDate[2] = nPayCycle + "";
					}
				}
				cal.add(Calendar.DAY_OF_MONTH, 1);
				if (hmFeatureStatus != null && hmFeatureStatus.get(F_SELECT_PREV_PAYCYCLE) != null
						&& uF.parseToBoolean(hmFeatureStatus.get(F_SELECT_PREV_PAYCYCLE))) {
					if (nPayCycle >= maxCycle || (nPayCycle >= nPaidMaxPaycycle)) { // &&
																					// nCurrMonth
																					// ==
																					// nPaycycleEndMonth
						break;
					}
				} else {
					if (nPayCycle >= maxCycle) {
						break;
					}
				}

			}

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return strPayCycleDate;

	}

	public String[] getPrevPayCycleByOrg(Connection con, String strDate, String strTimeZone, com.konnect.jpms.util.CommonFunctions CF, String f_org) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		UtilityFunctions uF = new UtilityFunctions();
		String[] strPayCycleDate = new String[3];

		try {

			String startDate = null;
			String strDisplayPaycycle = null;
			String strPaycycleDuration = null;

			pst = con.prepareStatement("select * from org_details where org_id=?");
			pst.setInt(1, uF.parseToInt(f_org));
			rs = pst.executeQuery();

			while (rs.next()) {
				startDate = rs.getString("start_paycycle");
				strDisplayPaycycle = rs.getString("display_paycycle");
				strPaycycleDuration = rs.getString("duration_paycycle");
			}
			rs.close();
			pst.close();

			String[] arrDisplayPAycycle = null;
			int minCycle = 0;
			int maxCycle = 0;
			if (strDisplayPaycycle != null) {
				arrDisplayPAycycle = strDisplayPaycycle.split("-");
				minCycle = uF.parseToInt(arrDisplayPAycycle[0]);
				maxCycle = uF.parseToInt(arrDisplayPAycycle[1]);
			}

//			System.out.println("strDate ===>> " + strDate);
			Calendar calCurrent = GregorianCalendar.getInstance(TimeZone.getTimeZone((strTimeZone)));
			calCurrent.set(Calendar.DAY_OF_MONTH, uF.parseToInt(uF.getDateFormat(strDate, DATE_FORMAT, "dd")));
			calCurrent.set(Calendar.MONTH, uF.parseToInt(uF.getDateFormat(strDate, DATE_FORMAT, "MM")) - 1);
			calCurrent.set(Calendar.YEAR, uF.parseToInt(uF.getDateFormat(strDate, DATE_FORMAT, "yyyy")));
//			System.out.println("Prev calCurrent ===>> " + calCurrent);
//			System.out.println("calCurrent.get(Calendar.DAY_OF_MONTH) ===>> " + calCurrent.get(Calendar.DAY_OF_MONTH));
//			System.out.println("calCurrent.get(Calendar.MONTH) ===>> " + calCurrent.get(Calendar.MONTH));
//			System.out.println("calCurrent.get(Calendar.YEAR) ===>> " + calCurrent.get(Calendar.YEAR));
			calCurrent.add(Calendar.DAY_OF_MONTH, -1);
//			System.out.println("1 -- calCurrent.get(Calendar.DAY_OF_MONTH) ===>> " + calCurrent.get(Calendar.DAY_OF_MONTH));
//			System.out.println("1 -- calCurrent ===>> " + calCurrent);
			
			Calendar cal = GregorianCalendar.getInstance(TimeZone.getTimeZone(strTimeZone));
			cal.set(Calendar.DAY_OF_MONTH, uF.parseToInt(uF.getDateFormat(startDate, DBDATE, "dd")));
			cal.set(Calendar.MONTH, uF.parseToInt(uF.getDateFormat(startDate, DBDATE, "MM")) - 1);
			cal.set(Calendar.YEAR, uF.parseToInt(uF.getDateFormat(startDate, DBDATE, "yyyy")));

			StringBuilder sb = new StringBuilder();
			int nPayCycle = 0;

			int nDurationCount = 0;
			String dt1 = null;
			String dt2 = null;

			// List<String> alInner = new ArrayList<String>();
			// java.util.Date strCurrentDate = calCurrent.getTime();
			java.util.Date strCurrentDate = uF.getDateFormatUtil(
					((calCurrent.get(Calendar.DAY_OF_MONTH) < 10) ? "0" + calCurrent.get(Calendar.DAY_OF_MONTH) : calCurrent.get(Calendar.DAY_OF_MONTH)) + "/"
							+ (((calCurrent.get(Calendar.MONTH)) < 10) ? "0" + (calCurrent.get(Calendar.MONTH)) : (calCurrent.get(Calendar.MONTH))) + "/"
							+ calCurrent.get(Calendar.YEAR), DATE_FORMAT);
			java.util.Date strCurrentPayCycleD1 = null;
			java.util.Date strCurrentPayCycleD2 = null;
//			System.out.println("strCurrentDate ===>>>> " + strCurrentDate);
			
			while (true) {
				sb = new StringBuilder();
				nPayCycle++;

				if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("M")) {
					nDurationCount = cal.getActualMaximum(Calendar.DAY_OF_MONTH) - 1;
				} else if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("F")) {
					nDurationCount = 15 - 1;
					if (cal.get(Calendar.DAY_OF_MONTH) == 16) {
						int nActual = cal.getActualMaximum(Calendar.DAY_OF_MONTH);
						nDurationCount = nActual - 15 - 1;
					}
				} else if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("BW")) {
					nDurationCount = 14 - 1;
				} else if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("W")) {
					nDurationCount = 7 - 1;
				} else {
					nDurationCount = cal.getMaximum(Calendar.DAY_OF_MONTH) - 1;
				}

				dt1 = ((cal.get(Calendar.DAY_OF_MONTH) < 10) ? "0" + cal.get(Calendar.DAY_OF_MONTH) : cal.get(Calendar.DAY_OF_MONTH)) + "/"
						+ (((cal.get(Calendar.MONTH) + 1) < 10) ? "0" + (cal.get(Calendar.MONTH) + 1) : (cal.get(Calendar.MONTH) + 1)) + "/"
						+ cal.get(Calendar.YEAR);
				cal.add(Calendar.DAY_OF_MONTH, nDurationCount);
				dt2 = ((cal.get(Calendar.DAY_OF_MONTH) < 10) ? "0" + cal.get(Calendar.DAY_OF_MONTH) : cal.get(Calendar.DAY_OF_MONTH)) + "/"
						+ (((cal.get(Calendar.MONTH) + 1) < 10) ? "0" + (cal.get(Calendar.MONTH) + 1) : (cal.get(Calendar.MONTH) + 1)) + "/"
						+ cal.get(Calendar.YEAR);

				if (nPayCycle < minCycle) {
					cal.add(Calendar.DAY_OF_MONTH, 1);
					continue;
				}

				sb.append("Pay Cycle " + nPayCycle + ", " + dt1 + " - " + dt2);

				strCurrentPayCycleD1 = uF.getDateFormatUtil(dt1, DATE_FORMAT);
				strCurrentPayCycleD2 = uF.getDateFormatUtil(dt2, DATE_FORMAT);

				log.debug("nPayCycle===>" + nPayCycle);

				if (strCurrentDate.equals(strCurrentPayCycleD1) || strCurrentDate.equals(strCurrentPayCycleD2)
						|| (strCurrentDate.after(strCurrentPayCycleD1) && strCurrentDate.before(strCurrentPayCycleD2))) {
					strPayCycleDate[0] = dt1;
					strPayCycleDate[1] = dt2;
					strPayCycleDate[2] = nPayCycle + "";

					log.debug("nPayCycle= E ==>" + nPayCycle);
				}

				cal.add(Calendar.DAY_OF_MONTH, 1);

				if (nPayCycle >= maxCycle) {
					break;
				}

			}

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return strPayCycleDate;
	}

	public String[] getNextPayCycleByOrg(Connection con, String strDate, String strTimeZone, com.konnect.jpms.util.CommonFunctions CF, String f_org) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		UtilityFunctions uF = new UtilityFunctions();
		String[] strPayCycleDate = new String[3];

		try {

			String startDate = null;
			String strDisplayPaycycle = null;
			String strPaycycleDuration = null;

			pst = con.prepareStatement("select * from org_details where org_id=?");
			pst.setInt(1, uF.parseToInt(f_org));
//			System.out.println("CF/13912--pst="+pst);
			rs = pst.executeQuery();

			while (rs.next()) {
				startDate = rs.getString("start_paycycle");
				strDisplayPaycycle = rs.getString("display_paycycle");
				strPaycycleDuration = rs.getString("duration_paycycle");
			}
			rs.close();
			pst.close();

			String[] arrDisplayPAycycle = null;
			int minCycle = 0;
			int maxCycle = 0;
			if (strDisplayPaycycle != null) {
				arrDisplayPAycycle = strDisplayPaycycle.split("-");
				minCycle = uF.parseToInt(arrDisplayPAycycle[0]);
				maxCycle = uF.parseToInt(arrDisplayPAycycle[1]);
			}

			Calendar calCurrent = GregorianCalendar.getInstance(TimeZone.getTimeZone((strTimeZone)));
			calCurrent.set(Calendar.DAY_OF_MONTH, uF.parseToInt(uF.getDateFormat(strDate, DATE_FORMAT, "dd")));
			calCurrent.set(Calendar.MONTH, uF.parseToInt(uF.getDateFormat(strDate, DATE_FORMAT, "MM")));
			calCurrent.set(Calendar.YEAR, uF.parseToInt(uF.getDateFormat(strDate, DATE_FORMAT, "yyyy")));

			calCurrent.add(Calendar.DAY_OF_MONTH, -1);

			Calendar cal = GregorianCalendar.getInstance(TimeZone.getTimeZone(strTimeZone));
			cal.set(Calendar.DAY_OF_MONTH, uF.parseToInt(uF.getDateFormat(startDate, DBDATE, "dd")));
			cal.set(Calendar.MONTH, uF.parseToInt(uF.getDateFormat(startDate, DBDATE, "MM")) - 1);
			cal.set(Calendar.YEAR, uF.parseToInt(uF.getDateFormat(startDate, DBDATE, "yyyy")));

			StringBuilder sb = new StringBuilder();
			int nPayCycle = 0;

			int nDurationCount = 0;
			String dt1 = null;
			String dt2 = null;

			// List<String> alInner = new ArrayList<String>();
			// java.util.Date strCurrentDate = calCurrent.getTime();
			java.util.Date strCurrentDate = uF.getDateFormatUtil(((calCurrent.get(Calendar.DAY_OF_MONTH) < 10)
					? "0" + calCurrent.get(Calendar.DAY_OF_MONTH)
					: calCurrent.get(Calendar.DAY_OF_MONTH))
					+ "/"
					+ (((calCurrent.get(Calendar.MONTH) + 1) < 10) ? "0" + (calCurrent.get(Calendar.MONTH) + 1) : (calCurrent.get(Calendar.MONTH) + 1))
					+ "/"
					+ calCurrent.get(Calendar.YEAR), DATE_FORMAT);
			
			
			java.util.Date strCurrentPayCycleD1 = null;
			java.util.Date strCurrentPayCycleD2 = null;

			while (true) {
				sb = new StringBuilder();
				nPayCycle++;

				if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("M")) {
					nDurationCount = cal.getActualMaximum(Calendar.DAY_OF_MONTH) - 1;
				} else if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("F")) {
					nDurationCount = 15 - 1;
					if (cal.get(Calendar.DAY_OF_MONTH) == 16) {
						int nActual = cal.getActualMaximum(Calendar.DAY_OF_MONTH);
						nDurationCount = nActual - 15 - 1;
					}
				} else if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("BW")) {
					nDurationCount = 14 - 1;
				} else if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("W")) {
					nDurationCount = 7 - 1;
				} else {
					nDurationCount = cal.getMaximum(Calendar.DAY_OF_MONTH) - 1;
				}

				dt1 = ((cal.get(Calendar.DAY_OF_MONTH) < 10) ? "0" + cal.get(Calendar.DAY_OF_MONTH) : cal.get(Calendar.DAY_OF_MONTH)) + "/"
						+ (((cal.get(Calendar.MONTH) + 1) < 10) ? "0" + (cal.get(Calendar.MONTH) + 1) : (cal.get(Calendar.MONTH) + 1)) + "/"
						+ cal.get(Calendar.YEAR);
				cal.add(Calendar.DAY_OF_MONTH, nDurationCount);
				dt2 = ((cal.get(Calendar.DAY_OF_MONTH) < 10) ? "0" + cal.get(Calendar.DAY_OF_MONTH) : cal.get(Calendar.DAY_OF_MONTH)) + "/"
						+ (((cal.get(Calendar.MONTH) + 1) < 10) ? "0" + (cal.get(Calendar.MONTH) + 1) : (cal.get(Calendar.MONTH) + 1)) + "/"
						+ cal.get(Calendar.YEAR);

				if (nPayCycle < minCycle) {
					cal.add(Calendar.DAY_OF_MONTH, 1);
					continue;
				}

				sb.append("Pay Cycle " + nPayCycle + ", " + dt1 + " - " + dt2);

				strCurrentPayCycleD1 = uF.getDateFormatUtil(dt1, DATE_FORMAT);
				strCurrentPayCycleD2 = uF.getDateFormatUtil(dt2, DATE_FORMAT);

				log.debug("nPayCycle===>" + nPayCycle);
//				System.out.println("CF/14004---strCurrentDate="+strCurrentDate+"---strCurrentPayCycleD1="+strCurrentPayCycleD1+"---strCurrentPayCycleD2="+strCurrentPayCycleD2);
				
				if (strCurrentDate.equals(strCurrentPayCycleD1) || strCurrentDate.equals(strCurrentPayCycleD2)
						|| (strCurrentDate.after(strCurrentPayCycleD1) && strCurrentDate.before(strCurrentPayCycleD2))) {
					strPayCycleDate[0] = dt1;
					strPayCycleDate[1] = dt2;
					strPayCycleDate[2] = nPayCycle + "";

//					System.out.println("CF/14012--strPayCycleDate[0]="+strPayCycleDate[0]+"---strPayCycleDate[1]="+strPayCycleDate[1]);
					log.debug("nPayCycle= E ==>" + nPayCycle);
				}

				cal.add(Calendar.DAY_OF_MONTH, 1);

				if (nPayCycle >= maxCycle) {
					break;
				}

			}

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return strPayCycleDate;
	}

	public Map<String, String> getHolidayCount(Connection con, CommonFunctions CF, UtilityFunctions uF, String strD1, String strD2, String strPC) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmHolidayCount = new HashMap<String, String>();
		try {
			List<String> leaveDateList = new ArrayList<String>();
			pst = con
					.prepareStatement("select emp_id,_date from leave_application_register where to_date(_date::text,'yyyy-MM-dd') between ? and ? order by emp_id,_date");
			pst.setDate(1, uF.getDateFormat(strD1, DATE_FORMAT));
			pst.setDate(2, uF.getDateFormat(strD2, DATE_FORMAT));
			rs = pst.executeQuery();
			while (rs.next()) {
				leaveDateList.add(rs.getString("emp_id") + "_" + uF.getDateFormat(rs.getString("_date"), DBDATE, DATE_FORMAT));
			}
			rs.close();
			pst.close();

			pst = con.prepareStatement("select emp_id,_date from holiday_count where to_date(_date::text,'yyyy-MM-dd') between ? and ? order by emp_id,_date");
			pst.setDate(1, uF.getDateFormat(strD1, DATE_FORMAT));
			pst.setDate(2, uF.getDateFormat(strD2, DATE_FORMAT));
			rs = pst.executeQuery();
			while (rs.next()) {
				if (!leaveDateList.contains(rs.getString("emp_id") + "_" + uF.getDateFormat(rs.getString("_date"), DBDATE, DATE_FORMAT))) {
					/**
					 * condition revoked for KPCA by sandesh 26 May 2014
					 * */
					// int cnt =
					// uF.parseToInt(hmHolidayCount.get(rs.getString("emp_id")))+1;
					// hmHolidayCount.put(rs.getString("emp_id"), ""+cnt);
				}
			}
			rs.close();
			pst.close();
			// System.out.println("hmHolidayCount.size()=====>"+hmHolidayCount.size());
			// System.out.println("hmHolidayCount=====>"+hmHolidayCount);
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

		return hmHolidayCount;
	}

	public String getUnderSectionName(int uSection) {
		// '1':'17(1)','2':'17(2)','3':'17(3)','4':'10','5':'16','6':'80C','7':'89','8':'Under
		// VI-A'
		String underSection = "";
		switch (uSection) {
			case 1 :
				underSection = "17(1)";
				break;
			case 2 :
				underSection = "17(2)";
				break;
			case 3 :
				underSection = "17(3)";
				break;
			case 4 :
				underSection = "10";
				break;
			case 5 :
				underSection = "16";
				break;
			case 6 :
				underSection = "80C";
				break;
			case 7 :
				underSection = "89";
				break;
			case 8 :
				underSection = "Under VI-A 1";
				break;
			case 9 :
				underSection = "Under VI-A 2";
				break;
		}
		return underSection;
	}

	public void getLoanPayrollDetails(Connection con, UtilityFunctions uF, List<String> alLoans, Map<String, Map<String, String>> hmEmpLoan, String strD1,
			String strD2, String strEmpId) {
		PreparedStatement pst = null;
		ResultSet rs = null;

		try {
			Map<String, String> hmEmpLoanInner = new HashMap<String, String>();

			// pst = con.prepareStatement(selectLoanDetails3);
			pst = con.prepareStatement("select * from loan_payments where paycycle_start=? and paycycle_end=? and pay_source=? and emp_id=?");
			pst.setDate(1, uF.getDateFormat(strD1, DATE_FORMAT));
			pst.setDate(2, uF.getDateFormat(strD2, DATE_FORMAT));
			pst.setString(3, "S");
			pst.setInt(4, uF.parseToInt(strEmpId));
			rs = pst.executeQuery();

			while (rs.next()) {

				hmEmpLoanInner = hmEmpLoan.get(rs.getString("emp_id"));
				if (hmEmpLoanInner == null)
					hmEmpLoanInner = new HashMap<String, String>();
				double loanAmt = uF.parseToDouble(rs.getString("amount_paid"));
				if (hmEmpLoanInner != null) {
					loanAmt += uF.parseToDouble(hmEmpLoanInner.get(rs.getString("loan_id")));
				}
				// hmEmpLoanInner.put(rs.getString("loan_id"),
				// uF.formatIntoTwoDecimal(uF.parseToDouble(rs.getString("amount_paid"))));
				hmEmpLoanInner.put(rs.getString("loan_id"), uF.formatIntoTwoDecimal(loanAmt));
				hmEmpLoan.put(rs.getString("emp_id"), hmEmpLoanInner);

				if (!alLoans.contains(rs.getString("loan_id"))) {
					alLoans.add(rs.getString("loan_id"));
				}
			}
			rs.close();
			pst.close();

			// System.out.println("2222 hmEmpLoan===="+hmEmpLoan.get("656"));

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
	}

	public Map<String, Map<String, String>> getPrevEmpTdsDetails(Connection con, UtilityFunctions uF, String strFinancialYearStart, String strFinancialYearEnd) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, Map<String, String>> hmPrevEmpTds = new HashMap<String, Map<String, String>>();
		try {
			pst = con.prepareStatement("select * from prev_earn_deduct_details where financial_start=? and financial_end=?");
			pst.setDate(1, uF.getDateFormat(strFinancialYearStart, DATE_FORMAT));
			pst.setDate(2, uF.getDateFormat(strFinancialYearEnd, DATE_FORMAT));
			rs = pst.executeQuery();

			while (rs.next()) {
				Map<String, String> hmInner = new HashMap<String, String>();
				hmInner.put("PREV_EARN_DEDUCT_ID", rs.getString("prev_earn_deduct_id"));
				hmInner.put("PREV_TOTAL_EARN", rs.getString("gross_amount"));
				hmInner.put("PREV_TOTAL_DEDUCT", rs.getString("tds_amount"));
				
				String document_name = rs.getString("document_name") != null ? "<a target=\"_blank\" href=\"" + getStrDocRetriveLocation()
						+ rs.getString("document_name") + "\">Document </a><br/>" : "";
				hmInner.put("PREV_DOCUMENT", document_name);

				String fDate = uF.getDateFormat(rs.getString("financial_start"), DBDATE, DATE_FORMAT) + "-"
						+ uF.getDateFormat(rs.getString("financial_end"), DBDATE, DATE_FORMAT);
				hmInner.put("PREV_EMPF_YEAR", fDate);

				hmPrevEmpTds.put(rs.getString("emp_id"), hmInner);
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmPrevEmpTds;
	}

	public Map<String, String> getOrgName(Connection con) {
		Map<String, String> hmOrg = new HashMap<String, String>();

		PreparedStatement pst = null;
		ResultSet rs = null;

		try {
			pst = con.prepareStatement("select org_id,org_name from org_details");
			rs = pst.executeQuery();
			while (rs.next()) {
				hmOrg.put(rs.getString("org_id"), rs.getString("org_name"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmOrg;
	}

	public String getSelectedFilter(CommonFunctions CF, UtilityFunctions uF, List<String> alFilter, Map<String, String> hmFilter) {
		// StringBuilder sbFilter=new
		// StringBuilder("<strong>Filter Summary: </strong>");
		StringBuilder sbFilter = new StringBuilder("<span style=\"float: left;margin-right: 5px;\"><i class=\"fa fa-filter\"></i></span>");
		sbFilter.append("<span style=\"float: left; width: 95%;\">");
		for (int i = 0; alFilter != null && i < alFilter.size(); i++) {
			if (i > 0) {
				sbFilter.append(", ");
			}
			if (alFilter.get(i).equals("EMP")) {
				sbFilter.append("<strong>EMP:</strong> ");
				sbFilter.append(hmFilter.get("EMP"));
			} else if (alFilter.get(i).equals("DURATION")) {
				sbFilter.append("<strong>DURATION:</strong> ");
				sbFilter.append(hmFilter.get("DURATION"));
			} else if (alFilter.get(i).equals("PAYCYCLE")) {
				sbFilter.append("<strong>PAYCYCLE:</strong> ");
				sbFilter.append(hmFilter.get("PAYCYCLE"));
			} else if (alFilter.get(i).equals("ORGANISATION")) {
				sbFilter.append("<strong>ORG:</strong> ");
				sbFilter.append(hmFilter.get("ORGANISATION"));
			} else if (alFilter.get(i).equals("PAYMODE")) {
				sbFilter.append("<strong>PAYMENT MODE:</strong> ");
				sbFilter.append(hmFilter.get("PAYMODE"));
			} else if (alFilter.get(i).equals("LOCATION")) {
				sbFilter.append("<strong>LOC:</strong> ");
				sbFilter.append(hmFilter.get("LOCATION"));
			} else if (alFilter.get(i).equals("DEPARTMENT")) {
				sbFilter.append("<strong>DEPT:</strong> ");
				sbFilter.append(hmFilter.get("DEPARTMENT"));
			} else if (alFilter.get(i).equals("SERVICE")) {
				sbFilter.append("<strong>SBU:</strong> ");
				sbFilter.append(hmFilter.get("SERVICE"));
			} else if (alFilter.get(i).equals("LEVEL")) {
				sbFilter.append("<strong>LEVEL:</strong> ");
				sbFilter.append(hmFilter.get("LEVEL"));
			} else if (alFilter.get(i).equals("DESIG")) {
				sbFilter.append("<strong>DESIG:</strong> ");
				sbFilter.append(hmFilter.get("DESIG"));
			} else if (alFilter.get(i).equals("GRADE")) {
				sbFilter.append("<strong>GRADE:</strong> ");
				sbFilter.append(hmFilter.get("GRADE"));
			} else if (alFilter.get(i).equals("SOURCE")) {
				sbFilter.append("<strong>SOURCE TYPE:</strong> ");
				sbFilter.append(hmFilter.get("SOURCE"));
			} else if (alFilter.get(i).equals("SOURCE_NAME")) {
				sbFilter.append("<strong>SOURCE NAME:</strong> ");
				sbFilter.append(hmFilter.get("SOURCE_NAME"));

			} else if (alFilter.get(i).equals("STATUS")) {
				sbFilter.append("<strong>STATUS:</strong> ");
				sbFilter.append(hmFilter.get("STATUS"));

			} else if (alFilter.get(i).equals("FROMTO")) {
				sbFilter.append("<strong>FROMTO:</strong> ");
				sbFilter.append(hmFilter.get("FROMTO"));

			} else if (alFilter.get(i).equals("SALARY_BAND")) {
				sbFilter.append("<strong>SALARY BAND:</strong> ");
				sbFilter.append(hmFilter.get("SALARY_BAND"));

			}
			
		}
		sbFilter.append("</span>");

		return sbFilter.toString();
	}

	public Map<String, String> getTrainerNameMap(Connection con) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmTrainerName = new HashMap<String, String>();
		try {
			pst = con.prepareStatement("select trainer_id,trainer_fname,trainer_lname from trainer_personal_details");
			rs = pst.executeQuery();
			while (rs.next()) {
				hmTrainerName.put(rs.getString("trainer_id"), rs.getString("trainer_fname") + " " + rs.getString("trainer_lname"));
			}
			rs.close();
			pst.close();
			// System.out.println("hmEmpDetails ====>"+hmEmpDetails);
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmTrainerName;
	}

	public String getEmpDesigMapByEmpId(Connection con, String empId) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		String empDesignation = null;
		try {
			pst = con
					.prepareStatement("select * from grades_details gd, designation_details dd, level_details ld, employee_official_details eod where dd.designation_id = gd.designation_id and ld.level_id = dd.level_id and gd.grade_id = eod.grade_id and eod.emp_id = ?");
			pst.setInt(1, uF.parseToInt(empId));
			rs = pst.executeQuery();
			while (rs.next()) {
				empDesignation = rs.getString("designation_name");

			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return empDesignation;
	}

	public String getEmpNameMapByEmpId(Connection con, String strEmpId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		String empName = null;
		try {

			Map<String, String> hmFeatureStatus = getFeatureStatusMap(con);
			boolean flagMiddleName = uF.parseToBoolean(hmFeatureStatus.get(F_SHOW_EMPLOYEE_MIDDLE_NAME));

			pst = con.prepareStatement("SELECT emp_fname,emp_mname, emp_lname FROM employee_personal_details epd where epd.emp_per_id = ? ");
			pst.setInt(1, uF.parseToInt(strEmpId));
			rs = pst.executeQuery();
			while (rs.next()) {
				/*
				 * String strMiddleName = (rs.getString("emp_mname") != null &&
				 * !rs.getString("emp_mname").trim().equals("") &&
				 * !rs.getString("emp_mname").trim() .equalsIgnoreCase("NULL"))
				 * ? rs.getString("emp_mname").trim() + " " : "";
				 */

				String strMiddleName = "";

				if (flagMiddleName) {
					if (rs.getString("emp_mname") != null && rs.getString("emp_mname").trim().length() > 0) {
						strMiddleName = " " + rs.getString("emp_mname");
					}
				}
				empName = rs.getString("emp_fname") + uF.showData(strMiddleName, "") + " " + rs.getString("emp_lname");
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return empName;
	}

	public String getTrainingNameByTrainingId(Connection con, UtilityFunctions uF, String trainingId) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		String trainingName = null;
		try {
			pst = con.prepareStatement("select training_title from training_plan where plan_id = ?");
			pst.setInt(1, uF.parseToInt(trainingId));
			rs = pst.executeQuery();
			while (rs.next()) {
				trainingName = rs.getString("training_title");
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return trainingName;
	}

	public String getAssessmentNameByAssessId(Connection con, UtilityFunctions uF, String assessId) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		String assessmentName = null;
		try {
			pst = con.prepareStatement("select assessment_name from assessment_details where assessment_details_id = ?");
			pst.setInt(1, uF.parseToInt(assessId));
			rs = pst.executeQuery();
			while (rs.next()) {
				assessmentName = rs.getString("assessment_name");
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return assessmentName;
	}

	public Map<String, String> getAssessmentNameMap(Connection con, UtilityFunctions uF) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmAssessmentName = new HashMap<String, String>();
		try {
			pst = con.prepareStatement("select assessment_details_id, assessment_name from assessment_details");
			rs = pst.executeQuery();
			while (rs.next()) {
				hmAssessmentName.put(rs.getString("assessment_details_id"), rs.getString("assessment_name"));
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmAssessmentName;
	}

	public void getEmpUserTypeId(Connection con, HttpServletRequest request, String empId) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		try {
			pst = con.prepareStatement("select usertype_id from user_details where emp_id=?");
			pst.setInt(1, uF.parseToInt(empId));
			rs = pst.executeQuery();
			if (rs.next()) {
				request.setAttribute("EMP_USER_TYPE_ID", rs.getString("usertype_id"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
	}

	public String getCertificateFirstLine(Connection con, String flineType) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		String firstLine = null;
		try {
			pst = con.prepareStatement("select data_text from certificate_master_data_details where data_type_value = 2 and data_value = ?");
			pst.setInt(1, uF.parseToInt(flineType));
			rs = pst.executeQuery();
			while (rs.next()) {
				firstLine = rs.getString("data_text");
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return firstLine;
	}

	public String getCertificateSecondLine(Connection con, String slineType) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		String secondLine = null;
		try {
			pst = con.prepareStatement("select data_text from certificate_master_data_details where data_type_value = 3 and data_value = ?");
			pst.setInt(1, uF.parseToInt(slineType));
			rs = pst.executeQuery();
			while (rs.next()) {
				secondLine = rs.getString("data_text");
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return secondLine;
	}

	public String getCertificateThirdLine(Connection con, String tlineType) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		String thirdLine = null;
		try {
			pst = con.prepareStatement("select data_text from certificate_master_data_details where data_type_value = 4 and data_value = ?");
			pst.setInt(1, uF.parseToInt(tlineType));
			rs = pst.executeQuery();
			while (rs.next()) {
				thirdLine = rs.getString("data_text");
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return thirdLine;
	}

	public String getCertificateFontSize(Connection con, String fSizeType) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		String fontSize = null;
		try {
			pst = con.prepareStatement("select data_text from certificate_master_data_details where data_type_value = 5 and data_value = ?");
			pst.setInt(1, uF.parseToInt(fSizeType));
			rs = pst.executeQuery();
			while (rs.next()) {
				fontSize = rs.getString("data_text");
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return fontSize;
	}

	public String getCertificateName(Connection con, String certiID) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		String certiName = null;
		try {
			pst = con.prepareStatement("select certificate_name from certificate_details where certificate_details_id = ?");
			pst.setInt(1, uF.parseToInt(certiID));
			rs = pst.executeQuery();
			while (rs.next()) {
				certiName = rs.getString("certificate_name");
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return certiName;
	}

	public Map<String, String> getSkillNameMap(Connection con) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmSkillName = new HashMap<String, String>();
		try {
			pst = con.prepareStatement("select skill_id, skill_name from skills_details");
			rs = pst.executeQuery();
			while (rs.next()) {
				hmSkillName.put(rs.getString("skill_id"), rs.getString("skill_name"));
			}
			rs.close();
			pst.close();
			// System.out.println("hmEmpDetails ====>"+hmEmpDetails);
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmSkillName;
	}

	public String getDegreeNameByDegreeId(Connection con, String degreeId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		String degreeName = null;
		try {
			pst = con.prepareStatement("select education_name from educational_details where edu_id=?");
			pst.setInt(1, uF.parseToInt(degreeId));
			rs = pst.executeQuery();
			// System.out.println("degreeName pst ====>"+ pst);
			while (rs.next()) {
				degreeName = rs.getString("education_name");
			}
			rs.close();
			pst.close();
			// System.out.println("degreeName ====>"+ degreeName);
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return degreeName;
	}

	public Map<String, String> getDegreeNameMap(Connection con) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmDegreeName = new HashMap<String, String>();
		try {
			pst = con.prepareStatement("select edu_id, education_name from educational_details");
			rs = pst.executeQuery();
			while (rs.next()) {
				hmDegreeName.put(rs.getString("edu_id"), rs.getString("education_name"));
			}
			rs.close();
			pst.close();
			// System.out.println("hmEmpDetails ====>"+hmEmpDetails);
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmDegreeName;
	}

	public String getSkillNameBySkillId(Connection con, String skillId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		String skillName = null;
		try {
			pst = con.prepareStatement("select skill_name from skills_details where skill_id=?");
			pst.setInt(1, uF.parseToInt(skillId));
			rs = pst.executeQuery();
			while (rs.next()) {
				skillName = rs.getString("skill_name");
			}
			rs.close();
			pst.close();
			// System.out.println("hmEmpDetails ====>"+hmEmpDetails);
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return skillName;
	}

	public List<List<String>> selectCandidateSkills(Connection con, int candiId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		List<List<String>> alSkills = new ArrayList<List<String>>();
		try {
			pst = con.prepareStatement("SELECT * FROM candidate_skills_description WHERE emp_id=? ORDER BY skills_id");
			pst.setInt(1, candiId);
			rs = pst.executeQuery();
			while (rs.next()) {

				List<String> alInner1 = new ArrayList<String>();
				alInner1.add(rs.getInt("skill_id") + "");
				alInner1.add(uF.showData(getSkillNameBySkillId(con, rs.getString("skill_id")), "-"));
				alInner1.add(uF.showData(rs.getString("skills_value"), "-"));
				alInner1.add(rs.getInt("emp_id") + "");
				alSkills.add(alInner1);
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return alSkills;
	}

	public List<List<String>> selectCandidateHobbies(Connection con, int candiId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		List<List<String>> alHobbies = new ArrayList<List<String>>();

		try {
			pst = con.prepareStatement("SELECT * FROM candidate_hobbies_details WHERE emp_id=? ORDER BY hobbies_name");
			pst.setInt(1, candiId);
			rs = pst.executeQuery();
			// System.out.println("new Date ===> " + new Date());
			while (rs.next()) {
				List<String> alInner1 = new ArrayList<String>();
				alInner1.add(rs.getInt("hobbies_id") + "");
				alInner1.add(uF.showData(rs.getString("hobbies_name"), ""));
				alInner1.add(rs.getInt("emp_id") + "");
				alHobbies.add(alInner1);
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return alHobbies;
	}

	public List<List<String>> selectCandidateLanguages(Connection con, int candiId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		List<List<String>> alLanguages = new ArrayList<List<String>>();

		try {
			pst = con.prepareStatement("SELECT * FROM candidate_languages_details WHERE emp_id = ?");
			pst.setInt(1, candiId);
			log.debug("pst=>" + pst);
			rs = pst.executeQuery();
			// System.out.println("new Date ===> " + new Date());
			while (rs.next()) {
				List<String> alInner = new ArrayList<String>();
				alInner.add(rs.getString("language_id"));
				alInner.add(uF.showData(rs.getString("language_name"), "-"));
				alInner.add(rs.getString("language_read"));
				alInner.add(rs.getString("language_write"));
				alInner.add(rs.getString("language_speak"));
				alLanguages.add(alInner);
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		log.debug("selectLanguages: alLanguages==>" + alLanguages);
		return alLanguages;
	}

	public List<List<String>> selectCandidateEducation(Connection con, int candiId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		List<List<String>> alEducation = new ArrayList<List<String>>();

		try {

			pst = con.prepareStatement("SELECT * FROM candidate_education_details WHERE emp_id = ?");
			pst.setInt(1, candiId);
			log.debug("pst=>" + pst);
			rs = pst.executeQuery();
			// System.out.println("new Date ===> " + new Date());
			while (rs.next()) {

				List<String> alInner = new ArrayList<String>();

				// alInner.add(rs.getString("degree_id"));
				alInner.add(rs.getString("education_id"));
				alInner.add(uF.showData(getDegreeNameByDegreeId(con, rs.getString("education_id")), "-"));
				alInner.add(uF.showData(rs.getString("degree_duration"), "-"));
				alInner.add(uF.showData(rs.getString("completion_year"), "-"));
				alInner.add(uF.showData(rs.getString("grade"), "-"));

//				Start Dattatray Date : 23-08-21
				alInner.add(uF.showData(rs.getString("subject"), ""));//5
				alInner.add(uF.showData(rs.getString("institute_name"), ""));//6
				alInner.add(uF.showData(rs.getString("university_name"), ""));//7
				alInner.add(uF.showData(uF.getDateFormat(rs.getString("start_date"), DBDATE, DATE_FORMAT), ""));//8
				alInner.add(uF.showData(uF.getDateFormat(rs.getString("completion_date"),DBDATE, DATE_FORMAT), ""));//9
				alInner.add(uF.showData(rs.getString("marks"), ""));//10
				alInner.add(uF.showData(rs.getString("city"), ""));//11
				//===start parvez date: 08-09-2021===
				alInner.add(rs.getString("degree_id"));//12
				//===end parvez date: 08-09-2021===
//				End Dattatray Date : 23-08-21
				alEducation.add(alInner);
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return alEducation;

	}

	public String getAttributeNameByAttributeId(Connection con, String attributeId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		String attributeName = null;
		try {
			pst = con.prepareStatement("select attribute_name from appraisal_attribute where arribute_id = ?");
			pst.setInt(1, uF.parseToInt(attributeId));
			rs = pst.executeQuery();
			while (rs.next()) {
				attributeName = rs.getString("attribute_name");
			}
			rs.close();
			pst.close();
			// System.out.println("hmEmpDetails ====>"+hmEmpDetails);
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return attributeName;
	}

	public String getAppendDataWithoutStartEndComma(String strIds) {

		StringBuilder sb = new StringBuilder();
		if (strIds != null && !strIds.equals("")) {

			List<String> idsList = Arrays.asList(strIds.split(","));
			if (idsList != null && !idsList.isEmpty()) {

				for (int i = 0; i < idsList.size(); i++) {
					if (i == 0) {
						sb.append(idsList.get(i).trim());
					} else {
						sb.append("," + idsList.get(i).trim());
					}
				}
			} else {
				return null;
			}
		}
		return sb.toString();
	}

	public String getAppendDataWithStartEndComma(String strIds) {

		StringBuilder sb = new StringBuilder();
		if (strIds != null && !strIds.equals("")) {

			List<String> idsList = Arrays.asList(strIds.split(","));
			if (idsList != null && !idsList.isEmpty()) {

				for (int i = 0; i < idsList.size(); i++) {
					if (i == 0) {
						sb.append("," + idsList.get(i).trim() + ",");
					} else {
						sb.append(idsList.get(i).trim() + ",");
					}
				}
			} else {
				return null;
			}
		}
		return sb.toString();
	}

	public String getAppendDatasWithoutStartEndComma(String[] skills) {

		String skillName = "";
		for (int i = 0; skills != null && i < skills.length; i++) {
			if (i == 0)
				skillName = skills[i].trim();
			else
				skillName += "," + skills[i].trim();
		}
		return skillName;
	}

	public Map<String, List<String>> getHRIdsWLocationwise(Connection con) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, List<String>> hmHrIds = new HashMap<String, List<String>>();
		try {
			pst = con
					.prepareStatement("SELECT eod.emp_id,eod.wlocation_id FROM user_details ud, employee_official_details eod WHERE (ud.usertype_id = 7 or ud.usertype_id = 1) and ud.emp_id = eod.emp_id");
			rs = pst.executeQuery();
			// System.out.println("new Date ===> " + new Date());
			while (rs.next()) {
				List<String> innerList = hmHrIds.get(rs.getString("wlocation_id"));
				innerList.add(rs.getString("emp_id"));
				hmHrIds.put(rs.getString("wlocation_id"), innerList);
			}
			rs.close();
			pst.close();
			// System.out.println("hmHrIds ===>>> " + hmHrIds);
		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmHrIds;
	}

	public StringBuilder getEmployeeSalaryDetails(Connection con, CommonFunctions CF, UtilityFunctions uF, String empId, HttpServletRequest request,
			HttpSession session) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		StringBuilder sbEmpSalTable = new StringBuilder();
		try {
			Map<String, String> hmEmpProfile = CF.getEmpProfileDetail(con, request, session, CF, uF, null, empId);
			Map<String, String> hmFeatureStatus = getFeatureStatusMap(con);
			boolean flagDisableNetTakeHomeSal = uF.parseToBoolean(hmFeatureStatus.get(F_DISABLE_NET_TAKE_HOME_SALARY));

			MyProfile myProfile = new MyProfile();
			myProfile.session = session;
			myProfile.request = request;
			myProfile.CF = CF;
			int intEmpIdReq = uF.parseToInt(empId);
			int nSalaryStrucuterType = uF.parseToInt(CF.getStrSalaryStructure());
			if (nSalaryStrucuterType == S_GRADE_WISE) {
				myProfile.getSalaryHeadsforEmployeeByGrade(con, uF, intEmpIdReq, hmEmpProfile);
			} else {
				myProfile.getSalaryHeadsforEmployee(con, uF, intEmpIdReq, hmEmpProfile);
			}

			/**
			 * Salary Structure Table
			 * */
			List<List<String>> salaryHeadDetailsList = (List<List<String>>) request.getAttribute("salaryHeadDetailsList");
			if (salaryHeadDetailsList == null)
				salaryHeadDetailsList = new ArrayList<List<String>>();
			// System.out.println("salaryHeadDetailsList 111 ===>> " +
			// salaryHeadDetailsList);
			if (salaryHeadDetailsList != null && !salaryHeadDetailsList.isEmpty() && salaryHeadDetailsList.size() > 0) {
				// sbEmpSalTable.append("<table>");
				// sbEmpSalTable.append("<tr>");
				// sbEmpSalTable.append("<td valign=\"top\">");
				sbEmpSalTable.append("<table border=\"1\" width=\"50%\">");
				sbEmpSalTable.append("<tr>");
				sbEmpSalTable.append("<td bgcolor=\"#FFC300\" align=\"center\"><b>Salary Head</b></td>");
				// sbEmpSalTable.append("<td width=\"30%\" align=\"right\">Monthly</td>");
				sbEmpSalTable.append("<td bgcolor=\"#FFC300\" width=\"30%\" align=\"right\"><b>Annual</b></td>");
				sbEmpSalTable.append("</tr>");
				sbEmpSalTable.append("<tr>");
				sbEmpSalTable.append("<td colspan=\"2\" nowrap=\"nowrap\" align=\"center\"><b>EARNING DETAILS</b></td>");
				sbEmpSalTable.append("</tr>");

				sbEmpSalTable.append("<tr>");
				sbEmpSalTable.append("<td colspan=\"2\"><b>Fixed Component- A</b></td>");
				// sbEmpSalTable.append("<td align=\"right\" valign=\"bottom\"></td>");
				// sbEmpSalTable.append("<td align=\"right\" valign=\"bottom\"></td>");
				sbEmpSalTable.append("</tr>");

				double grossAmount = 0.0d;
				double grossYearAmount = 0.0d;
				double netTakeHome = 0.0d;
				boolean veriableFlag = false;
				for (int i = 0; i < salaryHeadDetailsList.size(); i++) {
					List<String> innerList = salaryHeadDetailsList.get(i);
					if (innerList.get(1).equals("E") && !uF.parseToBoolean(innerList.get(5))) {
						double dblEarnMonth = Math.round(uF.parseToDouble(innerList.get(2)));
						double dblEarnAnnual = Math.round(uF.parseToDouble(innerList.get(3)));
						grossAmount += dblEarnMonth;
						grossYearAmount += dblEarnAnnual;

						netTakeHome += dblEarnMonth;

						sbEmpSalTable.append("<tr>");
						sbEmpSalTable.append("<td>" + uF.showData(innerList.get(0), "-") + "</td>");
						// sbEmpSalTable.append("<td align=\"right\" valign=\"bottom\">"
						// + dblEarnMonth + "</td>");
						sbEmpSalTable.append("<td width=\"30%\" align=\"right\" valign=\"bottom\">" + uF.formatIntoTwoDecimal(dblEarnAnnual) + "</td>");
						sbEmpSalTable.append("</tr>");
					} else if (innerList.get(1).equals("E")) {
						veriableFlag = true;
					}
				}

				sbEmpSalTable.append("<tr>");
				sbEmpSalTable.append("<td><strong>Sub Total</strong></td>");
				// sbEmpSalTable.append("<td align=\"right\"><strong>" +
				// uF.formatIntoTwoDecimal(grossAmount) + "</strong></td>");
				sbEmpSalTable.append("<td width=\"30%\" align=\"right\"><strong>" + uF.formatIntoTwoDecimal(grossYearAmount) + "</strong></td>");
				sbEmpSalTable.append("</tr>");

				if (veriableFlag) {
					sbEmpSalTable.append("<tr>");
					sbEmpSalTable.append("<td colspan=\"2\"><b>Variable Component- B</b></td>");
					// sbEmpSalTable.append("<td align=\"right\" valign=\"bottom\"></td>");
					// sbEmpSalTable.append("<td align=\"right\" valign=\"bottom\"></td>");
					sbEmpSalTable.append("</tr>");
				}

				for (int i = 0; i < salaryHeadDetailsList.size(); i++) {
					List<String> innerList = salaryHeadDetailsList.get(i);
					if (innerList.get(1).equals("E") && uF.parseToBoolean(innerList.get(5))) {
						double dblEarnMonth = Math.round(uF.parseToDouble(innerList.get(2)));
						double dblEarnAnnual = Math.round(uF.parseToDouble(innerList.get(3)));
						grossAmount += dblEarnMonth;
						grossYearAmount += dblEarnAnnual;

						netTakeHome += dblEarnMonth;

						sbEmpSalTable.append("<tr>");
						sbEmpSalTable.append("<td>" + uF.showData(innerList.get(0), "-") + "</td>");
						// sbEmpSalTable.append("<td align=\"right\" valign=\"bottom\">"
						// + dblEarnMonth + "</td>");
						sbEmpSalTable.append("<td width=\"30%\" align=\"right\" valign=\"bottom\">" + uF.formatIntoTwoDecimal(dblEarnAnnual) + "</td>");
						sbEmpSalTable.append("</tr>");
					}
				}

				sbEmpSalTable.append("<tr>");
				sbEmpSalTable.append("<td><strong>Gross Salary</strong></td>");
				// sbEmpSalTable.append("<td align=\"right\"><strong>" +
				// uF.formatIntoTwoDecimal(grossAmount) + "</strong></td>");
				sbEmpSalTable.append("<td width=\"30%\" align=\"right\"><strong>" + uF.formatIntoTwoDecimal(grossYearAmount) + "</strong></td>");
				sbEmpSalTable.append("</tr>");
				// sbEmpSalTable.append("</table>");
				// sbEmpSalTable.append("</td>");
				//
				// sbEmpSalTable.append("<td valign=\"top\">");
				// sbEmpSalTable.append("<table>");

				sbEmpSalTable.append("<tr>");
				sbEmpSalTable.append("<td colspan=\"2\" nowrap=\"nowrap\" align=\"center\"><b>DEDUCTION DETAILS</b></td>");
				sbEmpSalTable.append("</tr>");

				// sbEmpSalTable.append("<tr>");
				// sbEmpSalTable.append("<td align=\"center\">Salary Head</td>");
				// sbEmpSalTable.append("<td width=\"30%\" align=\"right\">Monthly</td>");
				// sbEmpSalTable.append("<td width=\"30%\" align=\"right\">Annual</td>");
				// sbEmpSalTable.append("</tr>");

				double deductAmount = 0.0d;
				double deductYearAmount = 0.0d;

				for (int i = 0; salaryHeadDetailsList != null && !salaryHeadDetailsList.isEmpty() && i < salaryHeadDetailsList.size(); i++) {
					List<String> innerList = salaryHeadDetailsList.get(i);
					if (innerList.get(1).equals("D")) {
						double dblDeductMonth = 0.0d;;
						double dblDeductAnnual = 0.0d;
						if (uF.parseToInt(innerList.get(4)) == EMPLOYEE_ESI) {
							dblDeductMonth = Math.ceil(uF.parseToDouble(innerList.get(2)));
							dblDeductAnnual = Math.ceil(uF.parseToDouble(innerList.get(3)));
						} else if (uF.parseToInt(innerList.get(4)) == EMPLOYER_ESI) {
							dblDeductMonth = Math.ceil(uF.parseToDouble(innerList.get(2)));
							dblDeductAnnual = Math.ceil(uF.parseToDouble(innerList.get(3)));
						} else {
							dblDeductMonth = Math.round(uF.parseToDouble(innerList.get(2)));
							dblDeductAnnual = Math.round(uF.parseToDouble(innerList.get(3)));
						}

						deductAmount += dblDeductMonth;
						deductYearAmount += dblDeductAnnual;

						netTakeHome -= dblDeductMonth;

						sbEmpSalTable.append("<tr>");
						sbEmpSalTable.append("<td>" + uF.showData(innerList.get(0), "-") + "</td>");
						// sbEmpSalTable.append("<td align=\"right\" valign=\"bottom\">"
						// + dblDeductMonth + "</td>");
						sbEmpSalTable.append("<td width=\"30%\" align=\"right\" valign=\"bottom\">" + uF.formatIntoTwoDecimal(dblDeductAnnual) + "</td>");
						sbEmpSalTable.append("</tr>");
					}
				}

				sbEmpSalTable.append("<tr>");
				sbEmpSalTable.append("<td align=\"center\"><strong>Total Deduction</strong></td>");
				// sbEmpSalTable.append("<td align=\"right\"><strong>" +
				// uF.formatIntoTwoDecimal(deductAmount) + "</strong></td>");
				sbEmpSalTable.append("<td width=\"30%\" align=\"right\"><strong>" + uF.formatIntoTwoDecimal(deductYearAmount) + "</strong></td>");
				sbEmpSalTable.append("</tr>");
				// sbEmpSalTable.append("</table>");
				// sbEmpSalTable.append("</td>");
				// sbEmpSalTable.append("</tr>");

				Map<String, String> hmContribution = (Map<String, String>) request.getAttribute("hmContribution");
				if (hmContribution == null)
					hmContribution = new HashMap<String, String>();
				double dblMonthContri = 0.0d;
				double dblAnnualContri = 0.0d;
				boolean isEPF = uF.parseToBoolean((String) request.getAttribute("isEPF"));
				boolean isESIC = uF.parseToBoolean((String) request.getAttribute("isESIC"));
				boolean isLWF = uF.parseToBoolean((String) request.getAttribute("isLWF"));

				if (isEPF || isESIC || isLWF) {

					// sbEmpSalTable.append("<tr>");
					// sbEmpSalTable.append("<td valign=\"top\">");
					// sbEmpSalTable.append("<table>");
					sbEmpSalTable.append("<tr>");
					sbEmpSalTable.append("<td colspan=\"2\" nowrap=\"nowrap\" align=\"center\"><b>CONTRIBUTION DETAILS</b></td>");
					sbEmpSalTable.append("</tr>");

					// sbEmpSalTable.append("<tr>");
					// sbEmpSalTable.append("<td align=\"center\">Contribution Head</td>");
					// sbEmpSalTable.append("<td width=\"30%\" align=\"right\">Monthly</td>");
					// sbEmpSalTable.append("<td width=\"30%\" align=\"right\">Annual</td>");
					// sbEmpSalTable.append("</tr>");
					if (isEPF) {
						double dblEPFMonth = Math.round(uF.parseToDouble(hmContribution.get("EPF_MONTHLY")));
						double dblEPFAnnual = Math.round(uF.parseToDouble(hmContribution.get("EPF_ANNUALY")));
						dblMonthContri += dblEPFMonth;
						dblAnnualContri += dblEPFAnnual;

						sbEmpSalTable.append("<tr>");
						sbEmpSalTable.append("<td>Employer PF</td>");
						// sbEmpSalTable.append("<td align=\"right\" valign=\"bottom\">"
						// + dblEPFMonth + "</td>");
						sbEmpSalTable.append("<td width=\"30%\" align=\"right\" valign=\"bottom\">" + uF.formatIntoTwoDecimal(dblEPFAnnual) + "</td>");
						sbEmpSalTable.append("</tr>");
					}
					if (isESIC) {
						double dblESIMonth = Math.ceil(uF.parseToDouble(hmContribution.get("ESI_MONTHLY")));
						double dblESIAnnual = Math.ceil(uF.parseToDouble(hmContribution.get("ESI_ANNUALY")));
						dblMonthContri += dblESIMonth;
						dblAnnualContri += dblESIAnnual;

						sbEmpSalTable.append("<tr>");
						sbEmpSalTable.append("<td>Employer ESI</td>");
						// sbEmpSalTable.append("<td align=\"right\" valign=\"bottom\">"
						// + dblESIMonth + "</td>");
						sbEmpSalTable.append("<td width=\"30%\" align=\"right\" valign=\"bottom\">" + uF.formatIntoTwoDecimal(dblESIAnnual) + "</td>");
						sbEmpSalTable.append("</tr>");
					}
					if (isLWF) {
						double dblLWFMonth = Math.round(uF.parseToDouble(hmContribution.get("LWF_MONTHLY")));
						double dblLWFAnnual = Math.round(uF.parseToDouble(hmContribution.get("LWF_ANNUALY")));
						dblMonthContri += dblLWFMonth;
						dblAnnualContri += dblLWFAnnual;

						sbEmpSalTable.append("<tr>");
						sbEmpSalTable.append("<td>Employer LWF</td>");
						// sbEmpSalTable.append("<td align=\"right\" valign=\"bottom\">"
						// + dblLWFMonth + "</td>");
						sbEmpSalTable.append("<td width=\"30%\" align=\"right\" valign=\"bottom\">" + uF.formatIntoTwoDecimal(dblLWFAnnual) + "</td>");
						sbEmpSalTable.append("</tr>");
					}

					sbEmpSalTable.append("<tr>");
					sbEmpSalTable.append("<td align=\"right\"><strong>Contribution Total</strong></td>");
					// sbEmpSalTable.append("<td align=\"right\"><strong>" +
					// uF.formatIntoTwoDecimal(dblMonthContri) +
					// "</strong></td>");
					sbEmpSalTable.append("<td width=\"30%\" align=\"right\"><strong>" + uF.formatIntoTwoDecimal(dblAnnualContri) + "</strong></td>");

					sbEmpSalTable.append("</tr>");
					// sbEmpSalTable.append("</table>");
					// sbEmpSalTable.append("</td>");
					// sbEmpSalTable.append("<td>&nbsp;</td>");
					// sbEmpSalTable.append("</tr>");
				}

				double dblCTCMonthly = grossAmount + dblMonthContri;
				double dblCTCAnnualy = grossYearAmount + dblAnnualContri;

				List<List<String>> salaryAnnualVariableDetailsList = (List<List<String>>) request.getAttribute("salaryAnnualVariableDetailsList");
				if (salaryAnnualVariableDetailsList == null)
					salaryAnnualVariableDetailsList = new ArrayList<List<String>>();

				int nAnnualVariSize = salaryAnnualVariableDetailsList.size();
				if (nAnnualVariSize > 0) {

					// sbEmpSalTable.append("<tr>");
					// sbEmpSalTable.append("<td valign=\"top\">");
					// sbEmpSalTable.append("<table>");
					sbEmpSalTable.append("<tr>");
					sbEmpSalTable.append("<td colspan=\"2\" nowrap=\"nowrap\" align=\"center\"><b>ANNUAL EARNING DETAILS</b></td>");
					sbEmpSalTable.append("</tr>");
					// sbEmpSalTable.append("<tr>");
					// sbEmpSalTable.append("<td align=\"center\">Salary Head</td>");
					// sbEmpSalTable.append("<td width=\"30%\" align=\"right\">Monthly</td>");
					// sbEmpSalTable.append("<td width=\"30%\" align=\"right\">Annual</td>");
					// sbEmpSalTable.append("</tr>");

					double grossAnnualAmount = 0.0d;
					double grossAnnualYearAmount = 0.0d;
					for (int i = 0; i < nAnnualVariSize; i++) {
						List<String> innerList = salaryAnnualVariableDetailsList.get(i);
						double dblEarnMonth = Math.round(uF.parseToDouble(innerList.get(2)));
						double dblEarnAnnual = Math.round(uF.parseToDouble(innerList.get(3)));
						grossAnnualAmount += dblEarnMonth;
						grossAnnualYearAmount += dblEarnAnnual;

						sbEmpSalTable.append("<tr>");
						sbEmpSalTable.append("<td>" + uF.showData(innerList.get(0), "-") + "</td>");
						// sbEmpSalTable.append("<td align=\"right\" valign=\"bottom\">"
						// + dblEarnMonth + "</td>");
						sbEmpSalTable.append("<td width=\"30%\" align=\"right\" valign=\"bottom\">" + uF.formatIntoTwoDecimal(dblEarnAnnual) + "</td>");
						sbEmpSalTable.append("</tr>");
					}
					dblCTCMonthly += grossAnnualAmount;
					dblCTCAnnualy += grossAnnualYearAmount;

					sbEmpSalTable.append("<tr>");
					sbEmpSalTable.append("<td><strong>Total</strong></td>");
					// sbEmpSalTable.append("<td align=\"right\"><strong>" +
					// uF.formatIntoTwoDecimal(grossAnnualAmount) +
					// "</strong></td>");
					sbEmpSalTable.append("<td width=\"30%\" align=\"right\"><strong>" + uF.formatIntoTwoDecimal(grossAnnualYearAmount) + "</strong></td>");
					sbEmpSalTable.append("</tr>");
					// sbEmpSalTable.append("</table>");
					// sbEmpSalTable.append("</td>");
					// sbEmpSalTable.append("<td>&nbsp;</td>");
					// sbEmpSalTable.append("</tr>");
				}
				sbEmpSalTable.append("</table>");

				sbEmpSalTable.append("<table border=\"1\" width=\"50%\">");
				if (!flagDisableNetTakeHomeSal) {
					sbEmpSalTable.append("<tr>");
			//===start parvez date: 12-08-2022===		
					/*sbEmpSalTable.append("<td>Net Take Home Per Month:</td>");*/
					sbEmpSalTable.append("<td>Net Earning:</td>");
			//===end parvez date: 12-08-2022===		
					sbEmpSalTable.append("<td width=\"30%\" align=\"right\" valign=\"bottom\"> " + uF.formatIntoTwoDecimal(netTakeHome) + "</td>");
					sbEmpSalTable.append("</tr>");
				}
				// sbEmpSalTable.append("<tr>");
				// sbEmpSalTable.append("<td>Cost To Company (Monthly):</td>");
				// sbEmpSalTable.append("<td valign=\"bottom\"> " +
				// uF.formatIntoTwoDecimal(dblCTCMonthly) + "</td>");
				// sbEmpSalTable.append("</tr>");
				// sbEmpSalTable.append("<tr>");
				
		//===start parvez date: 12-08-2022===		
				/*sbEmpSalTable.append("<td>Cost To Company (Annually):</td>");*/
				sbEmpSalTable.append("<td>Annual Gross Earning:</td>");
		//===end parvez date: 12-08-2022===		
				sbEmpSalTable.append("<td width=\"30%\" align=\"right\" valign=\"bottom\"> " + uF.formatIntoTwoDecimal(dblCTCAnnualy) + "</td>");
				sbEmpSalTable.append("</tr>");
				sbEmpSalTable.append("</table>");
			}
			/**
			 * Salary Structure End
			 * */

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return sbEmpSalTable;
	}

	public void getTaskBarNotification(CommonFunctions CF, String empType, String empId, HttpServletRequest request, HttpSession session) {

		PreparedStatement pst = null;
		ResultSet rs = null;

		UtilityFunctions uF = new UtilityFunctions();
		Database db = new Database();
		db.setRequest(request);
		Connection con = null;
		// System.out.println("empType ===> " + empType);
		// System.out.println("empId ===> " + empId);
		try {
			con = db.makeConnection(con);

			StringBuilder sbQuery = new StringBuilder();
			sbQuery.append("select count(*) as cnt from taskrig_user_alerts where (type is null or type != 'NA') and alert_data is not null and alert_action is not null ");
			if (empType != null && empType.equalsIgnoreCase(CUSTOMER)) {
				sbQuery.append(" and customer_id=?");
			} else {
				sbQuery.append(" and resource_id=?");
			}
			// sbQuery.append("");
			pst = con.prepareStatement(sbQuery.toString());
			pst.setInt(1, uF.parseToInt(empId));
			// System.out.println("pst ===> " +pst);
			rs = pst.executeQuery();
			int notificationCount = 0;
			while (rs.next()) {
				notificationCount = rs.getInt("cnt");
			}
			rs.close();
			pst.close();

			sbQuery = new StringBuilder();
			sbQuery.append("select * from taskrig_user_alerts where (type is null or type != 'NA') ");
			if (empType != null && empType.equalsIgnoreCase(CUSTOMER)) {
				sbQuery.append(" and customer_id=?");
			} else {
				sbQuery.append(" and resource_id=?");
			}
			sbQuery.append(" order by alerts_id desc limit 25");
			pst = con.prepareStatement(sbQuery.toString());
			pst.setInt(1, uF.parseToInt(empId));
			// System.out.println("pst ===> " +pst);
			rs = pst.executeQuery();
			StringBuilder sbNotifications = new StringBuilder();
			// int notiCnt = 0;
			while (rs.next()) {
				if (rs.getString("alert_data") != null && !rs.getString("alert_data").equals("null") && !rs.getString("alert_data").equals("")
						&& rs.getString("alert_action") != null && !rs.getString("alert_action").equals("null") && !rs.getString("alert_action").equals("")) {
					sbNotifications.append("<li>");
					sbNotifications.append("<a href=\"" + rs.getString("alert_action") + "?alertID=" + rs.getString("alerts_id") + "\">");
					sbNotifications.append(rs.getString("alert_data"));
					sbNotifications.append("</a>");
					sbNotifications.append("</li>");
					// notiCnt++;
				}
			}
			// if(notiCnt == 25) {
			// sbNotifications.append("<div style=\"float: left; width: 99%; border: 1px solid #CCCCCC; border-radius: 4px; margin: 2px 0px;\"");
			// sbNotifications.append("onmouseover=\"javascript:this.style.backgroundColor='#D4D4D4'\" onmouseout=\"javascript:this.style.backgroundColor=''\" >");
			// sbNotifications.append("<a href=\"#\" style=\"float: right; font-weight: normal; width: 100%;\">");
			// sbNotifications.append("See All");
			// sbNotifications.append("</a>");
			// sbNotifications.append("</div>");
			// }
			rs.close();
			pst.close();
			// System.out.println("sbNotifications ===>> " + sbNotifications);
			request.setAttribute("notificationCount", notificationCount + "");
			request.setAttribute("sbNotifications", sbNotifications.toString());

			String strBaseUsertype = (String) session.getAttribute(BASEUSERTYPE);
			Map<String, String> hmUsertypeId = getUserTypeIdMap(con);
			sbQuery = new StringBuilder();
			sbQuery.append("select count(*) as cnt from workrig_user_alerts where emp_user_type>0 ");
			if (empType != null && empType.equalsIgnoreCase(ADMIN)) {
				sbQuery.append(" and (emp_user_type =" + uF.parseToInt(hmUsertypeId.get(ADMIN)) + " or emp_user_type ="
						+ uF.parseToInt(hmUsertypeId.get(HRMANAGER)) + ") ");
			} else if (empType != null && empType.equalsIgnoreCase(MANAGER) && strBaseUsertype != null
					&& (strBaseUsertype.equals(CEO) || strBaseUsertype.equals(HOD))) {
				sbQuery.append(" and (emp_user_type =" + uF.parseToInt(hmUsertypeId.get(strBaseUsertype)) + " or emp_user_type ="
						+ uF.parseToInt(hmUsertypeId.get(MANAGER)) + ") ");
			} else {
				sbQuery.append(" and emp_user_type =" + uF.parseToInt(hmUsertypeId.get(empType)) + " ");
			}
			sbQuery.append(" and alert_data is not null and alert_action is not null and emp_id=?");
			pst = con.prepareStatement(sbQuery.toString());
			pst.setInt(1, uF.parseToInt(empId));
			// System.out.println("pst ===> " +pst);
			rs = pst.executeQuery();
			int notificationCountWR = 0;
			while (rs.next()) {
				notificationCountWR = rs.getInt("cnt");
			}

			rs.close();
			pst.close();

			sbQuery = new StringBuilder();
			sbQuery.append("select * from workrig_user_alerts where emp_user_type>0 ");
			if (empType != null && empType.equalsIgnoreCase(ADMIN)) {
				sbQuery.append(" and (emp_user_type =" + uF.parseToInt(hmUsertypeId.get(ADMIN)) + " or emp_user_type ="
						+ uF.parseToInt(hmUsertypeId.get(HRMANAGER)) + ") ");
			} else if (empType != null && empType.equalsIgnoreCase(MANAGER) && strBaseUsertype != null
					&& (strBaseUsertype.equals(CEO) || strBaseUsertype.equals(HOD))) {
				sbQuery.append(" and (emp_user_type =" + uF.parseToInt(hmUsertypeId.get(strBaseUsertype)) + " or emp_user_type ="
						+ uF.parseToInt(hmUsertypeId.get(MANAGER)) + ") ");
			} else {
				sbQuery.append(" and emp_user_type =" + uF.parseToInt(hmUsertypeId.get(empType)) + " ");
			}
			sbQuery.append(" and alert_data is not null and alert_action is not null and emp_id=?");
			sbQuery.append(" order by alerts_id desc limit 25");
			pst = con.prepareStatement(sbQuery.toString());
			pst.setInt(1, uF.parseToInt(empId));
			// System.out.println("pst ===> " +pst);
			rs = pst.executeQuery();
			StringBuilder sbNotificationsWR = new StringBuilder();
			// int notiCnt = 0;
			while (rs.next()) {
				if (rs.getString("alert_data") != null && !rs.getString("alert_data").equals("null") && !rs.getString("alert_data").equals("")
						&& rs.getString("alert_action") != null && !rs.getString("alert_action").equals("null") && !rs.getString("alert_action").equals("")) {
					sbNotificationsWR.append("<li>");
					sbNotificationsWR.append("<a href=\"" + rs.getString("alert_action") + "&alertID=" + rs.getString("alerts_id"));
					// if(strBaseUsertype != null &&
					// (strBaseUsertype.equals(CEO) ||
					// strBaseUsertype.equals(HOD)) &&
					// uF.parseToInt(rs.getString("emp_user_type")) ==
					// uF.parseToInt(hmUsertypeId.get(strBaseUsertype))) {
					// sbNotificationsWR.append("&currUserType="+strBaseUsertype);
					// }
					sbNotificationsWR.append("\" style=\"\">");
					sbNotificationsWR.append(rs.getString("alert_data"));
					sbNotificationsWR.append("</a>");
					sbNotificationsWR.append("</li>");
					// notiCnt++;
				}
			}
			rs.close();
			pst.close();
			// System.out.println("sbNotificationsWR ===>> " +
			// sbNotificationsWR);
			//
			// System.out.println("sbNotificationsWR Count ===>> " +
			// notificationCountWR);
			request.setAttribute("notificationCountWR", notificationCountWR + "");
			request.setAttribute("sbNotificationsWR", sbNotificationsWR.toString());

			sbQuery = new StringBuilder();
			sbQuery.append("select * from user_alerts ");
			if (empType != null && empType.equalsIgnoreCase(CUSTOMER)) {
				sbQuery.append("where customer_id=?");
			} else {
				sbQuery.append("where emp_id=?");
			}

			pst = con.prepareStatement(sbQuery.toString());
			pst.setInt(1, uF.parseToInt(empId));
			// System.out.println("pst ===> " +pst);
			rs = pst.executeQuery();
			Map<String, String> hmTaskNotification = new HashMap<String, String>();
			while (rs.next()) {

				hmTaskNotification.put("MY_PAY_CNT", "" + rs.getInt("mypay"));

				hmTaskNotification.put("LEAVE_REQUEST_CNT", "" + rs.getInt("leave_request"));
				hmTaskNotification.put("LEAVE_APPOVAL_CNT", "" + rs.getInt("leave_approval"));

				hmTaskNotification.put("REIM_REQUEST_CNT", "" + rs.getInt("reimbursement_request"));
				hmTaskNotification.put("REIM_APPOVAL_CNT", "" + rs.getInt("reimbursement_approval"));

				hmTaskNotification.put("TRAVEL_CNT", "" + rs.getInt("travel_request"));
				hmTaskNotification.put("TRAVEL_APPOVAL_CNT", "" + rs.getInt("travel_approval"));

				hmTaskNotification.put("JOBCODE_REQUEST_CNT", "" + rs.getInt("jobcode_request"));
				hmTaskNotification.put("REQUI_REQUEST_CNT", "" + rs.getInt("requirement_request"));
				hmTaskNotification.put("HR_REVIEWS_CNT", "" + rs.getInt("hr_reviews"));
				hmTaskNotification.put("REVIEWS_CNT", "" + rs.getInt("reviews"));

				hmTaskNotification.put("JOBCODE_APPROVE_CNT", "" + rs.getInt("jobcode_approval"));
				hmTaskNotification.put("REQUI_APPROVE_CNT", "" + rs.getInt("requirement_approval"));
				hmTaskNotification.put("MANAGER_REVIEWS_CNT", "" + rs.getInt("manager_reviews"));

				hmTaskNotification.put("MY_REVIEWS_CNT", "" + rs.getInt("my_reviews"));
				hmTaskNotification.put("MY_GOALS_CNT", "" + rs.getInt("my_goals"));
				hmTaskNotification.put("MY_KRAS_CNT", "" + rs.getInt("my_kras"));
				hmTaskNotification.put("MY_TARGETS_CNT", "" + rs.getInt("my_targets"));
				hmTaskNotification.put("MY_LEARNING_PLAN_CNT", "" + rs.getInt("my_learning_plans"));
				// hmTaskNotification.put("INTERVIEW_CNT",""+rs.getInt("interviews"));
				hmTaskNotification.put("NEWJOINEE_CNT", "" + rs.getInt("new_joinees"));
				hmTaskNotification.put("MANGER_LEARNING_GAPS_CNT", "" + rs.getInt("manager_learning_gaps"));
				hmTaskNotification.put("HR_LEARNING_GAPS_CNT", "" + rs.getInt("hr_learning_gaps"));
				hmTaskNotification.put("MY_INTERVIEW_SCHEDULED_CNT", "" + rs.getInt("my_interviews_scheduled"));
				hmTaskNotification.put("CANDIDATE_FINALIZATION_CNT", "" + rs.getInt("candidate_finalization"));
				hmTaskNotification.put("CANDIDATE_OFFER_ACCEPT_REJECT_CNT", "" + rs.getInt("candidate_offer_accept_reject"));
				hmTaskNotification.put("HR_LEARNING_FINALIZATION_CNT", "" + rs.getInt("hr_learning_finalization"));
				hmTaskNotification.put("REVIEW_FINALIZATION_CNT", "" + rs.getInt("review_finalization"));
				hmTaskNotification.put("MANAGER_GOALS_CNT", "" + rs.getInt("manager_goals"));

				hmTaskNotification.put("PERK_REQUEST_CNT", "" + rs.getInt("perk_request"));
				hmTaskNotification.put("PERK_APPOVAL_CNT", "" + rs.getInt("perk_approval"));
				hmTaskNotification.put("PAY_PERK_CNT", "" + rs.getInt("pay_perk"));

				hmTaskNotification.put("LTA_REQUEST_CNT", "" + rs.getInt("lta_request"));
				hmTaskNotification.put("LTA_APPOVAL_CNT", "" + rs.getInt("lta_approval"));
				hmTaskNotification.put("PAY_LTA_CNT", "" + rs.getInt("pay_lta"));

				hmTaskNotification.put(LEAVE_ENCASH_REQUEST_ALERT, "" + rs.getInt("leave_encash_request"));
				hmTaskNotification.put(LEAVE_ENCASH_APPROVAL_ALERT, "" + rs.getInt("leave_encash_approval"));

				hmTaskNotification.put(PAY_GRATUITY, "" + rs.getInt("pay_gratuity"));

				hmTaskNotification.put(PAY_REIM, "" + rs.getInt("pay_reimbursement"));

				hmTaskNotification.put(REQUISITION_REQUEST_ALERT, "" + rs.getInt("requisition_request"));
				hmTaskNotification.put(REQUISITION_APPROVAL_ALERT, "" + rs.getInt("requisition_approval"));

				hmTaskNotification.put(PRO_RECURRING_BILLING_ALERT, "" + rs.getInt("pro_recurring_billing"));

				hmTaskNotification.put(PRO_REQUEST_ALERT, "" + rs.getInt("pro_request"));
				hmTaskNotification.put(PRO_CREATED_ALERT, "" + rs.getInt("pro_created"));
				hmTaskNotification.put(PRO_COMPLETED_ALERT, "" + rs.getInt("pro_completed"));
				hmTaskNotification.put(PRO_NEW_RESOURCE_ALERT, "" + rs.getInt("pro_new_resource"));
				hmTaskNotification.put(TASK_ALLOCATE_ALERT, "" + rs.getInt("task_allocate"));
				hmTaskNotification.put(TASK_NEW_REQUEST_ALERT, "" + rs.getInt("task_new_request"));
				hmTaskNotification.put(TASK_ACCEPT_ALERT, "" + rs.getInt("task_accept"));
				hmTaskNotification.put(TASK_REQUEST_RESCHEDULE_ALERT, "" + rs.getInt("task_request_reschedule"));
				hmTaskNotification.put(TASK_REQUEST_REASSIGN_ALERT, "" + rs.getInt("task_request_reassign"));
				hmTaskNotification.put(TASK_REASSIGN_ALERT, "" + rs.getInt("task_reassign"));
				hmTaskNotification.put(TASK_RESCHEDULE_ALERT, "" + rs.getInt("task_reschedule"));
				hmTaskNotification.put(TASK_COMPLETED_ALERT, "" + rs.getInt("task_completed"));
				hmTaskNotification.put(TIMESHEET_RECEIVED_ALERT, "" + rs.getInt("timesheet_received"));
				hmTaskNotification.put(INVOICE_GENERATED_ALERT, "" + rs.getInt("invoice_generated"));
				hmTaskNotification.put(SHARE_DOCUMENTS_ALERT, "" + rs.getInt("share_document"));
				hmTaskNotification.put(ADD_MYTEAM_MEMBER_ALERT, "" + rs.getInt("add_myteam_member"));
				hmTaskNotification.put(NEW_JOINEE_PENDING_ALERT, "" + rs.getInt("new_joinee_pending"));
				hmTaskNotification.put(NEWS_AND_ALERTS, "" + rs.getInt("news_and_alerts"));

				hmTaskNotification.put(LOAN_REQUEST_ALERT, "" + rs.getInt("loan_request"));
				hmTaskNotification.put(LOAN_APPROVAL_ALERT, "" + rs.getInt("loan_approval"));

				hmTaskNotification.put(SELF_REVIEW_REQUEST_ALERT, "" + rs.getInt("self_review_request"));
				hmTaskNotification.put(SELF_REVIEW_APPROVAL_ALERT, "" + rs.getInt("self_review_approval"));
				hmTaskNotification.put(EMP_CONFIRMATIONS_ALERT, "" + rs.getInt("emp_confirmations"));
				hmTaskNotification.put(EMP_RESIGNATIONS_ALERT, "" + rs.getInt("emp_resignations"));
				hmTaskNotification.put(EMP_FINAL_DAY_ALERT, "" + rs.getInt("emp_final_day"));
				hmTaskNotification.put(TRAVEL_BOOKING_ALERT, rs.getString("travelbooking"));
				hmTaskNotification.put(LIBRARY_REQUEST_ALERT, rs.getString("library_request"));
				hmTaskNotification.put(LIBRARY_REQUEST_APPROVED_ALERT, rs.getString("library_req_approved"));
				hmTaskNotification.put(NEW_MANUAL_ALERT, rs.getString("new_manual"));
				hmTaskNotification.put(MEETING_ROOM_BOOKING_REQUEST_ALERT, rs.getString("meeting_room_booking_request"));
				hmTaskNotification.put(MEETING_ROOM_BOOKING_REQUEST_APPROVED_ALERT, rs.getString("meeting_room_booking_req_approved"));
				hmTaskNotification.put(FOOD_REQUEST_ALERT, rs.getString("food_request"));
				hmTaskNotification.put(NEW_CANDIDATE_FILL_ALERT, rs.getString("new_canditate_fill"));
				hmTaskNotification.put(EMP_TERMINATED_ALERT, rs.getString("emp_terminations"));
				hmTaskNotification.put(FORM16_RELEASE_ALERT, rs.getString("form16_release"));
				hmTaskNotification.put(HOD_REVIEW_ALERT, rs.getString("hod_reviews"));
				hmTaskNotification.put(CEO_REVIEW_ALERT, rs.getString("ceo_reviews"));
			}
			rs.close();
			pst.close();
			// System.out.println(empId+ "  SELF_REVIEW_REQUEST_ALERT ======> "
			// +hmTaskNotification.get(SELF_REVIEW_REQUEST_ALERT));

			pst = con.prepareStatement(getUnreadMailCount);
			pst.setInt(1, uF.parseToInt(empId));
			rs = pst.executeQuery();
			while (rs.next()) {
				hmTaskNotification.put("MAIL_CNT", "" + rs.getInt("count"));
			}
			rs.close();
			pst.close();

			// if(empType != null && (empType.equalsIgnoreCase(MANAGER) ||
			// empType.equalsIgnoreCase(HRMANAGER) ||
			// empType.equalsIgnoreCase(ADMIN))){
			// int nExceptionCount =
			// getExceptionCount(con,request,CF,uF,empType,empId,session);
			// hmTaskNotification.put("EXCEPTION_CNT",""+nExceptionCount);
			// }

			request.setAttribute("hmTaskNotification", hmTaskNotification);
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			db.closeResultSet(rs);
			db.closeStatements(pst);
			db.closeConnection(con);
		}
	}

	public int getExceptionCount(Connection con, HttpServletRequest request, CommonFunctions CF, UtilityFunctions uF, String empType, String empId,
			HttpSession session) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		int nExceptionCount = 0;

		try {

			// uF.getCurrentDate(CF.getStrTimeZone())
			String orgId = CF.getEmpOrgId(con, uF, empId);
			String[] currArr = CF.getCurrentPayCycleByOrg(con, CF.getStrTimeZone(), CF, orgId);

			if (currArr != null && currArr.length > 0 && currArr[0] != null && !currArr[0].trim().equals("") && !currArr[0].trim().equalsIgnoreCase("NULL")
					&& currArr[1] != null && !currArr[1].trim().equals("") && !currArr[1].trim().equalsIgnoreCase("NULL")) {
				UpdateClockEntries clockEntries = new UpdateClockEntries();
				clockEntries.session = session;
				clockEntries.request = request;
				clockEntries.CF = CF;
				// clockEntries.strUserType = (String)
				// session.getAttribute(USERTYPE);
				clockEntries.strUserType = empType;
				clockEntries.strSessionEmpId = (String) session.getAttribute(EMPID);
				clockEntries.strD1 = currArr[0];
				clockEntries.strD2 = currArr[1];
				clockEntries.setF_org(orgId);
				clockEntries.viewClockEntriesExceptionCount(null, null, uF);

				Map<String, String> hmEmpLevelMap = (Map<String, String>) request.getAttribute("hmEmpLevelMap1");
				if (hmEmpLevelMap == null)
					hmEmpLevelMap = new HashMap<String, String>();
				Map<String, Set<String>> hmWeekEndHalfDates = (Map<String, Set<String>>) request.getAttribute("hmWeekEndHalfDates1");
				if (hmWeekEndHalfDates == null)
					hmWeekEndHalfDates = new HashMap<String, Set<String>>();
				Map<String, Set<String>> hmWeekEndDates = (Map<String, Set<String>>) request.getAttribute("hmWeekEndDates1");
				if (hmWeekEndDates == null)
					hmWeekEndDates = new HashMap<String, Set<String>>();
				Map<String, String> hmEmpWlocation = (Map<String, String>) request.getAttribute("hmEmpWlocation1");
				if (hmEmpWlocation == null)
					hmEmpWlocation = new HashMap<String, String>();
				List<String> alEmpCheckRosterWeektype = (List<String>) request.getAttribute("alEmpCheckRosterWeektype1");
				if (alEmpCheckRosterWeektype == null)
					alEmpCheckRosterWeektype = new ArrayList<String>();
				Map<String, Set<String>> hmRosterWeekEndDates = (Map<String, Set<String>>) request.getAttribute("hmRosterWeekEndDates1");
				if (hmRosterWeekEndDates == null)
					hmRosterWeekEndDates = new HashMap<String, Set<String>>();

				Map<String, String> hmHolidays = (Map<String, String>) request.getAttribute("hmHolidays1");
				if (hmHolidays == null)
					hmHolidays = new HashMap<String, String>();
				Map<String, String> hmHolidayDates = (Map<String, String>) request.getAttribute("hmHolidayDates1");
				if (hmHolidayDates == null)
					hmHolidayDates = new HashMap<String, String>();

				List alEmp = (List) request.getAttribute("TIMESHEET_EMP1");
				if (alEmp == null)
					alEmp = new ArrayList();

				Map<String, List<String>> hmEmpSbu = (Map<String, List<String>>) request.getAttribute("hmEmpSbu1");
				if (hmEmpSbu == null)
					hmEmpSbu = new HashMap<String, List<String>>();

				Map hmTime = (Map) request.getAttribute("TIMESHEET_1");
				Map hmEmpName = (Map) request.getAttribute("TIMESHEET_EMPNAME1");
				Map hmServicesMap = (Map) request.getAttribute("TIMESHEET_SERVICENAME1");
				Map hmExceptionReason = (Map) request.getAttribute("hmExceptionReason1");
				Map hmGenderMap = (Map) request.getAttribute("hmGenderMap1");

				List alDt = (List) request.getAttribute("TIMESHEET_DATE1");
				List alService = (List) request.getAttribute("TIMESHEET_SERVICE1");

				int nCount = 0;
				int rowCount = 0;
				String strColour = "";
				boolean isRowCountFirst = false;
				int i = 0;
				// int k=0;
				for (i = 0; i < alEmp.size(); i++) {

					Map hmExceptionInner = (Map) hmExceptionReason.get((String) alEmp.get(i));
					if (hmExceptionInner == null)
						hmExceptionInner = new HashMap();

					List<String> alEmpSbu = hmEmpSbu.get((String) alEmp.get(i));
					if (alEmpSbu == null)
						alEmpSbu = new ArrayList<String>();

					String strWLocationId = hmEmpWlocation.get((String) alEmp.get(i));
					Set<String> weeklyOffSet = hmWeekEndDates.get(strWLocationId);
					if (weeklyOffSet == null)
						weeklyOffSet = new HashSet<String>();

					Set<String> halfDayWeeklyOffSet = hmWeekEndHalfDates.get(strWLocationId);
					if (halfDayWeeklyOffSet == null)
						halfDayWeeklyOffSet = new HashSet<String>();

					Set<String> rosterWeeklyOffSet = hmRosterWeekEndDates.get((String) alEmp.get(i));
					if (rosterWeeklyOffSet == null)
						rosterWeeklyOffSet = new HashSet<String>();

					// for(k=0; k<alDt.size(); k++){
					for (int k = alDt.size() - 1; k >= 0; k--) {

						for (int j = 0; j < alService.size(); j++) {

							if (!alEmpSbu.contains(alService.get(j))) {
								continue;
							}

							Map hmAS = (Map) hmTime.get(uF.getDateFormat((String) alDt.get(k), IConstants.DBDATE, CF.getStrReportDateFormat())
									+ (String) alService.get(j) + "_AS");
							Map hmAE = (Map) hmTime.get(uF.getDateFormat((String) alDt.get(k), IConstants.DBDATE, CF.getStrReportDateFormat())
									+ (String) alService.get(j) + "_AE");
							Map hmRS = (Map) hmTime.get(uF.getDateFormat((String) alDt.get(k), IConstants.DBDATE, CF.getStrReportDateFormat())
									+ (String) alService.get(j) + "_RS");
							Map hmRE = (Map) hmTime.get(uF.getDateFormat((String) alDt.get(k), IConstants.DBDATE, CF.getStrReportDateFormat())
									+ (String) alService.get(j) + "_RE");
							Map hmReason_OUT = (Map) hmTime.get(uF.getDateFormat((String) alDt.get(k), IConstants.DBDATE, CF.getStrReportDateFormat())
									+ (String) alService.get(j) + "_OUT_REASON");
							Map hmApprove_OUT = (Map) hmTime.get(uF.getDateFormat((String) alDt.get(k), IConstants.DBDATE, CF.getStrReportDateFormat())
									+ (String) alService.get(j) + "_OUT_APPROVE");
							Map hmReason_IN = (Map) hmTime.get(uF.getDateFormat((String) alDt.get(k), IConstants.DBDATE, CF.getStrReportDateFormat())
									+ (String) alService.get(j) + "_IN_REASON");
							Map hmApprove_IN = (Map) hmTime.get(uF.getDateFormat((String) alDt.get(k), IConstants.DBDATE, CF.getStrReportDateFormat())
									+ (String) alService.get(j) + "_IN_APPROVE");

							if (hmAS == null) {
								hmAS = new HashMap();
							}
							if (hmAE == null) {
								hmAE = new HashMap();
							}
							if (hmRS == null) {
								hmRS = new HashMap();
							}
							if (hmRE == null) {
								hmRE = new HashMap();
							}
							if (hmReason_IN == null) {
								hmReason_IN = new HashMap();
							}
							if (hmApprove_IN == null) {
								hmApprove_IN = new HashMap();
							}
							if (hmReason_OUT == null) {
								hmReason_OUT = new HashMap();
							}
							if (hmApprove_OUT == null) {
								hmApprove_OUT = new HashMap();
							}

							isRowCountFirst = false;

							rowCount++;
							isRowCountFirst = true;

							if (rowCount % 2 == 0) {
								strColour = "1";
							} else {
								strColour = "";
							}

							if ((String) hmAE.get((String) alEmp.get(i)) != null && ((String) hmAE.get((String) alEmp.get(i))).length() > 0) {
								nExceptionCount++;
							} else if (((String) hmAE.get((String) alEmp.get(i))) != null && ((String) hmAE.get((String) alEmp.get(i))).length() > 0
									&& ((String) hmExceptionInner.get((String) alDt.get(k) + "_" + (String) alService.get(j))) != null
									&& uF.parseToInt((String) hmExceptionInner.get((String) alDt.get(k) + "_" + (String) alService.get(j) + "_STATUS")) == 0) {
								nExceptionCount++;
							}

							if (((String) hmAS.get((String) alEmp.get(i))) != null && ((String) hmAE.get((String) alEmp.get(i))) != null
									&& ((String) hmAS.get((String) alEmp.get(i))).length() == 0 && ((String) hmAE.get((String) alEmp.get(i))).length() == 0) {
								if (((String) hmExceptionInner.get((String) alDt.get(k) + "_" + (String) alService.get(j))) != null
										&& uF.parseToInt(((String) hmExceptionInner.get((String) alDt.get(k) + "_" + (String) alService.get(j) + "_STATUS"))) == 0) {
									if (alEmpCheckRosterWeektype.contains((String) alEmp.get(i))) {
										if (rosterWeeklyOffSet.contains(uF.getDateFormat((String) alDt.get(k), IConstants.DBDATE, IConstants.DATE_FORMAT))) {
											continue;
										}
									} else if (weeklyOffSet.contains(uF.getDateFormat((String) alDt.get(k), IConstants.DBDATE, IConstants.DATE_FORMAT))) {
										continue;
									} else if (halfDayWeeklyOffSet.contains(uF.getDateFormat((String) alDt.get(k), IConstants.DBDATE, IConstants.DATE_FORMAT))) {
										continue;
									} else if (hmHolidayDates.containsKey(uF.getDateFormat(
											uF.getDateFormat((String) alDt.get(k), IConstants.DBDATE, IConstants.DATE_FORMAT), IConstants.DATE_FORMAT,
											CF.getStrReportDateFormat())
											+ "_" + strWLocationId)) {
										continue;
									}
									nExceptionCount++;
								}

							} else if (((String) hmAS.get((String) alEmp.get(i))) != null && ((String) hmAS.get((String) alEmp.get(i))).length() > 0) {
								if ((String) hmReason_IN.get((String) alEmp.get(i)) != null) {
									nExceptionCount++;
								}
							} else {
								if (((String) hmExceptionInner.get((String) alDt.get(k) + "_" + (String) alService.get(j))) != null
										&& (String) hmRS.get((String) alEmp.get(i)) != null) {
									nExceptionCount++;
								} else if (((String) hmExceptionInner.get((String) alDt.get(k) + "_" + (String) alService.get(j))) != null
										&& (String) hmRE.get((String) alEmp.get(i)) != null) {
									nExceptionCount++;
								}
							}
						}
					}
				}
			}
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
		}

		return nExceptionCount;
	}

	public Map<String, String> getLeaveEncashment(Connection con, UtilityFunctions uF, String strD1, String strD2, String strPC) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmLeaveEncashment = new HashMap<String, String>();

		try {
			pst = con.prepareStatement("select sum(no_days) as no_days ,emp_id from emp_leave_encashment where paid_from= ? and paid_to=? "
					+ "and paycycle=? and is_approved=1 and is_paid=false group by emp_id");
			pst.setDate(1, uF.getDateFormat(strD1, DATE_FORMAT));
			pst.setDate(2, uF.getDateFormat(strD2, DATE_FORMAT));
			pst.setInt(3, uF.parseToInt(strPC));
			// System.out.println("pst===>>>>>>"+pst);
			rs = pst.executeQuery();
			while (rs.next()) {
				hmLeaveEncashment.put(rs.getString("emp_id"), rs.getString("no_days"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

		return hmLeaveEncashment;
	}

	public Map<String, String> getBalanceLeaveMapNew(Connection con, String strEmpId, CommonFunctions CF) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		// Map<String, String> hmBalance = new HashMap<String, String>();
		Map<String, String> hmMainBalance = new HashMap<String, String>();
		try {
			if (strEmpId != null) {

				pst = con
						.prepareStatement("select emp_id,leave_type_id,balance from leave_register1 where register_id in(select max(register_id) from leave_register1 "
								+ "where _type='C' and leave_type_id in (select leave_type_id from leave_type) group by emp_id,leave_type_id) order by emp_id,leave_type_id");
				rs = pst.executeQuery();
				while (rs.next()) {
					hmMainBalance.put(rs.getString("emp_id") + "_" + rs.getString("leave_type_id"), rs.getString("balance"));
				}
				rs.close();
				pst.close();

			} else {

				pst = con
						.prepareStatement("select sum(accrued) as accrued,a.leave_type_id,a.emp_id from "
								+ "(select max(_date) as daa,leave_type_id,emp_id from leave_register1 where _type='C' "
								+ "and leave_type_id in (select leave_type_id from leave_type) group by emp_id,leave_type_id)as a,leave_register1 lr "
								+ "where  _type!='C' and a.leave_type_id=lr.leave_type_id and a.daa<=lr._date and a.emp_id=lr.emp_id group by a.emp_id,a.leave_type_id order by a.emp_id,leave_type_id");
				rs = pst.executeQuery();
				Map<String, String> hmAccruedBalance = new HashMap<String, String>();
				while (rs.next()) {
					hmAccruedBalance.put(rs.getString("emp_id") + "_" + rs.getString("leave_type_id"), rs.getString("accrued"));
				}
				rs.close();
				pst.close();

				pst = con.prepareStatement("select sum(leave_no) as count,leave_type_id,emp_id from (select a.daa,lar.* from "
						+ "(select max(_date) as daa,leave_type_id,emp_id from leave_register1 where _type='C' "
						+ "and leave_type_id in (select leave_type_id from leave_type) group by emp_id,leave_type_id) as a,leave_application_register lar "
						+ "where a.emp_id=lar.emp_id and is_paid=true and (is_modify is null or is_modify=false) and a.leave_type_id=lar.leave_type_id "
						+ "and a.daa<=lar._date) as a group by leave_type_id,emp_id order by emp_id,leave_type_id");
				rs = pst.executeQuery();
				Map<String, String> hmPaidBalance = new HashMap<String, String>();
				while (rs.next()) {
					hmPaidBalance.put(rs.getString("emp_id") + "_" + rs.getString("leave_type_id"), rs.getString("count"));
				}
				rs.close();
				pst.close();

				pst = con
						.prepareStatement("select emp_id,leave_type_id,balance from leave_register1 where register_id in(select max(register_id) from leave_register1 "
								+ "where _type='C' and leave_type_id in (select leave_type_id from leave_type) group by emp_id,leave_type_id) order by emp_id,leave_type_id");
				rs = pst.executeQuery();
				while (rs.next()) {
					double accrued = uF.parseToDouble(hmAccruedBalance.get(rs.getString("emp_id") + "_" + rs.getString("leave_type_id")));
					double paid = uF.parseToDouble(hmPaidBalance.get(rs.getString("emp_id") + "_" + rs.getString("leave_type_id")));
					double balance = uF.parseToDouble(rs.getString("balance"));

					hmMainBalance.put(rs.getString("emp_id") + "_" + rs.getString("leave_type_id"), (balance + accrued - paid) + "");
				}
				rs.close();
				pst.close();

			}

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmMainBalance;

	}

	public double calculateProfessionalTax(Connection con, UtilityFunctions uF, double dblGross, String strFinancialYearStart, String strFinancialYearEnd,
			int nPayMonth, String strWLocationStateId, String strEmpGender) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		double dblDeductionPayMonth = 0;
		try {

			pst = con.prepareStatement("select * from deduction_details_india where income_from<=? and income_to>=? and state_id=? "
					+ "and financial_year_from=? and financial_year_to=? and gender =? limit 1");
			pst.setDouble(1, dblGross);
			pst.setDouble(2, dblGross);
			pst.setInt(3, uF.parseToInt(strWLocationStateId));
			pst.setDate(4, uF.getDateFormat(strFinancialYearStart, DATE_FORMAT));
			pst.setDate(5, uF.getDateFormat(strFinancialYearEnd, DATE_FORMAT));
			pst.setString(6, strEmpGender);
			rs = pst.executeQuery();
			double dblDeductionAmount = 0;
			double dblDeductionPaycycleAmount = 0;
			while (rs.next()) {
				dblDeductionAmount = rs.getDouble("deduction_amount");
				dblDeductionPaycycleAmount = rs.getDouble("deduction_paycycle");
			}
			rs.close();
			pst.close();
			// nPayMonth = uF.parseToInt(uF.getDateFormat(strD2, DATE_FORMAT,
			// "MM"));

			int nFinancialYearEndMonth = uF.parseToInt(uF.getDateFormat(strFinancialYearEnd, DATE_FORMAT, "MM"));
			nFinancialYearEndMonth = nFinancialYearEndMonth - 1;

			if (nFinancialYearEndMonth == nPayMonth) {
				dblDeductionPayMonth = dblDeductionAmount - (11 * dblDeductionPaycycleAmount);
			} else {
				dblDeductionPayMonth = dblDeductionPaycycleAmount;
			}

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return dblDeductionPayMonth;

	}

	public double calculateEEPF(Connection con, String strDomain, UtilityFunctions uF, double dblGross, String strFinancialYearStart,
			String strFinancialYearEnd, Map<String, String> hmTotal, String strEmpId, String strMonth, String strPaycycle) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		double dblCalculatedAmount = 0;

		Database db = null;
		try {
			if (con == null) {
				db = new Database();
				db.setRequest(request);
				db.setDomain(strDomain);
				con = db.makeConnection(con);
			}

			pst = con
					.prepareStatement("select * from epf_details where financial_year_start=? and financial_year_end =? "
							+ "and org_id in (select org_id from employee_official_details where emp_id=?) and level_id in (select ld.level_id from grades_details gd, "
							+ "level_details ld, designation_details dd where gd.designation_id = dd.designation_id and dd.level_id = ld.level_id  "
							+ "and gd.grade_id in (select grade_id from employee_official_details where emp_id=? ))");
			pst.setDate(1, uF.getDateFormat(strFinancialYearStart, DATE_FORMAT));
			pst.setDate(2, uF.getDateFormat(strFinancialYearEnd, DATE_FORMAT));
			pst.setInt(3, uF.parseToInt(strEmpId));
			pst.setInt(4, uF.parseToInt(strEmpId));
			rs = pst.executeQuery();

			double dblEEPFAmount = 0;
			double dblMaxAmount = 0;
			String strSalaryHeads = null;
			while (rs.next()) {
				dblEEPFAmount = rs.getDouble("eepf_contribution");
				dblMaxAmount = rs.getDouble("epf_max_limit");
				strSalaryHeads = rs.getString("salary_head_id");
			}
			rs.close();
			pst.close();

			String[] arrSalaryHeads = null;
			if (strSalaryHeads != null) {
				arrSalaryHeads = strSalaryHeads.split(",");
			}

			double dblAmount = 0;
			for (int i = 0; arrSalaryHeads != null && i < arrSalaryHeads.length; i++) {
				dblAmount += uF.parseToDouble(hmTotal.get(arrSalaryHeads[i]));
			}

			/**
			 * Change on 24-04-2012
			 */

			if (dblAmount >= dblMaxAmount) {
				dblAmount = dblMaxAmount;

			}
			dblCalculatedAmount = (dblEEPFAmount * dblAmount) / 100;

			// dblCalculatedAmount = ( dblEEPFAmount * dblAmount ) / 100;
			// if(dblCalculatedAmount>=dblMaxAmount){
			// dblCalculatedAmount = dblMaxAmount;
			// }

			// System.out.println("dblCalculatedAmount===>"+dblCalculatedAmount);

			/**
			 * If VPF is to be calculated separately, the the below code needs
			 * to be commented
			 * 
			 * */

			// if(hmVoluntaryPF==null){
			// hmVoluntaryPF = new HashMap();
			// }
			// dblCalculatedAmount +=
			// uF.parseToDouble(hmVoluntaryPF.get("AMOUNT"));
			//
		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {

			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (db != null) {
				db.closeConnection(con);
			}
		}
		return dblCalculatedAmount;

	}

	public double getHRAExemptionCalculation(Connection con, UtilityFunctions uF, int nMonthsLeft, Map<String, String> hmPaidSalaryDetails,
			String strFinancialYearStart, String strFinancialYearEnd, String strEmpId, double dblHRA, double dblBasicDA, Map<String, String> hmEmpMertoMap,
			Map<String, String> hmEmpRentPaidMap) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		double dblHRAExemption = 0;

		try {

			pst = con.prepareStatement("select * from hra_exemption_details where financial_year_from = ? and financial_year_to =? ");
			pst.setDate(1, uF.getDateFormat(strFinancialYearStart, DATE_FORMAT));
			pst.setDate(2, uF.getDateFormat(strFinancialYearEnd, DATE_FORMAT));
			rs = pst.executeQuery();

			double dblCondition1 = 0;
			double dblCondition2 = 0;
			double dblCondition3 = 0;
			String strHraSalHeads = null;
			while (rs.next()) {
				dblCondition1 = rs.getDouble("condition1");
				dblCondition2 = rs.getDouble("condition2");
				dblCondition3 = rs.getDouble("condition3");
				strHraSalHeads = rs.getString("salary_head_id");
			}
			rs.close();
			pst.close();

			String[] hraSalaryHeads = null;
			if (strHraSalHeads != null) {
				hraSalaryHeads = strHraSalHeads.split(",");
			}

			double dblHraSalHeadsAmount = 0;
			for (int i = 0; hraSalaryHeads != null && i < hraSalaryHeads.length; i++) {
				dblHraSalHeadsAmount += uF.parseToDouble((String) hmPaidSalaryDetails.get(hraSalaryHeads[i]));
			}

			boolean isMetro = uF.parseToBoolean(hmEmpMertoMap.get(strEmpId));

			// String strBasicPaidAmount = hmPaidSalaryDetails.get(BASIC+"");
			String strHRAPaidAmount = hmPaidSalaryDetails.get(HRA + "");

			// log.debug("<===            ===>");
			// log.debug(HRA + " hmEmpPaidHRA==>" + hmPaidSalaryDetails);
			// log.debug("hmEmpPaidHRA.get(strEmpId)==>" +
			// hmPaidSalaryDetails.get(strEmpId));

			// String strMonthsLeft = uF.dateDifference(strD1, DATE_FORMAT,
			// strFinancialYearEnd, DATE_FORMAT);
			// int nMonthsLeft = uF.parseToInt(strMonthsLeft) / 30;

			// System.out.println("nMonthsLeft=="+nMonthsLeft);

			double dblBasicToBePaidAmount = nMonthsLeft * dblBasicDA;
			double dblHRAToBePaidAmount = nMonthsLeft * dblHRA;

			// double dblTotalBasicDAAmount =
			// uF.parseToDouble(strBasicPaidAmount) + dblBasicToBePaidAmount;
			double dblTotalBasicDAAmount = dblHraSalHeadsAmount + dblBasicToBePaidAmount;
			double dblTotalHRAAmount = uF.parseToDouble(strHRAPaidAmount) + dblHRAToBePaidAmount;

			double dblTotalRentPaid = uF.parseToDouble(hmEmpRentPaidMap.get(strEmpId));

			// if(strEmpId.equalsIgnoreCase("23")){
			// System.out.println("dblBasicToBePaidAmount====>"+dblBasicToBePaidAmount);
			// System.out.println("dblHRAToBePaidAmount====>"+dblHRAToBePaidAmount);
			// System.out.println("dblTotalBasicDAAmount====>"+dblTotalBasicDAAmount);
			// System.out.println("dblTotalHRAAmount====>"+dblTotalHRAAmount);
			// System.out.println("dblTotalRentPaid====>"+dblTotalRentPaid);
			// }

			// double dblRentPaidGreaterThanCondition1 = dblCondition1 *
			// dblTotalBasicDAAmount /100;
			double dblRentPaidGreaterThanCondition1 = 0;

			// log.debug("dblRentPaidGreaterThanCondition1==>" +
			// dblRentPaidGreaterThanCondition1);
			// log.debug("dblCondition1==>" + dblCondition1);
			// log.debug("dblTotalBasicDAAmount==>" + dblTotalBasicDAAmount);

			if (dblTotalRentPaid > dblRentPaidGreaterThanCondition1) {

				dblRentPaidGreaterThanCondition1 = dblCondition1 * dblTotalBasicDAAmount / 100;

				dblRentPaidGreaterThanCondition1 = dblTotalRentPaid - dblRentPaidGreaterThanCondition1;

			} else if (dblTotalRentPaid > 0) {
				dblRentPaidGreaterThanCondition1 = dblCondition1 * dblTotalBasicDAAmount / 100;

			}

			double dblRentPaidCondition23 = 0;

			if (isMetro) {
				dblRentPaidCondition23 = dblCondition2 * dblTotalBasicDAAmount / 100;
			} else {
				dblRentPaidCondition23 = dblCondition3 * dblTotalBasicDAAmount / 100;
			}

			dblHRAExemption = Math.min(dblTotalHRAAmount, dblRentPaidGreaterThanCondition1);
			// if(strEmpId.equalsIgnoreCase("23")){
			// System.out.println("1 dblHRAExemption====>"+dblHRAExemption);
			// }
			dblHRAExemption = Math.min(dblHRAExemption, dblRentPaidCondition23);

			// if(strEmpId.equalsIgnoreCase("23")){
			// System.out.println("dblTotalHRAAmount====>"+dblTotalHRAAmount);
			// System.out.println("dblRentPaidGreaterThanCondition1====>"+dblRentPaidGreaterThanCondition1);
			// System.out.println("dblRentPaidCondition23====>"+dblRentPaidCondition23);
			// System.out.println("dblHRAExemption====>"+dblHRAExemption);
			//
			// }

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return dblHRAExemption;

	}

	public String getAppendData(Connection con, List<String> strID, Map<String, String> mp) {
		StringBuilder sb = new StringBuilder();
		Map<String, String> hmDesignation = getEmpDesigMap(con);
		Map<String, String> hmEmpCode = getEmpCodeMap(con);

		if (strID != null) {
			for (int i = 0; i < strID.size(); i++) {
				if (i == 0) {
					sb.append("[" + hmEmpCode.get(strID.get(i)) + "] " + mp.get(strID.get(i)) + "(" + hmDesignation.get(strID.get(i)) + ")");
				} else {
					sb.append(", [" + hmEmpCode.get(strID.get(i)) + "] " + mp.get(strID.get(i)) + "(" + hmDesignation.get(strID.get(i)) + ")");
				}
			}
		} else {
			return null;
		}

		return sb.toString();
	}

	public String getAppendData(List<String> strID, Map<String, String> mp) {
		StringBuilder sb = new StringBuilder();
		int cnt = 0;
		if (strID != null) {
			for (int i = 0; i < strID.size(); i++) {
				if (!strID.get(i).trim().equals("")) {
					if (cnt == 0) {
						sb.append(mp.get(strID.get(i).trim()));
						cnt++;
					} else {
						sb.append(", " + mp.get(strID.get(i).trim()));
					}
				}
			}
		} else {
			return null;
		}

		return sb.toString();
	}

	public String getMaxTimeLimitIN() {
		return maxTimeLimitIN;
	}

	public void setMaxTimeLimitIN(String maxTimeLimitIN) {
		this.maxTimeLimitIN = maxTimeLimitIN;
	}

	public String getMaxTimeLimitOUT() {
		return maxTimeLimitOUT;
	}

	public void setMaxTimeLimitOUT(String maxTimeLimitOUT) {
		this.maxTimeLimitOUT = maxTimeLimitOUT;
	}

	public String getProjectDocumentFolder() {
		return projectDocumentFolder;
	}

	public void setProjectDocumentFolder(String projectDocumentFolder) {
		this.projectDocumentFolder = projectDocumentFolder;
	}

	public String getRetriveProjectDocumentFolder() {
		return retriveProjectDocumentFolder;
	}

	public void setRetriveProjectDocumentFolder(String retriveProjectDocumentFolder) {
		this.retriveProjectDocumentFolder = retriveProjectDocumentFolder;
	}

	public String getEmpEducations(Connection con, String strEmpId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		StringBuilder sbEduName = new StringBuilder();
		try {
			pst = con
					.prepareStatement("select eds.edu_id, eds.education_name from education_details ed , educational_details eds where ed.education_id = eds.edu_id and ed.emp_id = ? ");
			pst.setInt(1, uF.parseToInt(strEmpId));
			rs = pst.executeQuery();
			while (rs.next()) {

				if (sbEduName.toString().equals("")) {
					sbEduName.append(rs.getString("education_name"));
				} else {
					sbEduName.append(", " + rs.getString("education_name"));
				}
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return sbEduName.toString();
	}

	public boolean getOfficialFilledStatus(Connection con, UtilityFunctions uF, int intEmpId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		boolean isOfficialFilledStatus = true;
		try {

			pst = con.prepareStatement("select * from employee_official_details WHERE emp_id =?");
			pst.setInt(1, intEmpId);
			rs = pst.executeQuery();

			while (rs.next()) {
				if (rs.getString("depart_id") == null) {
					isOfficialFilledStatus = false;
				} else if (rs.getString("depart_id") == null) {
					isOfficialFilledStatus = false;
				} else if (rs.getString("supervisor_emp_id") == null) {
					isOfficialFilledStatus = false;
				} else if (rs.getString("wlocation_id") == null) {
					isOfficialFilledStatus = false;
				} else if (rs.getString("is_roster") == null) {
					isOfficialFilledStatus = false;
				} else if (rs.getString("emptype") == null) {
					isOfficialFilledStatus = false;
				} else if (rs.getString("grade_id") == null) {
					isOfficialFilledStatus = false;
				}
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return isOfficialFilledStatus;
	}

	public String getEmpTotalExperience(Connection con, String strEmpId) {

		PreparedStatement pst = null;
		UtilityFunctions uF = new UtilityFunctions();
		ResultSet rs = null;
		StringBuilder totalExp = new StringBuilder();
		try {

			pst = con.prepareStatement("select * from emp_prev_employment where emp_id = ? order by emp_id");
			pst.setInt(1, uF.parseToInt(strEmpId));
			rs = pst.executeQuery();
			// System.out.println("new Date ===> " + new Date());
			int noyear = 0, nomonth = 0, nodays = 0;
			long datediff = 0;
			while (rs.next()) {
				String datedif = uF.dateDifference(rs.getString("from_date"), DBDATE, rs.getString("to_date"), DBDATE);

				datediff += uF.parseToLong(datedif);
			}
			rs.close();
			pst.close();
			noyear += (int) (datediff / 365);
			nomonth += (int) ((datediff % 365) / 30);
			nodays += (int) ((datediff % 365) % 30);

			if (nodays > 30) {
				nomonth = nomonth + 1;
			}
			if (nomonth > 12) {
				nomonth = nomonth - 12;
				noyear = noyear + 1;
			}
			if (noyear > 1) {
				totalExp.append(noyear + " years ");
			} else if (noyear > 0) {
				totalExp.append(noyear + " year ");
			}
			if (noyear > 0 && nomonth > 0) {
				totalExp.append("and ");
			}
			if (nomonth > 1) {
				totalExp.append(nomonth + " months");
			} else if (nomonth > 0) {
				totalExp.append(nomonth + " month");
			}
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return totalExp.toString();

	}

	public List<List<String>> getElementList(Connection con, HttpServletRequest request) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		List<List<String>> elementouterList = new ArrayList<List<String>>();
		try {
			pst = con.prepareStatement("select * from appraisal_element order by appraisal_element_id");
			rs = pst.executeQuery();
			while (rs.next()) {
				List<String> innerList = new ArrayList<String>();
				innerList.add(rs.getString("appraisal_element_id"));
				innerList.add(rs.getString("appraisal_element_name"));
				elementouterList.add(innerList);
			}
			rs.close();
			pst.close();
			request.setAttribute("elementouterList", elementouterList);

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return elementouterList;
	}

	public Map getAttributes(Connection con, HttpServletRequest request, String empId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		UtilityFunctions uF = new UtilityFunctions();
		Map hmAttribData = new HashMap();
		try {

			pst = con.prepareStatement("select * from appraisal_element order by appraisal_element_id");
			rs = pst.executeQuery();
			List<List<String>> elementouterList = new ArrayList<List<String>>();
			while (rs.next()) {
				List<String> innerList = new ArrayList<String>();
				innerList.add(rs.getString("appraisal_element_id"));
				innerList.add(rs.getString("appraisal_element_name"));
				elementouterList.add(innerList);
			}
			rs.close();
			pst.close();
			request.setAttribute("elementouterList", elementouterList);

			List<String> alElementIds = new ArrayList<String>();
			Map<String, String> hmAnalysisSummaryMap = new HashMap<String, String>();
			Map<String, String> hmReviewAnalysisSummary = new HashMap<String, String>();
			StringBuilder sbQuery = new StringBuilder();
			sbQuery = new StringBuilder();
			sbQuery.append("select *,((marks*100/weightage)) as average from(select sum(marks) as marks, sum(weightage) as weightage,a.appraisal_element"
					+ " from (select appraisal_element,appraisal_attribute from appraisal_element_attribute where appraisal_attribute in (select "
					+ "aa.arribute_id from appraisal_attribute aa, appraisal_attribute_level aal where aal.attribute_id = aa.arribute_id) group by "
					+ "appraisal_element,appraisal_attribute) as a,appraisal_question_answer aqw where a.appraisal_attribute=aqw.appraisal_attribute ");
			sbQuery.append("and aqw.emp_id in (" + empId + ") ");
			sbQuery.append(" and aqw.appraisal_attribute >0 and weightage>0 group by a.appraisal_element) as aa order by aa.appraisal_element");
			pst = con.prepareStatement(sbQuery.toString());
			// System.out.println("pst ===>> " + pst);
			rs = pst.executeQuery();
			while (rs.next()) {
				// totAverage += uF.parseToDouble(rs.getString("average"));
				hmReviewAnalysisSummary.put(rs.getString("appraisal_element"), rs.getString("average"));
				if (rs.getInt("appraisal_element") > 0 && !alElementIds.contains(rs.getString("appraisal_element"))) {
					alElementIds.add(rs.getString("appraisal_element"));
				}
			}
			rs.close();
			pst.close();

			sbQuery = new StringBuilder();
			sbQuery.append("select gksrd.*, gd.goal_id,gd.goal_element from goal_kra_status_rating_details gksrd, goal_details gd "
					+ "where gksrd.goal_id=gd.goal_id and gksrd.emp_id in (" + empId + ") ");

			pst = con.prepareStatement(sbQuery.toString());
			// System.out.println("TAS pst ===>> " + pst);
			rs = pst.executeQuery();
			Map<String, String> hmElementwiseRatingAndCount = new HashMap<String, String>();
			while (rs.next()) {
				double totRating = uF.parseToDouble(hmElementwiseRatingAndCount.get(rs.getString("goal_element") + "_RATING"));
				int totCount = uF.parseToInt(hmElementwiseRatingAndCount.get(rs.getString("goal_element") + "_COUNT"));

				if ((rs.getString("manager_rating") != null && !rs.getString("manager_rating").equals(""))
						|| (rs.getString("hr_rating") != null && !rs.getString("hr_rating").equals(""))) {
					double strCurrGoalORTargetRating = (uF.parseToDouble(rs.getString("manager_rating")) + uF.parseToDouble(rs.getString("hr_rating"))) / 2;
					if (rs.getString("manager_rating") == null) {
						strCurrGoalORTargetRating = uF.parseToDouble(rs.getString("hr_rating"));
					} else if (rs.getString("hr_rating") == null) {
						strCurrGoalORTargetRating = uF.parseToDouble(rs.getString("manager_rating"));
					}
					totRating += strCurrGoalORTargetRating;
					totCount++;
					hmElementwiseRatingAndCount.put(rs.getString("goal_element") + "_RATING", totRating + "");
					hmElementwiseRatingAndCount.put(rs.getString("goal_element") + "_COUNT", totCount + "");
				}
				if (rs.getInt("goal_element") > 0 && !alElementIds.contains(rs.getString("goal_element"))) {
					alElementIds.add(rs.getString("goal_element"));
				}
			}
			rs.close();
			pst.close();

			Map<String, String> hmGKTAnalysisSummary = new HashMap<String, String>();
			for (int i = 0; alElementIds != null && i < alElementIds.size(); i++) {
				double elementAvgScore = 0.0d;
				if (uF.parseToDouble(hmElementwiseRatingAndCount.get(alElementIds.get(i) + "_COUNT")) > 0) {
					elementAvgScore = (uF.parseToDouble(hmElementwiseRatingAndCount.get(alElementIds.get(i) + "_RATING")) / uF
							.parseToDouble(hmElementwiseRatingAndCount.get(alElementIds.get(i) + "_COUNT"))) * 20;
				}
				hmGKTAnalysisSummary.put(alElementIds.get(i), elementAvgScore + "");
			}
			// System.out.println("TAS hmGKTAnalysisSummary ===>> " +
			// hmGKTAnalysisSummary);
			// request.setAttribute("hmGKTAnalysisSummary",
			// hmGKTAnalysisSummary);

			Map<String, String> hmEmpwiseGKTAnalysisSummary = new HashMap<String, String>();
			sbQuery = new StringBuilder();
			sbQuery.append("select sum(gksrd.user_rating) as user_rating, count(*) as cnt, gd.goal_element from goal_kra_emp_status_rating_details gksrd,"
					+ " goal_details gd where gksrd.goal_id=gd.goal_id and gksrd.emp_id in (" + empId + ") and user_type !='-' ");
			sbQuery.append(" group by gd.goal_element");
			pst = con.prepareStatement(sbQuery.toString());
			// System.out.println("TAS pst ===>> " + pst);
			rs = pst.executeQuery();
			while (rs.next()) {
				if ((rs.getString("user_rating") != null && !rs.getString("user_rating").equals(""))) {
					// double strCurrGoalORTargetRating =
					// rs.getDouble("user_rating")/ rs.getInt("cnt");
					double elementEmpAvgScore = (rs.getDouble("user_rating") / rs.getDouble("cnt")) * 20;
					hmEmpwiseGKTAnalysisSummary.put(rs.getString("goal_element"), elementEmpAvgScore + "");
					if (rs.getInt("goal_element") > 0 && !alElementIds.contains(rs.getString("goal_element"))) {
						alElementIds.add(rs.getString("goal_element"));
					}
				}
			}
			rs.close();
			pst.close();
			// System.out.println("TAS hmEmpwiseGKTAnalysisSummary ===>> " +
			// hmEmpwiseGKTAnalysisSummary);
			// request.setAttribute("hmEmpwiseGKTAnalysisSummary",hmEmpwiseGKTAnalysisSummary);

			// System.out.println("TAS alElementIds ===>> " + alElementIds);
			double totAverage = 0.0d;
			int totElementCnt = 0;
			for (int i = 0; alElementIds != null && i < alElementIds.size(); i++) {
				double dblTotScore = 0.0d;
				int intTotCount = 0;
				if (hmReviewAnalysisSummary != null && uF.parseToDouble(hmReviewAnalysisSummary.get(alElementIds.get(i))) > 0) {
					dblTotScore += uF.parseToDouble(hmReviewAnalysisSummary.get(alElementIds.get(i)));
					intTotCount++;
				}
				if (hmGKTAnalysisSummary != null && uF.parseToDouble(hmGKTAnalysisSummary.get(alElementIds.get(i))) > 0) {
					dblTotScore += uF.parseToDouble(hmGKTAnalysisSummary.get(alElementIds.get(i)));
					intTotCount++;
				}
				if (hmEmpwiseGKTAnalysisSummary != null && uF.parseToDouble(hmEmpwiseGKTAnalysisSummary.get(alElementIds.get(i))) > 0) {
					dblTotScore += uF.parseToDouble(hmEmpwiseGKTAnalysisSummary.get(alElementIds.get(i)));
					intTotCount++;
				}
				// System.out.println("dblTotScore ===>> " + dblTotScore);
				double elementwiseAvgScore = 0.0d;
				if (intTotCount > 0) {
					elementwiseAvgScore = dblTotScore / uF.parseToDouble(intTotCount + "");
					totElementCnt++;
				}
				totAverage += elementwiseAvgScore;
				hmAnalysisSummaryMap.put(alElementIds.get(i), elementwiseAvgScore + "");
			}
			if (totAverage > 0 && totElementCnt > 0) {
				totAverage = totAverage / totElementCnt;
			}
			request.setAttribute("hmAnalysisSummaryMap", hmAnalysisSummaryMap);
			request.setAttribute("totAverage", totAverage + "");

			Map<String, String> hmKRAAttributeId = new HashMap<String, String>();
			Map<String, String> hmGTAttributeId = new HashMap<String, String>();
			Map<String, String> hmAttributeIds = new HashMap<String, String>();
			Map<String, String> hmScoreAggregateMap = new HashMap<String, String>();

			Map<String, String> hmGTAttribAvg = new HashMap<String, String>();
			Map<String, String> hmAttribAvg = new HashMap<String, String>();
			Map<String, String> hmAttribEmpAvg = new HashMap<String, String>();
			pst = con
					.prepareStatement("select gksrd.*, gd.goal_attribute from goal_kra_status_rating_details gksrd, goal_details gd where gksrd.goal_id = gd.goal_id and gksrd.emp_id in ("
							+ empId + ")");
			rs = pst.executeQuery();
			Map<String, String> hmGTAttribRating = new HashMap<String, String>();
			while (rs.next()) {
				if ((rs.getString("manager_rating") != null && !rs.getString("manager_rating").equals(""))
						|| (rs.getString("hr_rating") != null && !rs.getString("hr_rating").equals(""))) {

					double strGoalwiseTaskRating = uF.parseToDouble(hmGTAttribRating.get(rs.getString("goal_attribute") + "_RATING"));
					int strGoalwiseTaskCount = uF.parseToInt(hmGTAttribRating.get(rs.getString("goal_attribute") + "_COUNT"));
					strGoalwiseTaskCount++;
					double strGoalwiseCurrTaskRating = (uF.parseToDouble(rs.getString("manager_rating")) + uF.parseToDouble(rs.getString("hr_rating"))) / 2;
					if (rs.getString("manager_rating") == null) {
						strGoalwiseCurrTaskRating = uF.parseToDouble(rs.getString("hr_rating"));
					} else if (rs.getString("hr_rating") == null) {
						strGoalwiseCurrTaskRating = uF.parseToDouble(rs.getString("manager_rating"));
					}
					strGoalwiseTaskRating += strGoalwiseCurrTaskRating;
					hmGTAttribRating.put(rs.getString("goal_attribute") + "_RATING", strGoalwiseTaskRating + "");
					hmGTAttribRating.put(rs.getString("goal_attribute") + "_COUNT", strGoalwiseTaskCount + "");
					hmAttributeIds.put(rs.getString("goal_attribute"), rs.getString("goal_attribute"));
					hmGTAttributeId.put(rs.getString("goal_attribute"), rs.getString("goal_attribute"));

					double strCurrGoalORTargetRating = (uF.parseToDouble(rs.getString("manager_rating")) + uF.parseToDouble(rs.getString("hr_rating"))) / 2;
					if (rs.getString("manager_rating") == null) {
						strCurrGoalORTargetRating = uF.parseToDouble(rs.getString("hr_rating"));
					} else if (rs.getString("hr_rating") == null) {
						strCurrGoalORTargetRating = uF.parseToDouble(rs.getString("manager_rating"));
					}
					hmAttribAvg.put(rs.getString("goal_attribute"), strCurrGoalORTargetRating + "");
					hmAttributeIds.put(rs.getString("goal_attribute"), rs.getString("goal_attribute"));
				}
			}
			rs.close();
			pst.close();

			sbQuery = new StringBuilder();
			sbQuery.append("select sum(gksrd.user_rating) as user_rating, count(*) as cnt, gd.goal_attribute from goal_kra_emp_status_rating_details gksrd, "
					+ "goal_details gd where gksrd.goal_id=gd.goal_id and gksrd.emp_id in (" + empId + ") and user_type !='-' group by gd.goal_attribute");
			pst = con.prepareStatement(sbQuery.toString());
			// System.out.println("TAS pst ===>> " + pst);
			rs = pst.executeQuery();
			while (rs.next()) {
				if ((rs.getString("user_rating") != null && !rs.getString("user_rating").equals(""))) {
					// double strCurrGoalORTargetRating =
					// rs.getDouble("user_rating")/ rs.getInt("cnt");
					double goalEmpAvgScore = (rs.getDouble("user_rating") / rs.getDouble("cnt"));
					hmAttribEmpAvg.put(rs.getString("goal_attribute"), goalEmpAvgScore + "");
					hmAttributeIds.put(rs.getString("goal_attribute"), rs.getString("goal_attribute"));
				}
			}
			rs.close();
			pst.close();

			Map<String, String> hmKRAAttribRating = new HashMap<String, String>();

			pst = con
					.prepareStatement("select gksrd.*, gk.attribute_id from goal_kra_status_rating_details gksrd, goal_kras gk where gksrd.kra_id = gk.goal_kra_id and gksrd.emp_id in ("
							+ empId + ")");
			rs = pst.executeQuery();
			while (rs.next()) {

				if ((rs.getString("manager_rating") != null && !rs.getString("manager_rating").equals(""))
						|| (rs.getString("hr_rating") != null && !rs.getString("hr_rating").equals(""))) {

					double strGoalwiseTaskRating = uF.parseToDouble(hmKRAAttribRating.get(rs.getString("attribute_id") + "_RATING"));
					int strGoalwiseTaskCount = uF.parseToInt(hmKRAAttribRating.get(rs.getString("attribute_id") + "_COUNT"));
					strGoalwiseTaskCount++;
					double strGoalwiseCurrTaskRating = (uF.parseToDouble(rs.getString("manager_rating")) + uF.parseToDouble(rs.getString("hr_rating"))) / 2;
					if (rs.getString("manager_rating") == null) {
						strGoalwiseCurrTaskRating = uF.parseToDouble(rs.getString("hr_rating"));
					} else if (rs.getString("hr_rating") == null) {
						strGoalwiseCurrTaskRating = uF.parseToDouble(rs.getString("manager_rating"));
					}
					strGoalwiseTaskRating += strGoalwiseCurrTaskRating;
					hmKRAAttribRating.put(rs.getString("attribute_id") + "_RATING", strGoalwiseTaskRating + "");
					hmKRAAttribRating.put(rs.getString("attribute_id") + "_COUNT", strGoalwiseTaskCount + "");
					hmAttributeIds.put(rs.getString("attribute_id"), rs.getString("attribute_id"));
					hmKRAAttributeId.put(rs.getString("attribute_id"), rs.getString("attribute_id"));
				}
			}
			rs.close();
			pst.close();

			Map<String, String> hmReviewAggregate = new HashMap<String, String>();

			pst = con
					.prepareStatement("select *,(marks*100/weightage) as average from (select sum(marks) as marks, sum(weightage) as weightage, aqw.appraisal_attribute "
							+ " from appraisal_question_answer aqw where emp_id=? and weightage>0 group by aqw.appraisal_attribute) as a"); // and
																																			// aqw.appraisal_attribute
																																			// =
																																			// ?
			pst.setInt(1, uF.parseToInt(empId));
			rs = pst.executeQuery();
			// System.out.println("pst ===> "+pst);
			while (rs.next()) {
				double starAvg = uF.parseToDouble(rs.getString("average")) / 20;
				hmReviewAggregate.put(rs.getString("appraisal_attribute"), uF.showData(starAvg + "", "0"));
				hmAttributeIds.put(rs.getString("appraisal_attribute"), rs.getString("appraisal_attribute"));
			}
			rs.close();
			pst.close();

			Iterator<String> gtIt = hmGTAttributeId.keySet().iterator();
			while (gtIt.hasNext()) {
				String attribId = gtIt.next();
				String goalRating = hmGTAttribRating.get(attribId + "_RATING");
				String goalTaskCount = hmGTAttribRating.get(attribId + "_COUNT");
				double avgGoalRating = 0.0d;
				if (uF.parseToInt(goalTaskCount) > 0) {
					avgGoalRating = uF.parseToDouble(goalRating) / uF.parseToInt(goalTaskCount);
				}
				hmGTAttribAvg.put(attribId, avgGoalRating + "");
			}

			Iterator<String> kraIt = hmKRAAttributeId.keySet().iterator();
			while (kraIt.hasNext()) {
				String attribId = kraIt.next();
				String goalRating = hmKRAAttribRating.get(attribId + "_RATING");
				String goalTaskCount = hmKRAAttribRating.get(attribId + "_COUNT");
				double avgGoalRating = 0.0d;
				if (uF.parseToInt(goalTaskCount) > 0) {
					avgGoalRating = uF.parseToDouble(goalRating) / uF.parseToInt(goalTaskCount);
				}
				hmAttribAvg.put(attribId, avgGoalRating + "");
			}

			Iterator<String> it = hmAttributeIds.keySet().iterator();
			while (it.hasNext()) {
				String attribId = it.next();
				String gtAvg = hmGTAttribAvg.get(attribId);
				String goalAvg = hmAttribAvg.get(attribId);
				String goalEmpAvg = hmAttribEmpAvg.get(attribId);
				String reviewAvg = hmReviewAggregate.get(attribId);
				// System.out.println("gtAvg ===>> " + gtAvg
				// +" -- goalAvg ===>> " + goalAvg + " -- goalEmpAvg ===>> "
				// +goalEmpAvg + " -- reviewAvg ===>> " + reviewAvg);
				double avgAttribRating = 0.0d;
				if (uF.parseToDouble(goalAvg) > 0 && uF.parseToDouble(goalEmpAvg) > 0 && uF.parseToDouble(gtAvg) > 0 && uF.parseToDouble(reviewAvg) > 0) {
					avgAttribRating = (uF.parseToDouble(goalAvg) + uF.parseToDouble(goalEmpAvg) + uF.parseToDouble(gtAvg) + uF.parseToDouble(reviewAvg)) / 4;

				} else if (uF.parseToDouble(goalEmpAvg) > 0 && uF.parseToDouble(gtAvg) > 0 && uF.parseToDouble(reviewAvg) > 0) {
					avgAttribRating = (uF.parseToDouble(goalEmpAvg) + uF.parseToDouble(gtAvg) + uF.parseToDouble(reviewAvg)) / 3;

				} else if (uF.parseToDouble(goalAvg) > 0 && uF.parseToDouble(gtAvg) > 0 && uF.parseToDouble(reviewAvg) > 0) {
					avgAttribRating = (uF.parseToDouble(goalAvg) + uF.parseToDouble(gtAvg) + uF.parseToDouble(reviewAvg)) / 3;

				} else if (uF.parseToDouble(goalAvg) > 0 && uF.parseToDouble(goalEmpAvg) > 0 && uF.parseToDouble(reviewAvg) > 0) {
					avgAttribRating = (uF.parseToDouble(goalAvg) + uF.parseToDouble(goalEmpAvg) + uF.parseToDouble(reviewAvg)) / 3;

				} else if (uF.parseToDouble(goalAvg) > 0 && uF.parseToDouble(goalEmpAvg) > 0 && uF.parseToDouble(gtAvg) > 0) {
					avgAttribRating = (uF.parseToDouble(goalAvg) + uF.parseToDouble(goalEmpAvg) + uF.parseToDouble(gtAvg)) / 3;

				} else if (uF.parseToDouble(goalAvg) > 0 && uF.parseToDouble(goalEmpAvg) > 0) {
					avgAttribRating = (uF.parseToDouble(goalAvg) + uF.parseToDouble(goalEmpAvg)) / 2;

				} else if (uF.parseToDouble(goalAvg) > 0 && uF.parseToDouble(reviewAvg) > 0) {
					avgAttribRating = (uF.parseToDouble(goalAvg) + uF.parseToDouble(reviewAvg)) / 2;

				} else if (uF.parseToDouble(goalAvg) > 0 && uF.parseToDouble(gtAvg) > 0) {
					avgAttribRating = (uF.parseToDouble(goalAvg) + uF.parseToDouble(gtAvg)) / 2;

				} else if (uF.parseToDouble(reviewAvg) > 0 && uF.parseToDouble(gtAvg) > 0) {
					avgAttribRating = (uF.parseToDouble(reviewAvg) + uF.parseToDouble(gtAvg)) / 2;

				} else if (uF.parseToDouble(goalEmpAvg) > 0 && uF.parseToDouble(gtAvg) > 0) {
					avgAttribRating = (uF.parseToDouble(goalEmpAvg) + uF.parseToDouble(gtAvg)) / 2;

				} else if (uF.parseToDouble(goalEmpAvg) > 0 && uF.parseToDouble(reviewAvg) > 0) {
					avgAttribRating = (uF.parseToDouble(goalEmpAvg) + uF.parseToDouble(reviewAvg)) / 2;

				} else if (uF.parseToDouble(goalAvg) > 0) {
					avgAttribRating = uF.parseToDouble(goalAvg);

				} else if (uF.parseToDouble(goalEmpAvg) > 0) {
					avgAttribRating = uF.parseToDouble(goalEmpAvg);

				} else if (uF.parseToDouble(gtAvg) > 0) {
					avgAttribRating = uF.parseToDouble(gtAvg);

				} else if (uF.parseToDouble(reviewAvg) > 0) {
					avgAttribRating = uF.parseToDouble(reviewAvg);
				}
				hmScoreAggregateMap.put(attribId, avgAttribRating + "");
			}

			// System.out.println("hmScoreAggregateMap === >> " +
			// hmScoreAggregateMap);
			request.setAttribute("hmScoreAggregateMap", hmScoreAggregateMap);

			Map<String, String> empLevelMap = getEmpLevelMap(con);
			String empLevel = empLevelMap.get(empId);
			pst = con.prepareStatement("select aa.arribute_id,aa.attribute_name,aal.level_id,aal.element_id from appraisal_attribute aa, "
					+ "appraisal_attribute_level aal where aal.attribute_id = aa.arribute_id and aal.level_id = ?");
			pst.setInt(1, uF.parseToInt(empLevel));
			rs = pst.executeQuery();
			Map<String, List<List<String>>> hmElementAttribute = new HashMap<String, List<List<String>>>();
			while (rs.next()) {
				List<String> innerList = new ArrayList<String>();
				innerList.add(rs.getString("arribute_id"));
				innerList.add(rs.getString("attribute_name"));
				List<List<String>> attributeouterList = hmElementAttribute.get(rs.getString("element_id"));
				if (attributeouterList == null)
					attributeouterList = new ArrayList<List<String>>();
				attributeouterList.add(innerList);
				hmElementAttribute.put(rs.getString("element_id"), attributeouterList);
			}
			rs.close();
			pst.close();
			//
			//
			//
			// hmAttribData.put(empId+"_EA", hmElementAttribute);
			// hmAttribData.put(empId+"_EASA", hmScoreAggregateMap);
			request.setAttribute("hmElementAttribute", hmElementAttribute);
			// request.setAttribute("hmScoreAggregateMap", hmScoreAggregateMap);

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmAttribData;
	}

	/*
	 * public Map getAttributes(Connection con, HttpServletRequest request,
	 * String empId) {
	 * 
	 * PreparedStatement pst = null; ResultSet rs = null; UtilityFunctions uF =
	 * new UtilityFunctions(); Map hmAttribData = new HashMap(); try {
	 * 
	 * Map<String, String> empLevelMap = getEmpLevelMap(con);
	 * 
	 * String empLevel = empLevelMap.get(empId);
	 * 
	 * pst = con.prepareStatement(
	 * "select aa.arribute_id,aa.attribute_name,aal.level_id,aal.element_id from appraisal_attribute aa, "
	 * +
	 * "appraisal_attribute_level aal where aal.attribute_id = aa.arribute_id and aal.level_id = ?"
	 * ); pst.setInt(1, uF.parseToInt(empLevel)); rs = pst.executeQuery();
	 * Map<String,List<List<String>>> hmElementAttribute=new HashMap<String,
	 * List<List<String>>>(); while (rs.next()) { List<String> innerList=new
	 * ArrayList<String>(); innerList.add(rs.getString("arribute_id"));
	 * innerList.add(rs.getString("attribute_name")); List<List<String>>
	 * attributeouterList=hmElementAttribute.get(rs.getString("element_id"));
	 * if(attributeouterList==null) attributeouterList=new
	 * ArrayList<List<String>>(); attributeouterList.add(innerList);
	 * hmElementAttribute.put(rs.getString("element_id"), attributeouterList); }
	 * rs.close(); pst.close();
	 * 
	 * Map<String, String> hmScoreAggregateMap = new HashMap<String, String>();
	 * 
	 * pst = con.prepareStatement(
	 * "select *,(marks*100/weightage) as average from (select sum(marks) as marks, sum(weightage) as weightage, aqw.appraisal_attribute "
	 * +
	 * " from appraisal_question_answer aqw where emp_id=? group by aqw.appraisal_attribute) as a"
	 * ); //and aqw.appraisal_attribute = ? pst.setInt(1, uF.parseToInt(empId));
	 * rs = pst.executeQuery(); // System.out.println("pst ===> "+pst); while
	 * (rs.next()) {
	 * hmScoreAggregateMap.put(rs.getString("appraisal_attribute"),
	 * uF.showData(rs.getString("average"), "0")); } rs.close(); pst.close();
	 * 
	 * hmAttribData.put(empId+"_EA", hmElementAttribute);
	 * hmAttribData.put(empId+"_EASA", hmScoreAggregateMap);
	 * request.setAttribute("hmElementAttribute", hmElementAttribute);
	 * request.setAttribute("hmScoreAggregateMap", hmScoreAggregateMap);
	 * 
	 * } catch (Exception e) { e.printStackTrace(); } finally { if(rs != null) {
	 * try { rs.close(); } catch (SQLException e1) { e1.printStackTrace(); } }
	 * if(pst != null) { try { pst.close(); } catch (SQLException e1) {
	 * e1.printStackTrace(); } } } return hmAttribData; }
	 */

	public Map<String, String> getEmpProfileDetail(Connection con, HttpServletRequest request, HttpSession session, CommonFunctions CF, UtilityFunctions uF,
			String strUserType, String strEmpIdReq) {

		PreparedStatement pst = null;
		ResultSet rs = null;

		List<List<String>> alSkills = new ArrayList<List<String>>();
		Map<String, String> hmEmpProfile = new HashMap<String, String>();

		try {
			Map<String, String> hmFeatureStatus = getFeatureStatusMap(con);
			boolean flagMiddleName = uF.parseToBoolean(hmFeatureStatus.get(F_SHOW_EMPLOYEE_MIDDLE_NAME));

			String currDate = uF.getCurrentDate(CF.getStrTimeZone()) + "";

			Map<String, Map<String, String>> hmWorkLocationMap = getWorkLocationMap(con);
			Map<String, String> hmEmpName = getEmpNameMap(con, null, null);
			request.setAttribute("hmEmpName", hmEmpName);

			Map<String, String> hmEmpTypes = getEmployementTypeMap();

			Map<String, String> hmEmpResource = FillResourceType.getResourceData();
			if (hmEmpResource == null)
				hmEmpResource = new HashMap<String, String>();
			Map<String, String> hmStateMap = CF.getStateMap(con);
			Map<String, String> hmCountryMap = CF.getCountryMap(con);
			String empStatus = "";
			// pst =
			// con.prepareStatement("Select * from ( Select * from ( Select * from employee_personal_details epd left join employee_official_details eod on epd.emp_per_id=eod.emp_id where epd.emp_per_id=?) ast left join state s on ast.emp_state_id = s.state_id ) aco left join country co on aco.emp_country_id = co.country_id");
			pst = con.prepareStatement(" select a.*, org_name from org_details od right join(select a.*,wlocation_name from work_location_info wl right join("
					+ "select a.*,dept_name,dept_code from department_info d right join("
					+ "select a.*,level_code,level_name from level_details ld right join(select a.*,dd.designation_id,designation_code,designation_name,"
					+ "level_id from designation_details dd right join(select * from grades_details gd right join(select a.*,country_name from "
					+ "country co right join(select a.*,state_name from state s right join(select * from employee_personal_details epd, "
					+ "employee_official_details eod where epd.emp_per_id= ? and epd.emp_per_id=eod.emp_id) a on a.emp_state_id = s.state_id"
					+ ") a on a.emp_country_id = co.country_id) a on a.grade_id=gd.grade_id) a on a.designation_id=dd.designation_id"
					+ ") a on a.level_id=ld.level_id) a on a.depart_id=d.dept_id) a on a.wlocation_id=wl.wlocation_id" + ") a on a.org_id = od.org_id");
			pst.setInt(1, uF.parseToInt(strEmpIdReq));
			rs = pst.executeQuery();

			Map<String, String> hmStateName = getStateName(con);
			Map<String, String> hmCountryName = getCountryName(con);
			Map<String, String> hmSBUMap = getServicesMap(con, false);
			String joiningDate = null;
			int nGradeId = 0;
			while (rs.next()) {
				// System.out.println("strUserType===>"+strUserType);
				// String strMiddleName = (rs.getString("emp_mname") != null &&
				// !rs.getString("emp_mname").trim().equals("")) ?
				// rs.getString("emp_mname").trim() + " " : "";

				String strMiddleName = "";
				if (flagMiddleName) {
					if (rs.getString("emp_mname") != null && rs.getString("emp_mname").trim().length() > 0) {
						strMiddleName = " " + rs.getString("emp_mname");
					}
				}

				String strEmpName = rs.getString("emp_fname") + uF.showData(strMiddleName, "") + " " + rs.getString("emp_lname");

				if (strUserType != null
						&& (!strUserType.equalsIgnoreCase(EMPLOYEE) || !strUserType.equalsIgnoreCase(ARTICLE) || !strUserType.equalsIgnoreCase(CONSULTANT))) {
					request.setAttribute(TITLE, strEmpName + "'s Profile");
				}
				hmEmpProfile.put("EMP_ID", rs.getString("emp_per_id"));
				hmEmpProfile.put("EMPCODE", rs.getString("empcode"));
				hmEmpProfile.put("NAME", uF.showData(rs.getString("salutation"), "") + " " + strEmpName);
				hmEmpProfile.put("CURRENT_ADDRESS", uF.showData(rs.getString("emp_address1_tmp"), "") + " " + uF.showData(rs.getString("emp_address2_tmp"), ""));
				hmEmpProfile.put("CURRENT_CITY", rs.getString("emp_city_id_tmp"));
				hmEmpProfile.put("CURRENT_STATE", hmStateName.get(rs.getString("emp_state_id_tmp")));
				hmEmpProfile.put("CURRENT_COUNTRY", hmCountryName.get(rs.getString("emp_country_id_tmp")));
				hmEmpProfile.put("CURRENT_PINCODE", rs.getString("emp_pincode_tmp"));

				hmEmpProfile.put("ADDRESS", uF.showData(rs.getString("emp_address1"), "") + " " + uF.showData(rs.getString("emp_address2"), ""));
				hmEmpProfile.put("CITY", rs.getString("emp_city_id"));
				hmEmpProfile.put("STATE", rs.getString("state_name"));
				hmEmpProfile.put("COUNTRY", rs.getString("country_name"));
				hmEmpProfile.put("PINCODE", rs.getString("emp_pincode"));

				hmEmpProfile.put("CONTACT", rs.getString("emp_contactno"));
				hmEmpProfile.put("CONTACT_MOB", rs.getString("emp_contactno_mob"));
				hmEmpProfile.put("IMAGE", rs.getString("emp_image"));
				hmEmpProfile.put("COVER_IMAGE", rs.getString("emp_cover_image"));
				hmEmpProfile.put("EMAIL", rs.getString("emp_email"));
				hmEmpProfile.put("EMAIL_SEC", rs.getString("emp_email_sec"));
				hmEmpProfile.put("ORG_ID", rs.getString("org_id"));
				hmEmpProfile.put("ORG_NAME", rs.getString("org_name"));

				if (rs.getString("emp_email_sec") != null && rs.getString("emp_email_sec").indexOf("@") > 0) {
					hmEmpProfile.put("EMP_EMAIL", rs.getString("emp_email_sec"));
				} else {
					hmEmpProfile.put("EMP_EMAIL", rs.getString("emp_email"));
				}

				hmEmpProfile.put("SKYPE_ID", rs.getString("skype_id"));

				hmEmpProfile.put("DESIGNATION_ID", rs.getString("designation_id"));
				hmEmpProfile.put("DESIGNATION_NAME", rs.getString("designation_name"));
				hmEmpProfile.put("LEVEL_NAME", rs.getString("level_name"));
				hmEmpProfile.put("LEVEL_ID", rs.getString("level_id"));
				hmEmpProfile.put("GRADE_ID", rs.getString("grade_id"));
				hmEmpProfile.put("GRADE_NAME", rs.getString("grade_name"));
				nGradeId = uF.parseToInt(rs.getString("grade_id"));

				hmEmpProfile.put("GENDER", uF.getGender(rs.getString("emp_gender")));

				hmEmpProfile.put("UAN_NO", rs.getString("uan_no"));
				hmEmpProfile.put("UID_NO", rs.getString("uid_no"));
				hmEmpProfile.put("PAN_NO", rs.getString("emp_pan_no"));
				hmEmpProfile.put("MRD_NO", rs.getString("emp_mrd_no"));
				hmEmpProfile.put("PF_NO", rs.getString("emp_pf_no"));
				hmEmpProfile.put("ESIC_NO", rs.getString("emp_esic_no"));
				hmEmpProfile.put("GPF_ACC_NO", rs.getString("emp_gpf_no"));
				hmEmpProfile.put("IS_MEDICAL_PROFESSIONAL", rs.getString("is_medical_professional"));
				hmEmpProfile.put("EMP_KMC_NO", rs.getString("emp_kmc_no"));
				hmEmpProfile.put("EMP_KNC_NO", rs.getString("emp_knc_no"));
				hmEmpProfile.put("RENEWAL_DATE", uF.getDateFormat(rs.getString("renewal_date"), DBDATE, DATE_FORMAT_STR));

				hmEmpProfile.put("EMERGENCY_NAME", rs.getString("emergency_contact_name"));
				hmEmpProfile.put("EMERGENCY_NO", rs.getString("emergency_contact_no"));
		//===start parvez date: 30-07-2022===
				hmEmpProfile.put("EMERGENCY_RELATION", rs.getString("emergency_contact_relation"));
		//===end parvez date: 30-07-2022===		

				hmEmpProfile.put("DOCTOR_NAME", rs.getString("doctor_name"));
				hmEmpProfile.put("DOCTOR_NO", rs.getString("doctor_contact_no"));

				hmEmpProfile.put("DOB", uF.getDateFormat(rs.getString("emp_date_of_birth"), DBDATE, getStrReportDateFormat()));
				hmEmpProfile.put("MARITAL_STATUS", uF.getMaritalStatus(rs.getString("marital_status")));
				hmEmpProfile.put("PASSPORT_NO", rs.getString("passport_no"));
				hmEmpProfile.put("PASSPORT_EXPIRY", uF.getDateFormat(rs.getString("passport_expiry_date"), DBDATE, getStrReportDateFormat()));

				hmEmpProfile.put("WLOCATION_NAME", rs.getString("wlocation_name"));
				Map<String, String> hmWLocation = hmWorkLocationMap.get(rs.getString("wlocation_id"));
				if (hmWLocation == null) {
					hmWLocation = new HashMap<String, String>();
				}
				hmEmpProfile.put("WLOCATION_CITY", hmWLocation.get("WL_CITY"));
				hmEmpProfile.put("DEPARTMENT_NAME", rs.getString("dept_name"));

				// hmEmpProfile.put("SBU_NAME", rs.getString("service_name"));
				hmEmpProfile.put("SBU_ID", rs.getString("service_id"));
				List<String> sbuIdList = null;
				if (rs.getString("service_id") != null) {
					sbuIdList = Arrays.asList(rs.getString("service_id").split(","));
				}
				hmEmpProfile.put("SBU_NAME", getSBUNames(sbuIdList, hmSBUMap));
				String joinDate = "";
				if (rs.getString("joining_date") != null) {
					joinDate = uF.getDateFormat(rs.getString("joining_date"), DBDATE, getStrReportDateFormat());
				}

				String confirmDate = "";
				if (rs.getString("confirmation_date") != null) {
					confirmDate = uF.getDateFormat(rs.getString("confirmation_date"), DBDATE, getStrReportDateFormat());
				}

				String actConfirmDate = "";
				if (rs.getString("actual_confirmation_date") != null) {
					actConfirmDate = uF.getDateFormat(rs.getString("actual_confirmation_date"), DBDATE, getStrReportDateFormat());
				}

				String promotionDate = "";
				if (rs.getString("promotion_date") != null) {
					promotionDate = uF.getDateFormat(rs.getString("promotion_date"), DBDATE, getStrReportDateFormat());
				}

				String separationnDate = "";
				if (rs.getString("separation_date") != null) {
					separationnDate = uF.getDateFormat(rs.getString("separation_date"), DBDATE, getStrReportDateFormat());
				}

				hmEmpProfile.put("JOINING_DATE", joinDate);
				hmEmpProfile.put("CONFIRMATION_DATE", confirmDate);
				hmEmpProfile.put("ACT_CONFIRM_DATE", actConfirmDate);
				hmEmpProfile.put("PROMOTION_DATE", promotionDate);
				hmEmpProfile.put("SEPARATION_DATE", separationnDate);

				hmEmpProfile.put("EMP_TYPE", hmEmpTypes.get(rs.getString("emptype")));
				hmEmpProfile.put("EMPLOYMENT_TYPE", rs.getString("emp_status"));

				hmEmpProfile.put("SUPER_ID", rs.getString("supervisor_emp_id"));
				hmEmpProfile.put("EMP_IS_DISABLE_SAL_CALCULATE", rs.getString("is_disable_sal_calculate"));

				hmEmpProfile.put("SUPERVISOR_NAME", hmEmpName.get(rs.getString("supervisor_emp_id")));
				hmEmpProfile.put("HOD_NAME", hmEmpName.get(rs.getString("hod_emp_id")));
				hmEmpProfile.put("HR_NAME", hmEmpName.get(rs.getString("emp_hr")));

				hmEmpProfile.put("ROSTER_DEPENDENCY", uF.showYesNo(rs.getString("is_roster")));
				hmEmpProfile.put("ALLOWANCE", uF.showYesNo(rs.getString("first_aid_allowance")));

				if (rs.getString("joining_date") != null && rs.getString("employment_end_date") == null) {
					uF.getTimeDuration(rs.getString("joining_date"), CF, uF, request);
					hmEmpProfile.put("TIME_DURATION", uF.getTimeDurationWithNoSpan(rs.getString("joining_date"), CF, uF, request));
				} else if (rs.getString("joining_date") != null && rs.getString("employment_end_date") != null) {
					// uF.getTimeDuration(rs.getString("joining_date"), CF, uF,
					// request);
					hmEmpProfile.put("TIME_DURATION", uF.getTimeDurationWithNoSpan(rs.getString("joining_date"), rs.getString("employment_end_date"), CF, uF, request));
					request.setAttribute("TIME_DURATION", uF.getTimeDurationWithNoSpan(rs.getString("joining_date"), rs.getString("employment_end_date"), CF, uF, request));
				}

				hmEmpProfile.put("PAYOUT_TYPE", uF.getPaymentMode(rs.getString("payment_mode")));

				String emp_bank_acct_nbr = rs.getString("payment_mode") != null && rs.getString("payment_mode").equals("1") ? rs.getString("emp_bank_acct_nbr") : "";
				hmEmpProfile.put("EMP_ACT_NO", emp_bank_acct_nbr);

				hmEmpProfile.put("EMP_BANK_NAME", rs.getString("emp_bank_name"));
				
		//===start parvez date: 12-08-20222===
				String emp_other_bank_name = rs.getString("emp_bank_name") != null && rs.getString("emp_bank_name").equals("-1") ? rs.getString("emp_other_bank_name") : "";
				hmEmpProfile.put("EMP_OTHER_BANK_NAME", emp_other_bank_name);
		//===end parvez date: 12-08-20222===	
				
				String emp_other_bank_branch = rs.getString("emp_bank_name") != null && rs.getString("emp_bank_name").equals("-1") ? rs.getString("emp_other_bank_branch") : "";
				hmEmpProfile.put("EMP_OTHER_BANK_BRANCH", emp_other_bank_branch);

				String emp_Other_bank_IFSC_code = rs.getString("emp_bank_name") != null && rs.getString("emp_bank_name").equals("-1") ? rs
						.getString("emp_other_bank_acct_ifsc_code") : "";
				hmEmpProfile.put("EMP_OTHER_BANK_IFSC_CODE", emp_Other_bank_IFSC_code);

				Map<String, String> hmBankAccMap = getBankAccountDetailsMap(con, uF, rs.getString("emp_bank_name"));
				hmEmpProfile.put("EMP_IFSC_CODE", hmBankAccMap.get("IFSC_CODE"));
		//===start parvez date: 12-08-20222===		
				hmEmpProfile.put("EMP_STR_BANK_NAME", hmBankAccMap.get("BANK_NAME"));
		//===start parvez date: 12-08-20222===		
				
				hmEmpProfile.put("EMP_BLOOD_GROUP",
						(rs.getString("blood_group") != null && rs.getString("blood_group").equals("0")) ? "-" : rs.getString("blood_group"));

				hmEmpProfile.put("PAYCYCLE_DURATION", uF.charMapping(rs.getString("paycycle_duration")));
				hmEmpProfile.put("ATTENDANCE_DEPENDENCY", uF.showYesNo(rs.getString("is_attendance")));

				hmEmpProfile.put("BIOMATRIC_MACHINE_ID",
						(rs.getString("biometrix_id") != null && !rs.getString("biometrix_id").equals("0")) ? rs.getString("biometrix_id") : "");
				hmEmpProfile.put("IS_FORM16", rs.getString("is_form16"));
				hmEmpProfile.put("IS_FORM16_A", rs.getString("is_form16_a"));

				hmEmpProfile.put("CORPORATE_MOBILE", rs.getString("corporate_mobile_no"));
				hmEmpProfile.put("CORPORATE_DESK", rs.getString("corporate_desk"));
				hmEmpProfile.put("RELEVANT_EXPERIENCE", rs.getString("relevant_experience"));
				hmEmpProfile.put("TOTAL_EXPERIENCE", rs.getString("total_experience"));
				hmEmpProfile.put("HOUSE_NO", rs.getString("house_no"));
				hmEmpProfile.put("SUBURB", rs.getString("suburb"));

				String strEmpProfile = "";
				if (uF.parseToInt(rs.getString("emprofile")) > 0) {
					strEmpProfile = uF.showData(hmEmpResource.get(rs.getString("emprofile")), "");
				}
				hmEmpProfile.put("PROFILE", strEmpProfile);
				hmEmpProfile.put("PROFILE_ID", rs.getString("emprofile"));

				String strEmpContractor = "";
				if (uF.parseToInt(rs.getString("emp_contractor")) == 1) {
					strEmpContractor = "Employee";
				} else if (uF.parseToInt(rs.getString("emp_contractor")) == 2) {
					strEmpContractor = "Contractor";
				}
				hmEmpProfile.put("EMPLOYEE_CONTRACTOR", strEmpContractor);

				hmEmpProfile.put("MONTH_CTC", rs.getString("month_ctc"));
				hmEmpProfile.put("ANNUAL_CTC", rs.getString("annual_ctc"));
				if (rs.getString("emp_date_of_marriage") != null && !rs.getString("emp_date_of_marriage").equals("")) {
					hmEmpProfile.put("MARRAIGE_DATE", uF.getDateFormat(rs.getString("emp_date_of_marriage"), DBDATE, CF.getStrReportDateFormat()));
				} else {
					hmEmpProfile.put("MARRAIGE_DATE", "-");
				}

				StringBuilder pAddress = new StringBuilder();

				if (rs.getString("emp_address1") != null && !rs.getString("emp_address1").equals("") && !rs.getString("emp_address1").equals("null")) {
					pAddress.append(rs.getString("emp_address1") + ",");
				}

				if (rs.getString("emp_address2") != null && !rs.getString("emp_address2").equals("") && !rs.getString("emp_address2").equals("null")) {
					pAddress.append(rs.getString("emp_address2") + ",");
				}

				if (rs.getString("emp_city_id") != null && rs.getString("emp_city_id").equals("") && !rs.getString("emp_city_id").equals("null")) {
					pAddress.append(rs.getString("emp_city_id") + ",");
				}

				if (rs.getString("emp_state_id") != null && uF.parseToInt(rs.getString("emp_state_id")) > 0) {
					pAddress.append(hmStateMap.get(rs.getString("emp_state_id")) + ",");
				}

				if (rs.getString("emp_country_id") != null && uF.parseToInt(rs.getString("emp_country_id")) > 0) {
					pAddress.append(hmCountryMap.get(rs.getString("emp_country_id")) + ",");
				}

				if (rs.getString("emp_pincode") != null && !rs.getString("emp_pincode").equals("") && !rs.getString("emp_pincode").equals("null")) {
					pAddress.append(rs.getString("emp_pincode") + ".");
				}
				if (pAddress.length() == 0) {
					pAddress.append("-");
				}

				StringBuilder cAddress = new StringBuilder();
				if (rs.getString("emp_address1_tmp") != null && !rs.getString("emp_address1_tmp").equals("")
						&& !rs.getString("emp_address1_tmp").equals("null")) {
					cAddress.append(rs.getString("emp_address1_tmp") + ",");
				}

				if (rs.getString("emp_address2_tmp") != null && !rs.getString("emp_address2_tmp").equals("")
						&& !rs.getString("emp_address2_tmp").equals("null")) {
					cAddress.append(rs.getString("emp_address2_tmp") + ",");
				}

				if (rs.getString("emp_city_id_tmp") != null && !rs.getString("emp_city_id_tmp").equals("") && !rs.getString("emp_city_id_tmp").equals("null")) {
					cAddress.append(rs.getString("emp_city_id_tmp") + ",");
				}

				if (rs.getString("emp_state_id_tmp") != null && uF.parseToInt(rs.getString("emp_state_id_tmp")) > 0) {
					cAddress.append(hmStateMap.get(rs.getString("emp_state_id_tmp")) + ",");
				}

				if (rs.getString("emp_country_id_tmp") != null && uF.parseToInt(rs.getString("emp_country_id_tmp")) > 0) {
					cAddress.append(hmCountryMap.get(rs.getString("emp_country_id_tmp")) + ",");
				}

				if (rs.getString("emp_pincode_tmp") != null && !rs.getString("emp_pincode_tmp").equals("") && !rs.getString("emp_pincode_tmp").equals("null")) {
					cAddress.append(rs.getString("emp_pincode_tmp") + ".");
				}

				if (cAddress.length() == 0) {
					cAddress.append("-");
				}

				hmEmpProfile.put("EMP_PADDRESS", pAddress.toString());
				hmEmpProfile.put("EMP_CADDRESS", cAddress.toString());

				joiningDate = rs.getString("joining_date");
				empStatus = rs.getString("emp_status");
				
				//===start parvez date: 18-10-2021===
				hmEmpProfile.put("IS_ALIVE", rs.getString("is_alive"));
				hmEmpProfile.put("EMPLOYMENT_END_DATE", rs.getString("employment_end_date"));
				//===end parvez date: 18-10-2021===
			}
			rs.close();
			pst.close();

			// System.out.println("empStatus==>"+ empStatus);
			request.setAttribute("EMPSTATUS", empStatus);

			int nSalaryStrucuterType = uF.parseToInt(CF.getStrSalaryStructure());
			if (nSalaryStrucuterType == S_GRADE_WISE && nGradeId > 0) {
				getFitmentDetails(con, uF, CF, uF.parseToInt(hmEmpProfile.get("ORG_ID")), uF.parseToInt(hmEmpProfile.get("LEVEL_ID")),
						uF.parseToInt(hmEmpProfile.get("DESIGNATION_ID")), hmEmpProfile);
			}

			int year = 0;
			int days = 0;
			int months = 0;
			if (joiningDate != null && !joiningDate.equals("")) {
				LocalDate fromDate = new LocalDate(uF.parseToInt(uF.getDateFormat(joiningDate, DBDATE, "yyyy")), uF.parseToInt(uF.getDateFormat(joiningDate,
						DBDATE, "MM")), uF.parseToInt(uF.getDateFormat(joiningDate, DBDATE, "dd")));
				LocalDate toDate = new LocalDate(uF.parseToInt(uF.getDateFormat(currDate, DBDATE, "yyyy")), uF.parseToInt(uF.getDateFormat(currDate, DBDATE,
						"MM")), uF.parseToInt(uF.getDateFormat(currDate, DBDATE, "dd")));

				Period period = new Period(fromDate, toDate, PeriodType.yearMonthDay());
				year = year + period.getYears();
				months = months + period.getMonths();
				days = days + period.getDays();
			}

			// System.out.println("curr exp == >year==>"+year+"==>month==>"+months+"==day=="+days);
			StringBuilder sbTimeDuration = new StringBuilder();
			pst = con.prepareStatement("select * from emp_prev_employment where emp_id=?");
			pst.setInt(1, uF.parseToInt(strEmpIdReq));
			rs = pst.executeQuery();
			while (rs.next()) {

				String strStartDate = rs.getString("from_date");
				String strEndDate = rs.getString("to_date");
				if (strStartDate != null && !strStartDate.equals("") && strEndDate != null && !strEndDate.equals("")) {
					LocalDate fromDate = new LocalDate(uF.parseToInt(uF.getDateFormat(strStartDate, DBDATE, "yyyy")), uF.parseToInt(uF.getDateFormat(
							strStartDate, DBDATE, "MM")), uF.parseToInt(uF.getDateFormat(strStartDate, DBDATE, "dd")));
					LocalDate toDate = new LocalDate(uF.parseToInt(uF.getDateFormat(strEndDate, DBDATE, "yyyy")), uF.parseToInt(uF.getDateFormat(strEndDate,
							DBDATE, "MM")), uF.parseToInt(uF.getDateFormat(strEndDate, DBDATE, "dd")));

					Period period = new Period(fromDate, toDate, PeriodType.yearMonthDay());

					year = year + period.getYears();
					months = months + period.getMonths();
					days = days + period.getDays();

					if (months >= 12) {
						year = year + 1;
						months = months - 12;
					}
					if (days >= 30) {
						months = months + 1;
						days = days - 30;
					}
					if (months >= 12) {
						year = year + 1;
						months = months - 12;
					}
				}
				/*
				 * System.out.println("prev exp == >year==>"+year+"==>month==>"+
				 * months+"==day=="+days);
				 * System.out.println("startdate==>"+strStartDate
				 * +"==>strEndDate==>"+strEndDate);
				 */

			}
			rs.close();
			pst.close();

			if (year > 0 && year == 1) {
				sbTimeDuration.append(year + " year ");
			} else if (year > 0) {
				sbTimeDuration.append(year + " years ");
			}

			if (year > 0 && year > 0 && months > 0) {
				sbTimeDuration.append("and ");
			}

			if (months > 0 && months == 1) {
				sbTimeDuration.append(months + " month ");
			} else if (months > 0) {
				sbTimeDuration.append(months + " months ");
			}

			if (days > 0 && months > 0) {
				sbTimeDuration.append("and ");
			}

			if (days > 0 && days == 1) {
				sbTimeDuration.append(days + " day ");
			} else if (days > 0) {
				sbTimeDuration.append(days + " days ");
			}
			// System.out.println("Total exp1 ==>"+sbTimeDuration.toString());
			request.setAttribute("TOTAL_EXP", sbTimeDuration.toString());

			int intEmpIdReq = uF.parseToInt(strEmpIdReq);
			// request.setAttribute("myProfile", hmEmpProfile);

			EmpDashboardData objEmpDashboard = new EmpDashboardData(request, session, CF, uF, con, strEmpIdReq);
			objEmpDashboard.getEmpKPI();
			objEmpDashboard.getResignationStatus();
			objEmpDashboard.getProbationStatus();

			// alActivityDetails = CF.selectEmpActivityDetails(con, intEmpIdReq,
			// uF, CF);

			alSkills = selectSkills(con, intEmpIdReq);
			StringBuilder sbSkillsName = new StringBuilder();

			for (int i = 0; alSkills != null && !alSkills.isEmpty() && i < alSkills.size(); i++) {
				List<String> inneList = alSkills.get(i);
				if (sbSkillsName.toString().equals("")) {
					sbSkillsName.append(inneList.get(1));
				} else {
					sbSkillsName.append(", " + inneList.get(1));
				}
			}

			hmEmpProfile.put("SKILLS_NAME", sbSkillsName.toString());

			boolean isOfficialFilledStatus = getOfficialFilledStatus(con, uF, intEmpIdReq);
			String totExp = getEmpTotalExperience(con, strEmpIdReq);
			// System.out.println("isOfficialFilledStatus ===>> " +
			// isOfficialFilledStatus);
			hmEmpProfile.put("TOTAL_EXP", totExp);
			hmEmpProfile.put("OFFICIAL_FILLED_STATUS", "" + isOfficialFilledStatus);

			getEmpPreviousPromotionDetails(con, uF, CF, intEmpIdReq, hmEmpProfile);

			// System.out.println("hmEmpProfile ===>> " + hmEmpProfile);

			request.setAttribute("hmEmpProfile", hmEmpProfile);

			// request.setAttribute("alActivityDetails", alActivityDetails);

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

		return hmEmpProfile;
	}

	public Map<String, String> getEmployementTypeMap() {
		Map<String, String> hmEmpTypes = new HashMap<String, String>();

		hmEmpTypes.put("FT", "Full Time");
		hmEmpTypes.put("PT", "Part Time");
		hmEmpTypes.put("CON", "Contractual");
		hmEmpTypes.put("I", "Intern");
		hmEmpTypes.put("CT", "Contract");
		hmEmpTypes.put("R", "Regular");
		hmEmpTypes.put("PF", "Professional");
		hmEmpTypes.put("ST", "Stipend");
		hmEmpTypes.put("SCH", "Scholarship");
		hmEmpTypes.put("AT", "Article");
		hmEmpTypes.put("ORAT", "Outside Registered Article");
		hmEmpTypes.put("IHAT", "Inhouse Article");
		hmEmpTypes.put("CO", "Consultant");
		hmEmpTypes.put("FT", "Permanent (Full Time)");
		hmEmpTypes.put("PT", "Part Time");
		hmEmpTypes.put("P", "Partner");
		hmEmpTypes.put("C", "Temporary"); // Contract
		return hmEmpTypes;
	}

	public void getFitmentDetails(Connection con, UtilityFunctions uF, CommonFunctions CF, int nOrgId, int nLevelId, int nDesigId,
			Map<String, String> hmEmpProfile) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		try {
			StringBuilder sbQuery = new StringBuilder();
			sbQuery.append("select * from grades_details gd, designation_details dd where dd.designation_id = gd.designation_id "
					+ "and is_fitment=true and dd.level_id in (select ld.level_id from level_details ld "
					+ "where ld.org_id=? and ld.level_id=?) and dd.designation_id=? and dd.level_id > 0 order by gd.weightage desc");
			pst = con.prepareStatement(sbQuery.toString());
			pst.setInt(1, nOrgId);
			pst.setInt(2, nLevelId);
			pst.setInt(3, nDesigId);
			// System.out.println("pst==>"+pst);
			rs = pst.executeQuery();
			String strGradeIds = "";

			while (rs.next()) {
				if (strGradeIds.equals("")) {
					strGradeIds = rs.getString("grade_id");
				} else {
					strGradeIds += "," + rs.getString("grade_id");
				}
			}
			rs.close();
			pst.close();

			if (strGradeIds != null && !strGradeIds.equals("")) {
				pst = con.prepareStatement("select min(amount) as minscale, max(amount) as maxscale, "
						+ "max(increment_amount) as incrementamount from basic_fitment_details " + "where grade_id in(" + strGradeIds + ") and trail_status=1");
				// System.out.println("pst==>"+pst);
				rs = pst.executeQuery();
				while (rs.next()) {
					hmEmpProfile.put("MINSCALE", rs.getString("minscale"));
					hmEmpProfile.put("MAXSCALE", rs.getString("maxscale"));
					hmEmpProfile.put("INCREMENTAMOUNT", rs.getString("incrementamount"));
				}
				rs.close();
				pst.close();
			}

		} catch (Exception e) {
			e.printStackTrace();
		}

	}

	private Map<String, String> getStateName(Connection con) {

		PreparedStatement pst = null;
		ResultSet rs = null;

		Map<String, String> hmStateName = new HashMap<String, String>();

		try {

			pst = con.prepareStatement("select * from state");
			rs = pst.executeQuery();
			while (rs.next()) {
				hmStateName.put(rs.getString("state_id"), rs.getString("state_name"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmStateName;
	}

	private Map<String, String> getCountryName(Connection con) {

		PreparedStatement pst = null;
		ResultSet rs = null;

		Map<String, String> hmCountryName = new HashMap<String, String>();

		try {

			pst = con.prepareStatement("select * from country");
			rs = pst.executeQuery();
			while (rs.next()) {
				hmCountryName.put(rs.getString("country_id"), rs.getString("country_name"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmCountryName;
	}

	public List<List<String>> selectMedicalDetails(Connection con, int intEmpIdReq) {

		PreparedStatement pst = null;
		ResultSet rs = null;

		List<List<String>> alMedicalDetails = new ArrayList<List<String>>();

		try {

			pst = con.prepareStatement("select * from emp_medical_details where emp_id = ?");
			pst.setInt(1, intEmpIdReq);
			rs = pst.executeQuery();
			while (rs.next()) {
				List<String> innerList = new ArrayList<String>();
				innerList.add(rs.getString("question_id"));
				innerList.add(rs.getString("yes_no"));
				innerList.add(rs.getString("description"));
				innerList.add(rs.getString("filepath"));
				alMedicalDetails.add(innerList);
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return alMedicalDetails;
	}

	public List<Map<String, String>> selectReferences(Connection con, int intEmpIdReq) {

		PreparedStatement pst = null;
		ResultSet rs = null;

		List<Map<String, String>> empRefList = new ArrayList<Map<String, String>>();

		try {

			pst = con.prepareStatement("select * from emp_references where emp_id=? and ref_name!='' order by ref_id");
			pst.setInt(1, intEmpIdReq);
			rs = pst.executeQuery();

			while (rs.next()) {
				Map<String, String> hmInner = new HashMap<String, String>();
				hmInner.put("REF_ID", uF.showData(rs.getString("ref_id"), ""));
				hmInner.put("REF_NAME", uF.showData(rs.getString("ref_name"), ""));
				hmInner.put("REF_COMPANY", uF.showData(rs.getString("ref_company"), ""));
				hmInner.put("REF_DESIGNATION", uF.showData(rs.getString("ref_designation"), ""));
				hmInner.put("REF_CONTACT_NO", uF.showData(rs.getString("ref_contact_no"), ""));
				hmInner.put("REF_EMAIL", uF.showData(rs.getString("ref_email_id"), ""));

				empRefList.add(hmInner);
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return empRefList;
	}

	public void getEmpWorkedHours(Connection con, HttpServletRequest request, UtilityFunctions uF, String strEmpId) {

		PreparedStatement pst = null;
		ResultSet rs = null;

		try {
			pst = con.prepareStatement("SELECT sum(hours_worked) as hours_worked FROM attendance_details WHERE emp_id =?");
			pst.setInt(1, uF.parseToInt(strEmpId));
			rs = pst.executeQuery();
			double hrsWorked = 0;
			while (rs.next()) {
				hrsWorked = rs.getDouble("hours_worked");
			}
			rs.close();
			pst.close();

			request.setAttribute("HRS_WORKED", uF.formatIntoComma(hrsWorked));

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
	}

	private void getEmpPreviousPromotionDetails(Connection con, UtilityFunctions uF, CommonFunctions CF, int intEmpIdReq, Map<String, String> hmEmpProfile) {

		PreparedStatement pst = null;
		ResultSet rs = null;

		try {
			pst = con
					.prepareStatement("select * from employee_activity_details where emp_id = ? and activity_id = ? order by effective_date desc, emp_activity_id desc limit 2");
			pst.setInt(1, intEmpIdReq);
			pst.setInt(2, uF.parseToInt(ACTIVITY_PROMOTION_ID));
			// System.out.println("pst ===>> " + pst);
			rs = pst.executeQuery();
			Map<String, String> hmDesigMap = getDesigMap(con);
			while (rs.next()) {
				if (rs.isLast()) {
					hmEmpProfile.put("PREV_PROMOTION", uF.getDateFormat(rs.getString("effective_date"), DBDATE, CF.getStrReportDateFormat()));
					hmEmpProfile.put("PREV_DESIGNATION", hmDesigMap.get(rs.getString("desig_id")));
				}
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
	}

	public void getSalaryHeadsforEmployee(Connection con, HttpServletRequest request, CommonFunctions CF, UtilityFunctions uF, int intEmpIdReq,
			Map<String, String> hmEmpProfile) {

		// Map<String, Map<String, String>> hmSalaryHeadsPerService = new
		// LinkedHashMap<String, Map<String, String>>();
		// Map<String, Map<String, String>> hmSalaryHeadsPerServiceCTC = new
		// LinkedHashMap<String, Map<String, String>>();
		PreparedStatement pst = null;
		ResultSet rs = null;

		try {

			String[] strFinancialYearDates = new FillFinancialYears(request).fillLatestFinancialYears();
			String strFinancialYearStart = strFinancialYearDates[0];
			String strFinancialYearEnd = strFinancialYearDates[1];

			Map<String, String> hmEmpCurrency = CF.getEmpCurrency(con);
			if (hmEmpCurrency == null)
				hmEmpCurrency = new HashMap<String, String>();
			Map<String, Map<String, String>> hmCurrencyDetailsMap = CF.getCurrencyDetailsForPDF(con);
			if (hmCurrencyDetailsMap == null)
				hmCurrencyDetailsMap = new HashMap<String, Map<String, String>>();

			String strEmpGender = CF.getEmpGender(con, uF, "" + intEmpIdReq);

			String strCurrency = "";
			if (uF.parseToInt(hmEmpCurrency.get(intEmpIdReq + "")) > 0) {
				Map<String, String> hmCurrency = hmCurrencyDetailsMap.get(hmEmpCurrency.get(intEmpIdReq + ""));
				if (hmCurrency == null)
					hmCurrency = new HashMap<String, String>();
				strCurrency = uF.showData(hmCurrency.get("SHORT_CURR"), "");
			}

			// if (hmEmpProfile.get("SBU_ID") != null) {

			Map<String, String> hmEmpLevel = CF.getEmpLevelMap(con);
			String levelId = hmEmpLevel.get(intEmpIdReq + "");

			// for (String s : strServices) {

			Map<String, Double> hmSalaryTotal = new LinkedHashMap<String, Double>();
			// Map<String, String> hmInnerCTC = new LinkedHashMap<String,
			// String>();
			double grossAmount = 0.0d;
			double grossYearAmount = 0.0d;
			double deductAmount = 0.0d;
			double deductYearAmount = 0.0d;

			// pst = con.prepareStatement(selectEmpSalaryDetailsEarning1);
			pst = con.prepareStatement("SELECT * FROM (SELECT * FROM emp_salary_details WHERE emp_id = ? AND effective_date = (SELECT MAX("
					+ "effective_date) FROM emp_salary_details WHERE emp_id = ? and is_approved = true) AND effective_date <= ?) asd RIGHT JOIN "
					+ "salary_details sd ON asd.salary_head_id = sd.salary_head_id WHERE level_id = ? and asd.salary_head_id not in(" + GROSS + ") "
					+ "and (is_delete is null or is_delete=false) order by sd.earning_deduction desc, weight");
			pst.setInt(1, intEmpIdReq);
			pst.setInt(2, intEmpIdReq);
			pst.setDate(3, uF.getCurrentDate(CF.getStrTimeZone()));
			pst.setInt(4, uF.parseToInt(levelId));
			// System.out.println("pst ===>> " + pst);
			rs = pst.executeQuery();
			// Map<String, List<String>> hmSalaryHeadsDetail = new
			// HashMap<String, List<String>>();
			// System.out.println("pst ===>> " + pst);
			List alSalaryDuplicationTracer = new ArrayList();
			List<List<String>> salaryHeadDetailsList = new ArrayList<List<String>>();
			while (rs.next()) {

				List<String> innerList = new ArrayList<String>();
				innerList.add(rs.getString("salary_head_name"));
				innerList.add(rs.getString("earning_deduction"));
				innerList.add(uF.parseToBoolean(rs.getString("isdisplay")) ? rs.getString("amount") : "0");
				// hmInner.put(rs.getString("salary_head_name"),
				// uF.formatIntoTwoDecimal(uF.parseToDouble(rs.getString("amount"))));
				double dblYearAmount = (uF.parseToBoolean(rs.getString("isdisplay")) ? rs.getDouble("amount") : 0.0d) * 12;
				innerList.add("" + uF.formatIntoOneDecimalWithOutComma(dblYearAmount));
				innerList.add(rs.getString("salary_head_id"));
				innerList.add(rs.getString("is_variable"));

				// hmInnerCTC.put(rs.getString("salary_head_name"),
				// uF.formatIntoTwoDecimal(dblCTCAmount));
				if (rs.getString("earning_deduction").equals("E") && uF.parseToBoolean(rs.getString("isdisplay"))) {
					grossAmount += rs.getDouble("amount");
					grossYearAmount += dblYearAmount;
				}

				if (rs.getString("earning_deduction").equals("D") && uF.parseToBoolean(rs.getString("isdisplay"))) {
					deductAmount += rs.getDouble("amount");
					deductYearAmount += dblYearAmount;
				}

				// hmSalaryHeadsDetail.put(rs.getString("salary_head_id"),
				// innerList);

				int index = alSalaryDuplicationTracer.indexOf(rs.getString("salary_head_id"));

				if (index >= 0) {
					salaryHeadDetailsList.remove(index);
					salaryHeadDetailsList.add(index, innerList);
				} else {
					alSalaryDuplicationTracer.add(rs.getString("salary_head_id"));
					salaryHeadDetailsList.add(innerList);
				}
			}
			rs.close();
			pst.close();

			// System.out.println("salaryHeadDetailsList ===>> " +
			// salaryHeadDetailsList);

			hmSalaryTotal.put("GROSS_AMOUNT", grossAmount);
			hmSalaryTotal.put("GROSS_YEAR_AMOUNT", grossYearAmount);
			hmSalaryTotal.put("DEDUCT_AMOUNT", deductAmount);
			hmSalaryTotal.put("DEDUCT_YEAR_AMOUNT", deductYearAmount);
			// hmSalaryHeadsPerService.put(s, hmInner);
			// hmSalaryHeadsPerServiceCTC.put(s, hmInnerCTC);

			// }
			request.setAttribute("hmSalaryTotal", hmSalaryTotal);
			request.setAttribute("salaryHeadDetailsList", salaryHeadDetailsList);
			// request.setAttribute("hmSalaryHeadsDetail", hmSalaryHeadsDetail);
			// }

			// request.setAttribute("hmSalaryHeadsPerService",
			// hmSalaryHeadsPerService);
			// request.setAttribute("hmSalaryHeadsPerServiceCTC",
			// hmSalaryHeadsPerServiceCTC);

			pst = con
					.prepareStatement("select amount from payroll_generation where emp_id = ? and salary_head_id = ? and financial_year_from_date=? and financial_year_to_date=?");
			pst.setInt(1, intEmpIdReq);
			pst.setInt(2, PROFESSIONAL_TAX);
			pst.setDate(3, uF.getDateFormat(strFinancialYearStart, DATE_FORMAT));
			pst.setDate(4, uF.getDateFormat(strFinancialYearEnd, DATE_FORMAT));
			// System.out.println("pst ===>> " + pst);
			rs = pst.executeQuery();
			double dblAmount = 0;
			int nMonthCount = 0;
			while (rs.next()) {
				dblAmount += uF.parseToDouble(rs.getString("amount"));
				nMonthCount++;
			}
			rs.close();
			pst.close();

			int nTotalCount = 12;

			java.util.Date dtJoiningDt = uF.getDateFormatUtil((String) hmEmpProfile.get("JOINING_DATE"), CF.getStrReportDateFormat());
			java.util.Date dtFinancialYearStartDt = uF.getDateFormatUtil(strFinancialYearStart, DATE_FORMAT);
			java.util.Date dtFinancialYearEndDt = uF.getDateFormatUtil(strFinancialYearEnd, DATE_FORMAT);
			if (dtJoiningDt != null && dtJoiningDt.before(dtFinancialYearStartDt)) {
				nTotalCount = 12;
			} else if (dtJoiningDt != null) {
				int m1 = dtJoiningDt.getYear() * 12 + dtJoiningDt.getMonth();
				int m2 = dtFinancialYearEndDt.getYear() * 12 + dtFinancialYearEndDt.getMonth();
				nTotalCount = m2 - m1 + 1;
			}
			int nRemainingCount = nTotalCount - nMonthCount;

			pst = con
					.prepareStatement("select amount from emp_salary_details where emp_id = ? and earning_deduction = ? and is_approved =true and effective_date = (select max(effective_date) from emp_salary_details where emp_id = ? and earning_deduction = ? and is_approved = true)");
			pst.setInt(1, intEmpIdReq);
			pst.setString(2, "E");
			pst.setInt(3, intEmpIdReq);
			pst.setString(4, "E");
			// System.out.println("pst ===>> " + pst);
			rs = pst.executeQuery();
			double dblGrossAmount = 0;
			while (rs.next()) {
				dblGrossAmount += uF.parseToDouble(rs.getString("amount"));
			}
			rs.close();
			pst.close();

			Map hmEmpMertoMap = new HashMap();
			Map hmEmpWlocationMap = new HashMap();
			Map hmEmpStateMap = new HashMap();
			getEmpWlocationMap(con, hmEmpStateMap, hmEmpWlocationMap, hmEmpMertoMap);

			pst = con
					.prepareStatement("select  * from deduction_details_india where income_from<= ? and income_to>= ? and state_id=? and financial_year_from = (select max(financial_year_from) from deduction_details_india) limit 1");
			pst.setDouble(1, dblGrossAmount);
			pst.setDouble(2, dblGrossAmount);
			pst.setInt(3, uF.parseToInt((String) hmEmpStateMap.get(intEmpIdReq + "")));
			// System.out.println("pst ===>> " + pst);
			rs = pst.executeQuery();
			double dblDeductionAmount = 0;
			while (rs.next()) {
				dblDeductionAmount = rs.getDouble("deduction_amount");
			}
			rs.close();
			pst.close();

			ApprovePayroll objAppPayroll = new ApprovePayroll();
			objAppPayroll.CF = CF;
			objAppPayroll.request = request;

			double dblMonthlyAmount = objAppPayroll.calculateProfessionalTax(con, uF, null, dblGrossAmount, strFinancialYearStart, strFinancialYearEnd, 6,
					(String) hmEmpStateMap.get(intEmpIdReq + ""), strEmpGender);
			double dblVar = dblDeductionAmount - (dblMonthlyAmount * 12);
			dblAmount = dblAmount + (dblMonthlyAmount * nRemainingCount) + dblVar;

			request.setAttribute("dblAmount", strCurrency + uF.formatIntoOneDecimal(dblAmount));
			request.setAttribute("dblMonthlyAmount", strCurrency + uF.formatIntoOneDecimal(dblMonthlyAmount));

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

	}

	public List<List<String>> getEmpKRADetails(Connection con, String strEmpId, UtilityFunctions uF) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		List<List<String>> alKRADetails = new ArrayList<List<String>>();

		try {
			/*
			 * pst = con.prepareStatement(
			 * "SELECT goal_id FROM goal_details WHERE emp_ids like '%,"
			 * +strEmpId+",%' and goal_type = 8"); rs = pst.executeQuery(); int
			 * goalId = 0; while (rs.next()) { goalId = rs.getInt("goal_id"); }
			 */

			pst = con.prepareStatement("SELECT * FROM goal_kras WHERE emp_ids like '%," + strEmpId + ",%' and goal_type = " + EMPLOYEE_KRA
					+ " and is_assign = true and is_close = false");
			rs = pst.executeQuery();
			while (rs.next()) {
				List<String> innerList = new ArrayList<String>();
				innerList.add(uF.getDateFormat(rs.getString("effective_date"), DBDATE, getStrReportDateFormat()));
				innerList.add(rs.getString("kra_description"));
				alKRADetails.add(innerList);
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

		return alKRADetails;
	}

	public String getLoadingWeekDayCode(String str) {
		if (str != null) {
			if (str.equalsIgnoreCase("SUNDAY")) {
				return "SUN_LOADING";
			} else if (str.equalsIgnoreCase("MONDAY")) {
				return "MON_LOADING";
			} else if (str.equalsIgnoreCase("TUESDAY")) {
				return "TUE_LOADING";
			} else if (str.equalsIgnoreCase("WEDNESDAY")) {
				return "WED_LOADING";
			} else if (str.equalsIgnoreCase("THURSDAY")) {
				return "THURS_LOADING";
			} else if (str.equalsIgnoreCase("FRIDAY")) {
				return "FRI_LOADING";
			} else if (str.equalsIgnoreCase("SATURDAY")) {
				return "SAT_LOADING";
			} else {
				return "";
			}
		} else {
			return "";
		}
	}

	String getSBUNames(List<String> sbuIdList, Map<String, String> hmSBUMap) {

		StringBuilder sbuNames = new StringBuilder();
		int cnt = 0;
		for (int i = 0; sbuIdList != null && !sbuIdList.isEmpty() && i < sbuIdList.size(); i++) {
			if (!sbuIdList.get(i).equals("")) {
				if (cnt == 0) {
					sbuNames.append(hmSBUMap.get(sbuIdList.get(i)));
					cnt++;
				} else {
					sbuNames.append(", " + hmSBUMap.get(sbuIdList.get(i)));
				}
			}
		}
		return sbuNames.toString();
	}

	public Map<String, String> getUserTypeIdMap(Connection con) {

		Map<String, String> hmUserTypeIdMap = new HashMap<String, String>();

		PreparedStatement pst = null;
		ResultSet rs = null;

		try {

			pst = con.prepareStatement(selectUserTypeR);
			rs = pst.executeQuery();
			while (rs.next()) {
				hmUserTypeIdMap.put(rs.getString("user_type"), rs.getString("user_type_id"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

		return hmUserTypeIdMap;
	}

	public Map<String, String> getEmpServiceMap(Connection con) {
		Map<String, String> hmEmpService = new HashMap<String, String>();

		ResultSet rs = null;
		PreparedStatement pst = null;

		try {

			pst = con
					.prepareStatement("SELECT * FROM employee_official_details eod, employee_personal_details epd WHERE epd.emp_per_id=eod.emp_id order by emp_id");
			rs = pst.executeQuery();
			while (rs.next()) {
				hmEmpService.put(rs.getString("emp_id"), rs.getString("service_id"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmEmpService;
	}

	public Map<String, String> getOrgNameDepartIdwise(Connection con) {
		Map<String, String> hmOrg = new HashMap<String, String>();

		PreparedStatement pst = null;
		ResultSet rs = null;

		try {
			Map<String, String> hmOrgName = getOrgNameCode(con);
			pst = con.prepareStatement("select org_id,dept_id from department_info");
			rs = pst.executeQuery();
			while (rs.next()) {
				hmOrg.put(rs.getString("dept_id"), uF.showData(hmOrgName.get(rs.getString("org_id")), ""));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmOrg;
	}

	public Map<String, String> getOrgNameWLocationIdwise(Connection con) {
		Map<String, String> hmOrg = new HashMap<String, String>();

		PreparedStatement pst = null;
		ResultSet rs = null;

		try {
			Map<String, String> hmOrgName = getOrgName(con);

			pst = con.prepareStatement("select org_id,wlocation_id from work_location_info");
			rs = pst.executeQuery();
			while (rs.next()) {
				hmOrg.put(rs.getString("wlocation_id"), uF.showData(hmOrgName.get(rs.getString("org_id")), ""));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmOrg;
	}

	public String[] getCurrentPayCycleByOrg(String strTimeZone, CommonFunctions CF, String f_org, HttpServletRequest request) {
		Connection con = null;
		PreparedStatement pst = null;
		ResultSet rs = null;
		Database db = new Database();
		db.setRequest(request);
		UtilityFunctions uF = new UtilityFunctions();
		String[] strPayCycleDate = new String[3];

		try {

			con = db.makeConnection(con);

			String startDate = null;
			String strDisplayPaycycle = null;
			String strPaycycleDuration = null;

			pst = con
					.prepareStatement("select max (paycycle) as paycycle from payroll_generation where emp_id in (select emp_id from employee_official_details where org_id = ?)");
			pst.setInt(1, uF.parseToInt(f_org));
			rs = pst.executeQuery();
			int nPaidMaxPaycycle = 0;
			while (rs.next()) {
				nPaidMaxPaycycle = rs.getInt("paycycle");
			}
			rs.close();
			pst.close();
			nPaidMaxPaycycle = nPaidMaxPaycycle + 1;

			// System.out.println("nPaidMaxPaycycle ===>> " + nPaidMaxPaycycle);

			pst = con.prepareStatement("select * from org_details where org_id=? ");
			pst.setInt(1, uF.parseToInt(f_org));
			rs = pst.executeQuery();

			while (rs.next()) {
				startDate = rs.getString("start_paycycle");
				strDisplayPaycycle = rs.getString("display_paycycle");
				strPaycycleDuration = rs.getString("duration_paycycle");
			}
			rs.close();
			pst.close();
			// System.out.println("startDate ===>> " + startDate
			// +" -- strDisplayPaycycle ===>> " + strDisplayPaycycle +
			// " -- strPaycycleDuration ===>> " + strPaycycleDuration);

			String[] arrDisplayPAycycle = null;
			int minCycle = 0;
			int maxCycle = 0;
			if (strDisplayPaycycle != null) {
				arrDisplayPAycycle = strDisplayPaycycle.split("-");
				minCycle = uF.parseToInt(arrDisplayPAycycle[0]);
				maxCycle = uF.parseToInt(arrDisplayPAycycle[1]);
			}

			// System.out.println("minCycle ===>> " + minCycle +
			// " -- maxCycle ===>> " + maxCycle);
			Calendar calCurrent = GregorianCalendar.getInstance(TimeZone.getTimeZone((strTimeZone)));
			// System.out.println("calCurrent ===>> " + calCurrent);
			Calendar cal = GregorianCalendar.getInstance(TimeZone.getTimeZone(strTimeZone));
			cal.set(Calendar.DAY_OF_MONTH, uF.parseToInt(uF.getDateFormat(startDate, DBDATE, "dd")));
			cal.set(Calendar.MONTH, uF.parseToInt(uF.getDateFormat(startDate, DBDATE, "MM")) - 1);
			cal.set(Calendar.YEAR, uF.parseToInt(uF.getDateFormat(startDate, DBDATE, "yyyy")));

			StringBuilder sb = new StringBuilder();
			int nPayCycle = 0;

			int nDurationCount = 0;
			String dt1 = null;
			String dt2 = null;

			// java.util.Date strCurrentDate = calCurrent.getTime();
			java.util.Date strCurrentDate = uF.getDateFormatUtil(((calCurrent.get(Calendar.DAY_OF_MONTH) < 10)
					? "0" + calCurrent.get(Calendar.DAY_OF_MONTH)
					: calCurrent.get(Calendar.DAY_OF_MONTH))
					+ "/"
					+ (((calCurrent.get(Calendar.MONTH) + 1) < 10) ? "0" + (calCurrent.get(Calendar.MONTH) + 1) : (calCurrent.get(Calendar.MONTH) + 1))
					+ "/"
					+ calCurrent.get(Calendar.YEAR), DATE_FORMAT);

			java.util.Date strCurrentPayCycleD1 = null;
			java.util.Date strCurrentPayCycleD2 = null;

			while (true) {
				sb = new StringBuilder();
				nPayCycle++;

				if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("M")) {
					nDurationCount = cal.getActualMaximum(Calendar.DAY_OF_MONTH) - 1;
				} else if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("F")) {
					nDurationCount = 15 - 1;
					if (cal.get(Calendar.DAY_OF_MONTH) == 16) {
						int nActual = cal.getActualMaximum(Calendar.DAY_OF_MONTH);
						nDurationCount = nActual - 15 - 1;
					}
				} else if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("BW")) {
					nDurationCount = 14 - 1;
				} else if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("W")) {
					nDurationCount = 7 - 1;
				} else {
					nDurationCount = cal.getMaximum(Calendar.DAY_OF_MONTH) - 1;
				}

				dt1 = ((cal.get(Calendar.DAY_OF_MONTH) < 10) ? "0" + cal.get(Calendar.DAY_OF_MONTH) : cal.get(Calendar.DAY_OF_MONTH)) + "/"
						+ (((cal.get(Calendar.MONTH) + 1) < 10) ? "0" + (cal.get(Calendar.MONTH) + 1) : (cal.get(Calendar.MONTH) + 1)) + "/"
						+ cal.get(Calendar.YEAR);
				cal.add(Calendar.DAY_OF_MONTH, nDurationCount);
				dt2 = ((cal.get(Calendar.DAY_OF_MONTH) < 10) ? "0" + cal.get(Calendar.DAY_OF_MONTH) : cal.get(Calendar.DAY_OF_MONTH)) + "/"
						+ (((cal.get(Calendar.MONTH) + 1) < 10) ? "0" + (cal.get(Calendar.MONTH) + 1) : (cal.get(Calendar.MONTH) + 1)) + "/"
						+ cal.get(Calendar.YEAR);

				if (nPayCycle < minCycle) {
					cal.add(Calendar.DAY_OF_MONTH, 1);
					continue;
				}

				sb.append("Pay Cycle " + nPayCycle + ", " + dt1 + " - " + dt2);

				strCurrentPayCycleD1 = uF.getDateFormatUtil(dt1, DATE_FORMAT);
				strCurrentPayCycleD2 = uF.getDateFormatUtil(dt2, DATE_FORMAT);

				String strCurrDate = uF.getDateFormatUtil(strCurrentDate, DATE_FORMAT);
				int nCurrMonth = uF.parseToInt(uF.getDateFormat(strCurrDate, DATE_FORMAT, "MM"));
				int nPaycycleEndMonth = uF.parseToInt(uF.getDateFormat(dt2, DATE_FORMAT, "MM"));

				Map<String, String> hmFeatureStatus = getFeatureStatusMap(con);
				if (hmFeatureStatus != null && hmFeatureStatus.get(F_SELECT_PREV_PAYCYCLE) != null
						&& uF.parseToBoolean(hmFeatureStatus.get(F_SELECT_PREV_PAYCYCLE))) {
					if (strCurrentDate.after(strCurrentPayCycleD1) && strCurrentDate.after(strCurrentPayCycleD2) && nPayCycle == nPaidMaxPaycycle) { // &&
																																						// nCurrMonth
																																						// ==
																																						// nPaycycleEndMonth
						strPayCycleDate[0] = dt1;
						strPayCycleDate[1] = dt2;
						strPayCycleDate[2] = nPayCycle + "";
					} else if (strCurrentDate.equals(strCurrentPayCycleD1) || strCurrentDate.equals(strCurrentPayCycleD2)
							|| (strCurrentDate.after(strCurrentPayCycleD1) && strCurrentDate.before(strCurrentPayCycleD2))) {
						strPayCycleDate[0] = dt1;
						strPayCycleDate[1] = dt2;
						strPayCycleDate[2] = nPayCycle + "";
					}
				} else {
					if (strCurrentDate.equals(strCurrentPayCycleD1) || strCurrentDate.equals(strCurrentPayCycleD2)
							|| (strCurrentDate.after(strCurrentPayCycleD1) && strCurrentDate.before(strCurrentPayCycleD2))) {
						strPayCycleDate[0] = dt1;
						strPayCycleDate[1] = dt2;
						strPayCycleDate[2] = nPayCycle + "";
					}
				}
				cal.add(Calendar.DAY_OF_MONTH, 1);
				if (hmFeatureStatus != null && hmFeatureStatus.get(F_SELECT_PREV_PAYCYCLE) != null
						&& uF.parseToBoolean(hmFeatureStatus.get(F_SELECT_PREV_PAYCYCLE))) {
					if (nPayCycle >= maxCycle || (nPayCycle >= nPaidMaxPaycycle)) { // &&
																					// nCurrMonth
																					// ==
																					// nPaycycleEndMonth
						break;
					}
				} else {
					if (nPayCycle >= maxCycle) {
						break;
					}
				}
			}

			// System.out.println("strPayCycleDate[0] ===>> " +
			// strPayCycleDate[0]);

			/*
			 * String startDate = null; String strDisplayPaycycle = null; String
			 * strPaycycleDuration = null;
			 * 
			 * con = db.makeConnection(con); pst = con.prepareStatement(
			 * "select max (paycycle) as paycycle from payroll_generation where emp_id in (select emp_id from employee_official_details where org_id = ?)"
			 * ); pst.setInt(1, uF.parseToInt(f_org)); rs = pst.executeQuery();
			 * System.out.println("pst ===>> " + pst); int nPaidMaxPaycycle = 0;
			 * while (rs.next()) { nPaidMaxPaycycle = rs.getInt("paycycle"); }
			 * rs.close(); pst.close(); nPaidMaxPaycycle = nPaidMaxPaycycle+1;
			 * 
			 * pst =
			 * con.prepareStatement("select * from org_details where org_id=?");
			 * pst.setInt(1, uF.parseToInt(f_org)); rs = pst.executeQuery();
			 * System.out.println("pst ===>> " + pst); while (rs.next()) {
			 * startDate = rs.getString("start_paycycle"); strDisplayPaycycle =
			 * rs.getString("display_paycycle"); strPaycycleDuration =
			 * rs.getString("duration_paycycle"); } rs.close(); pst.close();
			 * 
			 * String[] arrDisplayPAycycle = null; int minCycle = 0; int
			 * maxCycle = 0; if (strDisplayPaycycle != null) {
			 * arrDisplayPAycycle = strDisplayPaycycle.split("-"); minCycle =
			 * uF.parseToInt(arrDisplayPAycycle[0]); maxCycle =
			 * uF.parseToInt(arrDisplayPAycycle[1]); }
			 * 
			 * Calendar calCurrent =
			 * GregorianCalendar.getInstance(TimeZone.getTimeZone
			 * ((strTimeZone))); Calendar cal =
			 * GregorianCalendar.getInstance(TimeZone.getTimeZone(strTimeZone));
			 * cal.set(Calendar.DAY_OF_MONTH,
			 * uF.parseToInt(uF.getDateFormat(startDate, DBDATE, "dd")));
			 * cal.set(Calendar.MONTH, uF.parseToInt(uF.getDateFormat(startDate,
			 * DBDATE, "MM")) - 1); cal.set(Calendar.YEAR,
			 * uF.parseToInt(uF.getDateFormat(startDate, DBDATE, "yyyy")));
			 * 
			 * StringBuilder sb = new StringBuilder(); int nPayCycle = 0;
			 * 
			 * int nDurationCount = 0; String dt1 = null; String dt2 = null;
			 * 
			 * // java.util.Date strCurrentDate = calCurrent.getTime();
			 * java.util.Date strCurrentDate =
			 * uF.getDateFormatUtil(((calCurrent.get(Calendar.DAY_OF_MONTH) <
			 * 10) ? "0" + calCurrent.get(Calendar.DAY_OF_MONTH) :
			 * calCurrent.get(Calendar.DAY_OF_MONTH)) + "/" +
			 * (((calCurrent.get(Calendar.MONTH) + 1) < 10) ? "0" +
			 * (calCurrent.get(Calendar.MONTH) + 1) :
			 * (calCurrent.get(Calendar.MONTH) + 1)) + "/" +
			 * calCurrent.get(Calendar.YEAR), DATE_FORMAT);
			 * 
			 * java.util.Date strCurrentPayCycleD1 = null; java.util.Date
			 * strCurrentPayCycleD2 = null;
			 * 
			 * while (true) { sb = new StringBuilder(); nPayCycle++;
			 * 
			 * if (strPaycycleDuration != null &&
			 * strPaycycleDuration.equalsIgnoreCase("M")) { nDurationCount =
			 * cal.getActualMaximum(Calendar.DAY_OF_MONTH) - 1; } else if
			 * (strPaycycleDuration != null &&
			 * strPaycycleDuration.equalsIgnoreCase("F")) { nDurationCount = 15
			 * - 1; if (cal.get(Calendar.DAY_OF_MONTH) == 16) { int nActual =
			 * cal.getActualMaximum(Calendar.DAY_OF_MONTH); nDurationCount =
			 * nActual - 15 - 1; } } else if (strPaycycleDuration != null &&
			 * strPaycycleDuration.equalsIgnoreCase("BW")) { nDurationCount = 14
			 * - 1; } else if (strPaycycleDuration != null &&
			 * strPaycycleDuration.equalsIgnoreCase("W")) { nDurationCount = 7 -
			 * 1; } else { nDurationCount =
			 * cal.getMaximum(Calendar.DAY_OF_MONTH) - 1; }
			 * 
			 * dt1 = ((cal.get(Calendar.DAY_OF_MONTH) < 10) ? "0" +
			 * cal.get(Calendar.DAY_OF_MONTH) : cal.get(Calendar.DAY_OF_MONTH))
			 * + "/" + (((cal.get(Calendar.MONTH) + 1) < 10) ? "0" +
			 * (cal.get(Calendar.MONTH) + 1) : (cal.get(Calendar.MONTH) + 1)) +
			 * "/" + cal.get(Calendar.YEAR); cal.add(Calendar.DAY_OF_MONTH,
			 * nDurationCount); dt2 = ((cal.get(Calendar.DAY_OF_MONTH) < 10) ?
			 * "0" + cal.get(Calendar.DAY_OF_MONTH) :
			 * cal.get(Calendar.DAY_OF_MONTH)) + "/" +
			 * (((cal.get(Calendar.MONTH) + 1) < 10) ? "0" +
			 * (cal.get(Calendar.MONTH) + 1) : (cal.get(Calendar.MONTH) + 1)) +
			 * "/" + cal.get(Calendar.YEAR);
			 * 
			 * if (nPayCycle < minCycle) { cal.add(Calendar.DAY_OF_MONTH, 1);
			 * continue; }
			 * 
			 * sb.append("Pay Cycle " + nPayCycle + ", " + dt1 + " - " + dt2);
			 * 
			 * strCurrentPayCycleD1 = uF.getDateFormatUtil(dt1, DATE_FORMAT);
			 * strCurrentPayCycleD2 = uF.getDateFormatUtil(dt2, DATE_FORMAT);
			 * 
			 * String strCurrDate = uF.getDateFormatUtil(strCurrentDate,
			 * DATE_FORMAT); int nCurrMonth =
			 * uF.parseToInt(uF.getDateFormat(strCurrDate, DATE_FORMAT, "MM"));
			 * int nPaycycleEndMonth = uF.parseToInt(uF.getDateFormat(dt2,
			 * DATE_FORMAT, "MM"));
			 * 
			 * Map<String, String> hmFeatureStatus = getFeatureStatusMap(con,
			 * request); if(hmFeatureStatus != null &&
			 * hmFeatureStatus.get(F_SELECT_PREV_PAYCYCLE) != null &&
			 * uF.parseToBoolean(hmFeatureStatus.get(F_SELECT_PREV_PAYCYCLE))) {
			 * if (strCurrentDate.after(strCurrentPayCycleD1) &&
			 * strCurrentDate.after(strCurrentPayCycleD2) && nPayCycle ==
			 * nPaidMaxPaycycle && nCurrMonth == nPaycycleEndMonth) {
			 * strPayCycleDate[0] = dt1; strPayCycleDate[1] = dt2;
			 * strPayCycleDate[2] = nPayCycle + ""; } else if
			 * (strCurrentDate.equals(strCurrentPayCycleD1) ||
			 * strCurrentDate.equals(strCurrentPayCycleD2) ||
			 * (strCurrentDate.after(strCurrentPayCycleD1) &&
			 * strCurrentDate.before(strCurrentPayCycleD2))) {
			 * strPayCycleDate[0] = dt1; strPayCycleDate[1] = dt2;
			 * strPayCycleDate[2] = nPayCycle + ""; } } else { if
			 * (strCurrentDate.equals(strCurrentPayCycleD1) ||
			 * strCurrentDate.equals(strCurrentPayCycleD2) ||
			 * (strCurrentDate.after(strCurrentPayCycleD1) &&
			 * strCurrentDate.before(strCurrentPayCycleD2))) {
			 * strPayCycleDate[0] = dt1; strPayCycleDate[1] = dt2;
			 * strPayCycleDate[2] = nPayCycle + ""; } }
			 * cal.add(Calendar.DAY_OF_MONTH, 1); if(hmFeatureStatus != null &&
			 * hmFeatureStatus.get(F_SELECT_PREV_PAYCYCLE) != null &&
			 * uF.parseToBoolean(hmFeatureStatus.get(F_SELECT_PREV_PAYCYCLE))) {
			 * if (nPayCycle >= maxCycle || (nPayCycle>=nPaidMaxPaycycle &&
			 * nCurrMonth == nPaycycleEndMonth)) { break; } } else { if
			 * (nPayCycle >= maxCycle) { break; } } }
			 */

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			db.closeResultSet(rs);
			db.closeStatements(pst);
			db.closeConnection(con);
		}
		return strPayCycleDate;
	}

	public String[] getCurrentPayCycleByOrg(String strTimeZone, String strDate, CommonFunctions CF, String f_org, HttpServletRequest request) {
		Connection con = null;
		PreparedStatement pst = null;
		ResultSet rs = null;
		Database db = new Database();
		db.setRequest(request);
		UtilityFunctions uF = new UtilityFunctions();
		String[] strPayCycleDate = new String[3];

		try {

			con = db.makeConnection(con);

			String startDate = null;
			String strDisplayPaycycle = null;
			String strPaycycleDuration = null;

			pst = con
					.prepareStatement("select max (paycycle) as paycycle from payroll_generation where emp_id in (select emp_id from employee_official_details where org_id = ?)");
			pst.setInt(1, uF.parseToInt(f_org));
			rs = pst.executeQuery();
			int nPaidMaxPaycycle = 0;
			while (rs.next()) {
				nPaidMaxPaycycle = rs.getInt("paycycle");
			}
			rs.close();
			pst.close();
			nPaidMaxPaycycle = nPaidMaxPaycycle + 1;

			// System.out.println("nPaidMaxPaycycle ===>> " + nPaidMaxPaycycle);

			pst = con.prepareStatement("select * from org_details where org_id=? ");
			pst.setInt(1, uF.parseToInt(f_org));
			rs = pst.executeQuery();

			while (rs.next()) {
				startDate = rs.getString("start_paycycle");
				strDisplayPaycycle = rs.getString("display_paycycle");
				strPaycycleDuration = rs.getString("duration_paycycle");
			}
			rs.close();
			pst.close();
			// System.out.println("startDate ===>> " + startDate
			// +" -- strDisplayPaycycle ===>> " + strDisplayPaycycle +
			// " -- strPaycycleDuration ===>> " + strPaycycleDuration);

			String[] arrDisplayPAycycle = null;
			int minCycle = 0;
			int maxCycle = 0;
			if (strDisplayPaycycle != null) {
				arrDisplayPAycycle = strDisplayPaycycle.split("-");
				minCycle = uF.parseToInt(arrDisplayPAycycle[0]);
				maxCycle = uF.parseToInt(arrDisplayPAycycle[1]);
			}

			// System.out.println("minCycle ===>> " + minCycle +
			// " -- maxCycle ===>> " + maxCycle);
			Calendar calCurrent = GregorianCalendar.getInstance(TimeZone.getTimeZone((strTimeZone)));
			calCurrent.set(Calendar.DAY_OF_MONTH, uF.parseToInt(uF.getDateFormat(strDate, DBDATE, "dd")));
			calCurrent.set(Calendar.MONTH, uF.parseToInt(uF.getDateFormat(strDate, DBDATE, "MM")) - 1);
			calCurrent.set(Calendar.YEAR, uF.parseToInt(uF.getDateFormat(strDate, DBDATE, "yyyy")));
//			 System.out.println("calCurrent ===>> " + calCurrent);
			Calendar cal = GregorianCalendar.getInstance(TimeZone.getTimeZone(strTimeZone));
			cal.set(Calendar.DAY_OF_MONTH, uF.parseToInt(uF.getDateFormat(startDate, DBDATE, "dd")));
			cal.set(Calendar.MONTH, uF.parseToInt(uF.getDateFormat(startDate, DBDATE, "MM")) - 1);
			cal.set(Calendar.YEAR, uF.parseToInt(uF.getDateFormat(startDate, DBDATE, "yyyy")));

			StringBuilder sb = new StringBuilder();
			int nPayCycle = 0;

			int nDurationCount = 0;
			String dt1 = null;
			String dt2 = null;

			// java.util.Date strCurrentDate = calCurrent.getTime();
			java.util.Date strCurrentDate = uF.getDateFormatUtil(((calCurrent.get(Calendar.DAY_OF_MONTH) < 10)
					? "0" + calCurrent.get(Calendar.DAY_OF_MONTH)
					: calCurrent.get(Calendar.DAY_OF_MONTH))
					+ "/"
					+ (((calCurrent.get(Calendar.MONTH) + 1) < 10) ? "0" + (calCurrent.get(Calendar.MONTH) + 1) : (calCurrent.get(Calendar.MONTH) + 1))
					+ "/"
					+ calCurrent.get(Calendar.YEAR), DATE_FORMAT);

			java.util.Date strCurrentPayCycleD1 = null;
			java.util.Date strCurrentPayCycleD2 = null;

			while (true) {
				sb = new StringBuilder();
				nPayCycle++;

				if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("M")) {
					nDurationCount = cal.getActualMaximum(Calendar.DAY_OF_MONTH) - 1;
				} else if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("F")) {
					nDurationCount = 15 - 1;
					if (cal.get(Calendar.DAY_OF_MONTH) == 16) {
						int nActual = cal.getActualMaximum(Calendar.DAY_OF_MONTH);
						nDurationCount = nActual - 15 - 1;
					}
				} else if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("BW")) {
					nDurationCount = 14 - 1;
				} else if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("W")) {
					nDurationCount = 7 - 1;
				} else {
					nDurationCount = cal.getMaximum(Calendar.DAY_OF_MONTH) - 1;
				}

				dt1 = ((cal.get(Calendar.DAY_OF_MONTH) < 10) ? "0" + cal.get(Calendar.DAY_OF_MONTH) : cal.get(Calendar.DAY_OF_MONTH)) + "/"
						+ (((cal.get(Calendar.MONTH) + 1) < 10) ? "0" + (cal.get(Calendar.MONTH) + 1) : (cal.get(Calendar.MONTH) + 1)) + "/"
						+ cal.get(Calendar.YEAR);
				cal.add(Calendar.DAY_OF_MONTH, nDurationCount);
				dt2 = ((cal.get(Calendar.DAY_OF_MONTH) < 10) ? "0" + cal.get(Calendar.DAY_OF_MONTH) : cal.get(Calendar.DAY_OF_MONTH)) + "/"
						+ (((cal.get(Calendar.MONTH) + 1) < 10) ? "0" + (cal.get(Calendar.MONTH) + 1) : (cal.get(Calendar.MONTH) + 1)) + "/"
						+ cal.get(Calendar.YEAR);

				if (nPayCycle < minCycle) {
					cal.add(Calendar.DAY_OF_MONTH, 1);
					continue;
				}

				sb.append("Pay Cycle " + nPayCycle + ", " + dt1 + " - " + dt2);

				strCurrentPayCycleD1 = uF.getDateFormatUtil(dt1, DATE_FORMAT);
				strCurrentPayCycleD2 = uF.getDateFormatUtil(dt2, DATE_FORMAT);

				String strCurrDate = uF.getDateFormatUtil(strCurrentDate, DATE_FORMAT);
				int nCurrMonth = uF.parseToInt(uF.getDateFormat(strCurrDate, DATE_FORMAT, "MM"));
				int nPaycycleEndMonth = uF.parseToInt(uF.getDateFormat(dt2, DATE_FORMAT, "MM"));

				Map<String, String> hmFeatureStatus = getFeatureStatusMap(con);
				if (hmFeatureStatus != null && hmFeatureStatus.get(F_SELECT_PREV_PAYCYCLE) != null
						&& uF.parseToBoolean(hmFeatureStatus.get(F_SELECT_PREV_PAYCYCLE))) {
					if (strCurrentDate.after(strCurrentPayCycleD1) && strCurrentDate.after(strCurrentPayCycleD2) && nPayCycle == nPaidMaxPaycycle) { // &&
																																						// nCurrMonth
																																						// ==
																																						// nPaycycleEndMonth
						strPayCycleDate[0] = dt1;
						strPayCycleDate[1] = dt2;
						strPayCycleDate[2] = nPayCycle + "";
					} else if (strCurrentDate.equals(strCurrentPayCycleD1) || strCurrentDate.equals(strCurrentPayCycleD2)
							|| (strCurrentDate.after(strCurrentPayCycleD1) && strCurrentDate.before(strCurrentPayCycleD2))) {
						strPayCycleDate[0] = dt1;
						strPayCycleDate[1] = dt2;
						strPayCycleDate[2] = nPayCycle + "";
					}
				} else {
					if (strCurrentDate.equals(strCurrentPayCycleD1) || strCurrentDate.equals(strCurrentPayCycleD2)
							|| (strCurrentDate.after(strCurrentPayCycleD1) && strCurrentDate.before(strCurrentPayCycleD2))) {
						strPayCycleDate[0] = dt1;
						strPayCycleDate[1] = dt2;
						strPayCycleDate[2] = nPayCycle + "";
					}
				}
				cal.add(Calendar.DAY_OF_MONTH, 1);
				if (hmFeatureStatus != null && hmFeatureStatus.get(F_SELECT_PREV_PAYCYCLE) != null
						&& uF.parseToBoolean(hmFeatureStatus.get(F_SELECT_PREV_PAYCYCLE))) {
					if (nPayCycle >= maxCycle || (nPayCycle >= nPaidMaxPaycycle)) { // &&
																					// nCurrMonth
																					// ==
																					// nPaycycleEndMonth
						break;
					}
				} else {
					if (nPayCycle >= maxCycle) {
						break;
					}
				}
			}

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			db.closeResultSet(rs);
			db.closeStatements(pst);
			db.closeConnection(con);
		}
		return strPayCycleDate;
	}

	public String[] getCurrentPayCycleUsingDurationByOrg(String strTimeZone, CommonFunctions CF, String f_org, HttpServletRequest request,
			String paycycleDuration) {
		Connection con = null;
		PreparedStatement pst = null;
		ResultSet rs = null;
		Database db = new Database();
		db.setRequest(request);
		UtilityFunctions uF = new UtilityFunctions();
		String[] strPayCycleDate = new String[3];

		try {

			String startDate = null;
			String strDisplayPaycycle = null;
			String strPaycycleDuration = null;

			con = db.makeConnection(con);
			pst = con.prepareStatement("select * from org_details where org_id=?");
			pst.setInt(1, uF.parseToInt(f_org));
			rs = pst.executeQuery();

			while (rs.next()) {
				startDate = rs.getString("start_paycycle");
				strDisplayPaycycle = rs.getString("display_paycycle");
				strPaycycleDuration = rs.getString("duration_paycycle");
			}
			rs.close();
			pst.close();

			if (paycycleDuration != null && !paycycleDuration.trim().equals("") && !paycycleDuration.trim().equalsIgnoreCase("NULL")) {
				strPaycycleDuration = paycycleDuration;
			}

			String[] arrDisplayPAycycle = null;
			int minCycle = 0;
			int maxCycle = 0;
			if (strDisplayPaycycle != null) {
				arrDisplayPAycycle = strDisplayPaycycle.split("-");
				minCycle = uF.parseToInt(arrDisplayPAycycle[0]);
				maxCycle = uF.parseToInt(arrDisplayPAycycle[1]);
			}

			Calendar calCurrent = GregorianCalendar.getInstance(TimeZone.getTimeZone((strTimeZone)));
			Calendar cal = GregorianCalendar.getInstance(TimeZone.getTimeZone(strTimeZone));
			cal.set(Calendar.DAY_OF_MONTH, uF.parseToInt(uF.getDateFormat(startDate, DBDATE, "dd")));
			cal.set(Calendar.MONTH, uF.parseToInt(uF.getDateFormat(startDate, DBDATE, "MM")) - 1);
			cal.set(Calendar.YEAR, uF.parseToInt(uF.getDateFormat(startDate, DBDATE, "yyyy")));

			StringBuilder sb = new StringBuilder();
			int nPayCycle = 0;

			int nDurationCount = 0;
			String dt1 = null;
			String dt2 = null;

			// java.util.Date strCurrentDate = calCurrent.getTime();
			java.util.Date strCurrentDate = uF.getDateFormatUtil(((calCurrent.get(Calendar.DAY_OF_MONTH) < 10)
					? "0" + calCurrent.get(Calendar.DAY_OF_MONTH)
					: calCurrent.get(Calendar.DAY_OF_MONTH))
					+ "/"
					+ (((calCurrent.get(Calendar.MONTH) + 1) < 10) ? "0" + (calCurrent.get(Calendar.MONTH) + 1) : (calCurrent.get(Calendar.MONTH) + 1))
					+ "/"
					+ calCurrent.get(Calendar.YEAR), DATE_FORMAT);

			java.util.Date strCurrentPayCycleD1 = null;
			java.util.Date strCurrentPayCycleD2 = null;

			while (true) {
				sb = new StringBuilder();
				nPayCycle++;

				if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("M")) {
					nDurationCount = cal.getActualMaximum(Calendar.DAY_OF_MONTH) - 1;
				} else if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("F")) {
					nDurationCount = 15 - 1;
					if (cal.get(Calendar.DAY_OF_MONTH) == 16) {
						int nActual = cal.getActualMaximum(Calendar.DAY_OF_MONTH);
						nDurationCount = nActual - 15 - 1;
					}
				} else if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("BW")) {
					nDurationCount = 14 - 1;
				} else if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("W")) {
					nDurationCount = 7 - 1;
				} else {
					nDurationCount = cal.getMaximum(Calendar.DAY_OF_MONTH) - 1;
				}

				dt1 = ((cal.get(Calendar.DAY_OF_MONTH) < 10) ? "0" + cal.get(Calendar.DAY_OF_MONTH) : cal.get(Calendar.DAY_OF_MONTH)) + "/"
						+ (((cal.get(Calendar.MONTH) + 1) < 10) ? "0" + (cal.get(Calendar.MONTH) + 1) : (cal.get(Calendar.MONTH) + 1)) + "/"
						+ cal.get(Calendar.YEAR);
				cal.add(Calendar.DAY_OF_MONTH, nDurationCount);
				dt2 = ((cal.get(Calendar.DAY_OF_MONTH) < 10) ? "0" + cal.get(Calendar.DAY_OF_MONTH) : cal.get(Calendar.DAY_OF_MONTH)) + "/"
						+ (((cal.get(Calendar.MONTH) + 1) < 10) ? "0" + (cal.get(Calendar.MONTH) + 1) : (cal.get(Calendar.MONTH) + 1)) + "/"
						+ cal.get(Calendar.YEAR);

				if (nPayCycle < minCycle) {
					cal.add(Calendar.DAY_OF_MONTH, 1);
					continue;
				}

				sb.append("Pay Cycle " + nPayCycle + ", " + dt1 + " - " + dt2);

				strCurrentPayCycleD1 = uF.getDateFormatUtil(dt1, DATE_FORMAT);
				strCurrentPayCycleD2 = uF.getDateFormatUtil(dt2, DATE_FORMAT);

				if (strCurrentDate.equals(strCurrentPayCycleD1) || strCurrentDate.equals(strCurrentPayCycleD2)
						|| (strCurrentDate.after(strCurrentPayCycleD1) && strCurrentDate.before(strCurrentPayCycleD2))) {
					strPayCycleDate[0] = dt1;
					strPayCycleDate[1] = dt2;
					strPayCycleDate[2] = nPayCycle + "";
				}

				cal.add(Calendar.DAY_OF_MONTH, 1);

				if (nPayCycle >= maxCycle) {
					break;
				}

			}

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			db.closeResultSet(rs);
			db.closeStatements(pst);
			db.closeConnection(con);
		}
		return strPayCycleDate;

	}

	public String getRecruitmentNameById(Connection con, UtilityFunctions uF, String recruitmentId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		String recruitmentName = null;
		try {
			pst = con.prepareStatement("select job_code from recruitment_details where recruitment_id = ?");
			pst.setInt(1, uF.parseToInt(recruitmentId));
			rs = pst.executeQuery();
			while (rs.next()) {
				recruitmentName = rs.getString("job_code");
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return recruitmentName;
	}

	public String getReviewNameById(Connection con, UtilityFunctions uF, String reviewId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		String reviewName = null;
		try {
			pst = con.prepareStatement("select appraisal_name from appraisal_details where appraisal_details_id = ?");
			pst.setInt(1, uF.parseToInt(reviewId));
			rs = pst.executeQuery();
			while (rs.next()) {
				reviewName = rs.getString("appraisal_name");
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return reviewName;
	}

	public String getLearningPlanNameById(Connection con, UtilityFunctions uF, String planId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		String lPlanName = null;
		try {
			pst = con.prepareStatement("select learning_plan_name from learning_plan_details where learning_plan_id = ?");
			pst.setInt(1, uF.parseToInt(planId));
			rs = pst.executeQuery();
			while (rs.next()) {
				lPlanName = rs.getString("learning_plan_name");
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return lPlanName;
	}

	public String getGoalNameById(Connection con, UtilityFunctions uF, String goalId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		String goalName = null;
		try {
			pst = con.prepareStatement("select goal_title from goal_details where goal_id = ?");
			pst.setInt(1, uF.parseToInt(goalId));
			rs = pst.executeQuery();
			while (rs.next()) {
				goalName = rs.getString("goal_title");
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return goalName;
	}

	public List<String> getEmpSkillsList(Connection con, UtilityFunctions uF, String empId) {

		ResultSet rs = null;
		PreparedStatement pst = null;
		List<String> empSkillsList = new ArrayList<String>();
		try {
			pst = con.prepareStatement("select skill_id from skills_description where emp_id = ? "); // ,assessment_details_id
			pst.setInt(1, uF.parseToInt(empId));
			rs = pst.executeQuery();

			while (rs.next()) {
				empSkillsList.add(rs.getString("skill_id"));
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return empSkillsList;
	}

	public Map<String, List<String>> getEmpLearningPlanAndSkillsList(Connection con, UtilityFunctions uF, String empId) {

		ResultSet rs = null;
		PreparedStatement pst = null;
		Map<String, List<String>> hmEmpLPlanData = new HashMap<String, List<String>>();
		try {
			pst = con.prepareStatement("select learning_plan_id,skills from learning_plan_details where learning_plan_id in(select "
					+ "distinct(learning_plan_id) from learning_plan_stage_details where learning_type = 'Assessment') and " + "learner_ids like '%," + empId
					+ ",%'"); // ,assessment_details_id
			rs = pst.executeQuery();

			while (rs.next()) {
				List<String> innerList = new ArrayList<String>();
				innerList.add(rs.getString("learning_plan_id"));
				innerList.add(rs.getString("skills"));
				hmEmpLPlanData.put(rs.getString("learning_plan_id"), innerList);
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmEmpLPlanData;
	}

	public Map<String, String> employeeSkillRatingOnAssessments(Connection con, HttpServletRequest request, CommonFunctions CF, UtilityFunctions uF,
			String empId) {

		ResultSet rs = null;
		PreparedStatement pst = null;

		Map<String, String> hmSkillAvgRating = new HashMap<String, String>();

		try {
			pst = con.prepareStatement("select *,(marks*100/weightage) as average from(select sum(marks) as marks ,sum(weightage) as weightage,"
					+ "user_type_id,emp_id,learning_plan_id from assessment_question_answer where emp_id = ? " + // ,assessment_details_id
					"group by user_type_id,emp_id,learning_plan_id)as a where weightage>0"); // ,assessment_details_id
			pst.setInt(1, uF.parseToInt(empId));
			rs = pst.executeQuery();
			// System.out.println("pst ===>> " +pst);

			Map<String, Map<String, String>> hmEmpLPlanRating = new HashMap<String, Map<String, String>>();
			Map<String, String> hmLearningPlanRating = new HashMap<String, String>();

			while (rs.next()) {
				hmLearningPlanRating = hmEmpLPlanRating.get(rs.getString("emp_id"));

				if (hmLearningPlanRating == null)
					hmLearningPlanRating = new HashMap<String, String>();

				hmLearningPlanRating.put(rs.getString("learning_plan_id"), uF.formatIntoTwoDecimal(uF.parseToDouble(rs.getString("average"))));
				hmEmpLPlanRating.put(rs.getString("emp_id"), hmLearningPlanRating);
			}
			rs.close();
			pst.close();

			List<String> empSkillList = getEmpSkillsList(con, uF, empId);
			Map<String, List<String>> hmEmpLPlanData = getEmpLearningPlanAndSkillsList(con, uF, empId);

			Set<String> keys1 = hmEmpLPlanData.keySet();
			Iterator<String> it1 = keys1.iterator();
			// System.out.println("empSkillList ===> " + empSkillList);

			Map<String, String> hmSkillRating = new HashMap<String, String>();
			Map<String, String> hmSkillCnt = new HashMap<String, String>();
			while (it1.hasNext()) {
				String lPlanId = (String) it1.next();
				List<String> innerList = hmEmpLPlanData.get(lPlanId);

				List<String> empLplanSkillList = null;
				if (innerList.get(1) != null && !innerList.get(1).equals("")) {
					empLplanSkillList = Arrays.asList(innerList.get(1).split(","));
				}
				// System.out.println("empId ===> " + empId + " innerList ===> "
				// + innerList);
				for (int i = 0; empSkillList != null && !empSkillList.isEmpty() && i < empSkillList.size(); i++) {
					if (empLplanSkillList != null && empLplanSkillList.contains(empSkillList.get(i))) {
						double lPlanSkillRating = uF.parseToDouble(hmSkillRating.get(empSkillList.get(i)));
						int skillCnt = uF.parseToInt(hmSkillCnt.get(empSkillList.get(i)));
						skillCnt++;
						lPlanSkillRating += uF.parseToDouble(hmLearningPlanRating.get(lPlanId));
						hmSkillRating.put(empSkillList.get(i), lPlanSkillRating + "");
						hmSkillCnt.put(empSkillList.get(i), skillCnt + "");
					}
				}
			}

			Set<String> keyss = hmSkillRating.keySet();
			Iterator<String> itt = keyss.iterator();
			while (itt.hasNext()) {
				String skillId = (String) itt.next();
				double totSkillRating = uF.parseToDouble(hmSkillRating.get(skillId));
				int totSkillCnt = uF.parseToInt(hmSkillCnt.get(skillId));
				double avgSkillRating = 0.0d;
				if (totSkillCnt > 0) {
					avgSkillRating = totSkillRating / totSkillCnt;
				}
				hmSkillAvgRating.put(skillId, avgSkillRating + "");
			}
			// System.out.println("hmSkillAvgRating ===>> " + hmSkillAvgRating);
			request.setAttribute("hmSkillAvgRating", hmSkillAvgRating);

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmSkillAvgRating;
	}

	public Map<String, String> getIndividualBonusMap(Connection con, UtilityFunctions uF, CommonFunctions CF, String strPC, String strD1, String strD2) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmIndividualBonusAmountMap = new HashMap<String, String>();

		try {

			pst = con.prepareStatement("select * from bonus_individual_details where paid_from = ? and paid_to=? and pay_paycycle = ? and is_approved = 1");
			pst.setDate(1, uF.getDateFormat(strD1, DATE_FORMAT));
			pst.setDate(2, uF.getDateFormat(strD2, DATE_FORMAT));
			pst.setInt(3, uF.parseToInt(strPC));
//			System.out.println("CF/19510--pst="+pst);
			rs = pst.executeQuery();
			while (rs.next()) {
				hmIndividualBonusAmountMap.put(rs.getString("emp_id"), uF.formatIntoOneDecimalWithOutComma(uF.parseToDouble(rs.getString("pay_amount"))));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmIndividualBonusAmountMap;
	}

	public Map<String, String> getIndividualOtherDeductionMap(Connection con, UtilityFunctions uF, CommonFunctions CF, String strPC, String strD1, String strD2) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmIndividualOtherDeductionAmountMap = new HashMap<String, String>();

		try {

			// pst =
			// con.prepareStatement("select * from otherdeduction_individual_details where paid_from = ? and paid_to=? and pay_paycycle = ? and is_approved = 1");
			// pst.setDate(1, uF.getDateFormat(strD1, DATE_FORMAT));
			// pst.setDate(2, uF.getDateFormat(strD2, DATE_FORMAT));
			// pst.setInt(3, uF.parseToInt(strPC));
			// rs = pst.executeQuery();
			// while (rs.next()) {
			// hmIndividualOtherDeductionAmountMap.put(rs.getString("emp_id"),
			// uF.formatIntoOneDecimalWithOutComma(uF.parseToDouble(rs.getString("pay_amount"))));
			// }
			pst = con
					.prepareStatement("select * from otherearning_individual_details where paid_from = ? and paid_to=? and pay_paycycle = ? and is_approved = 1 and salary_head_id = ?");
			pst.setDate(1, uF.getDateFormat(strD1, DATE_FORMAT));
			pst.setDate(2, uF.getDateFormat(strD2, DATE_FORMAT));
			pst.setInt(3, uF.parseToInt(strPC));
			pst.setInt(4, OTHER_DEDUCTION);
			rs = pst.executeQuery();
			while (rs.next()) {
				hmIndividualOtherDeductionAmountMap.put(rs.getString("emp_id"),
						uF.formatIntoOneDecimalWithOutComma(uF.parseToDouble(rs.getString("pay_amount"))));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmIndividualOtherDeductionAmountMap;
	}

	public Map<String, String> getIndividualOtherEarningMap(Connection con, UtilityFunctions uF, CommonFunctions CF, String strPC, String strD1, String strD2) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmIndividualOtherEarningAmountMap = new HashMap<String, String>();

		try {

			pst = con
					.prepareStatement("select * from otherearning_individual_details where paid_from = ? and paid_to=? and pay_paycycle = ? and is_approved = 1 and salary_head_id = ?");
			pst.setDate(1, uF.getDateFormat(strD1, DATE_FORMAT));
			pst.setDate(2, uF.getDateFormat(strD2, DATE_FORMAT));
			pst.setInt(3, uF.parseToInt(strPC));
			pst.setInt(4, OTHER_EARNING);
			rs = pst.executeQuery();
			while (rs.next()) {
				hmIndividualOtherEarningAmountMap
						.put(rs.getString("emp_id"), uF.formatIntoOneDecimalWithOutComma(uF.parseToDouble(rs.getString("pay_amount"))));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmIndividualOtherEarningAmountMap;
	}

	public Map<String, String> getIndividualOvertimeMap(Connection con, UtilityFunctions uF, CommonFunctions CF, String strPC, String strD1, String strD2) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmIndividualOvertimeAmountMap = new HashMap<String, String>();

		try {

			pst = con.prepareStatement("select * from overtime_individual_details where paid_from = ? and paid_to=? and pay_paycycle = ? and is_approved = 1");
			pst.setDate(1, uF.getDateFormat(strD1, DATE_FORMAT));
			pst.setDate(2, uF.getDateFormat(strD2, DATE_FORMAT));
			pst.setInt(3, uF.parseToInt(strPC));
			rs = pst.executeQuery();

			while (rs.next()) {
				hmIndividualOvertimeAmountMap.put(rs.getString("emp_id"), uF.formatIntoOneDecimalWithOutComma(uF.parseToDouble(rs.getString("pay_amount"))));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmIndividualOvertimeAmountMap;
	}

	public Map<String, String> getIndividualMobileRecoveryMap(Connection con, UtilityFunctions uF, CommonFunctions CF, String strPC, String strD1, String strD2) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmIndividualMobileRecoveryMap = new HashMap<String, String>();

		try {

			// pst =
			// con.prepareStatement("select * from mobile_recovery_individual_details where paid_from = ? and paid_to=? and pay_paycycle = ? and is_approved = 1");
			// pst.setDate(1, uF.getDateFormat(strD1, DATE_FORMAT));
			// pst.setDate(2, uF.getDateFormat(strD2, DATE_FORMAT));
			// pst.setInt(3, uF.parseToInt(strPC));
			// rs = pst.executeQuery();
			//
			// while (rs.next()) {
			// hmIndividualMobileRecoveryMap.put(rs.getString("emp_id"),
			// uF.formatIntoOneDecimalWithOutComma(uF.parseToDouble(rs.getString("pay_amount"))));
			// }
			pst = con
					.prepareStatement("select * from otherearning_individual_details where paid_from = ? and paid_to=? and pay_paycycle = ? and is_approved = 1 and salary_head_id = ?");
			pst.setDate(1, uF.getDateFormat(strD1, DATE_FORMAT));
			pst.setDate(2, uF.getDateFormat(strD2, DATE_FORMAT));
			pst.setInt(3, uF.parseToInt(strPC));
			pst.setInt(4, MOBILE_RECOVERY);
			rs = pst.executeQuery();
			while (rs.next()) {
				hmIndividualMobileRecoveryMap.put(rs.getString("emp_id"), uF.formatIntoOneDecimalWithOutComma(uF.parseToDouble(rs.getString("pay_amount"))));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmIndividualMobileRecoveryMap;
	}

	public Map<String, String> getTrainingTrainerNameMap(Connection con) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmTrainerName = new HashMap<String, String>();
		try {
			pst = con.prepareStatement("select trainer_id,trainer_name,trainer_emp_id,emp_id from training_trainer");
			rs = pst.executeQuery();
			while (rs.next()) {
				hmTrainerName.put(rs.getString("trainer_id"), rs.getString("trainer_name"));
			}
			rs.close();
			pst.close();
			// System.out.println("hmEmpDetails ====>"+hmEmpDetails);
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmTrainerName;
	}

	public double getCalculatedEmpGratuityAmount(Connection con, HttpServletRequest request, CommonFunctions CF, UtilityFunctions uF, String strEmpId,
			String strOrgId, String strLevel, String strLocation, int nNoOfYears, int nNoOfMonths, String paycycle,
			Map<String, Set<String>> hmWeekEndHalfDates, Map<String, Set<String>> hmWeekEnds, List<String> alEmpCheckRosterWeektype,
			Map<String, Set<String>> hmRosterWeekEndDates) {

		double dblCalculatedGratuityAmount = 0.0d;
		PreparedStatement pst = null;
		ResultSet rs = null;
		try {
			String[] strPayCycleDates = paycycle.split("-");

			Set<String> weeklyOffEndDate = hmWeekEnds.get(strLocation);
			if (weeklyOffEndDate == null)
				weeklyOffEndDate = new HashSet<String>();

			Set<String> rosterWeeklyOffSet = hmRosterWeekEndDates.get(strEmpId);
			if (rosterWeeklyOffSet == null)
				rosterWeeklyOffSet = new HashSet<String>();

			Map<String, String> hmHolidaysCnt = new HashMap<String, String>();
			Map<String, String> hmHolidayDates = new HashMap<String, String>();
			if (alEmpCheckRosterWeektype != null && alEmpCheckRosterWeektype.contains(strEmpId)) {
				CF.getHolidayListCount(con, request, strPayCycleDates[0], strPayCycleDates[1], CF, hmHolidayDates, hmHolidaysCnt, rosterWeeklyOffSet, false);
			} else {
				CF.getHolidayListCount(con, request, strPayCycleDates[0], strPayCycleDates[1], CF, hmHolidayDates, hmHolidaysCnt, weeklyOffEndDate, false);
			}

			String diffInDays = uF.dateDifference(strPayCycleDates[0], DATE_FORMAT, strPayCycleDates[1], DATE_FORMAT, CF.getStrTimeZone());

			pst = con.prepareStatement(selectGratuity);
			pst.setInt(1, uF.parseToInt(strOrgId));
			rs = pst.executeQuery();
			double dblServiceFrom = 0;
			double dblServiceTo = 0;
			int nGratuityDays = 0;
			double dblMaxAmount = 0;
			String salary_cal_basis = null;
			String[] arrSalary = null;
			double dblFixedDays = 0;
			while (rs.next()) {
				dblServiceFrom = rs.getDouble("service_from");
				dblServiceTo = rs.getDouble("service_to");
				nGratuityDays = rs.getInt("gratuity_days");
				dblMaxAmount = rs.getDouble("max_amount");
				salary_cal_basis = rs.getString("salary_cal_basis");

				arrSalary = rs.getString("salary_head_id") != null ? rs.getString("salary_head_id").split(",") : null;
				dblFixedDays = uF.parseToDouble(rs.getString("fixed_days"));
			}
			rs.close();
			pst.close();

			double dblWorkDays = 0.0d;
			if (salary_cal_basis != null && "AWD".equalsIgnoreCase(salary_cal_basis)) {
				int nWeekEnd = (alEmpCheckRosterWeektype != null && alEmpCheckRosterWeektype.contains(strEmpId)) ? rosterWeeklyOffSet.size() : weeklyOffEndDate
						.size();
				int nHolidayCnt = uF.parseToInt(hmHolidaysCnt.get(strLocation));
				dblWorkDays = (uF.parseToDouble(diffInDays) - nWeekEnd) - nHolidayCnt;
			} else if (salary_cal_basis != null && "AMD".equalsIgnoreCase(salary_cal_basis)) {
				dblWorkDays = uF.parseToDouble(diffInDays);
			} else {
				dblWorkDays = dblFixedDays;
			}

			Map<String, Map<String, Map<String, String>>> hmSalaryDetails1 = new HashMap<String, Map<String, Map<String, String>>>();
			pst = con.prepareStatement("select * from salary_details where level_id in (select level_id from level_details where "
					+ "level_id =?) and (is_delete is null or is_delete=false) order by level_id, earning_deduction desc, salary_head_id, weight");
			pst.setInt(1, uF.parseToInt(strLevel));
			rs = pst.executeQuery();
			while (rs.next()) {

				Map<String, Map<String, String>> hmSalInner = hmSalaryDetails1.get(rs.getString("level_id"));
				if (hmSalInner == null)
					hmSalInner = new HashMap<String, Map<String, String>>();

				Map<String, String> hmInnerSal = new HashMap<String, String>();
				hmInnerSal.put("SALARY_HEAD_ID", rs.getString("salary_head_id"));
				hmInnerSal.put("EARNING_DEDUCTION", rs.getString("earning_deduction"));
				hmInnerSal.put("SALARY_AMOUNT_TYPE", rs.getString("salary_head_amount_type"));
				hmInnerSal.put("SUB_SALARY_HEAD_ID", rs.getString("sub_salary_head_id"));
				hmInnerSal.put("SALARY_HEAD_AMOUNT", rs.getString("salary_head_amount"));
				hmInnerSal.put("IS_CTC_VARIABLE", "" + uF.parseToBoolean(rs.getString("is_ctc_variable")));
				hmInnerSal.put("MULTIPLE_CALCULATION", rs.getString("multiple_calculation"));
				hmInnerSal.put("IS_ALIGN_WITH_PERK", "" + uF.parseToBoolean(rs.getString("is_align_with_perk")));
				hmInnerSal.put("IS_DEFAULT_CAL_ALLOWANCE", "" + uF.parseToBoolean(rs.getString("is_default_cal_allowance")));
				hmInnerSal.put("SALARY_TYPE", rs.getString("salary_type"));

				hmSalInner.put(rs.getString("salary_head_id"), hmInnerSal);

				hmSalaryDetails1.put(rs.getString("level_id"), hmSalInner);
			}
			rs.close();
			pst.close();

			Map<String, Map<String, String>> hmSalInner = hmSalaryDetails1.get(strLevel);
			if (hmSalInner == null)
				hmSalInner = new HashMap<String, Map<String, String>>();

			Map<String, Map<String, String>> hmInnerisDisplay = new HashMap<String, Map<String, String>>();
			Map<String, Map<String, String>> hmEmpSalaryDetails = CF.getSalaryCalculation(con, hmInnerisDisplay, uF.parseToInt(strEmpId), dblWorkDays, 0, 0,
					((int) dblWorkDays), 0, 0, strLevel, uF, CF, strPayCycleDates[1], hmSalInner, null, null);
			if (hmEmpSalaryDetails == null)
				hmEmpSalaryDetails = new HashMap<String, Map<String, String>>();

			double dblSalaryAmount = 0.0d;
			for (int i = 0; arrSalary != null && i < arrSalary.length; i++) {
				
				Map<String, String> hmTemp = hmEmpSalaryDetails.get(arrSalary[i]);
				if (hmTemp == null)
					hmTemp = new HashMap<String, String>();
				dblSalaryAmount += uF.parseToDouble(hmTemp.get("AMOUNT"));
			}

			if (nNoOfYears >= dblServiceFrom && dblServiceTo >= nNoOfYears) {
				if (nNoOfMonths > 6) {
					nNoOfYears++; // if number of months is greater than 6 it is
									// treated as one year else 0
				}
				dblCalculatedGratuityAmount = (dblSalaryAmount * nGratuityDays * nNoOfYears) / dblWorkDays;
				dblCalculatedGratuityAmount = uF.parseToDouble(uF.formatIntoZeroWithOutComma(dblCalculatedGratuityAmount));
				// System.out.println("strEmpId====>"+strEmpId+"----dblSalaryAmount====>"+dblSalaryAmount+"----nGratuityDays====>"+nGratuityDays+"----nNoOfYears====>"+nNoOfYears+"----dblWorkDays====>"+dblWorkDays+"----dblCalculatedGratuityAmount====>"+dblCalculatedGratuityAmount);
			}

			if (dblCalculatedGratuityAmount > dblMaxAmount) {
				return dblMaxAmount;
			} else {
				return dblCalculatedGratuityAmount;
			}

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

		return 0.0d;
	}

	public void getHolidayListCount(Connection con, HttpServletRequest request, String strD1, String strD2, CommonFunctions CF,
			Map<String, String> hmHolidayDates, Map<String, String> hmHolidays, Set<String> weeklyOffDate, boolean isWithLocation) {

		PreparedStatement pst = null;
		ResultSet rs = null;

		try {
			if (weeklyOffDate == null)
				weeklyOffDate = new HashSet<String>();

			if (strD1 != null && strD2 != null) {
				pst = con.prepareStatement(selectHolidaysR2);
				pst.setDate(1, uF.getDateFormat(strD1, DATE_FORMAT));
				pst.setDate(2, uF.getDateFormat(strD2, DATE_FORMAT));

			} else {
				pst = con.prepareStatement(selectHolidaysR1);
				pst.setInt(1, uF.parseToInt(uF.getDateFormat(uF.getCurrentDate(CF.getStrTimeZone()) + "", DBDATE, "yyyy")));

			}
			// System.out.println("pst======>"+pst);
			rs = pst.executeQuery();

			while (rs.next()) {

				if (isWithLocation) {
					if (hmHolidayDates != null
							&& !hmHolidayDates.containsKey(uF.getDateFormat(rs.getString("_date"), DBDATE, CF.getStrReportDateFormat()) + "_"
									+ rs.getString("wlocation_id")) && !weeklyOffDate.contains(uF.getDateFormat(rs.getString("_date"), DBDATE, DATE_FORMAT))) {
						hmHolidayDates.put(uF.getDateFormat(rs.getString("_date"), DBDATE, CF.getStrReportDateFormat()) + "_" + rs.getString("wlocation_id"),
								rs.getString("colour_code"));
						int count = uF.parseToInt(hmHolidays.get(rs.getString("wlocation_id")));
						hmHolidays.put(rs.getString("wlocation_id"), (count + 1) + "");
					}
				} else {
					if (hmHolidayDates != null && !hmHolidayDates.containsKey(uF.getDateFormat(rs.getString("_date"), DBDATE, CF.getStrReportDateFormat()))
							&& !weeklyOffDate.contains(uF.getDateFormat(rs.getString("_date"), DBDATE, DATE_FORMAT))) {
						hmHolidayDates.put(uF.getDateFormat(rs.getString("_date"), DBDATE, CF.getStrReportDateFormat()), rs.getString("colour_code"));
						int count = uF.parseToInt(hmHolidays.get(rs.getString("wlocation_id")));
						hmHolidays.put(rs.getString("wlocation_id"), (count + 1) + "");
					}
				}

			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
	}

	public String getElementDetails(Connection con, HttpServletRequest request, String elementId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		StringBuilder sb = new StringBuilder();
		try {

			pst = con.prepareStatement("select * from appraisal_element order by appraisal_element_id");
			rs = pst.executeQuery();
			// System.out.println("pst ===>> " + pst);
			while (rs.next()) {
				if (elementId != null && rs.getString("appraisal_element_id").equals(elementId)) {
					sb.append("<option value=" + rs.getString("appraisal_element_id") + " selected >" + rs.getString("appraisal_element_name") + "</option>");
				} else {
					sb.append("<option value=" + rs.getString("appraisal_element_id") + ">" + rs.getString("appraisal_element_name") + "</option>");
				}
			}
			rs.close();
			pst.close();
			// System.out.println("sb ===>> " + sb.toString());
			request.setAttribute("elementOptions", sb.toString());

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return sb.toString();
	}

	public String getAttributeListElementwise(Connection con, UtilityFunctions uF, HttpServletRequest request, String orgId, String elementId,
			String attributeId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		StringBuilder sb = new StringBuilder();
		try {
			StringBuilder sbLevelids = new StringBuilder();
			pst = con.prepareStatement("select level_id from level_details where org_id = ?");
			pst.setInt(1, uF.parseToInt(orgId));
			rs = pst.executeQuery();
			int cnt = 0;
			while (rs.next()) {
				if (cnt == 0) {
					sbLevelids.append(rs.getString("level_id"));
					cnt++;
				} else {
					sbLevelids.append("," + rs.getString("level_id"));
				}
			}
			rs.close();
			pst.close();

			StringBuilder sbQuery = new StringBuilder();
			sbQuery.append("select distinct(arribute_id) as arribute_id, attribute_name,appraisal_element_name from (select * from "
					+ "appraisal_attribute_level aal,appraisal_attribute aa where aal.attribute_id=aa.arribute_id and aa.status = true ");
			if (sbLevelids != null && !sbLevelids.toString().equals("")) {
				sbQuery.append(" and aal.level_id in (" + sbLevelids.toString() + ") ");
			}
			sbQuery.append(") a, appraisal_element ae where ae.appraisal_element_id = a.element_id and ae.appraisal_element_id=?");

			// sbQuery.append("select distinct(a.appraisal_attribute),a.appraisal_element,aa.attribute_name from (select "
			// +
			// "appraisal_element,appraisal_attribute from appraisal_element_attribute where appraisal_element = ?"
			// +
			// ") as a, appraisal_attribute aa where a.appraisal_attribute=aa.arribute_id ");
			// if(sbLevelids != null && !sbLevelids.toString().equals("")){
			// sbQuery.append("and level_id in ("+sbLevelids.toString()+")");
			// }

			sbQuery.append(" order by arribute_id");
			pst = con.prepareStatement(sbQuery.toString());
			pst.setInt(1, uF.parseToInt(elementId));
			rs = pst.executeQuery();
			// System.out.println("pst ===> "+pst);
			while (rs.next()) {
				if (attributeId != null && rs.getString("arribute_id").equals(attributeId)) {
					sb.append("<option value=" + rs.getString("arribute_id") + " selected>" + rs.getString("attribute_name") + "</option>");
				} else {
					sb.append("<option value=" + rs.getString("arribute_id") + ">" + rs.getString("attribute_name") + "</option>");
				}
				// al.add(new FillAttribute(rs.getString("appraisal_attribute"),
				// rs.getString("attribute_name")));
			}
			rs.close();
			pst.close();
			request.setAttribute("attributeOptions", sb.toString());
			// System.out.println("ATTRIBUTES =====> "+al.toString());
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return sb.toString();
	}

	public Map<String, String> getEmpOrgDetails(Connection con, UtilityFunctions uF, String strEmpId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmOrg = new HashMap<String, String>();
		try {
			pst = con.prepareStatement("select * from org_details where org_id in (select org_id from employee_official_details where emp_id=? and org_id>0)");
			pst.setInt(1, uF.parseToInt(strEmpId));
			// System.out.println("pst====>"+pst);
			rs = pst.executeQuery();
			while (rs.next()) {
				hmOrg.put("ORG_ID", rs.getString("org_id"));
				hmOrg.put("ORG_NAME", rs.getString("org_name"));
				hmOrg.put("ORG_SUB_TITLE", rs.getString("org_subtitle"));
				hmOrg.put("ORG_LOGO", rs.getString("org_logo"));
				hmOrg.put("ORG_ADDRESS", rs.getString("org_address"));
				hmOrg.put("ORG_PINCODE", rs.getString("org_pincode"));
				hmOrg.put("ORG_CONTACT", rs.getString("org_contact1"));
				hmOrg.put("ORG_EMAIL", rs.getString("org_email"));
				hmOrg.put("ORG_STATE_ID", rs.getString("org_state_id"));
				hmOrg.put("ORG_COUNTRY_ID", rs.getString("org_country_id"));
				hmOrg.put("ORG_CITY", rs.getString("org_city"));
				hmOrg.put("ORG_CODE", rs.getString("org_code"));
				hmOrg.put("ORG_DISPLAY_PAYCYCLE", rs.getString("display_paycycle"));
				hmOrg.put("ORG_DURATION_PAYCYCLE", rs.getString("duration_paycycle"));
				hmOrg.put("ORG_SALARY_CAL_BASIS", rs.getString("salary_cal_basis"));
				hmOrg.put("ORG_START_PAYCYCLE", uF.getDateFormat(rs.getString("start_paycycle"), DBDATE, DATE_FORMAT));
				hmOrg.put("ORG_TRRN_EPF", rs.getString("trrn_epf"));
				hmOrg.put("ORG_EPF_ACCOUNT_NO", rs.getString("epf_account_no"));
				hmOrg.put("ORG_SALARY_FIX_DAYS", rs.getString("salary_fix_days"));
				hmOrg.put("ORG_PAN_NO", rs.getString("org_pan_no"));
				hmOrg.put("ORG_TAN_NO", rs.getString("org_tan_no"));
				hmOrg.put("ORG_REG_NO", rs.getString("org_reg_no"));
				hmOrg.put("ORG_ST_REG_NO", rs.getString("org_st_reg_no"));
				hmOrg.put("ORG_ADDITIONAL_NOTE", rs.getString("org_additional_note"));
				hmOrg.put("ORG_OFFICES_AT", rs.getString("offices_at"));
				hmOrg.put("ORG_CURRENCY", rs.getString("org_currency"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmOrg;
	}

	public double getBonusCalculation(Connection con, CommonFunctions CF, UtilityFunctions uF, String strEmpId, String strD2,
			Map<String, String> hmEmpLevelMap, Map<String, Map<String, String>> hmTotal, String strFinancialYearStart, String strFinancialYearEnd,
			int nPayMonth, Map<String, String> hmEmpJoiningMap) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		double dblBonusCalculatedAmount = 0;

		try {

			String strJoiningDate = hmEmpJoiningMap.get(strEmpId);
			String strDays = uF.dateDifference(strJoiningDate, DATE_FORMAT, strD2, DATE_FORMAT, CF.getStrTimeZone());
			int nDays = uF.parseToInt(strDays);

			Map<String, String> hmTemp = hmTotal.get(BASIC + "");
			if (hmTemp == null)
				hmTemp = new HashMap<String, String>();
			double dblBasic = uF.parseToDouble(hmTemp.get("AMOUNT"));
			hmTemp = hmTotal.get(DA + "");
			if (hmTemp == null)
				hmTemp = new HashMap<String, String>();
			double dblDA = uF.parseToDouble(hmTemp.get("AMOUNT"));
			double dblTotalGross = dblBasic + dblDA;

			String strLevelId = hmEmpLevelMap.get(strEmpId);

			pst = con.prepareStatement(selectBonus1);
			pst.setDate(1, uF.getDateFormat(strFinancialYearStart, DATE_FORMAT));
			pst.setDate(2, uF.getDateFormat(strFinancialYearEnd, DATE_FORMAT));
			pst.setInt(3, uF.parseToInt(strLevelId));
			/*if(uF.parseToInt(strEmpId)==601){
				System.out.println("CF/20195---pst="+pst);
			}*/
			rs = pst.executeQuery();

			// double dblMinimumBonus = 0.0;
			double dblMaximumBonus = 0.0d;
			double dblBonusAmount = 0.0d;
			double dblMinimumBonusDays = 0.0d;
			String strBonusType = null;
			String strBonusPeriod = null;
			String strBonusSalary = null;
			String strEffectiveFY = null;
			String strSalaryCalculation = null;
			boolean isBonusCondition = false;
			double dblMin = 0.0d;
			double dblMax = 0.0d;
			double dblCondition1 = 0.0d;
			double dblMax2 = 0.0d;
			double dblCondition2 = 0.0d;

			if (rs.next()) {
				// dblMinimumBonus = rs.getDouble("bonus_minimum");
				dblMaximumBonus = rs.getDouble("bonus_maximum");
				dblBonusAmount = rs.getDouble("bonus_amount");
				dblMinimumBonusDays = rs.getDouble("bonus_minimum_days");
				strBonusType = rs.getString("bonus_type");
				strBonusPeriod = rs.getString("bonus_period");
				strBonusSalary = rs.getString("salary_head_id");
				strEffectiveFY = rs.getString("salary_effective_year");
				strSalaryCalculation = rs.getString("salary_calculation");

				isBonusCondition = uF.parseToBoolean(rs.getString("is_bonus_condition"));
				dblMin = rs.getDouble("min1");
				dblMax = rs.getDouble("max1");
				dblCondition1 = rs.getDouble("percentage1");

				dblMax2 = rs.getDouble("max2");
				dblCondition2 = rs.getDouble("percentage2");
			}
			rs.close();
			pst.close();

			String[] arrMonth = null;
			boolean isBonusCalculation = false;

			if (strBonusPeriod != null) {
				strBonusPeriod = strBonusPeriod.replaceAll("\\[", "");
				strBonusPeriod = strBonusPeriod.replaceAll("\\]", "");
				strBonusPeriod = strBonusPeriod.replaceAll(", ", ",");
				arrMonth = strBonusPeriod.split(",");

				if (arrMonth != null && ArrayUtils.contains(arrMonth, nPayMonth + "") >= 0) {
					isBonusCalculation = true;
				}
			}

			if (strBonusSalary != null) {
				int index = strBonusSalary.lastIndexOf(",");
				if(index>0) {
					strBonusSalary = strBonusSalary.substring(0, index);
				}
			}

			String[] arrSalary = null;
			if (strBonusSalary != null) {
				arrSalary = strBonusSalary.split(",");
			}

			double dblAmount = 0;
			double dblSalaryAmount = 0;

			if ("%".equalsIgnoreCase(strBonusType)) {
				
				if (uF.parseToInt(strSalaryCalculation) == 2) { // 2 is for cumulative
					pst = con.prepareStatement("select sum(amount) as amount from payroll_generation where salary_head_id in (" + strBonusSalary
							+ ") and emp_id = ? and financial_year_from_date=? and financial_year_to_date=? and paid_to<=? and paid_to>=?");
					pst.setInt(1, uF.parseToInt(strEmpId));

					if (uF.parseToInt(strSalaryCalculation) == 2) {// 2 is for previous year

						Calendar cal = GregorianCalendar.getInstance(TimeZone.getTimeZone(CF.getStrTimeZone()));
						cal.add(Calendar.YEAR, -1);
						String strPrevDate = uF.getDateFormat(cal.get(Calendar.DATE) + "/" + (cal.get(Calendar.DATE) + 1) + "/" + cal.get(Calendar.YEAR),
								DATE_FORMAT, DATE_FORMAT);
						String[] arrFinancialYear = CF.getFinancialYear(con, strPrevDate, CF, uF);
						pst.setDate(2, uF.getDateFormat(arrFinancialYear[0], DATE_FORMAT));
						pst.setDate(3, uF.getDateFormat(arrFinancialYear[1], DATE_FORMAT));
						pst.setDate(4, uF.getDateFormat(strPrevDate, DATE_FORMAT));
						pst.setDate(5, uF.getDateFormat(arrFinancialYear[0], DATE_FORMAT)); // This condittion needs to be modified if Bonus is paid 2nd or 3rd time.
					} else {
						String[] arrFinancialYear = CF.getFinancialYear(con, strD2, CF, uF);
						pst.setDate(2, uF.getDateFormat(arrFinancialYear[0], DATE_FORMAT));
						pst.setDate(3, uF.getDateFormat(arrFinancialYear[1], DATE_FORMAT));
						pst.setDate(4, uF.getDateFormat(strD2, DATE_FORMAT));
						pst.setDate(5, uF.getDateFormat(arrFinancialYear[0], DATE_FORMAT)); // This condittion needs to be modified if Bonus is paid 2nd or 3rd time.
					}
					// System.out.println("pst=====>"+pst);
					rs = pst.executeQuery();
					while (rs.next()) {
						dblSalaryAmount = uF.parseToDouble(rs.getString("amount"));
					}
					rs.close();
					pst.close();
				} else {

					/**
					 * If current salary is considered for previous months, then
					 * the condition needs to be added here.
					 * */
					for (int i = 0; arrSalary != null && i < arrSalary.length; i++) {

						hmTemp = hmTotal.get(arrSalary[i]);
						if (hmTemp == null)
							hmTemp = new HashMap<String, String>();
						dblSalaryAmount += uF.parseToDouble(hmTemp.get("AMOUNT"));
					}
				}
				if (isBonusCalculation && nDays >= dblMinimumBonusDays) {
					double dblCalculatedAmount = 0;
					if (isBonusCondition) {
						if (dblSalaryAmount > 0.0d && dblSalaryAmount >= dblMin && dblSalaryAmount <= dblMax) {
							dblAmount = (dblCondition1 * dblSalaryAmount) / 100;
						} else if (dblSalaryAmount > 0.0d && dblSalaryAmount <= dblMax2) {
							dblAmount = (dblCondition2 * dblMax2) / 100;
						}
					} else {
						dblAmount = (dblBonusAmount * dblSalaryAmount) / 100;
					}
					dblCalculatedAmount = dblAmount;
					if (dblCalculatedAmount > dblMaximumBonus) {
						dblBonusCalculatedAmount = dblMaximumBonus;
						
					} else {
						dblBonusCalculatedAmount = dblCalculatedAmount;
						
					}
				}
			} else {
				
				if (isBonusCalculation && nDays >= dblMinimumBonusDays) {
					dblBonusCalculatedAmount = dblBonusAmount;
					
				}
			}
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return dblBonusCalculatedAmount;
	}

	public Map<String, String> getRecruitmentDetails(Connection con, UtilityFunctions uF, CommonFunctions CF, HttpServletRequest request, String strId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmRecruitData = new HashMap<String, String>();
		try {
			// System.out.println("in getRecruitmentDetails strid " + strId);

			StringBuilder strQuery = new StringBuilder();

			// strQuery.append("select d.designation_code,d.designation_name,g.grade_code,g.grade_name,w.wlocation_name,r.no_position,"
			// +
			// "r.job_code,s.service_name,r.added_by,l.level_code,l.level_name,r.skills from recruitment_details r,grades_details g,"
			// +
			// "work_location_info w,designation_details d,services s,department_info di,employee_personal_details e,level_details l "
			// +
			// "where r.grade_id=g.grade_id and r.wlocation=w.wlocation_id and r.designation_id=d.designation_id and r.added_by=e.emp_per_id "
			// +
			// "and r.services=s.service_id and r.dept_id=di.dept_id and r.level_id=l.level_id and r.recruitment_id=?");

			strQuery.append("select d.designation_code,d.designation_name,g.grade_code,g.grade_name,w.wlocation_name,r.no_position,r.job_code,"
					+ "r.added_by,l.level_code,l.level_name,r.skills,r.added_by,r.job_title from recruitment_details r,grades_details g,work_location_info w,"
					+ "designation_details d,employee_personal_details e,level_details l where r.grade_id = g.grade_id and "
					+ "r.wlocation = w.wlocation_id and r.designation_id = d.designation_id and r.added_by = e.emp_per_id and "
					+ "r.level_id=l.level_id and r.recruitment_id=?"); // Created Dattatray Date : 05-10-21 Note:r.job_title

			pst = con.prepareStatement(strQuery.toString());
			pst.setInt(1, uF.parseToInt(strId));
			rs = pst.executeQuery();
			// System.out.println("new Date ===> " + new java.util.Date());
			while (rs.next()) {
				// System.out.println("in rst.next");
				hmRecruitData.put("DESIG_NAME", "[" + rs.getString("designation_code") + "] " + rs.getString("designation_name"));
				hmRecruitData.put("GRADE_NAME", "[" + rs.getString("grade_code") + "] " + rs.getString("grade_name"));
				hmRecruitData.put("WLOC_NAME", rs.getString("wlocation_name"));
				hmRecruitData.put("POSITIONS", rs.getString("no_position"));
				hmRecruitData.put("JOB_CODE", rs.getString("job_code"));
				hmRecruitData.put("EMP_ID", rs.getString("added_by"));
				hmRecruitData.put("LEVEL_NAME", "[" + rs.getString("level_code") + "] " + rs.getString("level_name"));
				hmRecruitData.put("SKILLS_NAME", rs.getString("skills"));
				hmRecruitData.put("ADDED_BY", rs.getString("added_by"));
				hmRecruitData.put("JOB_TITLE", rs.getString("job_title"));// Created Dattatray Date : 05-10-21 
			}
			rs.close();
			pst.close();

		} catch (SQLException e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

		return hmRecruitData;
	}

	public List<List<String>> getLevelLeaveTypeBalanceForEmp(Connection con, String strLevel, String strEmpId, CommonFunctions CF) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		UtilityFunctions uF = new UtilityFunctions();
		List<List<String>> leaveTypeListWithBalance = new ArrayList<List<String>>();
		try {
			// Map<String, String> hmEmpLeaveStartDateMap =
			// CF.getEmpJoiningDateMap(con, uF);
			int orgId = 0;
			int wLocationId = 0;
			String joiningDate = "";
			String empStatus = "";
			pst = con.prepareStatement("select wlocation_id,org_id,joining_date,emp_status from employee_personal_details epd, "
					+ "employee_official_details eod where emp_id = ? and epd.emp_per_id = eod.emp_id");
			pst.setInt(1, uF.parseToInt(strEmpId));
			// System.out.println("pst ===>> " + pst); ?
			rs = pst.executeQuery();
			while (rs.next()) {
				wLocationId = rs.getInt("wlocation_id");
				orgId = rs.getInt("org_id");
				joiningDate = uF.getDateFormat(rs.getString("joining_date"), DBDATE, DATE_FORMAT);
				empStatus = rs.getString("emp_status");
			}
			rs.close();
			pst.close();

			pst = con.prepareStatement("select * from probation_policy where emp_id = ?");
			pst.setInt(1, uF.parseToInt(strEmpId));
			rs = pst.executeQuery();
			String strAllowedLeaves = null;
			boolean isProbation = false;
			while (rs.next()) {
				strAllowedLeaves = rs.getString("leaves_types_allowed");
			}
			rs.close();
			pst.close();

			List<String> alEmpLeaves = null;
			if (strAllowedLeaves != null && strAllowedLeaves.length() > 0) {
				alEmpLeaves = Arrays.asList(strAllowedLeaves.split(","));
			}
			if (alEmpLeaves == null)
				alEmpLeaves = new ArrayList<String>();

			StringBuilder sbQuery = new StringBuilder();
			sbQuery.append("select * from emp_leave_type elt, leave_type lt where level_id = ? "
					+ "and wlocation_id = ? and elt.org_id = ? and elt.leave_type_id = lt.leave_type_id"
					+ " and lt.is_compensatory=false and elt.is_constant_balance=false ");
			sbQuery.append(" and (");
			sbQuery.append(" elt.leave_available like '%,0,%'");

			if (empStatus != null && empStatus.equals(PROBATION)) {
				sbQuery.append(" OR elt.leave_available like '%,1,%' ");
			}
			if (empStatus != null && empStatus.equals(PERMANENT)) {
				sbQuery.append(" OR elt.leave_available like '%,2,%' ");
			}
			if (empStatus != null && empStatus.equals(RESIGNED)) {
				sbQuery.append(" OR elt.leave_available like '%,3,%' ");
			}
			if (empStatus != null && empStatus.equals(TEMPORARY)) {
				sbQuery.append(" OR elt.leave_available like '%,4,%' ");
			}
			sbQuery.append(" ) ");
			pst = con.prepareStatement(sbQuery.toString());
			// pst =
			// con.prepareStatement("select * from emp_leave_type where level_id=?");
			pst.setInt(1, uF.parseToInt(strLevel));
			pst.setInt(2, wLocationId);
			pst.setInt(3, orgId);
			// System.out.println("pst ========>> " + pst);
			rs = pst.executeQuery();

			while (rs.next()) {
				// System.out.println("joiningDate ========>> " + joiningDate);
				if (!alEmpLeaves.contains(rs.getString("leave_type_id"))) {
					continue;
				}

				double dblTotal = 0;
				if (uF.parseToBoolean(rs.getString("is_prorata"))) {
					if ("CY".equalsIgnoreCase(rs.getString("effective_date_type"))) {
						dblTotal = CF.getLeavesCount1(joiningDate, uF.getDateFormat("31/12/" + uF.getYear(), DATE_FORMAT, DATE_FORMAT),
								rs.getDouble("no_of_leave"), rs.getBoolean("is_carryforward"), CF);
					} else if ("FY".equalsIgnoreCase(rs.getString("effective_date_type"))) {
						dblTotal = CF.getLeavesCount1(joiningDate, CF.getStrFinancialYearTo(), rs.getDouble("no_of_leave"), rs.getBoolean("is_carryforward"),
								CF);
					} else {
						dblTotal = CF.getLeavesCount1(joiningDate, uF.getDateFormat("31/12/" + uF.getYear(), DATE_FORMAT, DATE_FORMAT),
								rs.getDouble("no_of_leave"), rs.getBoolean("is_carryforward"), CF);
					}
				} else {
					dblTotal = rs.getDouble("no_of_leave");
				}
				if (rs.getInt("leave_type_id") > 0 && dblTotal > 0) {
					List<String> innerList = new ArrayList<String>();
					innerList.add(rs.getString("leave_type_id"));
					innerList.add(rs.getString("leave_type_name"));
					innerList.add("" + dblTotal);
					leaveTypeListWithBalance.add(innerList);
				}

			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return leaveTypeListWithBalance;
	}

	public boolean checkExistLeaveType(Connection con, String strLeaveType, String strEmpId, CommonFunctions CF) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		UtilityFunctions uF = new UtilityFunctions();
		boolean flag = false;
		try {

			// insert into
			// leave_register1(emp_id,_date,balance,leave_type_id,_type)values(?,?,?,?,?)");
			pst = con.prepareStatement("select * from leave_register1 where emp_id=? and leave_type_id=? and _type='C' ");
			pst.setInt(1, uF.parseToInt(strEmpId));
			pst.setInt(2, uF.parseToInt(strLeaveType));
			// System.out.println("checkExistLeaveType pst ===>> " + pst);
			rs = pst.executeQuery();
			while (rs.next()) {
				flag = true;
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return flag;
	}

	public String getEmpLevelId(Connection con, String empId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		UtilityFunctions uF = new UtilityFunctions();
		int levelId = 0;
		try {
			pst = con.prepareStatement("select * from level_details ld, grades_details gd, designation_details dd where dd.level_id = ld.level_id and dd.designation_id = gd.designation_id and grade_id in (select grade_id from employee_official_details where emp_id = ?)");
			pst.setInt(1, uF.parseToInt(empId));
			rs = pst.executeQuery();
			while (rs.next()) {
				levelId = rs.getInt("level_id");
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return levelId + "";
	}

	public String getEmpDesigId(Connection con, String empId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		UtilityFunctions uF = new UtilityFunctions();
		int desigId = 0;
		try {
			pst = con
					.prepareStatement("select designation_id from grades_details where grade_id in (select grade_id from employee_official_details where emp_id = ?)");
			pst.setInt(1, uF.parseToInt(empId));
			rs = pst.executeQuery();
			while (rs.next()) {
				desigId = rs.getInt("designation_id");
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return desigId + "";
	}

	public void insertLeaveBalanceForNewEmployee(Connection con, String strLeaveType, String strLeaveBalance, String strEmpId, CommonFunctions CF) {

		PreparedStatement pst1 = null;
		UtilityFunctions uF = new UtilityFunctions();
		ResultSet rs = null;
		try {

			boolean flag = checkExistLeaveType(con, strLeaveType, strEmpId, CF);
			if (!flag) {
				String strEmpJoiningDate = CF.getEmpJoiningDate(con, uF, uF.parseToInt(strEmpId));

				String strLeaveBalDate = null;
				boolean isJoiningDate = false;

				pst1 = con.prepareStatement("insert into leave_register1(emp_id,_date,balance,leave_type_id,_type)values(?,?,?,?,?)");
				pst1.setInt(1, uF.parseToInt(strEmpId));
				if (strEmpJoiningDate != null && !strEmpJoiningDate.trim().equals("") && !strEmpJoiningDate.trim().equalsIgnoreCase("NULL")) {
					isJoiningDate = true;
					java.util.Date dateJoin = uF.getDateFormatUtil(strEmpJoiningDate, DATE_FORMAT);
					java.util.Date dateCY = uF.getDateFormatUtil("01/01/" + uF.getYear(), DATE_FORMAT);
					String strJoinDate = strEmpJoiningDate;
					if (dateJoin.before(dateCY)) {
						strJoinDate = "01/01/" + uF.getYear();
					}
					strLeaveBalDate = strJoinDate;
					pst1.setDate(2, uF.getDateFormat(strJoinDate, DATE_FORMAT));
				} else {
					pst1.setDate(2, uF.getCurrentDate(CF.getStrTimeZone()));
				}
				pst1.setDouble(3, uF.parseToDouble(strLeaveBalance));
				pst1.setInt(4, uF.parseToInt(strLeaveType));
				pst1.setString(5, "C");
				System.out.println("pst1 =====> " + pst1);
				int x = pst1.executeUpdate();
				pst1.close();

				if (x > 0 && isJoiningDate && strLeaveBalDate != null && !strLeaveBalDate.trim().equals("") && !strLeaveBalDate.trim().equalsIgnoreCase("NULL")) {
					java.util.Date leaveJoinDate = uF.getDateFormatUtil(strLeaveBalDate, DATE_FORMAT);
					java.util.Date currDate = uF.getDateFormatUtil(uF.getDateFormat("" + uF.getCurrentDate(CF.getStrTimeZone()), DBDATE, DATE_FORMAT),
							DATE_FORMAT);
					if (leaveJoinDate.before(currDate)) {
						String strEmpWlocationId = CF.getEmpWlocationId(con, uF, strEmpId);
						String strEmpLevelId = CF.getEmpLevelId(con, strEmpId);
						String strEmpOrgId = CF.getEmpOrgId(con, uF, strEmpId);
						pst1 = con.prepareStatement("select * from emp_leave_type where is_accrued_cal_days=true and is_leave_accrual=true and level_id=? "
								+ "and wlocation_id=? and org_id=? and leave_type_id=?");
						pst1.setInt(1, uF.parseToInt(strEmpLevelId));
						pst1.setInt(2, uF.parseToInt(strEmpWlocationId));
						pst1.setInt(3, uF.parseToInt(strEmpOrgId));
						pst1.setInt(4, uF.parseToInt(strLeaveType));
						rs = pst1.executeQuery();
						boolean isAvailableLeave = false;
						if (rs.next()) {
							isAvailableLeave = true;
						}
						rs.close();
						pst1.close();
						// System.out.println("isAvailableLeave ===>> " +
						// isAvailableLeave);

						if (isAvailableLeave) {
							pst1 = con.prepareStatement("insert into leave_register1(emp_id,_date,balance,leave_type_id,_type,accrued)values(?,?,?,?, ?,?)");
							pst1.setInt(1, uF.parseToInt(strEmpId));
							pst1.setDate(2, uF.getCurrentDate(CF.getStrTimeZone()));
							pst1.setDouble(3, 0.0d);
							pst1.setInt(4, uF.parseToInt(strLeaveType));
							pst1.setString(5, "A");
							pst1.setDouble(6, 0.0d);
							System.out.println("pst1 =====> " + pst1);
							pst1.execute();
							pst1.close();
						}
					}
				}
			}//===start parvez on 03-08-2021===
			else{
				System.out.println("CF/20691--");
				String strEmpJoiningDate = CF.getEmpJoiningDate(con, uF, uF.parseToInt(strEmpId));

				String strLeaveBalDate = null;
				boolean isJoiningDate = false;
				String leaveTypeId1 = null;

				
				String strEmpWlocationId = CF.getEmpWlocationId(con, uF, strEmpId);
				String strEmpLevelId = CF.getEmpLevelId(con, strEmpId);
				String strEmpOrgId = CF.getEmpOrgId(con, uF, strEmpId);
				int strDistributedMonth = 0;
				pst1 = con.prepareStatement("select * from emp_leave_type where level_id=? and wlocation_id=? and org_id=? and distributed_month > 0");
				pst1.setInt(1, uF.parseToInt(strEmpLevelId));
				pst1.setInt(2, uF.parseToInt(strEmpWlocationId));
				pst1.setInt(3, uF.parseToInt(strEmpOrgId));
//				pst1.setInt(4, uF.parseToInt(strLeaveType));
				rs = pst1.executeQuery();
				while(rs.next()){
					strDistributedMonth = uF.parseToInt(rs.getString("distributed_month"));
					leaveTypeId1 = rs.getString("leave_type_id");
				}
				rs.close();
				pst1.close();
				
				java.util.Date empJoinDate = uF.getDateFormatUtil(strEmpJoiningDate, DATE_FORMAT);
				java.util.Date dateCY1 = uF.getDateFormatUtil("01/01/" + uF.getYear(), DATE_FORMAT);
				if(strDistributedMonth > 0 && empJoinDate.after(dateCY1)){
						
//						System.out.println("CF/20647--strLeaveBalance="+strLeaveBalance);
						pst1 = con.prepareStatement("update leave_register1 set _date=?,balance=? where emp_id=? and leave_type_id=?");
						
						if (strEmpJoiningDate != null && !strEmpJoiningDate.trim().equals("") && !strEmpJoiningDate.trim().equalsIgnoreCase("NULL")) {
							isJoiningDate = true;
							java.util.Date dateJoin = uF.getDateFormatUtil(strEmpJoiningDate, DATE_FORMAT);
							java.util.Date dateCY = uF.getDateFormatUtil("01/01/" + uF.getYear(), DATE_FORMAT);
							String strJoinDate = strEmpJoiningDate;
							if (dateJoin.before(dateCY)) {
								strJoinDate = "01/01/" + uF.getYear();
							}
							strLeaveBalDate = strJoinDate;
							pst1.setDate(1, uF.getDateFormat(strJoinDate, DATE_FORMAT));
						} else {
							pst1.setDate(1, uF.getCurrentDate(CF.getStrTimeZone()));
						}
						pst1.setDouble(2, uF.parseToDouble(strLeaveBalance));
						pst1.setInt(3, uF.parseToInt(strEmpId));
						pst1.setInt(4, uF.parseToInt(leaveTypeId1));
//						System.out.println("CF/20785--pst==>"+pst1);
						int y = pst1.executeUpdate();
						pst1.close();
						
						if(y == 0){
//							System.out.println("CF/20789--if");
							pst1 = con.prepareStatement("insert into leave_register1(emp_id,_date,balance,leave_type_id,_type)values(?,?,?,?,?)");
							pst1.setInt(1, uF.parseToInt(strEmpId));
							if (strEmpJoiningDate != null && !strEmpJoiningDate.trim().equals("") && !strEmpJoiningDate.trim().equalsIgnoreCase("NULL")) {
								isJoiningDate = true;
								java.util.Date dateJoin = uF.getDateFormatUtil(strEmpJoiningDate, DATE_FORMAT);
								java.util.Date dateCY = uF.getDateFormatUtil("01/01/" + uF.getYear(), DATE_FORMAT);
								String strJoinDate = strEmpJoiningDate;
								if (dateJoin.before(dateCY)) {
									strJoinDate = "01/01/" + uF.getYear();
								}
								strLeaveBalDate = strJoinDate;
								pst1.setDate(2, uF.getDateFormat(strJoinDate, DATE_FORMAT));
							} else {
								pst1.setDate(2, uF.getCurrentDate(CF.getStrTimeZone()));
							}
							pst1.setDouble(3, uF.parseToDouble(strLeaveBalance));
							pst1.setInt(4, uF.parseToInt(strLeaveType));
							pst1.setString(5, "C");
							// System.out.println("pst1 =====> " + pst1);
							int x = pst1.executeUpdate();
							pst1.close();

							if (x > 0 && isJoiningDate && strLeaveBalDate != null && !strLeaveBalDate.trim().equals("") && !strLeaveBalDate.trim().equalsIgnoreCase("NULL")) {
								
								java.util.Date leaveJoinDate = uF.getDateFormatUtil(strLeaveBalDate, DATE_FORMAT);
								java.util.Date currDate = uF.getDateFormatUtil(uF.getDateFormat("" + uF.getCurrentDate(CF.getStrTimeZone()), DBDATE, DATE_FORMAT),
										DATE_FORMAT);
								if (leaveJoinDate.before(currDate)) {
									/*String strEmpWlocationId = CF.getEmpWlocationId(con, uF, strEmpId);
									String strEmpLevelId = CF.getEmpLevelId(con, strEmpId);
									String strEmpOrgId = CF.getEmpOrgId(con, uF, strEmpId);*/
									pst1 = con.prepareStatement("select * from emp_leave_type where is_accrued_cal_days=true and is_leave_accrual=true and level_id=? "
											+ "and wlocation_id=? and org_id=? and leave_type_id=?");
									pst1.setInt(1, uF.parseToInt(strEmpLevelId));
									pst1.setInt(2, uF.parseToInt(strEmpWlocationId));
									pst1.setInt(3, uF.parseToInt(strEmpOrgId));
									pst1.setInt(4, uF.parseToInt(strLeaveType));
									rs = pst1.executeQuery();
									boolean isAvailableLeave = false;
									if (rs.next()) {
										isAvailableLeave = true;
									}
									rs.close();
									pst1.close();
									// System.out.println("isAvailableLeave ===>> " +
									// isAvailableLeave);

									if (isAvailableLeave) {
										pst1 = con.prepareStatement("insert into leave_register1(emp_id,_date,balance,leave_type_id,_type,accrued)values(?,?,?,?, ?,?)");
										pst1.setInt(1, uF.parseToInt(strEmpId));
										pst1.setDate(2, uF.getCurrentDate(CF.getStrTimeZone()));
										pst1.setDouble(3, 0.0d);
										pst1.setInt(4, uF.parseToInt(strLeaveType));
										pst1.setString(5, "A");
										pst1.setDouble(6, 0.0d);
										// System.out.println("pst1 =====> " + pst1);
										pst1.execute();
										pst1.close();
									}
								}
							}
						}
					}
					
					
			}
			//===end parvez on 03-08-2021=== 
			
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst1 != null) {
				try {
					pst1.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
	}

	public Map<String, String> getEmpExistLeaveBalance(Connection con, String strEmpId, CommonFunctions CF) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		UtilityFunctions uF = new UtilityFunctions();
		boolean flag = false;
		Map<String, String> hmEmpLeaveBalance = new HashMap<String, String>();
		try {
			pst = con.prepareStatement("select * from leave_register1 where emp_id = ? and _type = 'C' order by register_id");
			pst.setInt(1, uF.parseToInt(strEmpId));
			rs = pst.executeQuery();
			while (rs.next()) {
				hmEmpLeaveBalance.put(rs.getString("leave_type_id"), rs.getString("balance"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmEmpLeaveBalance;
	}

	public String getEmpOrgId(UtilityFunctions uF, String strEmpId, HttpServletRequest request) {
		Connection con = null;
		Database db = new Database();
		db.setRequest(request);
		PreparedStatement pst = null;
		ResultSet rs = null;
		String orgId = null;

		try {
			con = db.makeConnection(con);
			pst = con.prepareStatement("select org_id from employee_official_details WHERE emp_id = ?");
			pst.setInt(1, uF.parseToInt(strEmpId));
			rs = pst.executeQuery();
			while (rs.next()) {
				orgId = rs.getString("org_id");
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			db.closeResultSet(rs);
			db.closeStatements(pst);
			db.closeConnection(con);
		}
		return orgId;
	}

	public String getEmpWlocationId(Connection con, UtilityFunctions uF, String empId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		int wLocId = 0;
		try {
			pst = con.prepareStatement("select wlocation_id from employee_official_details where emp_id = ?");
			pst.setInt(1, uF.parseToInt(empId));
			rs = pst.executeQuery();
			while (rs.next()) {
				wLocId = rs.getInt("wlocation_id");
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return wLocId + "";
	}

	public List<String> getEmpTimesheetFilledDates(Connection con, UtilityFunctions uF, String empId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		List<String> filledDateList = new ArrayList<String>();
		try {
			pst = con.prepareStatement("select distinct (task_date) as task_date from task_activity where emp_id = ? order by task_date");
			pst.setInt(1, uF.parseToInt(empId));
			rs = pst.executeQuery();
			while (rs.next()) {
				filledDateList.add(uF.getDateFormat(rs.getString("task_date"), DBDATE, DATE_FORMAT));
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return filledDateList;
	}

	public List<String> getHolidayDateList(Connection con, String strD1, String strD2, CommonFunctions CF, Set<String> weeklyOffDate, String strWLocationId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		List<String> holidayDateList = new ArrayList<String>();
		try {

			if (strD1 != null && strD2 != null) {
				if (uF.parseToInt(strWLocationId) > 0) {
					pst = con
							.prepareStatement("SELECT * FROM holidays WHERE _date BETWEEN ? AND ? and wlocation_id = ? and (is_optional_holiday is null or is_optional_holiday=false) order by _date desc ");
					pst.setDate(1, uF.getDateFormat(strD1, DATE_FORMAT));
					pst.setDate(2, uF.getDateFormat(strD2, DATE_FORMAT));
					pst.setInt(3, uF.parseToInt(strWLocationId));
				} else {
					pst = con
							.prepareStatement("SELECT * FROM holidays WHERE _date BETWEEN ? AND ? and (is_optional_holiday is null or is_optional_holiday=false) order by _date desc ");
					pst.setDate(1, uF.getDateFormat(strD1, DATE_FORMAT));
					pst.setDate(2, uF.getDateFormat(strD2, DATE_FORMAT));
				}
			} else {
				if (uF.parseToInt(strWLocationId) > 0) {
					pst = con
							.prepareStatement("SELECT * FROM holidays WHERE _year=? and wlocation_id = ? and (is_optional_holiday is null or is_optional_holiday=false) order by _date desc");
					pst.setInt(1, uF.parseToInt(uF.getDateFormat(uF.getCurrentDate(CF.getStrTimeZone()) + "", DBDATE, "yyyy")));
					pst.setInt(2, uF.parseToInt(strWLocationId));
				} else {
					pst = con
							.prepareStatement("SELECT * FROM holidays WHERE _year=? and (is_optional_holiday is null or is_optional_holiday=false) order by _date desc");
					pst.setInt(1, uF.parseToInt(uF.getDateFormat(uF.getCurrentDate(CF.getStrTimeZone()) + "", DBDATE, "yyyy")));
				}
			}
			rs = pst.executeQuery();
			while (rs.next()) {
				if (!holidayDateList.contains(uF.getDateFormat(rs.getString("_date"), DBDATE, DATE_FORMAT))
						&& !weeklyOffDate.contains(uF.getDateFormat(rs.getString("_date"), DBDATE, DATE_FORMAT))) {
					holidayDateList.add(uF.getDateFormat(rs.getString("_date"), DBDATE, DATE_FORMAT));
				}
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return holidayDateList;
	}

	public Map<String, String> getRosterWeeklyOffPolicy(Connection con, UtilityFunctions uF) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmRosterWeeklyOff = new HashMap<String, String>();
		try {

			pst = con.prepareStatement("select * from roster_weeklyoff_policy");
			rs = pst.executeQuery();
			while (rs.next()) {
				hmRosterWeeklyOff.put(rs.getString("roster_weeklyoff_id"), rs.getString("weeklyoff_name"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmRosterWeeklyOff;
	}

	public Map<String, Map<String, String>> getRosterWeeklyOffDetails(Connection con, CommonFunctions CF, UtilityFunctions uF) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, Map<String, String>> hmRosterWeeklyoff = new HashMap<String, Map<String, String>>();
		try {

			String strReportDateFormat = DATE_FORMAT_STR;
			if (CF.getStrReportDateFormat() != null) {
				strReportDateFormat = CF.getStrReportDateFormat();
			}
			Map<String, String> hmEmpCodeName = CF.getEmpNameMap(con, null, null);
			if (hmEmpCodeName == null)
				hmEmpCodeName = new HashMap<String, String>();

			pst = con.prepareStatement("select * from roster_weeklyoff_policy where roster_weeklyoff_id >= 1 order by roster_weeklyoff_id desc");
			rs = pst.executeQuery();

			while (rs.next()) {
				Map<String, String> hmInner = new HashMap<String, String>();
				hmInner.put("ROSTER_WEEKLYOFF_ID", rs.getString("roster_weeklyoff_id"));
				hmInner.put("WEEKLYOFF_NAME", rs.getString("weeklyoff_name"));

				String weeklyoff_type = rs.getString("weeklyoff_type") != null && !rs.getString("weeklyoff_type").equals("") ? rs.getString("weeklyoff_type")
						.equals("HD") ? "Half Day" : "Full Day" : "";
				hmInner.put("WEEKLYOFF_TYPE", weeklyoff_type);

				String weeklyoff_day = "";
				if (rs.getString("weeklyoff_day") != null && !rs.getString("weeklyoff_day").equals("")) {
					String[] arr = rs.getString("weeklyoff_day").split(",");
					for (int i = 0; i < arr.length; i++) {
						if (i == 0) {
							weeklyoff_day = arr[i];
						} else {
							weeklyoff_day += "," + arr[i];
						}
					}
				}
				hmInner.put("WEEKLYOFF_DAY", weeklyoff_day);

				String weeklyoff_weekno = "";
				if (rs.getString("weeklyoff_weekno") != null && !rs.getString("weeklyoff_weekno").equals("")) {
					String[] arr = rs.getString("weeklyoff_weekno").split(",");
					for (int i = 0; i < arr.length; i++) {
						if (i == 0) {
							weeklyoff_weekno = "" + uF.parseToInt(arr[i]);
						} else {
							weeklyoff_weekno += "," + uF.parseToInt(arr[i]);
						}
					}
				}
				hmInner.put("WEEKLYOFF_WEEKNO", weeklyoff_weekno);
				hmInner.put("ENTRY_DATE", uF.getDateFormat(rs.getString("entry_date"), DBDATE, strReportDateFormat));
				hmInner.put("ADDED_BY", uF.showData(hmEmpCodeName.get(rs.getString("added_by")), ""));

				hmRosterWeeklyoff.put(rs.getString("roster_weeklyoff_id"), hmInner);
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmRosterWeeklyoff;
	}

	public void getEmpRosterWeekOffTypeByDate(Connection con, UtilityFunctions uF, CommonFunctions CF, String strStartDate, String strEndDate,
			List<String> alEmpCheckRosterWeektype, Map<String, Set<String>> hmRosterWeekEndDates, Map<String, Set<String>> hmWeekEndDates,
			Map<String, String> hmEmpLevelMap, Map<String, String> hmEmpWlocation, Map<String, Set<String>> hmWeekEndHalfDates) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		try {
			pst = con.prepareStatement("select emp_id from roster_details where roster_weeklyoff_id >= 1 and _date between ? and ? group by emp_id");
			pst.setDate(1, uF.getDateFormat(strStartDate, DATE_FORMAT));
			pst.setDate(2, uF.getDateFormat(strEndDate, DATE_FORMAT));
//			System.out.println("pst ===>> " + pst);
			rs = pst.executeQuery();
			while (rs.next()) {
				alEmpCheckRosterWeektype.add(rs.getString("emp_id"));
			}
			rs.close();
			pst.close();

			pst = con.prepareStatement("select * from roster_details where _date between ? and ? order by emp_id,_date");
			pst.setDate(1, uF.getDateFormat(strStartDate, DATE_FORMAT));
			pst.setDate(2, uF.getDateFormat(strEndDate, DATE_FORMAT));
			rs = pst.executeQuery();
			Map<String, List<List<String>>> hmRosterWeekOffType = new HashMap<String, List<List<String>>>();
			while (rs.next()) {
				List<List<String>> alList = hmRosterWeekOffType.get(rs.getString("emp_id"));
				if (alList == null)
					alList = new ArrayList<List<String>>();

				List<String> alInner = new ArrayList<String>();
				alInner.add(uF.getDateFormat(rs.getString("_date"), DBDATE, DATE_FORMAT));
				alInner.add(rs.getString("roster_weeklyoff_id"));
				alInner.add(rs.getString("shift_id"));
				alList.add(alInner);

				hmRosterWeekOffType.put(rs.getString("emp_id"), alList);
			}
			rs.close();
			pst.close();
//			System.out.println("hmRosterWeekOffType ===>> " + hmRosterWeekOffType.get("563"));
			
			Map<String, Map<String, String>> hmRosterWeeklyoff = CF.getRosterWeeklyOffDetails(con, CF, uF);
			if (hmRosterWeeklyoff == null)
				hmRosterWeeklyoff = new HashMap<String, Map<String, String>>();
			//
			// pst =
			// con.prepareStatement("select emp_id,weekoff_date from roster_weekly_off where weekoff_date between ? and ? order by emp_id,weekoff_date");
			// pst.setDate(1, uF.getDateFormat(strStartDate, DATE_FORMAT));
			// pst.setDate(2, uF.getDateFormat(strEndDate, DATE_FORMAT));
			// rs = pst.executeQuery();
			// while(rs.next()){
			// Set<String> setWeekEndDate
			// =hmRosterWeekEndDates.get(rs.getString("emp_id"));
			// if(setWeekEndDate == null) setWeekEndDate = new
			// HashSet<String>();
			//
			// setWeekEndDate.add(uF.getDateFormat(rs.getString("weekoff_date"),
			// DBDATE, DATE_FORMAT));
			// hmRosterWeekEndDates.put(rs.getString("emp_id"), setWeekEndDate);
			// }

			Iterator<String> it = hmRosterWeekOffType.keySet().iterator();
			while (it.hasNext()) {
				String strEmpId = it.next();
				List<List<String>> alList = hmRosterWeekOffType.get(strEmpId);

				String strWLocationId = hmEmpWlocation.get(strEmpId);
				Set<String> weeklyOffSet = hmWeekEndDates.get(strWLocationId);
				// String strLevelId = hmEmpLevelMap.get(strEmpId);
				// Set<String> weeklyOffSet= hmWeekEndDates.get(strLevelId);
				if (weeklyOffSet == null)
					weeklyOffSet = new HashSet<String>();

				Set<String> halfDayWeeklyOffSet = hmWeekEndHalfDates.get(strWLocationId);
				if (halfDayWeeklyOffSet == null)
					halfDayWeeklyOffSet = new HashSet<String>();

				for (int i = 0; alList != null && i < alList.size(); i++) {
					List<String> alInner = alList.get(i);
					if (uF.parseToInt(alInner.get(1)) == 1) {
						if (weeklyOffSet.contains(alInner.get(0))) {
							Set<String> setWeekEndDate = hmRosterWeekEndDates.get(strEmpId);
							if (setWeekEndDate == null)
								setWeekEndDate = new HashSet<String>();

							setWeekEndDate.add(alInner.get(0));
							hmRosterWeekEndDates.put(strEmpId, setWeekEndDate);
						} /*
						 * else
						 * if(halfDayWeeklyOffSet.contains(alInner.get(0))){
						 * Set<String> setWeekEndDate
						 * =hmRosterWeekEndDates.get(strEmpId);
						 * if(setWeekEndDate == null) setWeekEndDate = new
						 * HashSet<String>();
						 * 
						 * setWeekEndDate.add(alInner.get(0));
						 * hmRosterWeekEndDates.put(strEmpId, setWeekEndDate); }
						 */
					} else {
						String strDay = uF.getDateFormat(alInner.get(0), DATE_FORMAT, "EEEE");
						if (strDay != null)
							strDay = strDay.toUpperCase();

						Map<String, String> hmInner = (Map<String, String>) hmRosterWeeklyoff.get(alInner.get(1));
						if (hmInner == null)
							hmInner = new HashMap<String, String>();
						List<String> weeklyOffDayList = hmInner.get("WEEKLYOFF_DAY") != null && !hmInner.get("WEEKLYOFF_DAY").equals("") ? Arrays
								.asList(hmInner.get("WEEKLYOFF_DAY").trim().split(",")) : new ArrayList<String>();

						List<String> weekNoList = hmInner.get("WEEKLYOFF_WEEKNO") != null && !hmInner.get("WEEKLYOFF_WEEKNO").equals("") ? Arrays
								.asList(hmInner.get("WEEKLYOFF_WEEKNO").trim().split(",")) : new ArrayList<String>();

						if (weeklyOffDayList != null && weeklyOffDayList.contains(strDay)) {
							String strDate = uF.getDateFormat(alInner.get(0), DATE_FORMAT, DATE_FORMAT);
							int checkWeek = CF.getMonthCount(uF, strDate);
							if (weekNoList.contains("" + checkWeek)) {
								Set<String> setWeekEndDate = hmRosterWeekEndDates.get(strEmpId);
								if (setWeekEndDate == null)
									setWeekEndDate = new HashSet<String>();

								setWeekEndDate.add(alInner.get(0));
								hmRosterWeekEndDates.put(strEmpId, setWeekEndDate);
							}
						}
					}
				}
			}

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
	}

	public int getMonthCount(UtilityFunctions uF, String strDate) {

		Calendar mycal = Calendar.getInstance();
		mycal.setTime(uF.getDateFormat(strDate, DATE_FORMAT));

		java.util.Date d1 = uF.getDateFormatUtil("01" + "/" + (mycal.get(Calendar.MONTH) + 1) + "/" + mycal.get(Calendar.YEAR), DATE_FORMAT);
		java.util.Date d2 = uF.getDateFormatUtil(strDate, DATE_FORMAT);

		int cnt = 0;
		while (d1.compareTo(d2) <= 0) {
			cnt++;
			mycal.add(Calendar.DATE, -7);
			d2 = mycal.getTime();
			if (cnt == 10) {
				break;
			}
		}

		return cnt;

	}

//===start parvez date: 24-03-2022===	
	public Map<String, String> getEmpNetSalary(UtilityFunctions uF, CommonFunctions CF, Connection con, String strDate, String strType, Map<String,String> hmWorkDays ) {
//	public Map<String, String> getEmpNetSalary(UtilityFunctions uF, CommonFunctions CF, Connection con, String strDate, String strType ) {

		PreparedStatement pst = null;
		ResultSet rs = null;

		Map<String, String> hmEmpCostRateAmountMap = new HashMap<String, String>();

		Map<String, String> hmEmpEDAmountMap = new HashMap<String, String>();
		Map<String, String> hmEmpIdMap = new HashMap<String, String>();

		Map<String, String> hmEmpEmpType = getEmpTypeMap(con);
		Map<String, String> hmEmpOrgId = getEmpOrgIdList(con, uF);
		try {

			// pst =
			// con.prepareStatement("select emp_id, sum(amount) as gross from ( select sd.emp_id, amount from emp_salary_details sd, ( select max(effective_date) as effective_date, emp_id from emp_salary_details where effective_date <= ? and is_approved = true group by emp_id) a where sd.emp_id = a.emp_id and sd.effective_date = a.effective_date and earning_deduction = 'E' order by sd.emp_id) b group by emp_id ");
			pst = con.prepareStatement("select emp_id, sum(amount) as sal_amt, earning_deduction from ( select sd.emp_id, amount, sd.earning_deduction from emp_salary_details sd, ("
				+ "select max(effective_date) as effective_date, emp_id from emp_salary_details where effective_date <= ? and is_approved = true group by emp_id) a where "
				+ "sd.emp_id = a.emp_id and sd.effective_date = a.effective_date order by sd.emp_id ) b group by emp_id, earning_deduction order by emp_id");
			pst.setDate(1, uF.getDateFormat(strDate, DBDATE));
			rs = pst.executeQuery();
			while (rs.next()) {
				hmEmpIdMap.put(rs.getString("emp_id"), rs.getString("emp_id"));
				if (rs.getString("earning_deduction") != null && rs.getString("earning_deduction").equalsIgnoreCase("E")) {
					hmEmpEDAmountMap.put(rs.getString("emp_id") + "_E", rs.getString("sal_amt"));
				} else if (rs.getString("earning_deduction") != null && rs.getString("earning_deduction").equalsIgnoreCase("D")) {
					hmEmpEDAmountMap.put(rs.getString("emp_id") + "_D", rs.getString("sal_amt"));
				}
			}
			rs.close();
			pst.close();

			Iterator<String> it = hmEmpIdMap.keySet().iterator();
			while (it.hasNext()) {
				String empId = it.next();
				String empOrgId = hmEmpOrgId.get(empId);
				String empType = hmEmpEmpType.get(empId);
				pst = con.prepareStatement("select org_id, calculation_type, days,artical_days from cost_calculation_settings where org_id = ?");
				pst.setInt(1, uF.parseToInt(empOrgId));
				// System.out.println("pst ===> " + pst);
				rs = pst.executeQuery();
				Map<String, String> hmOrgCalType = new HashMap<String, String>();
				while (rs.next()) {
					hmOrgCalType.put("CAL_TYPE", rs.getString("calculation_type"));
					hmOrgCalType.put("DAYS", rs.getString("days"));
					hmOrgCalType.put("ARTICAL_DAYS", rs.getString("artical_days"));
				}
				rs.close();
				pst.close();

				double nTotalNumberOfDays = 30;
				if (uF.parseToInt(hmOrgCalType.get("CAL_TYPE")) == 3 && empType!=null && empType.equals("AT")) {
					nTotalNumberOfDays = uF.parseToDouble(hmOrgCalType.get("ARTICAL_DAYS"));
				} else if (uF.parseToInt(hmOrgCalType.get("CAL_TYPE")) == 3) {
					nTotalNumberOfDays = uF.parseToDouble(hmOrgCalType.get("DAYS"));
		//===start parvez date: 24-03-2022===		
				} else if (uF.parseToInt(hmOrgCalType.get("CAL_TYPE")) == 2 && hmWorkDays.get(empId) !=null) {
					nTotalNumberOfDays = uF.parseToDouble(hmWorkDays.get(empId));
				}
		//===end parvez date: 24-03-2022===		

				double empNetSal = uF.parseToDouble(hmEmpEDAmountMap.get(empId + "_E")) - uF.parseToDouble(hmEmpEDAmountMap.get(empId + "_D"));
				if (strType != null && strType.equalsIgnoreCase("D")) {
					hmEmpCostRateAmountMap.put(empId, uF.formatIntoTwoDecimal(CF.getDailyAmount(empNetSal, nTotalNumberOfDays, CF)));
				} else if (strType != null && strType.equalsIgnoreCase("H")) {
					hmEmpCostRateAmountMap.put(empId, uF.formatIntoTwoDecimal(CF.getHourlyAmount(empNetSal, nTotalNumberOfDays, CF)));
				} else {
					hmEmpCostRateAmountMap.put(empId, uF.formatIntoTwoDecimal(CF.getHourlyAmount(empNetSal, nTotalNumberOfDays, CF)));
				}
			}
			// System.out.println("strType ===> " + strType);
			// System.out.println("hmEmpCostRateAmountMap ===> " +
			// hmEmpCostRateAmountMap);

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmEmpCostRateAmountMap;
	}
//===end parvez date: 24-03-2022===	

	public String getServiceNameById(Connection con, String serviceId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		String serviceName = null;
		try {
			pst = con.prepareStatement("SELECT service_name FROM services where service_id = ? ");
			pst.setInt(1, uF.parseToInt(serviceId));
			rs = pst.executeQuery();
			// System.out.println("pst ===>> " + pst);
			while (rs.next()) {
				serviceName = rs.getString("service_name");
			}
			rs.close();
			pst.close();
			// System.out.println("serviceName ===>> " + serviceName);
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return serviceName;
	}

	public String getSelectedFilter1(CommonFunctions CF, UtilityFunctions uF, List<String> alFilter, Map<String, String> hmFilter) {
		StringBuilder sbFilter = new StringBuilder("<span style=\"float: left; margin-right: 5px;\"><i class=\"fa fa-filter\"></i></span>");
		sbFilter.append("<span style=\" width: 95%; float: left;\">");

		int cnt = 0;
		for (int i = 0; alFilter != null && i < alFilter.size(); i++) {
			if (i > 0) {
				if (!alFilter.get(i).equals("LBL_FINANCIALYEAR")) {
					sbFilter.append(", ");
				}
			}
			if (alFilter.get(i).equals("PROJECT_TYPE")) {
				sbFilter.append("<strong>PROJECT TYPE:</strong> ");
				sbFilter.append(hmFilter.get("PROJECT_TYPE"));
				cnt++;
			} else if (alFilter.get(i).equals("ORGANISATION")) {
				sbFilter.append("<strong>ORG:</strong> ");
				sbFilter.append(hmFilter.get("ORGANISATION"));
				cnt++;
			} else if (alFilter.get(i).equals("LOCATION")) {
				sbFilter.append("<strong>LOC:</strong> ");
				sbFilter.append(hmFilter.get("LOCATION"));
				cnt++;
			} else if (alFilter.get(i).equals("DEPARTMENT")) {
				sbFilter.append("<strong>DEP:</strong> ");
				sbFilter.append(hmFilter.get("DEPARTMENT"));
				cnt++;
			} else if (alFilter.get(i).equals("SERVICE")) {
				sbFilter.append("<strong>SBU:</strong> ");
				sbFilter.append(hmFilter.get("SERVICE"));
				cnt++;
			} else if (alFilter.get(i).equals("LEVEL")) {
				sbFilter.append("<strong>LEVEL:</strong> ");
				sbFilter.append(hmFilter.get("LEVEL"));
				cnt++;
			} else if (alFilter.get(i).equals("PROJECT_SERVICE")) {
				sbFilter.append("<strong>SERVICE:</strong> ");
				sbFilter.append(hmFilter.get("PROJECT_SERVICE"));
				cnt++;
			} else if (alFilter.get(i).equals("CLIENT")) {
				sbFilter.append("<strong>CLIENT:</strong> ");
				sbFilter.append(hmFilter.get("CLIENT"));
				cnt++;
			} else if (alFilter.get(i).equals("PROJECT")) {
				sbFilter.append("<strong>PROJECT:</strong> ");
				sbFilter.append(hmFilter.get("PROJECT"));
				cnt++;
			} else if (alFilter.get(i).equals("PERIOD")) {
				if (cnt > 0) {
					sbFilter.append("<br/>");
				}
				sbFilter.append("<strong>PERIOD:</strong> ");
				sbFilter.append(hmFilter.get("PERIOD"));
				cnt++;
			} else if (alFilter.get(i).equals("FROM_TO")) {
				if (cnt > 0) {
					sbFilter.append("<br/>");
				}
				sbFilter.append("<strong>PERIOD:</strong> ");
				sbFilter.append(hmFilter.get("FROM_TO"));
				cnt++;
			} else if (alFilter.get(i).equals("FROMTO")) {
				sbFilter.append(hmFilter.get("FROMTO"));
				cnt++;
			} else if (alFilter.get(i).equals("FINANCIALYEAR")) {
				sbFilter.append(hmFilter.get("FINANCIALYEAR"));
				cnt++;
			} else if (alFilter.get(i).equals("MONTH")) {
				sbFilter.append(hmFilter.get("MONTH"));
				cnt++;
			} else if (alFilter.get(i).equals("PAYCYCLE")) {
				sbFilter.append(hmFilter.get("PAYCYCLE"));
				cnt++;
			} else if (alFilter.get(i).equals("BILL_TYPE")) {
				sbFilter.append("<strong>BILLING TYPE:</strong> ");
				sbFilter.append(hmFilter.get("BILL_TYPE"));
				cnt++;
			} else if (alFilter.get(i).equals("BILL_FREQUENCY")) {
				sbFilter.append("<strong>BILLING FREQUENCY:</strong> ");
				sbFilter.append(hmFilter.get("BILL_FREQUENCY"));
				cnt++;
			} else if (alFilter.get(i).equals("PROJECT_STATUS")) {
				sbFilter.append("<strong>STATUS:</strong> ");
				sbFilter.append(hmFilter.get("PROJECT_STATUS"));
				cnt++;
			} else if (alFilter.get(i).equals("STATUS")) {
				sbFilter.append("<strong>STATUS:</strong> ");
				sbFilter.append(hmFilter.get("STATUS"));
				cnt++;
			} else if (alFilter.get(i).equals("FREQ")) {
				sbFilter.append("<strong>FREQUENCY:</strong> ");
				sbFilter.append(hmFilter.get("FREQ"));
				cnt++;
			} else if (alFilter.get(i).equals("COUNTRY")) {
				sbFilter.append("<strong>COUNTRY:</strong> ");
				sbFilter.append(hmFilter.get("COUNTRY"));
				cnt++;
			}
		}
		sbFilter.append("</span>");

		return sbFilter.toString();
	}

	public String getSelectedFilter2(CommonFunctions CF, UtilityFunctions uF, List<String> alFilter, Map<String, String> hmFilter) {
		StringBuilder sbFilter = new StringBuilder("<span style=\"float: left; margin-right: 5px;\"><i class=\"fa fa-filter\"></i></span>");
		sbFilter.append("<span style=\"width: 95%;float: left;\">");

		int cnt = 0;
		for (int i = 0; alFilter != null && i < alFilter.size(); i++) {
			if (i > 0) {
				sbFilter.append(", ");
			}
			if (alFilter.get(i).equals("PROJECT_TYPE")) {
				sbFilter.append("<strong>PROJECT TYPE:</strong> ");
				sbFilter.append(hmFilter.get("PROJECT_TYPE"));
				cnt++;
			} else if (alFilter.get(i).equals("EMP")) {
				sbFilter.append("<strong>EMP:</strong> ");
				sbFilter.append(hmFilter.get("EMP"));
				cnt++;
			} else if (alFilter.get(i).equals("ACTIVITY")) {
				sbFilter.append("<strong>ACTIVITY:</strong> ");
				sbFilter.append(hmFilter.get("ACTIVITY"));
				cnt++;
			} else if (alFilter.get(i).equals("PAYMENTMODE")) {
				sbFilter.append("<strong>PAYMENT MODE:</strong> ");
				sbFilter.append(hmFilter.get("PAYMENTMODE"));
				cnt++;
			} else if (alFilter.get(i).equals("LOANSTATUS")) {
				sbFilter.append("<strong>LOAN STATUS:</strong> ");
				sbFilter.append(hmFilter.get("LOANSTATUS"));
				cnt++;
			} else if (alFilter.get(i).equals("ORGANISATION")) {
				sbFilter.append("<strong>ORG:</strong> ");
				sbFilter.append(hmFilter.get("ORGANISATION"));
				cnt++;
			} else if (alFilter.get(i).equals("LOCATION")) {
				sbFilter.append("<strong>LOC:</strong> ");
				sbFilter.append(hmFilter.get("LOCATION"));
				cnt++;
			} else if (alFilter.get(i).equals("DEPARTMENT")) {
				sbFilter.append("<strong>DEP:</strong> ");
				sbFilter.append(hmFilter.get("DEPARTMENT"));
				cnt++;
			} else if (alFilter.get(i).equals("SERVICE")) {
				sbFilter.append("<strong>SBU:</strong> ");
				sbFilter.append(hmFilter.get("SERVICE"));
				cnt++;
			} else if (alFilter.get(i).equals("LEVEL")) {
				sbFilter.append("<strong>LEVEL:</strong> ");
				sbFilter.append(hmFilter.get("LEVEL"));
				cnt++;
			} else if (alFilter.get(i).equals("SKILL")) {
				sbFilter.append("<strong>SKILL:</strong> ");
				sbFilter.append(hmFilter.get("SKILL"));
				cnt++;
			} else if (alFilter.get(i).equals("EDUCATION")) {
				sbFilter.append("<strong>EDUCATION:</strong> ");
				sbFilter.append(hmFilter.get("EDUCATION"));
				cnt++;
			} else if (alFilter.get(i).equals("PROJECT_SERVICE")) {
				sbFilter.append("<strong>SERVICE:</strong> ");
				sbFilter.append(hmFilter.get("PROJECT_SERVICE"));
				cnt++;
			} else if (alFilter.get(i).equals("RESOURCE_TYPE")) {
				sbFilter.append("<strong>RESOURCE:</strong> ");
				sbFilter.append(hmFilter.get("RESOURCE_TYPE"));
				cnt++;
			} else if (alFilter.get(i).equals("CLIENT")) {
				sbFilter.append("<strong>CLIENT:</strong> ");
				sbFilter.append(hmFilter.get("CLIENT"));
				cnt++;
			} else if (alFilter.get(i).equals("PROJECT")) {
				sbFilter.append("<strong>PROJECT:</strong> ");
				sbFilter.append(hmFilter.get("PROJECT"));
				cnt++;
			} else if (alFilter.get(i).equals("PROJECT_OWNER")) {
				sbFilter.append("<strong>PROJECT OWNER:</strong> ");
				sbFilter.append(hmFilter.get("PROJECT_OWNER"));
				cnt++;
			} else if (alFilter.get(i).equals("STATE")) {
				sbFilter.append("<strong>STATE:</strong> ");
				sbFilter.append(hmFilter.get("STATE"));
				cnt++;
			} else if (alFilter.get(i).equals("GENDER")) {
				sbFilter.append("<strong>GENDER:</strong> ");
				sbFilter.append(hmFilter.get("GENDER"));
				cnt++;
			} else if (alFilter.get(i).equals("PERIOD")) {
				if (cnt > 0) {
					sbFilter.append("<br/>");
				}
				sbFilter.append("<strong>PERIOD:</strong> ");
				sbFilter.append(hmFilter.get("PERIOD"));
				cnt++;
			} else if (alFilter.get(i).equals("FROMTO")) {
				sbFilter.append(uF.showData(hmFilter.get("FROMTO"), ""));

			} else if (alFilter.get(i).equals("FINANCIALYEAR")) {
				if (cnt > 0) {
					sbFilter.append("<br/>");
				}
				sbFilter.append("<strong>FINANCIAL YEAR:</strong> ");
				sbFilter.append(hmFilter.get("FINANCIALYEAR"));
				cnt++;
			} else if (alFilter.get(i).equals("MONTH")) {
				sbFilter.append("<strong>MONTH:</strong> ");
				sbFilter.append(hmFilter.get("MONTH"));
				cnt++;
			} else if (alFilter.get(i).equals("YEAR")) {
				sbFilter.append("<strong>YEAR:</strong> ");
				sbFilter.append(hmFilter.get("YEAR"));
				cnt++;
			} else if (alFilter.get(i).equals("PAYCYCLE")) {
				if (cnt > 0) {
					sbFilter.append("<br/>");
				}
				sbFilter.append("<strong>PAYCYCLE:</strong> ");
				sbFilter.append(hmFilter.get("PAYCYCLE"));
				cnt++;
			} else if (alFilter.get(i).equals("CALENDARYEAR")) {
				if (cnt > 0) {
					sbFilter.append("<br/>");
				}
				sbFilter.append("<strong>CALENDAR YEAR:</strong> ");
				sbFilter.append(hmFilter.get("CALENDARYEAR"));
				cnt++;
			} else if (alFilter.get(i).equals("LEAVE_STATUS")) {
				sbFilter.append("<strong>STATUS:</strong> ");
				sbFilter.append(hmFilter.get("LEAVE_STATUS"));
				cnt++;
			} else if (alFilter.get(i).equals("WEEK")) {
				sbFilter.append("<strong>WEEK:</strong> ");
				sbFilter.append(hmFilter.get("WEEK"));
				cnt++;
			} else if (alFilter.get(i).equals("DATE")) {
				sbFilter.append("<strong>DATE:</strong> ");
				sbFilter.append(hmFilter.get("DATE"));
				cnt++;
			} else if (alFilter.get(i).equals("PAID_STATUS")) {
				sbFilter.append("<strong>PAID STATUS:</strong> ");
				sbFilter.append(hmFilter.get("PAID_STATUS"));
				cnt++;
			} else if (alFilter.get(i).equals("ALLOWHEAD")) {
				sbFilter.append("<strong>ALLOWANCE HEAD:</strong> ");
				sbFilter.append(hmFilter.get("ALLOWHEAD"));
				cnt++;
			} else if (alFilter.get(i).equals("DURATION")) {
				sbFilter.append("<strong>DURATION:</strong> ");
				sbFilter.append(hmFilter.get("DURATION"));
				cnt++;
			} else if (alFilter.get(i).equals("STATUS")) {
				sbFilter.append("<strong>STATUS:</strong> ");
				sbFilter.append(hmFilter.get("STATUS"));
				cnt++;
			} else if (alFilter.get(i).equals("SAL_HEAD")) {
				sbFilter.append("<strong>SALARY HEAD:</strong> ");
				sbFilter.append(hmFilter.get("SAL_HEAD"));
				cnt++;
			} else if (alFilter.get(i).equals("PRODUCTIONLINE")) {
				sbFilter.append("<strong>PRODUCTION LINE:</strong> ");
				sbFilter.append(hmFilter.get("PRODUCTIONLINE"));
				cnt++;
			} else if (alFilter.get(i).equals("DESIG")) {
				sbFilter.append("<strong>DESIG:</strong> ");
				sbFilter.append(hmFilter.get("DESIG"));
				cnt++;
			} else if (alFilter.get(i).equals("EXPERIENCE")) {
				sbFilter.append("<strong>EXPERIENCE:</strong> ");
				sbFilter.append(hmFilter.get("EXPERIENCE"));
				cnt++;
			} else if (alFilter.get(i).equals("REPORT_TYPE")) {
				sbFilter.append("<strong>REPORT TYPE:</strong> ");
				sbFilter.append(hmFilter.get("REPORT_TYPE"));
				cnt++;
			} else if (alFilter.get(i).equals("EMPTYPE")) {
				sbFilter.append("<strong>EMPLOYEE TYPE:</strong> ");
				sbFilter.append(hmFilter.get("EMPTYPE"));
				cnt++;
			} else if (alFilter.get(i).equals("EMPSTATUS")) {
				sbFilter.append("<strong>EMPLOYEE STATUS:</strong> ");
				sbFilter.append(hmFilter.get("EMPSTATUS"));
				cnt++;
			} else if (alFilter.get(i).equals("GRADE")) {
				sbFilter.append("<strong>GRADE:</strong> ");
				sbFilter.append(hmFilter.get("GRADE"));
				cnt++;
			} else if (alFilter.get(i).equals("AS_OF_DATE")) {
				sbFilter.append("<strong>AS OF DATE:</strong> ");
				sbFilter.append(hmFilter.get("AS_OF_DATE"));
				cnt++;
			} else if (alFilter.get(i).equals("BANK")) {
				sbFilter.append("<strong>BANK:</strong> ");
				sbFilter.append(hmFilter.get("BANK"));
				cnt++;
			} else if (alFilter.get(i).equals("REIMBURSEMENT_TYPE")) {
				sbFilter.append("<strong>REIMBURSEMENT TYPE:</strong> ");
				sbFilter.append(hmFilter.get("REIMBURSEMENT_TYPE"));
				cnt++;
			} else if (alFilter.get(i).equals("CLASS")) {
				sbFilter.append("<strong>CLASS:</strong> ");
				sbFilter.append(hmFilter.get("CLASS"));
				cnt++;
			} else if (alFilter.get(i).equals("USERTYPE")) {
				sbFilter.append("<strong>USERTYPE:</strong> ");
				sbFilter.append(hmFilter.get("USERTYPE"));
				cnt++;
			}
		}
		sbFilter.append("</span>");

		return sbFilter.toString();
	}

	public String getClientNameById(Connection con, String clientId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		String clientName = null;
		try {
			pst = con.prepareStatement("SELECT client_name FROM client_details where client_id = ? ");
			pst.setInt(1, uF.parseToInt(clientId));
			rs = pst.executeQuery();
			// System.out.println("pst ===>> " + pst);
			while (rs.next()) {
				clientName = rs.getString("client_name");
			}
			rs.close();
			pst.close();
			// System.out.println("serviceName ===>> " + serviceName);
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return clientName;
	}

	public String getEmpCodeByEmpId(Connection con, String strEmpId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		String empCode = null;
		try {
			pst = con.prepareStatement("SELECT empcode FROM employee_personal_details epd where epd.emp_per_id = ? ");
			pst.setInt(1, uF.parseToInt(strEmpId));
			rs = pst.executeQuery();
			while (rs.next()) {
				empCode = rs.getString("empcode");
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return empCode;
	}

	public Map<String, String> getEmpOrgIdList(Connection con, UtilityFunctions uF) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmEmpOrgId = new HashMap<String, String>();
		try {
			pst = con.prepareStatement("select emp_id,org_id from employee_official_details");
			rs = pst.executeQuery();
			while (rs.next()) {
				hmEmpOrgId.put(rs.getString("emp_id"), rs.getString("org_id"));
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmEmpOrgId;
	}

	public String getWorkLocationNameById(Connection con, String wLocId) {
		UtilityFunctions uF = new UtilityFunctions();
		PreparedStatement pst = null;
		ResultSet rs = null;
		String wLocName = null;
		try {
			pst = con.prepareStatement("select wlocation_name from work_location_info where wlocation_id = ?");
			pst.setInt(1, uF.parseToInt(wLocId));
			rs = pst.executeQuery();
			while (rs.next()) {
				wLocName = rs.getString("wlocation_name");
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return wLocName;
	}

	public String getProjectServiceNameById(Connection con, String serviceId) {
		UtilityFunctions uF = new UtilityFunctions();
		PreparedStatement pst = null;
		ResultSet rs = null;
		String serviceName = null;
		try {
			pst = con.prepareStatement("select service_name from services_project where service_project_id = ?");
			pst.setInt(1, uF.parseToInt(serviceId));
			rs = pst.executeQuery();
			while (rs.next()) {
				serviceName = rs.getString("service_name");
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return serviceName;
	}

	public String getOrgNameById(Connection con, String orgId) {
		UtilityFunctions uF = new UtilityFunctions();
		PreparedStatement pst = null;
		ResultSet rs = null;
		String orgName = null;
		try {
			pst = con.prepareStatement("select org_name from org_details where org_id = ?");
			pst.setInt(1, uF.parseToInt(orgId));
			rs = pst.executeQuery();
			while (rs.next()) {
				orgName = rs.getString("org_name");
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return orgName;
	}

	public String getDepartMentNameById(Connection con, String departId) {
		UtilityFunctions uF = new UtilityFunctions();
		PreparedStatement pst = null;
		ResultSet rs = null;
		String departName = null;
		try {
			pst = con.prepareStatement("select dept_name from department_info where dept_id = ?");
			pst.setInt(1, uF.parseToInt(departId));
			rs = pst.executeQuery();
			while (rs.next()) {
				departName = rs.getString("dept_name");
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return departName;
	}

	public String getProjectNameById(Connection con, String proId) {
		UtilityFunctions uF = new UtilityFunctions();
		PreparedStatement pst = null;
		ResultSet rs = null;
		String proName = null;
		try {
			pst = con.prepareStatement("select pro_name from projectmntnc where pro_id = ?");
			pst.setInt(1, uF.parseToInt(proId));
			rs = pst.executeQuery();
			while (rs.next()) {
				proName = rs.getString("pro_name");
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return proName;
	}

	public Map<String, String> getAllReimbursementAmount(Connection con, String strType, String groupType, String proType, String strStartDate,
			String strEndDate, UtilityFunctions uF) {

		PreparedStatement pst = null;
		ResultSet rs = null;

		Map<String, String> hmReimbursementAmountMap = new HashMap<String, String>();

		try {

			StringBuilder sbQuery = new StringBuilder();

			if (strType != null && strType.equalsIgnoreCase("P")) {
				if (groupType != null && groupType.equalsIgnoreCase("P")) {
					sbQuery.append("select sum(reimbursement_amount) as reimbursement_amount, pro_id as group_type from emp_reimbursement where approval_2 = 1 and pro_id in (select pmc.pro_id from projectmntnc pmc, activity_info ai where ai.pro_id = pmc.pro_id ");
					if (proType != null && proType.equals("C")) {
						sbQuery.append(" and pmc.approve_status = 'approved'");
					} else if (proType != null && proType.equals("B")) {
						sbQuery.append(" and pmc.approve_status = 'blocked'");
					} else if (proType != null && proType.equals("WC")) {
						sbQuery.append(" and (pmc.approve_status = 'n' or pmc.approve_status = 'approved')");
					} else if (proType != null && proType.equals("R")) {
						sbQuery.append(" and pmc.approve_status = 'n'");
					} else {
						sbQuery.append(" and (pmc.approve_status = 'n' or pmc.approve_status = 'approved' or pmc.approve_status = 'blocked')");
					}
					if (strStartDate != null && strEndDate != null && !strStartDate.equalsIgnoreCase(LABEL_FROM_DATE)
							&& !strEndDate.equalsIgnoreCase(LABEL_TO_DATE) && !strStartDate.equalsIgnoreCase("") && !strEndDate.equalsIgnoreCase("")) {
						sbQuery.append(" and from_date between '" + uF.getDateFormat(strStartDate, DATE_FORMAT, DBDATE) + "' and '"
								+ uF.getDateFormat(strEndDate, DATE_FORMAT, DBDATE) + "' ");
					}
					sbQuery.append(" ) and reimbursement_type1 = 'P' group by pro_id");
				} else if (groupType != null && groupType.equalsIgnoreCase("WL")) {
					sbQuery.append("select sum(reimbursement_amount) as reimbursement_amount, wlocation_id as group_type from emp_reimbursement a, employee_official_details b where a.emp_id = b.emp_id and  approval_2 = 1 and a.pro_id in ( select pmc.pro_id from projectmntnc pmc, activity_info ai where ai.pro_id = pmc.pro_id");
					if (proType != null && proType.equals("C")) {
						sbQuery.append(" and pmc.approve_status = 'approved'");
					} else if (proType != null && proType.equals("B")) {
						sbQuery.append(" and pmc.approve_status = 'blocked'");
					} else if (proType != null && proType.equals("WC")) {
						sbQuery.append(" and (pmc.approve_status = 'n' or pmc.approve_status = 'approved')");
					} else if (proType != null && proType.equals("R")) {
						sbQuery.append(" and pmc.approve_status = 'n'");
					} else {
						sbQuery.append(" and (pmc.approve_status = 'n' or pmc.approve_status = 'approved' or pmc.approve_status = 'blocked')");
					}
					if (strStartDate != null && strEndDate != null && strStartDate.equalsIgnoreCase(LABEL_FROM_DATE)
							&& strEndDate.equalsIgnoreCase(LABEL_TO_DATE) && !strStartDate.equalsIgnoreCase("") && !strEndDate.equalsIgnoreCase("")) {
						sbQuery.append(" and from_date between '" + uF.getDateFormat(strStartDate, DATE_FORMAT, DBDATE) + "' and '"
								+ uF.getDateFormat(strEndDate, DATE_FORMAT, DBDATE) + "' ");
					}
					sbQuery.append(" ) and reimbursement_type1 = 'P'  group by wlocation_id");
				} else if (groupType != null && groupType.equalsIgnoreCase("S")) {
					sbQuery.append("select sum(reimbursement_amount) as reimbursement_amount, service as group_type from emp_reimbursement er, projectmntnc pmc, activity_info ai where er.emp_id = ai.emp_id and ai.pro_id = pmc.pro_id and reimbursement_type1 = 'P'");
					if (proType != null && proType.equals("C")) {
						sbQuery.append(" and pmc.approve_status = 'approved'");
					} else if (proType != null && proType.equals("B")) {
						sbQuery.append(" and pmc.approve_status = 'blocked'");
					} else if (proType != null && proType.equals("WC")) {
						sbQuery.append(" and (pmc.approve_status = 'n' or pmc.approve_status = 'approved')");
					} else if (proType != null && proType.equals("R")) {
						sbQuery.append(" and pmc.approve_status = 'n'");
					} else {
						sbQuery.append(" and (pmc.approve_status = 'n' or pmc.approve_status = 'approved' or pmc.approve_status = 'blocked')");
					}
					if (strStartDate != null && strEndDate != null && strStartDate.equalsIgnoreCase(LABEL_FROM_DATE)
							&& strEndDate.equalsIgnoreCase(LABEL_TO_DATE) && !strStartDate.equalsIgnoreCase("") && !strEndDate.equalsIgnoreCase("")) {
						sbQuery.append(" and er.from_date between '" + uF.getDateFormat(strStartDate, DATE_FORMAT, DBDATE) + "' and '"
								+ uF.getDateFormat(strEndDate, DATE_FORMAT, DBDATE) + "' ");
					}
					sbQuery.append(" group by service");
				}
			}

			pst = con.prepareStatement(sbQuery.toString());
			// System.out.println("pst ===> " + pst);
			rs = pst.executeQuery();
			while (rs.next()) {
				String arr[] = null;
				if (rs.getString("group_type") != null) {
					arr = rs.getString("group_type").split(",");
					hmReimbursementAmountMap.put(arr[0], rs.getString("reimbursement_amount"));
				}
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmReimbursementAmountMap;
	}

	public Map<String, String> getEmpESICNo(Connection con) {
		Map<String, String> hmEmpESICNo = new HashMap<String, String>();

		PreparedStatement pst = null;
		ResultSet rs = null;

		try {

			pst = con.prepareStatement(selectEmployeeR3);
			rs = pst.executeQuery();
			while (rs.next()) {
				hmEmpESICNo.put(rs.getString("emp_id"), rs.getString("emp_esic_no"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmEmpESICNo;
	}

	public String getClientAddressIdByClientId(Connection con, String clientId) {
		UtilityFunctions uF = new UtilityFunctions();
		PreparedStatement pst = null;
		ResultSet rs = null;
		String clientAddressId = null;
		try {
			pst = con.prepareStatement("select client_address_id from client_address where client_id = ? limit 1");
			pst.setInt(1, uF.parseToInt(clientId));
			// System.out.println("pst ====>>> " + pst);
			rs = pst.executeQuery();
			while (rs.next()) {
				clientAddressId = rs.getString("client_address_id");
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return clientAddressId;
	}

	public String getClientSPOCIdByClientId(Connection con, String clientId) {
		UtilityFunctions uF = new UtilityFunctions();
		PreparedStatement pst = null;
		ResultSet rs = null;
		String clientSPOCId = null;
		try {
			pst = con.prepareStatement("select poc_id from client_poc where client_id = ? limit 1");
			pst.setInt(1, uF.parseToInt(clientId));
			// System.out.println("pst ====>>> " + pst);
			rs = pst.executeQuery();
			while (rs.next()) {
				clientSPOCId = rs.getString("poc_id");
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return clientSPOCId;
	}

	public Map<String, String> getDeductionTaxMISCDetails(Connection con) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmTaxMiscSetting = new HashMap<String, String>();
		try {
			pst = con.prepareStatement("select * from deduction_tax_misc_details where trail_status = 1");
			rs = pst.executeQuery();
			while (rs.next()) {
				hmTaxMiscSetting.put("DEDUCTION_TAX_MISC_ID", rs.getString("deduction_tax_misc_id"));
				hmTaxMiscSetting.put("STANDARD_TAX", rs.getString("standard_tax"));
				hmTaxMiscSetting.put("EDUCATION_TAX", rs.getString("education_tax"));
				hmTaxMiscSetting.put("FLAT_TDS", rs.getString("flat_tds"));
				hmTaxMiscSetting.put("SERVICE_TAX", rs.getString("service_tax"));
				hmTaxMiscSetting.put("DEDUCTION_TYPE", rs.getString("deduction_type"));
				hmTaxMiscSetting.put("FINANCIAL_YEAR_FROM", rs.getString("financial_year_from"));
				hmTaxMiscSetting.put("FINANCIAL_YEAR_TO", rs.getString("financial_year_to"));
				hmTaxMiscSetting.put("YEAR", rs.getString("_year"));
				hmTaxMiscSetting.put("ENTRY_TIMESTAMP", rs.getString("entry_timestamp"));
				hmTaxMiscSetting.put("USER_ID", rs.getString("user_id"));
				hmTaxMiscSetting.put("ACTIVITY", rs.getString("trail_status"));
				hmTaxMiscSetting.put("STATE_ID", rs.getString("state_id"));
				hmTaxMiscSetting.put("SWACHHA_BHARAT_CESS", rs.getString("swachha_bharat_cess"));
				hmTaxMiscSetting.put("KRISHI_KALYAN_CESS", rs.getString("krishi_kalyan_cess"));

				hmTaxMiscSetting.put("CGST", rs.getString("cgst"));
				hmTaxMiscSetting.put("SGST", rs.getString("sgst"));
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmTaxMiscSetting;
	}

	public Map<String, Map<String, String>> getCurrencyDetailsForPDF(Connection con) {

		PreparedStatement pst = null;
		ResultSet rs = null;

		Map<String, Map<String, String>> hmCurrencyDetailsMap = new HashMap<String, Map<String, String>>();
		try {

			pst = con.prepareStatement("select * from currency_details");
			rs = pst.executeQuery();

			while (rs.next()) {
				Map<String, String> hmInner = new HashMap<String, String>();

				hmInner.put("SHORT_CURR", rs.getString("short_currency"));
				hmInner.put("LONG_CURR", rs.getString("long_currency"));
				hmInner.put("CURR_DESC", rs.getString("currency_desc"));
				hmInner.put("CURR_CONVERSION_USD", rs.getString("currency_conversion_usd"));
				hmInner.put("CURR_INR_VALUE", rs.getString("inr_value"));
				hmInner.put("CURR_SUB_DIVISION", rs.getString("sub_division"));

				hmCurrencyDetailsMap.put(rs.getString("currency_id"), hmInner);
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmCurrencyDetailsMap;
	}

	public Map<String, String> getTaxMiscSetting(Connection con) {

		PreparedStatement pst = null;
		ResultSet rs = null;

		Map<String, String> hmTaxMiscSetting = new HashMap<String, String>();
		try {
			pst = con.prepareStatement("select * from deduction_tax_misc_details where trail_status = 1");
			rs = pst.executeQuery();

			while (rs.next()) {
				hmTaxMiscSetting.put("DEDUCTION_TAX_MISC_ID", rs.getString("deduction_tax_misc_id"));
				hmTaxMiscSetting.put("STANDARD_TAX", rs.getString("standard_tax"));
				hmTaxMiscSetting.put("EDUCATION_TAX", rs.getString("education_tax"));
				hmTaxMiscSetting.put("FLAT_TDS", rs.getString("flat_tds"));
				hmTaxMiscSetting.put("SERVICE_TAX", rs.getString("service_tax"));
				hmTaxMiscSetting.put("DEDUCTION_TYPE", rs.getString("deduction_type"));
				hmTaxMiscSetting.put("FINANCIAL_YEAR_FROM", rs.getString("financial_year_from"));
				hmTaxMiscSetting.put("FINANCIAL_YEAR_TO", rs.getString("financial_year_to"));
				hmTaxMiscSetting.put("YEAR", rs.getString("_year"));
				hmTaxMiscSetting.put("ENTRY_TIMESTAMP", rs.getString("entry_timestamp"));
				hmTaxMiscSetting.put("USER_ID", rs.getString("user_id"));
				hmTaxMiscSetting.put("ACTIVITY", rs.getString("trail_status"));
				hmTaxMiscSetting.put("STATE_ID", rs.getString("state_id"));
				hmTaxMiscSetting.put("SWACHHA_BHARAT_CESS", rs.getString("swachha_bharat_cess"));
				hmTaxMiscSetting.put("KRISHI_KALYAN_CESS", rs.getString("krishi_kalyan_cess"));

				hmTaxMiscSetting.put("CGST", rs.getString("cgst"));
				hmTaxMiscSetting.put("SGST", rs.getString("sgst"));
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmTaxMiscSetting;
	}

	public Map<String, Map<String, String>> getBankMap(Connection con, UtilityFunctions uF) {

		PreparedStatement pst = null;
		ResultSet rs = null;

		Map<String, Map<String, String>> hmBankMap = new HashMap<String, Map<String, String>>();
		try {
			Map<String, String> hmStates = getStateMap(con);
			Map<String, String> hmCountry = getCountryMap(con);

			pst = con
					.prepareStatement("select bd.bank_account_no, bd.branch_id, bd1.bank_name,bd.bank_branch, bd.branch_code, bd.bank_address, bd.bank_city, bd.bank_pincode, "
							+ "bd.bank_state_id, bd.bank_country_id,bd.bank_ifsc_code from bank_details bd1, branch_details bd where bd1.bank_id = bd.bank_id");
			rs = pst.executeQuery();
			while (rs.next()) {
				Map<String, String> hmInner = hmBankMap.get(rs.getString("branch_id"));
				if (hmInner == null)
					hmInner = new HashMap<String, String>();

				String strBankCode = rs.getString("branch_code");
				String strBranchIFSCCode = rs.getString("bank_ifsc_code");
				String strBankName = rs.getString("bank_name");
				String strBankBranch = rs.getString("bank_branch") + "[" + rs.getString("branch_code") + "]";
				String strBankAddress = rs.getString("bank_address") + "<br/>" + rs.getString("bank_city") + " - " + rs.getString("bank_pincode") + "<br/>"
						+ uF.showData(hmStates.get(rs.getString("bank_state_id")), "") + ", " + uF.showData(hmCountry.get(rs.getString("bank_country_id")), "");
				hmInner.put("BANK_CODE", strBankCode);
				hmInner.put("BANK_NAME", strBankName);
				hmInner.put("BANK_BRANCH", strBankBranch);
				hmInner.put("BANK_ADDRESS", strBankAddress);
				hmInner.put("IFSC_CODE", uF.showData(strBranchIFSCCode, ""));

				hmBankMap.put(rs.getString("branch_id"), hmInner);
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmBankMap;
	}

	public void getFormValidationFields(HttpServletRequest request, String formName) {

		Connection con = null;
		PreparedStatement pst = null;
		ResultSet rs = null;
		Database db = new Database();
		db.setRequest(request);
		try {
			con = db.makeConnection(con);
			Map<String, List<String>> hmValidationFields = new HashMap<String, List<String>>();

			pst = con.prepareStatement("select * from validation_details where form_name = ?");
			pst.setString(1, formName);
			rs = pst.executeQuery();
			List<String> innerList = new ArrayList<String>();
			while (rs.next()) {
				innerList = hmValidationFields.get(rs.getString("field_name"));
				if (innerList == null)
					innerList = new ArrayList<String>();

				innerList.add(rs.getString("required_field"));
				innerList.add(rs.getString("optional_field"));
				innerList.add(rs.getString("optional_field_value"));

				hmValidationFields.put(rs.getString("field_name"), innerList);
			}
			rs.close();
			pst.close();

			request.setAttribute("hmValidationFields", hmValidationFields);

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			db.closeResultSet(rs);
			db.closeStatements(pst);
			db.closeConnection(con);
		}

	}

	public Map<String, String> selectEmpPrevEarnDeduct(Connection con, int empId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		UtilityFunctions uF = new UtilityFunctions();

		Map<String, String> hmEmpPrevEarnDeduct = new HashMap<String, String>();

		try {
			pst = con.prepareStatement("SELECT * FROM prev_earn_deduct_details WHERE emp_id = ?");
			pst.setInt(1, empId);
			rs = pst.executeQuery();
			while (rs.next()) {
				hmEmpPrevEarnDeduct.put("PREV_COMP_FINANCIAL_YEAR",
						rs.getString("financial_start") != null ? uF.showData(uF.getDateFormat(rs.getString("financial_start"), DBDATE, DATE_FORMAT), "")
								+ " - " + uF.showData(uF.getDateFormat(rs.getString("financial_end"), DBDATE, DATE_FORMAT), "") : "-");
				hmEmpPrevEarnDeduct.put("PREV_COMP_GROSS_AMOUNT", uF.showData(rs.getString("gross_amount"), ""));
				hmEmpPrevEarnDeduct.put("PREV_COMP_TDS_AMOUNT", uF.showData(rs.getString("tds_amount"), ""));
				String document_name = rs.getString("document_name") != null ? "<a target=\"_blank\" href=\"" + getStrDocRetriveLocation()
						+ rs.getString("document_name") + "\">View Document </a><br/>" : "";
				hmEmpPrevEarnDeduct.put("PREV_COMP_DOC_NAME", uF.showData(rs.getString("document_name"), ""));
				
		//===start parvez date: 01-04-2022===
				hmEmpPrevEarnDeduct.put("PREV_COMP_PAN_NUMBER", rs.getString("org_pan_no"));
				hmEmpPrevEarnDeduct.put("PREV_COMP_TAN_NUMBER", rs.getString("org_tan_no"));
		//===end parvez date: 01-04-2022===		
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

		return hmEmpPrevEarnDeduct;
	}

	public Map<String, String> getActivityName(Connection con) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmActivity = new HashMap<String, String>();

		try {
			pst = con.prepareStatement("SELECT activity_id,activity_name FROM activity_details");
			rs = pst.executeQuery();
			while (rs.next()) {
				hmActivity.put(rs.getString("activity_id"), rs.getString("activity_name"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

		return hmActivity;
	}

	public Map<String, String> getProjectEmpActualRates(Connection con, UtilityFunctions uF, String pro_id, String strActualBilling) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmEmpCost = new HashMap<String, String>();

		try {

			pst = con.prepareStatement("select * from project_emp_details where pro_id=?");
			pst.setInt(1, uF.parseToInt(pro_id));
			rs = pst.executeQuery();
			while (rs.next()) {
				if (strActualBilling != null && strActualBilling.equalsIgnoreCase("D")) {
					hmEmpCost.put(rs.getString("emp_id"), rs.getString("emp_actual_rate_per_day"));
				} else if (strActualBilling != null && strActualBilling.equalsIgnoreCase("H")) {
					hmEmpCost.put(rs.getString("emp_id"), rs.getString("emp_actual_rate_per_hour"));
				} else if (strActualBilling != null && strActualBilling.equalsIgnoreCase("M")) {
					hmEmpCost.put(rs.getString("emp_id"), rs.getString("emp_actual_rate_per_month"));
				} else {
					hmEmpCost.put(rs.getString("emp_id"), rs.getString("emp_actual_rate_per_hour"));
				}
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

		return hmEmpCost;
	}

	public Map<String, String> getProjectEmpBillRates(Connection con, UtilityFunctions uF, String pro_id, String strActualBilling) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmEmpCost = new HashMap<String, String>();

		try {

			pst = con.prepareStatement("select * from project_emp_details where pro_id=?");
			pst.setInt(1, uF.parseToInt(pro_id));
			rs = pst.executeQuery();
			while (rs.next()) {
				if (strActualBilling != null && strActualBilling.equalsIgnoreCase("D")) {
					hmEmpCost.put(rs.getString("emp_id"), rs.getString("emp_rate_per_day"));
				} else if (strActualBilling != null && strActualBilling.equalsIgnoreCase("H")) {
					hmEmpCost.put(rs.getString("emp_id"), rs.getString("emp_rate_per_hour"));
				} else if (strActualBilling != null && strActualBilling.equalsIgnoreCase("M")) {
					hmEmpCost.put(rs.getString("emp_id"), rs.getString("emp_rate_per_month"));
				} else {
					hmEmpCost.put(rs.getString("emp_id"), rs.getString("emp_rate_per_hour"));
				}
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

		return hmEmpCost;
	}

	public boolean getProjectTLByEmpId(Connection con, String proId, String empId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		boolean isTeamLead = false;
		try {
			pst = con.prepareStatement("select * from project_emp_details where pro_id=? and emp_id=?");
			pst.setInt(1, uF.parseToInt(proId));
			pst.setInt(2, uF.parseToInt(empId));
			rs = pst.executeQuery();
			while (rs.next()) {
				isTeamLead = rs.getBoolean("_isteamlead");
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return isTeamLead;
	}

	public String getProjectActualTime(Connection con, String proId, String strBillingType) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		String strActualTime = null;
		try {
			pst = con.prepareStatement("select * from activity_info where pro_id=?");
			pst.setInt(1, uF.parseToInt(proId));
			rs = pst.executeQuery();
			// System.out.println("pst ===>> " + pst);
			// System.out.println("strBillingType ===>> " + strBillingType);
			double totActualTime = 0.0d;
			while (rs.next()) {
				if (strBillingType != null && strBillingType.equalsIgnoreCase("D")) {
					totActualTime += rs.getDouble("already_work_days");
				} else {
					totActualTime += rs.getDouble("already_work");
				}
			}
			rs.close();
			pst.close();
			// System.out.println("totActualTime ===>> " + totActualTime);
			strActualTime = uF.formatIntoOneDecimal(totActualTime);
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return strActualTime;
	}

	public List<String> getEmpLeaveCount(Connection con, String strD1, String strD2, CommonFunctions CF, Map<String, String> hmHolidayDates,
			Set<String> weeklyOffDate, String empId, String wLocationId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		List<String> leaveDateList = new ArrayList<String>();

		try {
			if (weeklyOffDate == null)
				weeklyOffDate = new HashSet<String>();

			pst = con.prepareStatement("select * from leave_application_register where _date between ? and ? and emp_id = ? and is_modify = false");
			pst.setDate(1, uF.getDateFormat(strD1, DATE_FORMAT));
			pst.setDate(2, uF.getDateFormat(strD2, DATE_FORMAT));
			pst.setInt(3, uF.parseToInt(empId));
			// System.out.println("pst======>"+pst);
			rs = pst.executeQuery();
			while (rs.next()) {
				if (hmHolidayDates != null
						&& !hmHolidayDates.containsKey(uF.getDateFormat(rs.getString("_date"), DBDATE, CF.getStrReportDateFormat()) + "_" + wLocationId)
						&& !weeklyOffDate.contains(uF.getDateFormat(rs.getString("_date"), DBDATE, DATE_FORMAT))) {
					// leaveCount++;
					leaveDateList.add(uF.getDateFormat(rs.getString("_date"), DBDATE, DATE_FORMAT));
				}
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return leaveDateList;
	}

	public Map<String, String> getProjectDetailsByProId(Connection con, String proId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		UtilityFunctions uF = new UtilityFunctions();
		Map<String, String> hmProjectData = new HashMap<String, String>();
		try {

			pst = con.prepareStatement("select * from projectmntnc where pro_id = ?");
			pst.setInt(1, uF.parseToInt(proId));
			rs = pst.executeQuery();
			// System.out.println("pst ===> " + pst);
			while (rs.next()) {
				hmProjectData.put("PRO_ID", rs.getString("pro_id"));
				hmProjectData.put("PRO_NAME", rs.getString("pro_name"));
				hmProjectData.put("PRO_CUSTOMER_NAME", getClientNameById(con, rs.getString("client_id")));
				hmProjectData.put("PRO_CUST_SPOC_ID", rs.getString("poc"));
				hmProjectData.put("PRO_CUST_SPOC_NAME", getClientSPOCNameById(con, rs.getString("poc")));
				hmProjectData.put("PRO_OWNER_ID", rs.getString("project_owner"));
				hmProjectData.put("PRO_OWNER_NAME", getEmpNameMapByEmpId(con, rs.getString("project_owner")));
				hmProjectData.put("PRO_BILLING_TYPE", getBillinType(rs.getString("billing_type")));
				hmProjectData.put("PRO_BILL_TYPE", rs.getString("billing_type"));
				hmProjectData.put("PRO_BILLING_ACTUAL_TYPE", rs.getString("actual_calculation_type"));
				hmProjectData.put("PRO_BILLING_FREQUENCY", getBillinFreq(rs.getString("billing_kind"), rs.getString("billing_type")));
				hmProjectData.put("PRO_BILL_FREQUENCY", rs.getString("billing_kind"));
				hmProjectData.put("PRO_START_DATE", uF.getDateFormat(rs.getString("start_date"), DBDATE, DATE_FORMAT));
				hmProjectData.put("PRO_END_DATE", uF.getDateFormat(rs.getString("deadline"), DBDATE, DATE_FORMAT));
				hmProjectData.put("PRO_BILL_DAYS_TYPE", rs.getString("bill_days_type"));
				hmProjectData.put("PRO_HOURS_FOR_BILL_DAY", rs.getString("hours_for_bill_day"));
				hmProjectData.put("PRO_SERVICE_ID", rs.getString("service"));
				hmProjectData.put("PRO_REPORT_CURR_ID", rs.getString("curr_id"));
				hmProjectData.put("PRO_BILLING_CURR_ID", rs.getString("billing_curr_id"));
				hmProjectData.put("PRO_BILLING_AMOUNT", rs.getString("billing_amount"));
				hmProjectData.put("PRO_ORG_ID", rs.getString("org_id"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmProjectData;
	}

	public String getBillinType(String billingType) {
		String billType = "";

		if (billingType != null && billingType.equals("F")) {
			billType = "Fixed";
		} else if (billingType != null && billingType.equals("H")) {
			billType = "Hourly";
		} else if (billingType != null && billingType.equals("D")) {
			billType = "Daily";
		} else if (billingType != null && billingType.equals("M")) {
			billType = "Monthly";
		}
		return billType;
	}

	public String getBillinFreq(String billFreq, String billType) {
		String billingFreq = "";

		if (billType != null && billType.equals("F") && billFreq != null && billFreq.equals("O")) {
			billingFreq = "Milestone based";
		} else if (billFreq != null && billFreq.equals("M")) {
			billingFreq = "Monthly";
		} else if (billFreq != null && billFreq.equals("B")) {
			billingFreq = "Biweekly";
		} else if (billFreq != null && billFreq.equals("W")) {
			billingFreq = "Weekly";
		} else if (billFreq != null && billFreq.equals("O")) {
			billingFreq = "One Time";
		} else if (billFreq != null && billFreq.equals("Q")) {
			billingFreq = "Quarterly	";
		} else if (billFreq != null && billFreq.equals("H")) {
			billingFreq = "Half Year";
		} else if (billFreq != null && billFreq.equals("A")) {
			billingFreq = "Annually";
		}
		return billingFreq;
	}

	public String getClientIdByProjectTaskId(Connection con, UtilityFunctions uF, String taskId, String empId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		String clientId = null;

		try {
			pst = con.prepareStatement("select task_id,ai.pro_id,client_id from activity_info ai, projectmntnc pmt "
					+ "where ai.pro_id = pmt.pro_id and task_id =? and ai.resource_ids like '%," + empId + ",%'");
			pst.setInt(1, uF.parseToInt(taskId));
			// pst.setInt(2, uF.parseToInt(empId));
			// System.out.println("pst======>"+pst);
			rs = pst.executeQuery();
			while (rs.next()) {
				clientId = rs.getString("client_id");
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return clientId;
	}

	public void updateUserAlerts(CommonFunctions CF, HttpServletRequest request, String strEmpId, String strDomain, String alertType, String alertStatus) {
		Connection con = null;
		PreparedStatement pst = null;
		ResultSet rs = null;
		Database db = new Database();
		db.setRequest(request);
		UtilityFunctions uF = new UtilityFunctions();
		try {
			con = db.makeConnection(con);

			UserAlerts userAlerts = new UserAlerts(con, uF, CF, request);
			userAlerts.setStrDomain(strDomain);
			userAlerts.setStrEmpId(strEmpId);
			userAlerts.set_type(alertType);
			userAlerts.setStatus(alertStatus);
			Thread t = new Thread(userAlerts);
			t.run();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			db.closeResultSet(rs);
			db.closeStatements(pst);
			db.closeConnection(con);
		}
	}

	public String getOrgCurrencyId(Connection con, String locationId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		String currId = null;
		try {

			pst = con.prepareStatement("select org_currency from org_details where org_id = (select org_id from work_location_info where wlocation_id = ?)");
			pst.setInt(1, uF.parseToInt(locationId));
			rs = pst.executeQuery();
			while (rs.next()) {
				currId = rs.getString("org_currency");
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return currId;
	}

	public String getOrgCurrencyIdByOrg(Connection con, String orgId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		String currId = null;
		try {

			pst = con.prepareStatement("select org_currency from org_details where org_id = ?");
			pst.setInt(1, uF.parseToInt(orgId));
			rs = pst.executeQuery();
			while (rs.next()) {
				currId = rs.getString("org_currency");
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return currId;
	}

	public Map<String, String> getCurrencyFromIdToIdValue(Connection con) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmCurrDetails = new HashMap<String, String>();
		try {
			pst = con.prepareStatement("select * from currencies_details");
			rs = pst.executeQuery();
			while (rs.next()) {
				hmCurrDetails.put(rs.getString("curr_from_id") + "_" + rs.getString("curr_to_id"), rs.getString("curr_to_value"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmCurrDetails;
	}

	public Map<String, String> getOrgDetails(Connection con, UtilityFunctions uF, String strOrgId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmOrg = new HashMap<String, String>();
		try {
			pst = con.prepareStatement("select * from org_details where org_id = ? ");
			pst.setInt(1, uF.parseToInt(strOrgId));
			rs = pst.executeQuery();
			while (rs.next()) {
				hmOrg.put("ORG_ID", rs.getString("org_id"));
				hmOrg.put("ORG_NAME", rs.getString("org_name"));
				hmOrg.put("ORG_SUB_TITLE", rs.getString("org_subtitle"));
				hmOrg.put("ORG_LOGO", rs.getString("org_logo"));
				hmOrg.put("ORG_ADDRESS", rs.getString("org_address"));
				hmOrg.put("ORG_PINCODE", rs.getString("org_pincode"));
				hmOrg.put("ORG_CONTACT", rs.getString("org_contact1"));
				hmOrg.put("ORG_EMAIL", rs.getString("org_email"));
				hmOrg.put("ORG_WEBSITE", rs.getString("org_website"));
				hmOrg.put("ORG_STATE_ID", rs.getString("org_state_id"));
				hmOrg.put("ORG_COUNTRY_ID", rs.getString("org_country_id"));
				hmOrg.put("ORG_CITY", rs.getString("org_city"));
				hmOrg.put("ORG_CODE", rs.getString("org_code"));
				hmOrg.put("ORG_DISPLAY_PAYCYCLE", rs.getString("display_paycycle"));
				hmOrg.put("ORG_DURATION_PAYCYCLE", rs.getString("duration_paycycle"));
				hmOrg.put("ORG_SALARY_CAL_BASIS", rs.getString("salary_cal_basis"));
				hmOrg.put("ORG_START_PAYCYCLE", uF.getDateFormat(rs.getString("start_paycycle"), DBDATE, DATE_FORMAT));
				hmOrg.put("ORG_TRRN_EPF", rs.getString("trrn_epf"));
				hmOrg.put("ORG_EPF_ACCOUNT_NO", rs.getString("epf_account_no"));
				hmOrg.put("ORG_SALARY_FIX_DAYS", rs.getString("salary_fix_days"));
				hmOrg.put("ORG_PAN_NO", rs.getString("org_pan_no"));
				hmOrg.put("ORG_TAN_NO", rs.getString("org_tan_no"));
				hmOrg.put("ORG_REG_NO", rs.getString("org_reg_no"));
				hmOrg.put("ORG_ST_REG_NO", rs.getString("org_st_reg_no"));
				hmOrg.put("ORG_ADDITIONAL_NOTE", rs.getString("org_additional_note"));
				hmOrg.put("ORG_OFFICES_AT", rs.getString("offices_at"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmOrg;
	}

	public String getProjectTaskNameByTaskId(Connection con, UtilityFunctions uF, String proTaskId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		String proTaskName = null;
		try {
			pst = con.prepareStatement("select activity_name from activity_info where task_id = ?");
			pst.setInt(1, uF.parseToInt(proTaskId));
			rs = pst.executeQuery();
			while (rs.next()) {
				proTaskName = rs.getString("activity_name");
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return proTaskName;
	}

	public String getResourcesName(Connection con, String resourceIds, Map<String, String> hmTeamLead) {
		StringBuilder sbResources = null;
		List<String> strIdLsit = new ArrayList<String>();
		if (resourceIds != null) {
			strIdLsit = Arrays.asList(resourceIds.split(","));
		}
		if (strIdLsit != null) {
			for (int i = 0; i < strIdLsit.size(); i++) {
				if (!strIdLsit.get(i).trim().equals("")) {
					if (sbResources == null) {
						sbResources = new StringBuilder();
						sbResources.append(getEmpNameMapByEmpId(con, strIdLsit.get(i).trim())
								+ (hmTeamLead != null ? (uF.parseToBoolean(hmTeamLead.get(strIdLsit.get(i).trim())) == true ? " [TL]" : "") : ""));
					} else {
						sbResources.append(", " + getEmpNameMapByEmpId(con, strIdLsit.get(i).trim())
								+ (hmTeamLead != null ? (uF.parseToBoolean(hmTeamLead.get(strIdLsit.get(i).trim())) == true ? " [TL]" : "") : ""));
					}
				}
			}
		} else {
			return null;
		}
		if (sbResources == null) {
			sbResources = new StringBuilder();
		}
		return sbResources.toString();
	}

	public String getResourcesSkills(Connection con, String resourceIds) {

		PreparedStatement pst = null;
		ResultSet rs = null;

		StringBuilder sbSkills = null;
		try {
			if (resourceIds != null && resourceIds.length() > 1) {
				if (resourceIds.substring(0, 1).equals(",") && resourceIds.substring(resourceIds.length() - 1, resourceIds.length()).equals(",")) {
					resourceIds = resourceIds.substring(1, resourceIds.length() - 1);
				}
			}
			if (resourceIds != null && resourceIds.length() > 0) {
				pst = con.prepareStatement("select distinct(skill_id) as skill_id from skills_description where emp_id in (" + resourceIds + ")");
				// System.out.println("pst ==>> " + pst);
				rs = pst.executeQuery();
				while (rs.next()) {
					if (sbSkills == null) {
						sbSkills = new StringBuilder();
						sbSkills.append(getSkillNameBySkillId(con, rs.getString("skill_id")));
					} else {
						sbSkills.append("," + getSkillNameBySkillId(con, rs.getString("skill_id")));
					}
				}
				rs.close();
				pst.close();
			}
			if (sbSkills == null) {
				sbSkills = new StringBuilder();
			}
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return sbSkills.toString();
	}

	public Map<String, String> getProjectTeamLeads(Connection con, UtilityFunctions uF, String pro_id) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmTeamLead = new HashMap<String, String>();
		try {

			pst = con.prepareStatement("select * from project_emp_details where _isteamlead = true and pro_id=? ");
			pst.setInt(1, uF.parseToInt(pro_id));
			rs = pst.executeQuery();
			while (rs.next()) {
				hmTeamLead.put(rs.getString("emp_id"), rs.getString("_isteamlead"));
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmTeamLead;
	}

	public String getBackUpRetriveLocation() {
		return backUpRetriveLocation;
	}

	public void setBackUpRetriveLocation(String backUpRetriveLocation) {
		this.backUpRetriveLocation = backUpRetriveLocation;
	}

	public String getClientIdByProjectId(Connection con, UtilityFunctions uF, String proId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		String clientId = null;

		try {
			pst = con.prepareStatement("select client_id from projectmntnc where pro_id=?");
			pst.setInt(1, uF.parseToInt(proId));
			// System.out.println("pst======>"+pst);
			rs = pst.executeQuery();
			while (rs.next()) {
				clientId = rs.getString("client_id");
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return clientId;
	}

	public Map<String, String> getCurrencyDetailsById(Connection con, UtilityFunctions uF, String currId) {

		PreparedStatement pst = null;
		ResultSet rs = null;

		Map<String, String> hmCurrencyDetails = new HashMap<String, String>();
		try {

			pst = con.prepareStatement("select * from currency_details where currency_id = ?");
			pst.setInt(1, uF.parseToInt(currId));
			rs = pst.executeQuery();

			while (rs.next()) {
				hmCurrencyDetails.put("SHORT_CURR", rs.getString("short_currency"));
				hmCurrencyDetails.put("LONG_CURR", rs.getString("long_currency"));
				hmCurrencyDetails.put("CURR_DESC", rs.getString("currency_desc"));
				// hmCurrencyDetails.put("CURR_CONVERSION_USD",
				// rs.getString("currency_conversion_usd"));
				// hmCurrencyDetails.put("CURR_INR_VALUE",
				// rs.getString("inr_value"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmCurrencyDetails;
	}

	public String getTaskActivityTaskCount(Connection con, UtilityFunctions uF, String taskId) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		String taskCount = null;
		try {
			pst = con.prepareStatement("select count(activity_id) as taskCount from task_activity where activity_id=?");
			pst.setInt(1, uF.parseToInt(taskId));
			// System.out.println("pst======>"+pst);
			rs = pst.executeQuery();
			while (rs.next()) {
				taskCount = rs.getString("taskCount");
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return taskCount;
	}

	public Map<String, String> getProjectTaskActualWorkedDaysAndHrs(Connection con, String taskId, Map<String, String> hmProjectData) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		UtilityFunctions uF = new UtilityFunctions();
		Map<String, String> hmProjectEfforts = new HashMap<String, String>();
		try {

			List<String> tasksList = new ArrayList<String>();

			pst = con.prepareStatement("select task_id from activity_info where parent_task_id = ?");
			pst.setInt(1, uF.parseToInt(taskId));
			rs = pst.executeQuery();
			while (rs.next()) {
				if (!tasksList.contains(rs.getString("task_id")))
					tasksList.add(rs.getString("task_id"));
			}
			rs.close();
			pst.close();

			if (tasksList == null || tasksList.isEmpty() || tasksList.size() == 0) {
				tasksList.add(taskId);
			}
			StringBuilder sbtaskIds = null;
			for (int i = 0; tasksList != null && i < tasksList.size(); i++) {
				if (sbtaskIds == null) {
					sbtaskIds = new StringBuilder();
					sbtaskIds.append(tasksList.get(i));
				} else {
					sbtaskIds.append("," + tasksList.get(i));
				}
			}
			if (sbtaskIds == null) {
				sbtaskIds = new StringBuilder();
			}

			double totActualHrs = 0;
			double totBillableHrs = 0;
			double totActualDays = 0;
			double totBillableDays = 0;
			Map<String, String> hmApprovedBy = new HashMap<String, String>();
			for (int i = 0; tasksList != null && i < tasksList.size(); i++) {
				pst = con
						.prepareStatement("select sum(actual_hrs) as actual_hrs, approved_by from task_activity where activity_id=?  and task_date between ? and ? group by approved_by"); // and
																																															// is_approved
																																															// =
																																															// 2
				pst.setInt(1, uF.parseToInt(tasksList.get(i)));
				pst.setDate(2, uF.getDateFormat(hmProjectData.get("PRO_START_DATE"), DATE_FORMAT));
				pst.setDate(3, uF.getDateFormat(hmProjectData.get("PRO_END_DATE"), DATE_FORMAT));
				rs = pst.executeQuery();
				// System.out.println("pst ===> " + pst);
				while (rs.next()) {
					hmApprovedBy.put(rs.getString("approved_by"), rs.getString("approved_by"));
					totActualHrs += rs.getDouble("actual_hrs");
				}
				rs.close();
				pst.close();
			}

			if (sbtaskIds != null && sbtaskIds.toString().length() > 0) {
				pst = con.prepareStatement("select count(distinct task_date) as days from task_activity where activity_id in (" + sbtaskIds.toString()
						+ ")  and task_date between ? and ? group by emp_id"); // and
																				// is_approved
																				// =
																				// 2
				pst.setDate(1, uF.getDateFormat(hmProjectData.get("PRO_START_DATE"), DATE_FORMAT));
				pst.setDate(2, uF.getDateFormat(hmProjectData.get("PRO_END_DATE"), DATE_FORMAT));
				rs = pst.executeQuery();
				// System.out.println("pst ===> " + pst);
				while (rs.next()) {
					totActualDays += rs.getInt("days");
				}
				rs.close();
				pst.close();
			}

			for (int i = 0; tasksList != null && i < tasksList.size(); i++) {
				pst = con
						.prepareStatement("select sum(billable_hrs) as billable_hrs, count(distinct task_date) as task_date, approved_by from task_activity where activity_id=? and is_approved = 2 and is_billable = true and task_date between ? and ? group by approved_by");
				pst.setInt(1, uF.parseToInt(tasksList.get(i)));
				pst.setDate(2, uF.getDateFormat(hmProjectData.get("PRO_START_DATE"), DATE_FORMAT));
				pst.setDate(3, uF.getDateFormat(hmProjectData.get("PRO_END_DATE"), DATE_FORMAT));
				rs = pst.executeQuery();
				while (rs.next()) {
					totBillableHrs += rs.getDouble("billable_hrs");
				}
				rs.close();
				pst.close();
			}

			if (sbtaskIds != null && sbtaskIds.toString().length() > 0) {
				pst = con.prepareStatement("select count(distinct task_date) as days from task_activity where activity_id in (" + sbtaskIds.toString()
						+ ") and is_approved = 2 and is_billable = true and task_date between ? and ? group by emp_id");
				pst.setDate(1, uF.getDateFormat(hmProjectData.get("PRO_START_DATE"), DATE_FORMAT));
				pst.setDate(2, uF.getDateFormat(hmProjectData.get("PRO_END_DATE"), DATE_FORMAT));
				rs = pst.executeQuery();
				while (rs.next()) {
					totBillableDays += rs.getInt("days");
				}
				rs.close();
				pst.close();
			}

			if (hmProjectData.get("PRO_BILL_DAYS_TYPE") != null && hmProjectData.get("PRO_BILL_DAYS_TYPE").equals("2")
					&& uF.parseToDouble(hmProjectData.get("PRO_HOURS_FOR_BILL_DAY")) > 0) {
				totActualDays = totActualHrs / uF.parseToDouble(hmProjectData.get("PRO_HOURS_FOR_BILL_DAY"));
				totBillableDays = totBillableHrs / uF.parseToDouble(hmProjectData.get("PRO_HOURS_FOR_BILL_DAY"));
			}

			StringBuilder sbApproveBy = null;
			Iterator<String> it = hmApprovedBy.keySet().iterator();

			while (it.hasNext()) {
				String approveby = it.next();
				if (uF.parseToInt(approveby) > 0) {
					if (sbApproveBy == null) {
						sbApproveBy = new StringBuilder();
						sbApproveBy.append(getEmpNameMapByEmpId(con, approveby));
					} else {
						sbApproveBy.append("," + getEmpNameMapByEmpId(con, approveby));
					}
				}
			}
			if (sbApproveBy == null) {
				sbApproveBy = new StringBuilder();
			}
			hmProjectEfforts.put("ACTUAL_HRS", "" + uF.formatIntoTwoDecimalWithOutComma(totActualHrs));
			hmProjectEfforts.put("BILLABLE_HRS", "" + uF.formatIntoTwoDecimalWithOutComma(totBillableHrs));
			hmProjectEfforts.put("ACTUAL_DAYS", "" + uF.formatIntoOneDecimalWithOutComma(totActualDays));
			hmProjectEfforts.put("BILLABLE_DAYS", "" + uF.formatIntoOneDecimalWithOutComma(totBillableDays));

			hmProjectEfforts.put("APPROVED_BY", sbApproveBy.toString());

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmProjectEfforts;
	}

	public Map<String, String> getProjectActualAndBillableEfforts(Connection con, String proId, Map<String, String> hmProjectData) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		UtilityFunctions uF = new UtilityFunctions();
		Map<String, String> hmProjectEfforts = new HashMap<String, String>();
		try {

			pst = con.prepareStatement("select emp_id from project_emp_details where pro_id = ?");
			pst.setInt(1, uF.parseToInt(proId));
			rs = pst.executeQuery();
			List<String> empList = new ArrayList<String>();
			while (rs.next()) {
				empList.add(rs.getString("emp_id"));
			}
			rs.close();
			pst.close();

			List<String> tasksList = new ArrayList<String>();
			for (int i = 0; empList != null && i < empList.size(); i++) {
				pst = con.prepareStatement("select task_id from activity_info where pro_id = ? and resource_ids like '%," + empList.get(i) + ",%'");
				pst.setInt(1, uF.parseToInt(proId));
				rs = pst.executeQuery();
				while (rs.next()) {
					if (!tasksList.contains(rs.getString("task_id")))
						tasksList.add(rs.getString("task_id"));
				}
				rs.close();
				pst.close();
			}

			StringBuilder sbtaskIds = null;
			for (int i = 0; tasksList != null && i < tasksList.size(); i++) {
				if (sbtaskIds == null) {
					sbtaskIds = new StringBuilder();
					sbtaskIds.append(tasksList.get(i));
				} else {
					sbtaskIds.append("," + tasksList.get(i));
				}
			}
			if (sbtaskIds == null) {
				sbtaskIds = new StringBuilder();
			}

			double totActualHrs = 0;
			double totBillableHrs = 0;
			double totActualDays = 0;
			double totBillableDays = 0;
			Map<String, String> hmApprovedBy = new HashMap<String, String>();
			for (int i = 0; tasksList != null && i < tasksList.size(); i++) {
				pst = con.prepareStatement("select sum(actual_hrs) as actual_hrs, approved_by from task_activity where activity_id=? group by approved_by"); // and
																																								// task_date
																																								// between
																																								// ?
																																								// and
																																								// ?
																																								// //
																																								// is_approved=2
																																								// and
				pst.setInt(1, uF.parseToInt(tasksList.get(i)));
				// pst.setDate(2,
				// uF.getDateFormat(hmProjectData.get("PRO_START_DATE"),
				// DATE_FORMAT));
				// pst.setDate(3,
				// uF.getDateFormat(hmProjectData.get("PRO_END_DATE"),
				// DATE_FORMAT));
				rs = pst.executeQuery();
				// System.out.println("pst ===> " + pst);
				while (rs.next()) {
					hmApprovedBy.put(rs.getString("approved_by"), rs.getString("approved_by"));
					totActualHrs += rs.getDouble("actual_hrs");
				}
				rs.close();
				pst.close();
			}

			if (sbtaskIds != null && sbtaskIds.toString().length() > 0) {
				pst = con.prepareStatement("select count(distinct task_date) as days from task_activity where activity_id in (" + sbtaskIds.toString()
						+ ") group by activity_id,emp_id"); // and task_date
															// between ? and ?
															// // is_approved=2
															// and
				// pst.setDate(1,
				// uF.getDateFormat(hmProjectData.get("PRO_START_DATE"),
				// DATE_FORMAT));
				// pst.setDate(2,
				// uF.getDateFormat(hmProjectData.get("PRO_END_DATE"),
				// DATE_FORMAT));
				rs = pst.executeQuery();
				// System.out.println("pst ===> " + pst);
				while (rs.next()) {
					// totActualDays++;
					totActualDays += rs.getInt("days");
				}
				rs.close();
				pst.close();
			}

			for (int i = 0; tasksList != null && i < tasksList.size(); i++) {
				pst = con
						.prepareStatement("select sum(billable_hrs) as billable_hrs, count(distinct task_date) as task_date, approved_by from task_activity where activity_id=? and is_approved = 2 and is_billable = true group by approved_by"); // and
																																																													// task_date
																																																													// between
																																																													// ?
																																																													// and
																																																													// ?
				pst.setInt(1, uF.parseToInt(tasksList.get(i)));
				// pst.setDate(2,
				// uF.getDateFormat(hmProjectData.get("PRO_START_DATE"),
				// DATE_FORMAT));
				// pst.setDate(3,
				// uF.getDateFormat(hmProjectData.get("PRO_END_DATE"),
				// DATE_FORMAT));
				rs = pst.executeQuery();
				// System.out.println("pst ===> " + pst);
				while (rs.next()) {
					totBillableHrs += rs.getDouble("billable_hrs");
				}
				rs.close();
				pst.close();
			}

			if (sbtaskIds != null && sbtaskIds.toString().length() > 0) {
				pst = con.prepareStatement("select count(distinct task_date) as days from task_activity where activity_id in (" + sbtaskIds.toString()
						+ ") and is_approved = 2 and is_billable = true group by activity_id,emp_id"); // and
																										// task_date
																										// between
																										// ?
																										// and
																										// ?
				// pst.setDate(1,
				// uF.getDateFormat(hmProjectData.get("PRO_START_DATE"),
				// DATE_FORMAT));
				// pst.setDate(2,
				// uF.getDateFormat(hmProjectData.get("PRO_END_DATE"),
				// DATE_FORMAT));
				rs = pst.executeQuery();
				// System.out.println("pst ===> " + pst);
				while (rs.next()) {
					// totBillableDays++;
					totBillableDays += rs.getInt("days");
				}
				rs.close();
				pst.close();
			}

			if (hmProjectData.get("PRO_BILL_DAYS_TYPE") != null && hmProjectData.get("PRO_BILL_DAYS_TYPE").equals("2")
					&& uF.parseToDouble(hmProjectData.get("PRO_HOURS_FOR_BILL_DAY")) > 0) {
				totActualDays = totActualHrs / uF.parseToDouble(hmProjectData.get("PRO_HOURS_FOR_BILL_DAY"));
				totBillableDays = totBillableHrs / uF.parseToDouble(hmProjectData.get("PRO_HOURS_FOR_BILL_DAY"));
			}

			StringBuilder sbApproveBy = null;
			Iterator<String> it = hmApprovedBy.keySet().iterator();

			while (it.hasNext()) {
				String approveby = it.next();
				if (uF.parseToInt(approveby) > 0) {
					if (sbApproveBy == null) {
						sbApproveBy = new StringBuilder();
						sbApproveBy.append(getEmpNameMapByEmpId(con, approveby));
					} else {
						sbApproveBy.append("," + getEmpNameMapByEmpId(con, approveby));
					}
				}
			}
			if (sbApproveBy == null) {
				sbApproveBy = new StringBuilder();
			}

			hmProjectEfforts.put("ACTUAL_HRS", uF.formatIntoTwoDecimalWithOutComma(totActualHrs));
			hmProjectEfforts.put("BILLABLE_HRS", uF.formatIntoTwoDecimalWithOutComma(totBillableHrs));
			hmProjectEfforts.put("ACTUAL_DAYS", uF.formatIntoOneDecimalWithOutComma(totActualDays));
			hmProjectEfforts.put("BILLABLE_DAYS", uF.formatIntoOneDecimalWithOutComma(totBillableDays));

			hmProjectEfforts.put("APPROVED_BY", sbApproveBy.toString());

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmProjectEfforts;
	}

	public String getStateNameById(Connection con, UtilityFunctions uF, String stateId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		String stateName = null;
		try {
			pst = con.prepareStatement("select * from state where state_id =?");
			pst.setInt(1, uF.parseToInt(stateId));
			rs = pst.executeQuery();
			while (rs.next()) {
				stateName = rs.getString("state_name");
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return stateName;
	}

	public String getCountryNameById(Connection con, UtilityFunctions uF, String countryId) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		String countryName = null;
		try {
			pst = con.prepareStatement("select * from country where country_id =?");
			pst.setInt(1, uF.parseToInt(countryId));
			rs = pst.executeQuery();
			while (rs.next()) {
				countryName = rs.getString("country_name");
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return countryName;
	}

	public String getCandiNameByCandiId(Connection con, String strCandiId) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		String candiName = null;
		try {

			Map<String, String> hmFeatureStatus = getFeatureStatusMap(con);
			boolean flagMiddleName = uF.parseToBoolean(hmFeatureStatus.get(F_SHOW_EMPLOYEE_MIDDLE_NAME));

			pst = con.prepareStatement("SELECT emp_fname, emp_mname, emp_lname FROM candidate_personal_details cpd where cpd.emp_per_id = ? ");
			pst.setInt(1, uF.parseToInt(strCandiId));
			rs = pst.executeQuery();
			while (rs.next()) {

				String strEmpMName = "";

				if (flagMiddleName) {
					if (rs.getString("emp_mname") != null && rs.getString("emp_mname").trim().length() > 0) {
						strEmpMName = " " + rs.getString("emp_mname");
					}
				}

				candiName = rs.getString("emp_fname") + strEmpMName + " " + rs.getString("emp_lname");
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return candiName;
	}

	public Map<String, String> getHolidayName(Connection con, CommonFunctions CF, String strD1, String strD2) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmHolidayName = new HashMap<String, String>();
		try {
			HttpSession session = request.getSession(true);
			pst = con.prepareStatement(selectHolidaysR2);
			pst.setDate(1, uF.getDateFormat(strD1, DATE_FORMAT));
			pst.setDate(2, uF.getDateFormat(strD2, DATE_FORMAT));

			rs = pst.executeQuery();
			while (rs.next()) {
				hmHolidayName.put(uF.getDateFormat(rs.getString("_date"), DBDATE, CF.getStrReportDateFormat()) + "_" + rs.getString("wlocation_id"),
						rs.getString("description"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
		}
		return hmHolidayName;
	}

	public String getStrHostPort() {
		return strHostPort;
	}

	public void setStrHostPort(String strHostPort) {
		this.strHostPort = strHostPort;
	}

	public double getProjectVariableCost(Connection con, UtilityFunctions uF, String proId) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		double proVariableCost = 0;
		try {
			pst = con.prepareStatement("select sum(variable_cost) as variable_cost from variable_cost where pro_id=?");
			pst.setInt(1, uF.parseToInt(proId));
			rs = pst.executeQuery();
			while (rs.next()) {
				proVariableCost = rs.getDouble("variable_cost");
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return proVariableCost;
	}

	public Map<String, String> getProjectActualCostAndTime(Connection con, HttpServletRequest request, CommonFunctions CF, UtilityFunctions uF, String proId,
			Map<String, String> hmProjectData, boolean isSubmit, boolean isApprove) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmProActualAndBillableCost = new HashMap<String, String>();
		try {

			pst = con.prepareStatement("select * from project_emp_details where pro_id=?");
			pst.setInt(1, uF.parseToInt(proId));
			rs = pst.executeQuery();
			Map<String, String> hmProEmpRate = new HashMap<String, String>();
			while (rs.next()) {
				hmProEmpRate.put(rs.getString("emp_id") + "_PER_HOUR", rs.getString("emp_actual_rate_per_hour"));
				hmProEmpRate.put(rs.getString("emp_id") + "_PER_DAY", rs.getString("emp_actual_rate_per_day"));
				hmProEmpRate.put(rs.getString("emp_id") + "_PER_MONTH", rs.getString("emp_actual_rate_per_month"));
				hmProEmpRate.put(rs.getString("emp_id") + "_RATE_PER_HOUR", rs.getString("emp_rate_per_hour"));
				hmProEmpRate.put(rs.getString("emp_id") + "_RATE_PER_DAY", rs.getString("emp_rate_per_day"));
				hmProEmpRate.put(rs.getString("emp_id") + "_RATE_PER_MONTH", rs.getString("emp_rate_per_month"));
			}
			rs.close();
			pst.close();
			// System.out.println(proId + "   hmProEmpRate ===>> " +
			// hmProEmpRate);

			StringBuilder sbQuery = new StringBuilder();
			sbQuery.append("select sum(a1.hrs) actual_hrs, sum(a1.days) actual_days, a1.emp_id from (select sum(ta.actual_hrs) hrs, "
					+ "count(distinct ta.task_date) days, ta.emp_id, ta.activity_id from task_activity ta where ta.emp_id>0 "); // task_date
																																// between
																																// ?
																																// and
																																// ?
			if (isSubmit && isApprove) {
				sbQuery.append(" and (is_approved = 1 or is_approved = 2)");
			} else if (isSubmit) {
				sbQuery.append(" and is_approved = 1 ");
			} else if (isApprove) {
				sbQuery.append(" and is_approved = 2 ");
			}
			sbQuery.append(" group by ta.activity_id, ta.emp_id) as a1, activity_info ai where ai.task_id = a1.activity_id and ai.pro_id = ? "
					+ "group by a1.emp_id");
			pst = con.prepareStatement(sbQuery.toString()); // and (is_approved
															// = 1 or
															// is_approved = 2)
			// pst.setDate(1,
			// uF.getDateFormat(hmProjectData.get("PRO_START_DATE"),
			// DATE_FORMAT));
			// pst.setDate(2,
			// uF.getDateFormat(hmProjectData.get("PRO_END_DATE"),
			// DATE_FORMAT));
			pst.setInt(1, uF.parseToInt(proId));
			// System.out.println("pst======> " + pst);
			rs = pst.executeQuery();
			Map<String, String> hmResourceActualTime = new HashMap<String, String>();
			while (rs.next()) {
				if (hmProjectData != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE") != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE").equals("H")) {
					hmResourceActualTime.put(rs.getString("emp_id"), rs.getString("actual_hrs"));
				} else if (hmProjectData != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE") != null
						&& hmProjectData.get("PRO_BILLING_ACTUAL_TYPE").equals("D")) {
					if (hmProjectData.get("PRO_BILL_DAYS_TYPE") != null && hmProjectData.get("PRO_BILL_DAYS_TYPE").equals("2")
							&& uF.parseToDouble(hmProjectData.get("PRO_HOURS_FOR_BILL_DAY")) > 0) {
						double dblActualDays = uF.parseToDouble(rs.getString("actual_hrs")) / uF.parseToDouble(hmProjectData.get("PRO_HOURS_FOR_BILL_DAY"));
						hmResourceActualTime.put(rs.getString("emp_id"), dblActualDays + "");
					} else {
						hmResourceActualTime.put(rs.getString("emp_id"), rs.getString("actual_days"));
					}
				} else if (hmProjectData != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE") != null
						&& hmProjectData.get("PRO_BILLING_ACTUAL_TYPE").equals("M")) {
					double dblActualDays = 0;
					if (hmProjectData.get("PRO_BILL_DAYS_TYPE") != null && hmProjectData.get("PRO_BILL_DAYS_TYPE").equals("2")
							&& uF.parseToDouble(hmProjectData.get("PRO_HOURS_FOR_BILL_DAY")) > 0) {
						dblActualDays = uF.parseToDouble(rs.getString("actual_hrs")) / uF.parseToDouble(hmProjectData.get("PRO_HOURS_FOR_BILL_DAY"));
						// hmResourceActualTime.put(rs.getString("emp_id"),
						// dblActualDays+"");
					} else {
						dblActualDays = uF.parseToDouble(rs.getString("actual_days"));
						// hmResourceActualTime.put(rs.getString("emp_id"),
						// rs.getString("actual_days"));
					}

					Map<String, String> hmEmpLevelMap = getEmpLevelMap(con);
					Map<String, String> hmEmpWlocation = getEmpWlocationMap(con);
					Map<String, Set<String>> hmWeekEndHalfDates = new HashMap<String, Set<String>>();
					// Map<String, Set<String>> hmWeekEnds =
					// getWeekEndDateList(con,hmProjectData.get("PRO_START_DATE"),
					// hmProjectData.get("PRO_END_DATE"), CF, uF,
					// hmWeekEndHalfDates, null);
					Map<String, Set<String>> hmWeekEnds = getWeekEndDateList(con, hmProjectData.get("PRO_START_DATE"), hmProjectData.get("PRO_END_DATE"), CF,
							uF, hmWeekEndHalfDates, null);
					List<String> alEmpCheckRosterWeektype = new ArrayList<String>();
					Map<String, Set<String>> hmRosterWeekEndDates = new HashMap<String, Set<String>>();
					getEmpRosterWeekOffTypeByDate(con, uF, CF, hmProjectData.get("PRO_START_DATE"), hmProjectData.get("PRO_END_DATE"),
							alEmpCheckRosterWeektype, hmRosterWeekEndDates, hmWeekEnds, hmEmpLevelMap, hmEmpWlocation, hmWeekEndHalfDates);

					String strWLocationId = CF.getEmpWlocationId(con, uF, rs.getString("emp_id"));

					Set<String> weeklyOffEndDate = hmWeekEnds.get(strWLocationId);
					if (weeklyOffEndDate == null)
						weeklyOffEndDate = new HashSet<String>();

					Set<String> rosterWeeklyOffSet = hmRosterWeekEndDates.get(rs.getString("emp_id"));
					if (rosterWeeklyOffSet == null)
						rosterWeeklyOffSet = new HashSet<String>();

					Map<String, String> hmHolidaysCnt = new HashMap<String, String>();
					Map<String, String> hmHolidayDates = new HashMap<String, String>();
					// List<String> empLeaveCountList = new ArrayList<String>();
					// List<String> holidayDateList = new ArrayList<String>();

					if (alEmpCheckRosterWeektype != null && alEmpCheckRosterWeektype.contains(rs.getString("emp_id"))) {
						CF.getHolidayListCount(con, request, hmProjectData.get("PRO_START_DATE"), hmProjectData.get("PRO_END_DATE"), CF, hmHolidayDates,
								hmHolidaysCnt, rosterWeeklyOffSet, true);
					} else {
						CF.getHolidayListCount(con, request, hmProjectData.get("PRO_START_DATE"), hmProjectData.get("PRO_END_DATE"), CF, hmHolidayDates,
								hmHolidaysCnt, weeklyOffEndDate, true);
					}

					String diffInDays = uF.dateDifference(hmProjectData.get("PRO_START_DATE"), DATE_FORMAT, hmProjectData.get("PRO_END_DATE"), DATE_FORMAT,
							CF.getStrTimeZone());

					int nWeekEnd = (alEmpCheckRosterWeektype != null && alEmpCheckRosterWeektype.contains(rs.getString("emp_id")))
							? rosterWeeklyOffSet.size()
							: weeklyOffEndDate.size();
					int nHolidayCnt = uF.parseToInt(hmHolidaysCnt.get(strWLocationId));

					// int nLeaveCnt = empLeaveCountList.size();
					double nWorkDays = (uF.parseToDouble(diffInDays) - nWeekEnd) - nHolidayCnt; // -
																								// nLeaveCnt

					double actualMonths = 0;
					if (nWorkDays > 0) {
						actualMonths = dblActualDays / nWorkDays;
					}
					hmResourceActualTime.put(rs.getString("emp_id"), actualMonths + "");
				}
			}
//			 System.out.println("CF/24147---"+proId + "---hmResourceActualTime ===>> "+hmResourceActualTime);
			rs.close();
			pst.close();

			Iterator<String> it = hmResourceActualTime.keySet().iterator();
			double proActualCost = 0;
			double proActualTime = 0;
			while (it.hasNext()) {
				String empId = it.next();
				String actualTime = hmResourceActualTime.get(empId);
				double taskResourceActualCost = 0;
				if (hmProjectData != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE") != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE").equals("H")) {
					taskResourceActualCost = uF.parseToDouble(actualTime) * uF.parseToDouble(hmProEmpRate.get(empId + "_PER_HOUR"));
				} else if (hmProjectData != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE") != null
						&& hmProjectData.get("PRO_BILLING_ACTUAL_TYPE").equals("D")) {
					taskResourceActualCost = uF.parseToDouble(actualTime) * uF.parseToDouble(hmProEmpRate.get(empId + "_PER_DAY"));
				} else if (hmProjectData != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE") != null
						&& hmProjectData.get("PRO_BILLING_ACTUAL_TYPE").equals("M")) {
					taskResourceActualCost = uF.parseToDouble(actualTime) * uF.parseToDouble(hmProEmpRate.get(empId + "_PER_MONTH"));
				}

				proActualTime += uF.parseToDouble(actualTime);
				proActualCost += taskResourceActualCost;
				// System.out.println(proId +"  empId ===>> " + empId +
				// "  actualTime ===>>> " + actualTime +
				// " taskResourceActualCost ===>> " + taskResourceActualCost);
			}

			hmProActualAndBillableCost.put("proActualTime", "" + proActualTime);
			hmProActualAndBillableCost.put("proActualCost", "" + proActualCost);
			// System.out.println(proId + "   hmProActualAndBillableCost ===>> "
			// + hmProActualAndBillableCost);
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmProActualAndBillableCost;
	}

	public Map<String, String> getProjectBudgetedCost(Connection con, UtilityFunctions uF, String proId, Map<String, String> hmProjectData) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmBudgetedCostAndTime = new HashMap<String, String>();
		try {
			pst = con.prepareStatement("select * from project_emp_details where pro_id=?");
			pst.setInt(1, uF.parseToInt(proId));
			rs = pst.executeQuery();
			Map<String, String> hmProEmpRate = new HashMap<String, String>();
			while (rs.next()) {
				hmProEmpRate.put(rs.getString("emp_id") + "_PER_HOUR", rs.getString("emp_actual_rate_per_hour"));
				hmProEmpRate.put(rs.getString("emp_id") + "_PER_DAY", rs.getString("emp_actual_rate_per_day"));
				hmProEmpRate.put(rs.getString("emp_id") + "_PER_MONTH", rs.getString("emp_actual_rate_per_month"));
			}
			rs.close();
			pst.close();

			double proVariableCost = getProjectVariableCost(con, uF, proId);

			// pst =
			// con.prepareStatement("select task_id, activity_name, resource_ids, idealtime, parent_task_id from activity_info where "
			// +
			// "task_id not in (select parent_task_id from activity_info where parent_task_id is not null) and (parent_task_id in ("
			// +
			// "select task_id from activity_info) or parent_task_id = 0) and pro_id = ? ");
			pst = con.prepareStatement("select task_id, activity_name, resource_ids, idealtime, parent_task_id from activity_info where "
					+ " parent_task_id = 0 and pro_id = ? ");
			pst.setInt(1, uF.parseToInt(proId));
			// System.out.println("pst======>"+pst);
			rs = pst.executeQuery();
			Map<String, Map<String, String>> hmTaskData = new HashMap<String, Map<String, String>>();
			while (rs.next()) {
				Map<String, String> hmInner = new HashMap<String, String>();
				hmInner.put(rs.getString("task_id") + "_IDEAL_TIME", rs.getString("idealtime"));
				hmInner.put(rs.getString("task_id") + "_RESOURCES", rs.getString("resource_ids"));
				hmTaskData.put(rs.getString("task_id"), hmInner);
			}
			rs.close();
			pst.close();

			Iterator<String> it = hmTaskData.keySet().iterator();
			double proBudgetedCost = 0;
			double proBudgetedTime = 0;
			// System.out.println("billType ===>> " + billType);
			while (it.hasNext()) {
				String taskId = it.next();
				Map<String, String> hmInner = hmTaskData.get(taskId);
				List<String> alResources = new ArrayList<String>();
				if (hmInner.get(taskId + "_RESOURCES") != null) {
					alResources = Arrays.asList(hmInner.get(taskId + "_RESOURCES").split(","));
				}
				int taskResourceCnt = 0;
				double taskResourceCost = 0;
				for (int i = 0; alResources != null && !alResources.isEmpty() && i < alResources.size(); i++) {
					if (alResources.get(i) != null && !alResources.get(i).equals("")) {
						// System.out.println(taskId +
						// "  -- alResources.get(i) ===>> " + alResources.get(i)
						// + "  billType ===>> " + billType);
						if (hmProjectData != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE") != null
								&& hmProjectData.get("PRO_BILLING_ACTUAL_TYPE").equals("H")) {
							taskResourceCost += uF.parseToDouble(hmProEmpRate.get(alResources.get(i) + "_PER_HOUR"));
						} else if (hmProjectData != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE") != null
								&& hmProjectData.get("PRO_BILLING_ACTUAL_TYPE").equals("D")) {
							taskResourceCost += uF.parseToDouble(hmProEmpRate.get(alResources.get(i) + "_PER_DAY"));
						} else if (hmProjectData != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE") != null
								&& hmProjectData.get("PRO_BILLING_ACTUAL_TYPE").equals("M")) {
							taskResourceCost += uF.parseToDouble(hmProEmpRate.get(alResources.get(i) + "_PER_MONTH"));
						}
						taskResourceCnt++;
					}
				}
				// System.out.println(taskId + "  taskResourceCnt ===>> " +
				// taskResourceCnt + "  taskResourceCost ====>> " +
				// taskResourceCost +" IDEAL_TIME =>>>>> " +
				// hmInner.get(taskId+"_IDEAL_TIME"));
				double taskAvgResourceCost = 0;
				if (taskResourceCnt > 0) {
					taskAvgResourceCost = taskResourceCost / taskResourceCnt;
				}
				double taskBudgetedCost = taskAvgResourceCost * uF.parseToDouble(hmInner.get(taskId + "_IDEAL_TIME"));
				// System.out.println(taskId + "  taskBudgetedCost ===>> " +
				// taskBudgetedCost);
				proBudgetedCost += taskBudgetedCost;

				proBudgetedTime += uF.parseToDouble(hmInner.get(taskId + "_IDEAL_TIME"));
			}
			proBudgetedCost += proVariableCost;
			hmBudgetedCostAndTime.put("proBudgetedCost", proBudgetedCost + "");
			hmBudgetedCostAndTime.put("proBudgetedTime", proBudgetedTime + "");
			// System.out.println("proBudgetedCost ===>> " + proBudgetedCost);
			// strBudgetedCost = proBudgetedCost+"";

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmBudgetedCostAndTime;
	}

	public Map<String, Map<String, String>> getOrgDetails(Connection con, UtilityFunctions uF) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, Map<String, String>> hmOrgMap = new HashMap<String, Map<String, String>>();
		try {
			pst = con.prepareStatement("select * from org_details");
			rs = pst.executeQuery();
			while (rs.next()) {
				Map<String, String> hmOrg = new HashMap<String, String>();

				hmOrg.put("ORG_ID", rs.getString("org_id"));
				hmOrg.put("ORG_NAME", rs.getString("org_name"));
				hmOrg.put("ORG_SUB_TITLE", rs.getString("org_subtitle"));
				hmOrg.put("ORG_LOGO", rs.getString("org_logo"));
				hmOrg.put("ORG_ADDRESS", rs.getString("org_address"));
				hmOrg.put("ORG_PINCODE", rs.getString("org_pincode"));
				hmOrg.put("ORG_CONTACT", rs.getString("org_contact1"));
				hmOrg.put("ORG_EMAIL", rs.getString("org_email"));
				hmOrg.put("ORG_STATE_ID", rs.getString("org_state_id"));
				hmOrg.put("ORG_COUNTRY_ID", rs.getString("org_country_id"));
				hmOrg.put("ORG_CITY", rs.getString("org_city"));
				hmOrg.put("ORG_CODE", rs.getString("org_code"));
				hmOrg.put("ORG_DISPLAY_PAYCYCLE", rs.getString("display_paycycle"));
				hmOrg.put("ORG_DURATION_PAYCYCLE", rs.getString("duration_paycycle"));
				hmOrg.put("ORG_SALARY_CAL_BASIS", rs.getString("salary_cal_basis"));
				hmOrg.put("ORG_START_PAYCYCLE", uF.getDateFormat(rs.getString("start_paycycle"), DBDATE, DATE_FORMAT));
				hmOrg.put("ORG_TRRN_EPF", rs.getString("trrn_epf"));
				hmOrg.put("ORG_EPF_ACCOUNT_NO", rs.getString("epf_account_no"));
				hmOrg.put("ORG_SALARY_FIX_DAYS", rs.getString("salary_fix_days"));
				hmOrg.put("ORG_PAN_NO", rs.getString("org_pan_no"));
				hmOrg.put("ORG_TAN_NO", rs.getString("org_tan_no"));
				hmOrg.put("ORG_REG_NO", rs.getString("org_reg_no"));
				hmOrg.put("ORG_ST_REG_NO", rs.getString("org_st_reg_no"));
				hmOrg.put("ORG_ADDITIONAL_NOTE", rs.getString("org_additional_note"));
				hmOrg.put("ORG_OFFICES_AT", rs.getString("offices_at"));
				hmOrg.put("ORG_CURRENCY", rs.getString("org_currency"));

				hmOrgMap.put(rs.getString("org_id"), hmOrg);

			}
			rs.close();
			pst.close();
			// System.out.println("hmOrgMap ==>> " + hmOrgMap);
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmOrgMap;
	}

	public Map<String, String> getOrgDetails(UtilityFunctions uF, String strOrgId, HttpServletRequest request) {

		Connection con = null;
		PreparedStatement pst = null;
		ResultSet rs = null;
		Database db = new Database();
		db.setRequest(request);
		Map<String, String> hmOrg = new HashMap<String, String>();
		try {
			con = db.makeConnection(con);
			pst = con.prepareStatement("select * from org_details where org_id = ? ");
			pst.setInt(1, uF.parseToInt(strOrgId));
			rs = pst.executeQuery();
			while (rs.next()) {
				hmOrg.put("ORG_ID", rs.getString("org_id"));
				hmOrg.put("ORG_NAME", rs.getString("org_name"));
				hmOrg.put("ORG_SUB_TITLE", rs.getString("org_subtitle"));
				hmOrg.put("ORG_LOGO", rs.getString("org_logo"));
				hmOrg.put("ORG_ADDRESS", rs.getString("org_address"));
				hmOrg.put("ORG_PINCODE", rs.getString("org_pincode"));
				hmOrg.put("ORG_CONTACT", rs.getString("org_contact1"));
				hmOrg.put("ORG_EMAIL", rs.getString("org_email"));
				hmOrg.put("ORG_STATE_ID", rs.getString("org_state_id"));
				hmOrg.put("ORG_COUNTRY_ID", rs.getString("org_country_id"));
				hmOrg.put("ORG_CITY", rs.getString("org_city"));
				hmOrg.put("ORG_CODE", rs.getString("org_code"));
				hmOrg.put("ORG_DISPLAY_PAYCYCLE", rs.getString("display_paycycle"));
				hmOrg.put("ORG_DURATION_PAYCYCLE", rs.getString("duration_paycycle"));
				hmOrg.put("ORG_SALARY_CAL_BASIS", rs.getString("salary_cal_basis"));
				hmOrg.put("ORG_START_PAYCYCLE", uF.getDateFormat(rs.getString("start_paycycle"), DBDATE, DATE_FORMAT));
				hmOrg.put("ORG_TRRN_EPF", rs.getString("trrn_epf"));
				hmOrg.put("ORG_EPF_ACCOUNT_NO", rs.getString("epf_account_no"));
				hmOrg.put("ORG_SALARY_FIX_DAYS", rs.getString("salary_fix_days"));
				hmOrg.put("ORG_PAN_NO", rs.getString("org_pan_no"));
				hmOrg.put("ORG_TAN_NO", rs.getString("org_tan_no"));
				hmOrg.put("ORG_REG_NO", rs.getString("org_reg_no"));
				hmOrg.put("ORG_ST_REG_NO", rs.getString("org_st_reg_no"));
				hmOrg.put("ORG_ADDITIONAL_NOTE", rs.getString("org_additional_note"));
				hmOrg.put("ORG_OFFICES_AT", rs.getString("offices_at"));
				hmOrg.put("ORG_CURRENCY", rs.getString("org_currency"));

			}
			rs.close();
			pst.close();
			// System.out.println("hmOrg ==>> " + hmOrg);
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			db.closeResultSet(rs);
			db.closeStatements(pst);
			db.closeConnection(con);
		}
		return hmOrg;
	}

	public String getClientAddressById(Connection con, String addressId) {
		UtilityFunctions uF = new UtilityFunctions();
		PreparedStatement pst = null;
		ResultSet rs = null;
		String clientAddress = null;
		try {
			pst = con.prepareStatement("select client_address from client_address where client_address_id = ?");
			pst.setInt(1, uF.parseToInt(addressId));
			// System.out.println("pst ====>>> " + pst);
			rs = pst.executeQuery();
			while (rs.next()) {
				clientAddress = uF.showData(rs.getString("client_address"), "-");
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return clientAddress;
	}

	public String getClientSPOCNameById(Connection con, String spocId) {
		UtilityFunctions uF = new UtilityFunctions();
		PreparedStatement pst = null;
		ResultSet rs = null;
		String spocName = null;
		try {
			pst = con.prepareStatement("select contact_fname,contact_lname from client_poc where poc_id = ?");
			pst.setInt(1, uF.parseToInt(spocId));
			// System.out.println("pst ====>>> " + pst);
			rs = pst.executeQuery();
			while (rs.next()) {
				spocName = uF.showData(rs.getString("contact_fname"), "N/A") + " " + uF.showData(rs.getString("contact_lname"), "N/A");
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return spocName;
	}

	public String getBankNameByBankId(Connection con, UtilityFunctions uF, String bankId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		String bankName = null;
		try {
			pst = con
					.prepareStatement("select bbd.branch_id,bd.bank_name,bbd.bank_branch FROM bank_details bd, branch_details bbd where bbd.bank_id = bd.bank_id and bbd.branch_id=?");
			pst.setInt(1, uF.parseToInt(bankId));
			rs = pst.executeQuery();
			while (rs.next()) {
				bankName = uF.showData(rs.getString("bank_name"), "") + " " + uF.showData(rs.getString("bank_branch"), "");
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return bankName;
	}

	public Map<String, String> getGradeDesig(Connection con) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmGradeDesig = new HashMap<String, String>();
		try {

			pst = con.prepareStatement("select * from grades_details");
			rs = pst.executeQuery();
			while (rs.next()) {
				hmGradeDesig.put(rs.getString("grade_id"), rs.getString("designation_id"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
		}
		return hmGradeDesig;
	}

	public Map<String, String> getProjectTaskActualWorkedDaysHrsMonthsCostOrRate(Connection con, HttpServletRequest request, CommonFunctions CF, String taskId,
			String resourceIds, Map<String, String> hmEmpCost, Map<String, String> hmProjectData) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		UtilityFunctions uF = new UtilityFunctions();
		Map<String, String> hmTaskCostORRateData = new LinkedHashMap<String, String>();
		try {

			List<String> resourceList = new ArrayList<String>();
			if (resourceIds != null) {
				resourceList = Arrays.asList(resourceIds.split(","));
			}

			List<String> tasksList = new ArrayList<String>();

			pst = con.prepareStatement("select task_id from activity_info where parent_task_id = ?");
			pst.setInt(1, uF.parseToInt(taskId));
			// System.out.println("pst ==>> " + pst);
			rs = pst.executeQuery();
			while (rs.next()) {
				if (!tasksList.contains(rs.getString("task_id")))
					tasksList.add(rs.getString("task_id"));
			}
			rs.close();
			pst.close();

			if (tasksList == null || tasksList.isEmpty() || tasksList.size() == 0) {
				tasksList.add(taskId);
			}
			// System.out.println("tasksList ==>> " + tasksList);
			StringBuilder sbtaskIds = null;
			for (int i = 0; tasksList != null && i < tasksList.size(); i++) {
				if (sbtaskIds == null) {
					sbtaskIds = new StringBuilder();
					sbtaskIds.append(tasksList.get(i));
				} else {
					sbtaskIds.append("," + tasksList.get(i));
				}
			}
			if (sbtaskIds == null) {
				sbtaskIds = new StringBuilder();
			}

			// double totActualHrs = 0;
			// double totBillableHrs = 0;
			// double totActualDays = 0;
			// double totBillableDays = 0;
			Map<String, String> hmApprovedBy = new HashMap<String, String>();

			Map<String, String> hmResourcewiseData = new LinkedHashMap<String, String>();

			StringBuilder sbEmpCostRate = null;
			// System.out.println(taskId+ " --- resourceList ==>> " +
			// resourceList);
			// System.out.println("PRO_BILLING_ACTUAL_TYPE ===>> " +
			// hmProjectData.get("PRO_BILLING_ACTUAL_TYPE"));
			// System.out.println("PRO_BILL_DAYS_TYPE ===>> " +
			// hmProjectData.get("PRO_BILL_DAYS_TYPE"));

			for (int a = 0; resourceList != null && a < resourceList.size(); a++) {
				if (resourceList.get(a) != null && !resourceList.get(a).equals("")) {
					for (int i = 0; tasksList != null && i < tasksList.size(); i++) {
						pst = con.prepareStatement("select sum(actual_hrs) as actual_hrs, approved_by from task_activity where activity_id=? and "
								+ "task_date between ? and ? and emp_id=? group by approved_by"); // and
																									// is_approved
																									// =
																									// 2
						pst.setInt(1, uF.parseToInt(tasksList.get(i)));
						pst.setDate(2, uF.getDateFormat(hmProjectData.get("PRO_START_DATE"), DATE_FORMAT));
						pst.setDate(3, uF.getDateFormat(hmProjectData.get("PRO_END_DATE"), DATE_FORMAT));
						pst.setInt(4, uF.parseToInt(resourceList.get(a)));
						rs = pst.executeQuery();
						// System.out.println("pst ===> " + pst);
						while (rs.next()) {
							hmApprovedBy.put(rs.getString("approved_by"), rs.getString("approved_by"));
							double totActualHrs = uF.parseToDouble(hmResourcewiseData.get(resourceList.get(a) + "_ACTUAL_HRS"));
							totActualHrs += rs.getDouble("actual_hrs");
							hmResourcewiseData.put(resourceList.get(a) + "_ACTUAL_HRS", totActualHrs + "");
						}
						rs.close();
						pst.close();
					}

					if (sbtaskIds != null && sbtaskIds.toString().length() > 0) {
						pst = con.prepareStatement("select count(distinct task_date) as days from task_activity where activity_id in (" + sbtaskIds.toString()
								+ ") " + "and task_date between ? and ? and emp_id=? group by emp_id,activity_id"); // and
																													// is_approved
																													// =
																													// 2
						pst.setDate(1, uF.getDateFormat(hmProjectData.get("PRO_START_DATE"), DATE_FORMAT));
						pst.setDate(2, uF.getDateFormat(hmProjectData.get("PRO_END_DATE"), DATE_FORMAT));
						pst.setInt(3, uF.parseToInt(resourceList.get(a)));
						rs = pst.executeQuery();
						// System.out.println("pst ===> " + pst);
						while (rs.next()) {
							double totActualDays = uF.parseToDouble(hmResourcewiseData.get(resourceList.get(a) + "_ACTUAL_DAYS"));
							totActualDays += rs.getInt("days");
							hmResourcewiseData.put(resourceList.get(a) + "_ACTUAL_DAYS", totActualDays + "");

						}
						rs.close();
						pst.close();
						// System.out.println("hmResourcewiseData ===>> " +
						// hmResourcewiseData);
					}

					for (int i = 0; tasksList != null && i < tasksList.size(); i++) {
						pst = con
								.prepareStatement("select sum(billable_hrs) as billable_hrs, count(distinct task_date) as task_date, approved_by "
										+ "from task_activity where activity_id=? and is_billable = true and task_date between ? and ? and emp_id=? group by approved_by"); // and
																																											// is_approved
																																											// =
																																											// 2
						pst.setInt(1, uF.parseToInt(tasksList.get(i)));
						pst.setDate(2, uF.getDateFormat(hmProjectData.get("PRO_START_DATE"), DATE_FORMAT));
						pst.setDate(3, uF.getDateFormat(hmProjectData.get("PRO_END_DATE"), DATE_FORMAT));
						pst.setInt(4, uF.parseToInt(resourceList.get(a)));
						rs = pst.executeQuery();
						while (rs.next()) {
							double totBillableHrs = uF.parseToDouble(hmResourcewiseData.get(resourceList.get(a) + "_BILLABLE_HRS"));
							totBillableHrs += rs.getDouble("billable_hrs");
							hmResourcewiseData.put(resourceList.get(a) + "_BILLABLE_HRS", totBillableHrs + "");
						}
						rs.close();
						pst.close();
					}

					if (sbtaskIds != null && sbtaskIds.toString().length() > 0) {
						pst = con.prepareStatement("select count(distinct task_date) as days from task_activity where activity_id in (" + sbtaskIds.toString()
								+ ") " + "and is_billable = true and task_date between ? and ? and emp_id=? group by emp_id,activity_id");// and
																																			// is_approved
																																			// =
																																			// 2
						pst.setDate(1, uF.getDateFormat(hmProjectData.get("PRO_START_DATE"), DATE_FORMAT));
						pst.setDate(2, uF.getDateFormat(hmProjectData.get("PRO_END_DATE"), DATE_FORMAT));
						pst.setInt(3, uF.parseToInt(resourceList.get(a)));
						rs = pst.executeQuery();
						// System.out.println("pst is_billable ===> " + pst);
						while (rs.next()) {
							double totBillableDays = uF.parseToDouble(hmResourcewiseData.get(resourceList.get(a) + "_BILLABLE_DAYS"));
							totBillableDays += rs.getInt("days");
							hmResourcewiseData.put(resourceList.get(a) + "_BILLABLE_DAYS", totBillableDays + "");
						}
						rs.close();
						pst.close();
						// System.out.println("hmResourcewiseData ==>> " +
						// hmResourcewiseData);
					}

					if (hmProjectData.get("PRO_BILL_DAYS_TYPE") != null && hmProjectData.get("PRO_BILL_DAYS_TYPE").equals("2")
							&& uF.parseToDouble(hmProjectData.get("PRO_HOURS_FOR_BILL_DAY")) > 0) {
						double totActualDays = uF.parseToDouble(hmResourcewiseData.get(resourceList.get(a) + "_ACTUAL_HRS"))
								/ uF.parseToDouble(hmProjectData.get("PRO_HOURS_FOR_BILL_DAY"));
						double totBillableDays = uF.parseToDouble(hmResourcewiseData.get(resourceList.get(a) + "_BILLABLE_HRS"))
								/ uF.parseToDouble(hmProjectData.get("PRO_HOURS_FOR_BILL_DAY"));
						hmResourcewiseData.put(resourceList.get(a) + "_ACTUAL_DAYS", totActualDays + "");
						hmResourcewiseData.put(resourceList.get(a) + "_BILLABLE_DAYS", totBillableDays + "");
					}
					// System.out.println("hmResourcewiseData 111111 ===>> " +
					// hmResourcewiseData);
					// }

					if (hmProjectData.get("PRO_BILLING_ACTUAL_TYPE") != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE").equals("H")) {
						double billableHrs = 0;
						double actualHrs = 0;
						double totBillableHrs = 0;
						double totActualHrs = 0;
						billableHrs = uF.parseToDouble(hmResourcewiseData.get(resourceList.get(a) + "_BILLABLE_HRS"));
						actualHrs = uF.parseToDouble(hmResourcewiseData.get(resourceList.get(a) + "_ACTUAL_HRS"));

						totBillableHrs = uF.parseToDouble(hmTaskCostORRateData.get("BILLABLE_WORKING"));
						totActualHrs = uF.parseToDouble(hmTaskCostORRateData.get("ACTUAL_WORKING"));
						totBillableHrs += billableHrs;
						totActualHrs += actualHrs;
						hmTaskCostORRateData.put("ACTUAL_WORKING", uF.formatIntoTwoDecimalWithOutComma(totActualHrs));
						hmTaskCostORRateData.put("BILLABLE_WORKING", uF.formatIntoTwoDecimalWithOutComma(totBillableHrs));

						double totActualCost = uF.parseToDouble(hmTaskCostORRateData.get("ACTUAL_COST"));
						double actualCost = actualHrs * uF.parseToDouble(hmEmpCost.get(resourceList.get(a)));
						totActualCost += actualCost;

						double totBillableCost = uF.parseToDouble(hmTaskCostORRateData.get("BILLABLE_COST"));
						double billableCost = billableHrs * uF.parseToDouble(hmEmpCost.get(resourceList.get(a)));
						totBillableCost += billableCost;
						// System.out.println(sbtaskIds+
						// " === EmpID ===>> "+resourceList.get(a)+" -- billableHrs ==>> "
						// + billableHrs +" -- hmEmpCost ==>> " +
						// uF.parseToDouble(hmEmpCost.get(resourceList.get(a))));
						// System.out.println("billableCost =====>> " +
						// billableCost
						// +" -- totBillableCost ===>> "+totBillableCost);

						hmTaskCostORRateData.put("ACTUAL_COST", uF.formatIntoTwoDecimalWithOutComma(totActualCost));
						hmTaskCostORRateData.put("BILLABLE_COST", uF.formatIntoTwoDecimalWithOutComma(totBillableCost));
						// System.out.println("hmTaskCostORRateData =====>> " +
						// hmTaskCostORRateData);
					} else if (hmProjectData.get("PRO_BILLING_ACTUAL_TYPE") != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE").equals("D")) {
						double billableDays = 0;
						double actualDays = 0;
						double totBillableDays = 0;
						double totActualDays = 0;
						billableDays = uF.parseToDouble(hmResourcewiseData.get(resourceList.get(a) + "_BILLABLE_DAYS"));
						actualDays = uF.parseToDouble(hmResourcewiseData.get(resourceList.get(a) + "_ACTUAL_DAYS"));

						totBillableDays = uF.parseToDouble(hmTaskCostORRateData.get("BILLABLE_WORKING"));
						totActualDays = uF.parseToDouble(hmTaskCostORRateData.get("ACTUAL_WORKING"));
						totBillableDays += billableDays;
						totActualDays += actualDays;
						hmTaskCostORRateData.put("ACTUAL_WORKING", uF.formatIntoTwoDecimalWithOutComma(totActualDays));
						hmTaskCostORRateData.put("BILLABLE_WORKING", uF.formatIntoTwoDecimalWithOutComma(totBillableDays));

						double totActualCost = uF.parseToDouble(hmTaskCostORRateData.get("ACTUAL_COST"));
						double actualCost = actualDays * uF.parseToDouble(hmEmpCost.get(resourceList.get(a)));
						totActualCost += actualCost;

						double totBillableCost = uF.parseToDouble(hmTaskCostORRateData.get("BILLABLE_COST"));
						double billableCost = billableDays * uF.parseToDouble(hmEmpCost.get(resourceList.get(a)));
						totBillableCost += billableCost;
						hmTaskCostORRateData.put("ACTUAL_COST", uF.formatIntoTwoDecimalWithOutComma(totActualCost));
						hmTaskCostORRateData.put("BILLABLE_COST", uF.formatIntoTwoDecimalWithOutComma(totBillableCost));
					} else if (hmProjectData.get("PRO_BILLING_ACTUAL_TYPE") != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE").equals("M")) {

						Map<String, String> hmEmpLevelMap = getEmpLevelMap(con);
						Map<String, String> hmEmpWlocation = getEmpWlocationMap(con);
						Map<String, Set<String>> hmWeekEndHalfDates = new HashMap<String, Set<String>>();
						// Map<String, Set<String>> hmWeekEnds =
						// getWeekEndDateList(con,hmProjectData.get("PRO_START_DATE"),
						// hmProjectData.get("PRO_END_DATE"), CF, uF,
						// hmWeekEndHalfDates, null);
						Map<String, Set<String>> hmWeekEnds = getWeekEndDateList(con, hmProjectData.get("PRO_START_DATE"), hmProjectData.get("PRO_END_DATE"),
								CF, uF, hmWeekEndHalfDates, null);
						List<String> alEmpCheckRosterWeektype = new ArrayList<String>();
						Map<String, Set<String>> hmRosterWeekEndDates = new HashMap<String, Set<String>>();
						getEmpRosterWeekOffTypeByDate(con, uF, CF, hmProjectData.get("PRO_START_DATE"), hmProjectData.get("PRO_END_DATE"),
								alEmpCheckRosterWeektype, hmRosterWeekEndDates, hmWeekEnds, hmEmpLevelMap, hmEmpWlocation, hmWeekEndHalfDates);

						String strWLocationId = CF.getEmpWlocationId(con, uF, resourceList.get(a));

						Set<String> weeklyOffEndDate = hmWeekEnds.get(strWLocationId);
						if (weeklyOffEndDate == null)
							weeklyOffEndDate = new HashSet<String>();

						Set<String> rosterWeeklyOffSet = hmRosterWeekEndDates.get(resourceList.get(a));
						if (rosterWeeklyOffSet == null)
							rosterWeeklyOffSet = new HashSet<String>();

						Map<String, String> hmHolidaysCnt = new HashMap<String, String>();
						Map<String, String> hmHolidayDates = new HashMap<String, String>();
						// List<String> empLeaveCountList = new
						// ArrayList<String>();
						// List<String> holidayDateList = new
						// ArrayList<String>();

						if (alEmpCheckRosterWeektype != null && alEmpCheckRosterWeektype.contains(resourceList.get(a))) {
							CF.getHolidayListCount(con, request, hmProjectData.get("PRO_START_DATE"), hmProjectData.get("PRO_END_DATE"), CF, hmHolidayDates,
									hmHolidaysCnt, rosterWeeklyOffSet, true);
						} else {
							CF.getHolidayListCount(con, request, hmProjectData.get("PRO_START_DATE"), hmProjectData.get("PRO_END_DATE"), CF, hmHolidayDates,
									hmHolidaysCnt, weeklyOffEndDate, true);
						}

						String diffInDays = uF.dateDifference(hmProjectData.get("PRO_START_DATE"), DATE_FORMAT, hmProjectData.get("PRO_END_DATE"), DATE_FORMAT,
								CF.getStrTimeZone());

						int nWeekEnd = (alEmpCheckRosterWeektype != null && alEmpCheckRosterWeektype.contains(resourceList.get(a)))
								? rosterWeeklyOffSet.size()
								: weeklyOffEndDate.size();
						int nHolidayCnt = uF.parseToInt(hmHolidaysCnt.get(strWLocationId));

						// int nLeaveCnt = empLeaveCountList.size();
						double nWorkDays = (uF.parseToDouble(diffInDays) - nWeekEnd) - nHolidayCnt; // -
																									// nLeaveCnt

						double billableMonths = 0;
						double actualMonths = 0;
						double totBillableMonths = 0;
						double totActualMonths = 0;
						// System.out.println("nWorkDays ===>> " + nWorkDays);
						// System.out.println("_BILLABLE_DAYS ===>> " +
						// uF.parseToDouble(hmResourcewiseData.get(resourceList.get(a)+"_BILLABLE_DAYS")));
						// System.out.println("_ACTUAL_DAYS ===>> " +
						// uF.parseToDouble(hmResourcewiseData.get(resourceList.get(a)+"_ACTUAL_DAYS")));
						if (nWorkDays > 0) {
							billableMonths = uF.parseToDouble(hmResourcewiseData.get(resourceList.get(a) + "_BILLABLE_DAYS")) / nWorkDays;
							actualMonths = uF.parseToDouble(hmResourcewiseData.get(resourceList.get(a) + "_ACTUAL_DAYS")) / nWorkDays;
						}

						totBillableMonths = uF.parseToDouble(hmTaskCostORRateData.get("BILLABLE_WORKING"));
						totActualMonths = uF.parseToDouble(hmTaskCostORRateData.get("ACTUAL_WORKING"));
						totBillableMonths += billableMonths;
						totActualMonths += actualMonths;
						// System.out.println("totActualMonths ===>> " +
						// totActualMonths);
						// System.out.println("totBillableMonths ===>> " +
						// totBillableMonths);

						hmTaskCostORRateData.put("ACTUAL_WORKING", uF.formatIntoTwoDecimalWithOutComma(totActualMonths));
						hmTaskCostORRateData.put("BILLABLE_WORKING", uF.formatIntoTwoDecimalWithOutComma(totBillableMonths));

						double totActualCost = uF.parseToDouble(hmTaskCostORRateData.get("ACTUAL_COST"));
						double actualCost = actualMonths * uF.parseToDouble(hmEmpCost.get(resourceList.get(a)));
						totActualCost += actualCost;

						double totBillableCost = uF.parseToDouble(hmTaskCostORRateData.get("BILLABLE_COST"));
						double billableCost = billableMonths * uF.parseToDouble(hmEmpCost.get(resourceList.get(a)));
						totBillableCost += billableCost;
						// System.out.println("hmEmpCost ===>> " +
						// uF.parseToDouble(hmEmpCost.get(resourceList.get(a))));
						// System.out.println("billableCost ===>> " +
						// billableCost);
						hmTaskCostORRateData.put("ACTUAL_COST", uF.formatIntoTwoDecimalWithOutComma(totActualCost));
						hmTaskCostORRateData.put("BILLABLE_COST", uF.formatIntoTwoDecimalWithOutComma(totBillableCost));
					}

					// String resourceCost =
					// hmTaskCostORRateData.get("RESOURCE_COST_RATE");
					if (sbEmpCostRate == null) {
						sbEmpCostRate = new StringBuilder();
						sbEmpCostRate.append(uF.formatIntoTwoDecimal(uF.parseToDouble(hmEmpCost.get(resourceList.get(a)))));
					} else {
						sbEmpCostRate.append(", " + uF.formatIntoTwoDecimal(uF.parseToDouble(hmEmpCost.get(resourceList.get(a)))));
					}
					hmTaskCostORRateData.put("RESOURCE_COST_RATE", sbEmpCostRate.toString());
				}
			}
			// System.out.println("hmTaskCostORRateData ===>> " +
			// hmTaskCostORRateData);

			// hmProjectEfforts.put("ACTUAL_HRS", ""+Math.round(totActualHrs));
			// hmProjectEfforts.put("BILLABLE_HRS",
			// ""+Math.round(totBillableHrs));
			// hmProjectEfforts.put("ACTUAL_DAYS",
			// ""+uF.formatIntoOneDecimalWithOutComma(totActualDays));
			// hmProjectEfforts.put("BILLABLE_DAYS",
			// ""+uF.formatIntoOneDecimalWithOutComma(totBillableDays));

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmTaskCostORRateData;
	}

	public Map<String, String> getProjectBillableCostAndTime(Connection con, HttpServletRequest request, CommonFunctions CF, UtilityFunctions uF, String proId,
			Map<String, String> hmProjectData, boolean isSubmit, boolean isApprove) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmProBillableCost = new HashMap<String, String>();
		try {

			pst = con.prepareStatement("select * from project_emp_details where pro_id=?");
			pst.setInt(1, uF.parseToInt(proId));
			rs = pst.executeQuery();
			Map<String, String> hmProEmpRate = new HashMap<String, String>();
			while (rs.next()) {
				hmProEmpRate.put(rs.getString("emp_id") + "_PER_HOUR", rs.getString("emp_actual_rate_per_hour"));
				hmProEmpRate.put(rs.getString("emp_id") + "_PER_DAY", rs.getString("emp_actual_rate_per_day"));
				hmProEmpRate.put(rs.getString("emp_id") + "_PER_MONTH", rs.getString("emp_actual_rate_per_month"));
				hmProEmpRate.put(rs.getString("emp_id") + "_RATE_PER_HOUR", rs.getString("emp_rate_per_hour"));
				hmProEmpRate.put(rs.getString("emp_id") + "_RATE_PER_DAY", rs.getString("emp_rate_per_day"));
				hmProEmpRate.put(rs.getString("emp_id") + "_RATE_PER_MONTH", rs.getString("emp_rate_per_month"));
			}
			rs.close();
			pst.close();
			// System.out.println(proId + "   hmProEmpRate ===>> " +
			// hmProEmpRate);

			StringBuilder sbQuery = new StringBuilder();
			sbQuery.append("select sum(a1.hrs) billable_hrs, sum(a1.days) billable_days, a1.emp_id from (select sum(ta.billable_hrs) hrs, "
					+ "count(distinct ta.task_date) days, ta.emp_id, ta.activity_id from task_activity ta where " // task_date
																													// between
																													// ?
																													// and
																													// ?
																													// and
					+ "is_billable = true ");
			if (isSubmit && isApprove) {
				sbQuery.append(" and (is_approved = 1 or is_approved = 2)");
			} else if (isSubmit) {
				sbQuery.append(" and is_approved = 1 ");
			} else if (isApprove) {
				sbQuery.append(" and is_approved = 2 ");
			}
			sbQuery.append(" group by ta.activity_id, ta.emp_id) as a1, activity_info ai where ai.task_id = a1.activity_id and ai.pro_id = ? "
					+ "group by a1.emp_id");
			pst = con.prepareStatement(sbQuery.toString()); // and (is_approved
															// = 1 or
															// is_approved = 2)
															// pst.setDate(1,
															// uF.getDateFormat(hmProjectData.get("PRO_START_DATE"),
															// DATE_FORMAT));
			// pst.setDate(2,
			// uF.getDateFormat(hmProjectData.get("PRO_END_DATE"),
			// DATE_FORMAT));
			pst.setInt(1, uF.parseToInt(proId));
			// System.out.println("pst======>"+pst);
			rs = pst.executeQuery();
			Map<String, String> hmResourceBillableTime = new HashMap<String, String>();
			while (rs.next()) {
				if (hmProjectData != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE") != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE").equals("H")) {
					hmResourceBillableTime.put(rs.getString("emp_id"), rs.getString("billable_hrs"));
				} else if (hmProjectData != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE") != null
						&& hmProjectData.get("PRO_BILLING_ACTUAL_TYPE").equals("D")) {
					if (hmProjectData.get("PRO_BILL_DAYS_TYPE") != null && hmProjectData.get("PRO_BILL_DAYS_TYPE").equals("2")
							&& uF.parseToDouble(hmProjectData.get("PRO_HOURS_FOR_BILL_DAY")) > 0) {
						double dblActualDays = uF.parseToDouble(rs.getString("billable_hrs")) / uF.parseToDouble(hmProjectData.get("PRO_HOURS_FOR_BILL_DAY"));
						hmResourceBillableTime.put(rs.getString("emp_id"), dblActualDays + "");
					} else {
						hmResourceBillableTime.put(rs.getString("emp_id"), rs.getString("billable_days"));
					}
				} else if (hmProjectData != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE") != null
						&& hmProjectData.get("PRO_BILLING_ACTUAL_TYPE").equals("M")) {
					double dblBillableDays = 0;
					if (hmProjectData.get("PRO_BILL_DAYS_TYPE") != null && hmProjectData.get("PRO_BILL_DAYS_TYPE").equals("2")
							&& uF.parseToDouble(hmProjectData.get("PRO_HOURS_FOR_BILL_DAY")) > 0) {
						dblBillableDays = uF.parseToDouble(rs.getString("billable_hrs")) / uF.parseToDouble(hmProjectData.get("PRO_HOURS_FOR_BILL_DAY"));
					} else {
						dblBillableDays = uF.parseToDouble(rs.getString("billable_days"));
					}

					Map<String, String> hmEmpLevelMap = getEmpLevelMap(con);
					Map<String, String> hmEmpWlocation = getEmpWlocationMap(con);
					Map<String, Set<String>> hmWeekEndHalfDates = new HashMap<String, Set<String>>();
					Map<String, Set<String>> hmWeekEnds = getWeekEndDateList(con, hmProjectData.get("PRO_START_DATE"), hmProjectData.get("PRO_END_DATE"), CF,
							uF, hmWeekEndHalfDates, null);

					List<String> alEmpCheckRosterWeektype = new ArrayList<String>();
					Map<String, Set<String>> hmRosterWeekEndDates = new HashMap<String, Set<String>>();
					getEmpRosterWeekOffTypeByDate(con, uF, CF, hmProjectData.get("PRO_START_DATE"), hmProjectData.get("PRO_END_DATE"),
							alEmpCheckRosterWeektype, hmRosterWeekEndDates, hmWeekEnds, hmEmpLevelMap, hmEmpWlocation, hmWeekEndHalfDates);

					String strWLocationId = getEmpWlocationId(con, uF, rs.getString("emp_id"));

					Set<String> weeklyOffEndDate = hmWeekEnds.get(strWLocationId);
					if (weeklyOffEndDate == null)
						weeklyOffEndDate = new HashSet<String>();

					Set<String> rosterWeeklyOffSet = hmRosterWeekEndDates.get(rs.getString("emp_id"));
					if (rosterWeeklyOffSet == null)
						rosterWeeklyOffSet = new HashSet<String>();

					Map<String, String> hmHolidaysCnt = new HashMap<String, String>();
					Map<String, String> hmHolidayDates = new HashMap<String, String>();

					if (alEmpCheckRosterWeektype != null && alEmpCheckRosterWeektype.contains(rs.getString("emp_id"))) {
						getHolidayListCount(con, request, hmProjectData.get("PRO_START_DATE"), hmProjectData.get("PRO_END_DATE"), CF, hmHolidayDates,
								hmHolidaysCnt, rosterWeeklyOffSet, true);
					} else {
						getHolidayListCount(con, request, hmProjectData.get("PRO_START_DATE"), hmProjectData.get("PRO_END_DATE"), CF, hmHolidayDates,
								hmHolidaysCnt, weeklyOffEndDate, true);
					}

					String diffInDays = uF.dateDifference(hmProjectData.get("PRO_START_DATE"), DATE_FORMAT, hmProjectData.get("PRO_END_DATE"), DATE_FORMAT,
							getStrTimeZone());

					int nWeekEnd = (alEmpCheckRosterWeektype != null && alEmpCheckRosterWeektype.contains(rs.getString("emp_id")))
							? rosterWeeklyOffSet.size()
							: weeklyOffEndDate.size();
					int nHolidayCnt = uF.parseToInt(hmHolidaysCnt.get(strWLocationId));

					double nWorkDays = (uF.parseToDouble(diffInDays) - nWeekEnd) - nHolidayCnt; // -
																								// nLeaveCnt

					double actualMonths = 0;
					if (nWorkDays > 0) {
						actualMonths = dblBillableDays / nWorkDays;
					}
					hmResourceBillableTime.put(rs.getString("emp_id"), actualMonths + "");
				}
			}
			// System.out.println(proId + "   hmResourceBillableTime ===>> " +
			// hmResourceBillableTime);
			rs.close();
			pst.close();

			Iterator<String> it = hmResourceBillableTime.keySet().iterator();
			double proBillableTime = 0;
			double proBillableCost = 0;
			while (it.hasNext()) {
				String empId = it.next();
				String billableTime = hmResourceBillableTime.get(empId);
				double taskResourceBillableCost = 0;
				if (hmProjectData != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE") != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE").equals("H")) {
					taskResourceBillableCost = uF.parseToDouble(billableTime) * uF.parseToDouble(hmProEmpRate.get(empId + "_RATE_PER_HOUR"));
				} else if (hmProjectData != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE") != null
						&& hmProjectData.get("PRO_BILLING_ACTUAL_TYPE").equals("D")) {
					taskResourceBillableCost = uF.parseToDouble(billableTime) * uF.parseToDouble(hmProEmpRate.get(empId + "_RATE_PER_DAY"));
				} else if (hmProjectData != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE") != null
						&& hmProjectData.get("PRO_BILLING_ACTUAL_TYPE").equals("M")) {
					taskResourceBillableCost = uF.parseToDouble(billableTime) * uF.parseToDouble(hmProEmpRate.get(empId + "_RATE_PER_MONTH"));
				}

				proBillableTime += uF.parseToDouble(billableTime);
				proBillableCost += taskResourceBillableCost;
				// System.out.println(proId +"  empId ===>> " + empId +
				// "  billableTime ===>>> " + billableTime +
				// " taskResourceBillableCost ===>> " +
				// taskResourceBillableCost);
			}

			hmProBillableCost.put("proBillableTime", "" + proBillableTime);
			hmProBillableCost.put("proBillableCost", "" + proBillableCost);
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmProBillableCost;
	}

	public String getProFreqNameById(Connection con, String proFreqId) {
		UtilityFunctions uF = new UtilityFunctions();
		PreparedStatement pst = null;
		ResultSet rs = null;
		String proFreqName = null;
		try {
			pst = con.prepareStatement("select pro_freq_name from projectmntnc_frequency where pro_freq_id = ?");
			pst.setInt(1, uF.parseToInt(proFreqId));
			rs = pst.executeQuery();
			while (rs.next()) {
				proFreqName = uF.showData(rs.getString("pro_freq_name"), "-");
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return proFreqName;
	}

	public Map<String, Map<String, String>> getCurrencyDetailsForMultiBillReceive(Connection con) {

		PreparedStatement pst = null;
		ResultSet rs = null;

		Map<String, Map<String, String>> hmCurrencyDetailsMap = new HashMap<String, Map<String, String>>();
		try {

			pst = con.prepareStatement("select * from currency_details");
			rs = pst.executeQuery();

			while (rs.next()) {
				Map<String, String> hmInner = new HashMap<String, String>();

				hmInner.put("SHORT_CURR", rs.getString("short_currency"));
				hmInner.put("LONG_CURR", rs.getString("long_currency"));

				hmInner.put("CURR_DESC", rs.getString("currency_desc"));
				hmInner.put("CURR_CONVERSION_USD", rs.getString("currency_conversion_usd"));
				hmInner.put("CURR_INR_VALUE", rs.getString("inr_value"));

				hmCurrencyDetailsMap.put(rs.getString("currency_id"), hmInner);
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmCurrencyDetailsMap;
	}

	public String getEmpImageByEmpId(Connection con, UtilityFunctions uF, String empId) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		String strEmpImage = null;
		try {
			pst = con.prepareStatement("select emp_image from employee_personal_details where emp_per_id = ?");
			pst.setInt(1, uF.parseToInt(empId));
			rs = pst.executeQuery();
			while (rs.next()) {
				strEmpImage = uF.showData(rs.getString("emp_image"), "-");
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return strEmpImage;
	}

	public String getProjectReimbursementAmount(Connection con, String proId, UtilityFunctions uF) {

		PreparedStatement pst = null;
		ResultSet rs = null;

		String reimbursement_amount = "";

		try {

			StringBuilder sbQuery = new StringBuilder();
			sbQuery.append("select sum(reimbursement_amount) as reimbursement_amount from emp_reimbursement where approval_2 = 1 "
					+ "and pro_id =? and reimbursement_type1 = 'P'");
			pst = con.prepareStatement(sbQuery.toString());
			pst.setInt(1, uF.parseToInt(proId));
			// System.out.println("pst ===> " + pst);
			rs = pst.executeQuery();
			while (rs.next()) {
				// String arr[] = null;
				// if (rs.getString("group_type") != null) {
				// arr = rs.getString("group_type").split(",");
				// hmReimbursementAmountMap.put(arr[0],
				// rs.getString("reimbursement_amount"));
				// }
				reimbursement_amount = rs.getString("reimbursement_amount");
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return reimbursement_amount;
	}

	public Map<String, String> getProjectTaskEmpwiseActualWorkedDaysAndHrs(Connection con, String taskId, String empId, Map<String, String> hmProjectData) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		UtilityFunctions uF = new UtilityFunctions();
		Map<String, String> hmProjectEfforts = new HashMap<String, String>();
		try {

			List<String> tasksList = new ArrayList<String>();

			pst = con.prepareStatement("select task_id from activity_info where parent_task_id = ?");
			pst.setInt(1, uF.parseToInt(taskId));
			rs = pst.executeQuery();
			while (rs.next()) {
				if (!tasksList.contains(rs.getString("task_id")))
					tasksList.add(rs.getString("task_id"));
			}
			rs.close();
			pst.close();

			if (tasksList == null || tasksList.isEmpty() || tasksList.size() == 0) {
				tasksList.add(taskId);
			}
			StringBuilder sbtaskIds = null;
			for (int i = 0; tasksList != null && i < tasksList.size(); i++) {
				if (sbtaskIds == null) {
					sbtaskIds = new StringBuilder();
					sbtaskIds.append(tasksList.get(i));
				} else {
					sbtaskIds.append("," + tasksList.get(i));
				}
			}
			if (sbtaskIds == null) {
				sbtaskIds = new StringBuilder();
			}

			double totActualHrs = 0;
			double totBillableHrs = 0;
			double totActualDays = 0;
			double totBillableDays = 0;
			Map<String, String> hmApprovedBy = new HashMap<String, String>();
			for (int i = 0; tasksList != null && i < tasksList.size(); i++) {
				pst = con
						.prepareStatement("select sum(actual_hrs) as actual_hrs, approved_by from task_activity where activity_id=? and task_date between ? and ? and emp_id=? group by approved_by"); // and
																																																		// is_approved
																																																		// =
																																																		// 2
				pst.setInt(1, uF.parseToInt(tasksList.get(i)));
				pst.setDate(2, uF.getDateFormat(hmProjectData.get("PRO_START_DATE"), DATE_FORMAT));
				pst.setDate(3, uF.getDateFormat(hmProjectData.get("PRO_END_DATE"), DATE_FORMAT));
				pst.setInt(4, uF.parseToInt(empId));
				rs = pst.executeQuery();
				// System.out.println("pst ===> " + pst);
				while (rs.next()) {
					hmApprovedBy.put(rs.getString("approved_by"), rs.getString("approved_by"));
					totActualHrs += rs.getDouble("actual_hrs");
				}
				rs.close();
				pst.close();
			}

			if (sbtaskIds != null && sbtaskIds.toString().length() > 0) {
				pst = con.prepareStatement("select count(distinct task_date) as days from task_activity where activity_id in (" + sbtaskIds.toString()
						+ ")  and task_date between ? and ? and emp_id=?"); // and
																			// is_approved
																			// =
																			// 2
				pst.setDate(1, uF.getDateFormat(hmProjectData.get("PRO_START_DATE"), DATE_FORMAT));
				pst.setDate(2, uF.getDateFormat(hmProjectData.get("PRO_END_DATE"), DATE_FORMAT));
				pst.setInt(3, uF.parseToInt(empId));
				rs = pst.executeQuery();
				// System.out.println("pst ===> " + pst);
				while (rs.next()) {
					totActualDays += rs.getInt("days");
				}
				rs.close();
				pst.close();
			}

			for (int i = 0; tasksList != null && i < tasksList.size(); i++) {
				pst = con
						.prepareStatement("select sum(billable_hrs) as billable_hrs, count(distinct task_date) as task_date, approved_by from task_activity where activity_id=? and is_approved = 2 and is_billable = true and task_date between ? and ? and emp_id=? group by approved_by");
				pst.setInt(1, uF.parseToInt(tasksList.get(i)));
				pst.setDate(2, uF.getDateFormat(hmProjectData.get("PRO_START_DATE"), DATE_FORMAT));
				pst.setDate(3, uF.getDateFormat(hmProjectData.get("PRO_END_DATE"), DATE_FORMAT));
				pst.setInt(4, uF.parseToInt(empId));
				rs = pst.executeQuery();
				while (rs.next()) {
					totBillableHrs += rs.getDouble("billable_hrs");
				}
				rs.close();
				pst.close();
			}

			if (sbtaskIds != null && sbtaskIds.toString().length() > 0) {
				pst = con.prepareStatement("select count(distinct task_date) as days from task_activity where activity_id in (" + sbtaskIds.toString()
						+ ") and is_approved = 2 and is_billable = true and task_date between ? and ? and emp_id=?");
				pst.setDate(1, uF.getDateFormat(hmProjectData.get("PRO_START_DATE"), DATE_FORMAT));
				pst.setDate(2, uF.getDateFormat(hmProjectData.get("PRO_END_DATE"), DATE_FORMAT));
				pst.setInt(3, uF.parseToInt(empId));
				rs = pst.executeQuery();
				while (rs.next()) {
					totBillableDays += rs.getInt("days");
				}
				rs.close();
				pst.close();
			}

			if (hmProjectData.get("PRO_BILL_DAYS_TYPE") != null && hmProjectData.get("PRO_BILL_DAYS_TYPE").equals("2")
					&& uF.parseToDouble(hmProjectData.get("PRO_HOURS_FOR_BILL_DAY")) > 0) {
				totActualDays = totActualHrs / uF.parseToDouble(hmProjectData.get("PRO_HOURS_FOR_BILL_DAY"));
				totBillableDays = totBillableHrs / uF.parseToDouble(hmProjectData.get("PRO_HOURS_FOR_BILL_DAY"));
			}

			StringBuilder sbApproveBy = null;
			Iterator<String> it = hmApprovedBy.keySet().iterator();

			while (it.hasNext()) {
				String approveby = it.next();
				if (uF.parseToInt(approveby) > 0) {
					if (sbApproveBy == null) {
						sbApproveBy = new StringBuilder();
						sbApproveBy.append(getEmpNameMapByEmpId(con, approveby));
					} else {
						sbApproveBy.append("," + getEmpNameMapByEmpId(con, approveby));
					}
				}
			}
			if (sbApproveBy == null) {
				sbApproveBy = new StringBuilder();
			}
			hmProjectEfforts.put("ACTUAL_HRS", "" + uF.formatIntoTwoDecimalWithOutComma(totActualHrs));
			hmProjectEfforts.put("BILLABLE_HRS", "" + uF.formatIntoTwoDecimalWithOutComma(totBillableHrs));
			hmProjectEfforts.put("ACTUAL_DAYS", "" + uF.formatIntoOneDecimalWithOutComma(totActualDays));
			hmProjectEfforts.put("BILLABLE_DAYS", "" + uF.formatIntoOneDecimalWithOutComma(totBillableDays));

			hmProjectEfforts.put("APPROVED_BY", sbApproveBy.toString());

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmProjectEfforts;
	}

	public Map<String, String> getProjectTaskActualWorkedMonthsCostOrRate(Connection con, HttpServletRequest request, CommonFunctions CF, String taskId,
			String resourceIds, Map<String, String> hmEmpCost, Map<String, String> hmProjectData) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		UtilityFunctions uF = new UtilityFunctions();
		Map<String, String> hmTaskCostORRateData = new LinkedHashMap<String, String>();
		try {

			List<String> resourceList = new ArrayList<String>();
			if (resourceIds != null) {
				resourceList = Arrays.asList(resourceIds.split(","));
			}
			List<String> tasksList = new ArrayList<String>();
			pst = con.prepareStatement("select task_id from activity_info where parent_task_id = ?");
			pst.setInt(1, uF.parseToInt(taskId));
			// System.out.println("pst ==>> " + pst);
			rs = pst.executeQuery();
			while (rs.next()) {
				if (!tasksList.contains(rs.getString("task_id")))
					tasksList.add(rs.getString("task_id"));
			}
			rs.close();
			pst.close();

			if (tasksList == null || tasksList.isEmpty() || tasksList.size() == 0) {
				tasksList.add(taskId);
			}
			// System.out.println("tasksList ==>> " + tasksList);
			StringBuilder sbtaskIds = null;
			for (int i = 0; tasksList != null && i < tasksList.size(); i++) {
				if (sbtaskIds == null) {
					sbtaskIds = new StringBuilder();
					sbtaskIds.append(tasksList.get(i));
				} else {
					sbtaskIds.append("," + tasksList.get(i));
				}
			}
			if (sbtaskIds == null) {
				sbtaskIds = new StringBuilder();
			}

			// Map<String, String> hmApprovedBy = new HashMap<String, String>();

			StringBuilder sbEmpCostRate = null;
			// System.out.println(taskId+ " --- resourceList ==>> " +
			// resourceList);
			// System.out.println("PRO_BILLING_ACTUAL_TYPE ===>> " +
			// hmProjectData.get("PRO_BILLING_ACTUAL_TYPE"));
			// System.out.println("PRO_BILL_DAYS_TYPE ===>> " +
			// hmProjectData.get("PRO_BILL_DAYS_TYPE"));

			for (int a = 0; resourceList != null && a < resourceList.size(); a++) {
				if (resourceList.get(a) != null && !resourceList.get(a).equals("")) {
					Date dt1 = uF.getDateFormat(hmProjectData.get("PRO_START_DATE"), DATE_FORMAT);
					Date dt2 = uF.getDateFormat(hmProjectData.get("PRO_END_DATE"), DATE_FORMAT);
					Date currDt2 = uF.getCurrentDate(getStrTimeZone());
					if (dt2.after(currDt2)) {
						String currdate = uF.getDateFormat(uF.getCurrentDate(CF.getStrTimeZone()) + "", DBDATE, DATE_FORMAT);
						dt2 = uF.getDateFormat(currdate, DATE_FORMAT);
					}
					int cnt = uF.getMonthsDifference(dt1, dt2);
					String startPeriod = hmProjectData.get("PRO_START_DATE");
					String mSTDate = null;
					String mENDDate = null;
					String res = uF.getCurrentMonthMinMaxDate(startPeriod, DATE_FORMAT);
					int count = 0;
					for (int b = 0; b <= cnt; b++) {

						if (b > 0) {
							res = uF.getNextMonthMinMaxDate(startPeriod, DATE_FORMAT);
						}
						String[] FTdate = res.split("::::");
						Date minDt1 = uF.getDateFormat(FTdate[0], DATE_FORMAT);
						Date maxDt1 = uF.getDateFormat(FTdate[1], DATE_FORMAT);
						if (minDt1.before(dt1)) {
							mSTDate = hmProjectData.get("PRO_START_DATE");
						} else {
							mSTDate = FTdate[0];
						}

						if (maxDt1.before(currDt2)) {
							startPeriod = FTdate[0];
							mENDDate = FTdate[1];
							// System.out.println("Result :: " + res);
						} else if (maxDt1.after(dt2)) {
							mENDDate = uF.getDateFormat(dt2 + "", DBDATE, DATE_FORMAT);
							count++;
						} else {
							// System.out.println("Result :: " + res);
							mENDDate = uF.getDateFormat(currDt2 + "", DBDATE, DATE_FORMAT);
							count++;
						}
						// System.out.println("mSTDate :: "+ mSTDate
						// +" === mENDDate :: " + mENDDate);
						if (count <= 1) {
							Map<String, String> hmResourcewiseData = new LinkedHashMap<String, String>();
							for (int i = 0; tasksList != null && i < tasksList.size(); i++) {
								pst = con.prepareStatement("select sum(actual_hrs) as actual_hrs from task_activity where activity_id=? and "
										+ "task_date between ? and ? and emp_id=?"); // and
																						// is_approved
																						// =
																						// 2
								pst.setInt(1, uF.parseToInt(tasksList.get(i)));
								pst.setDate(2, uF.getDateFormat(mSTDate, DATE_FORMAT));
								pst.setDate(3, uF.getDateFormat(mENDDate, DATE_FORMAT));
								pst.setInt(4, uF.parseToInt(resourceList.get(a)));
								rs = pst.executeQuery();
								// System.out.println("pst ===> " + pst);
								while (rs.next()) {
									// hmApprovedBy.put(rs.getString("approved_by"),
									// rs.getString("approved_by"));
									double totActualHrs = uF.parseToDouble(hmResourcewiseData.get(resourceList.get(a) + "_ACTUAL_HRS"));
									totActualHrs += rs.getDouble("actual_hrs");
									hmResourcewiseData.put(resourceList.get(a) + "_ACTUAL_HRS", totActualHrs + "");
								}
								rs.close();
								pst.close();
							}

							if (sbtaskIds != null && sbtaskIds.toString().length() > 0) {
								pst = con.prepareStatement("select count(distinct task_date) as days from task_activity where activity_id in ("
										+ sbtaskIds.toString() + ") " + "and task_date between ? and ? and emp_id=? group by emp_id,activity_id"); // and
																																					// is_approved
																																					// =
																																					// 2
								pst.setDate(1, uF.getDateFormat(mSTDate, DATE_FORMAT));
								pst.setDate(2, uF.getDateFormat(mENDDate, DATE_FORMAT));
								pst.setInt(3, uF.parseToInt(resourceList.get(a)));
								rs = pst.executeQuery();
								// System.out.println("pst ===> " + pst);
								while (rs.next()) {
									double totActualDays = uF.parseToDouble(hmResourcewiseData.get(resourceList.get(a) + "_ACTUAL_DAYS"));
									totActualDays += rs.getInt("days");
									hmResourcewiseData.put(resourceList.get(a) + "_ACTUAL_DAYS", totActualDays + "");

								}
								rs.close();
								pst.close();
								// System.out.println("hmResourcewiseData ===>> "
								// + hmResourcewiseData);
							}

							for (int i = 0; tasksList != null && i < tasksList.size(); i++) {
								pst = con
										.prepareStatement("select sum(billable_hrs) as billable_hrs, count(distinct task_date) as task_date, approved_by "
												+ "from task_activity where activity_id=? and is_billable = true and task_date between ? and ? and emp_id=? group by approved_by"); // and
																																													// is_approved
																																													// =
																																													// 2
								pst.setInt(1, uF.parseToInt(tasksList.get(i)));
								pst.setDate(2, uF.getDateFormat(mSTDate, DATE_FORMAT));
								pst.setDate(3, uF.getDateFormat(mENDDate, DATE_FORMAT));
								pst.setInt(4, uF.parseToInt(resourceList.get(a)));
								rs = pst.executeQuery();
								while (rs.next()) {
									double totBillableHrs = uF.parseToDouble(hmResourcewiseData.get(resourceList.get(a) + "_BILLABLE_HRS"));
									totBillableHrs += rs.getDouble("billable_hrs");
									hmResourcewiseData.put(resourceList.get(a) + "_BILLABLE_HRS", totBillableHrs + "");
								}
								rs.close();
								pst.close();
							}

							if (sbtaskIds != null && sbtaskIds.toString().length() > 0) {
								pst = con.prepareStatement("select count(distinct task_date) as days from task_activity where activity_id in ("
										+ sbtaskIds.toString() + ") "
										+ "and is_billable = true and task_date between ? and ? and emp_id=? group by emp_id,activity_id");// and
																																			// is_approved
																																			// =
																																			// 2
								pst.setDate(1, uF.getDateFormat(mSTDate, DATE_FORMAT));
								pst.setDate(2, uF.getDateFormat(mENDDate, DATE_FORMAT));
								pst.setInt(3, uF.parseToInt(resourceList.get(a)));
								rs = pst.executeQuery();
								// System.out.println("pst is_billable ===> " +
								// pst);
								while (rs.next()) {
									double totBillableDays = uF.parseToDouble(hmResourcewiseData.get(resourceList.get(a) + "_BILLABLE_DAYS"));
									totBillableDays += rs.getInt("days");
									hmResourcewiseData.put(resourceList.get(a) + "_BILLABLE_DAYS", totBillableDays + "");
								}
								rs.close();
								pst.close();
								// System.out.println("hmResourcewiseData ==>> "
								// + hmResourcewiseData);
							}

							if (hmProjectData.get("PRO_BILL_DAYS_TYPE") != null && hmProjectData.get("PRO_BILL_DAYS_TYPE").equals("2")
									&& uF.parseToDouble(hmProjectData.get("PRO_HOURS_FOR_BILL_DAY")) > 0) {
								double totActualDays = uF.parseToDouble(hmResourcewiseData.get(resourceList.get(a) + "_ACTUAL_HRS"))
										/ uF.parseToDouble(hmProjectData.get("PRO_HOURS_FOR_BILL_DAY"));
								double totBillableDays = uF.parseToDouble(hmResourcewiseData.get(resourceList.get(a) + "_BILLABLE_HRS"))
										/ uF.parseToDouble(hmProjectData.get("PRO_HOURS_FOR_BILL_DAY"));
								hmResourcewiseData.put(resourceList.get(a) + "_ACTUAL_DAYS", totActualDays + "");
								hmResourcewiseData.put(resourceList.get(a) + "_BILLABLE_DAYS", totBillableDays + "");
							}
							// System.out.println("hmResourcewiseData 111111 ===>> "
							// + hmResourcewiseData);
							// }

							if (hmProjectData.get("PRO_BILLING_ACTUAL_TYPE") != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE").equals("H")) {

							} else if (hmProjectData.get("PRO_BILLING_ACTUAL_TYPE") != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE").equals("D")) {

							} else if (hmProjectData.get("PRO_BILLING_ACTUAL_TYPE") != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE").equals("M")) {

								Map<String, String> hmEmpLevelMap = getEmpLevelMap(con);
								Map<String, String> hmEmpWlocation = getEmpWlocationMap(con);
								Map<String, Set<String>> hmWeekEndHalfDates = new HashMap<String, Set<String>>();
								// Map<String, Set<String>> hmWeekEnds =
								// getWeekEndDateList(con,hmProjectData.get("PRO_START_DATE"),
								// hmProjectData.get("PRO_END_DATE"), CF, uF,
								// hmWeekEndHalfDates, null);
								Map<String, Set<String>> hmWeekEnds = getWeekEndDateList(con, mSTDate, mENDDate, CF, uF, hmWeekEndHalfDates, null);
								List<String> alEmpCheckRosterWeektype = new ArrayList<String>();
								Map<String, Set<String>> hmRosterWeekEndDates = new HashMap<String, Set<String>>();
								getEmpRosterWeekOffTypeByDate(con, uF, CF, mSTDate, mENDDate, alEmpCheckRosterWeektype, hmRosterWeekEndDates, hmWeekEnds,
										hmEmpLevelMap, hmEmpWlocation, hmWeekEndHalfDates);

								String strWLocationId = CF.getEmpWlocationId(con, uF, resourceList.get(a));

								Set<String> weeklyOffEndDate = hmWeekEnds.get(strWLocationId);
								if (weeklyOffEndDate == null)
									weeklyOffEndDate = new HashSet<String>();

								Set<String> rosterWeeklyOffSet = hmRosterWeekEndDates.get(resourceList.get(a));
								if (rosterWeeklyOffSet == null)
									rosterWeeklyOffSet = new HashSet<String>();

								Map<String, String> hmHolidaysCnt = new HashMap<String, String>();
								Map<String, String> hmHolidayDates = new HashMap<String, String>();
								// List<String> empLeaveCountList = new
								// ArrayList<String>();
								// List<String> holidayDateList = new
								// ArrayList<String>();

								if (alEmpCheckRosterWeektype != null && alEmpCheckRosterWeektype.contains(resourceList.get(a))) {
									CF.getHolidayListCount(con, request, mSTDate, mENDDate, CF, hmHolidayDates, hmHolidaysCnt, rosterWeeklyOffSet, true);
								} else {
									CF.getHolidayListCount(con, request, mSTDate, mENDDate, CF, hmHolidayDates, hmHolidaysCnt, weeklyOffEndDate, true);
								}

								String diffInDays = uF.dateDifference(mSTDate, DATE_FORMAT, mENDDate, DATE_FORMAT, CF.getStrTimeZone());

								int nWeekEnd = (alEmpCheckRosterWeektype != null && alEmpCheckRosterWeektype.contains(resourceList.get(a)))
										? rosterWeeklyOffSet.size()
										: weeklyOffEndDate.size();
								int nHolidayCnt = uF.parseToInt(hmHolidaysCnt.get(strWLocationId));

								// int nLeaveCnt = empLeaveCountList.size();
								double nWorkDays = (uF.parseToDouble(diffInDays) - nWeekEnd) - nHolidayCnt; // -
																											// nLeaveCnt

								double billableMonths = 0;
								double actualMonths = 0;
								double billMonth = 0;
								double actMonth = 0;
								double totBillableMonths = 0;
								double totActualMonths = 0;
								// System.out.println("nWorkDays ===>> " +
								// nWorkDays);
								// System.out.println("_BILLABLE_DAYS ===>> " +
								// uF.parseToDouble(hmResourcewiseData.get(resourceList.get(a)+"_BILLABLE_DAYS"))
								// +" -- nWorkDays ===>> " + nWorkDays);
								// System.out.println("_ACTUAL_DAYS ===>> " +
								// uF.parseToDouble(hmResourcewiseData.get(resourceList.get(a)+"_ACTUAL_DAYS")));
								String proCostCalType = getProjectCostCalculationType(con, hmProjectData.get("PRO_ORG_ID"), uF);
								if (uF.parseToInt(proCostCalType) == 1) {
									nWorkDays = 30;
								}
								// System.out.println("nWorkDays ===>> " +
								// nWorkDays);
								if (nWorkDays > 0) {
									billableMonths = uF.parseToDouble(hmResourcewiseData.get(resourceList.get(a) + "_BILLABLE_DAYS")) / nWorkDays;
									actualMonths = uF.parseToDouble(hmResourcewiseData.get(resourceList.get(a) + "_ACTUAL_DAYS")) / nWorkDays;
								}
								billMonth = uF.parseToDouble(hmResourcewiseData.get(resourceList.get(a) + "_BILLABLE_DAYS")) / 30;
								actMonth = uF.parseToDouble(hmResourcewiseData.get(resourceList.get(a) + "_ACTUAL_DAYS")) / 30;

								totBillableMonths = uF.parseToDouble(hmTaskCostORRateData.get("BILLABLE_WORKING"));
								totActualMonths = uF.parseToDouble(hmTaskCostORRateData.get("ACTUAL_WORKING"));
								totBillableMonths += billMonth;
								totActualMonths += actMonth;
								// System.out.println("totActualMonths ===>> " +
								// totActualMonths);
								// System.out.println("totBillableMonths ===>> "
								// + totBillableMonths);

								hmTaskCostORRateData.put("ACTUAL_WORKING", uF.formatIntoTwoDecimalWithOutComma(totActualMonths));
								hmTaskCostORRateData.put("BILLABLE_WORKING", uF.formatIntoTwoDecimalWithOutComma(totBillableMonths));

								double totActualCost = uF.parseToDouble(hmTaskCostORRateData.get("ACTUAL_COST"));
								double actualCost = actualMonths * uF.parseToDouble(hmEmpCost.get(resourceList.get(a)));
								totActualCost += actualCost;

								double totBillableCost = uF.parseToDouble(hmTaskCostORRateData.get("BILLABLE_COST"));
								double billableCost = billableMonths * uF.parseToDouble(hmEmpCost.get(resourceList.get(a)));
								totBillableCost += billableCost;
								// System.out.println("hmEmpCost ===>> " +
								// uF.parseToDouble(hmEmpCost.get(resourceList.get(a))));
								// System.out.println("billableCost ===>> " +
								// billableCost);
								hmTaskCostORRateData.put("ACTUAL_COST", uF.formatIntoTwoDecimalWithOutComma(totActualCost));
								hmTaskCostORRateData.put("BILLABLE_COST", uF.formatIntoTwoDecimalWithOutComma(totBillableCost));
							}

							// String resourceCost =
							// hmTaskCostORRateData.get("RESOURCE_COST_RATE");
						}
					}
					if (sbEmpCostRate == null) {
						sbEmpCostRate = new StringBuilder();
						sbEmpCostRate.append(uF.formatIntoTwoDecimal(uF.parseToDouble(hmEmpCost.get(resourceList.get(a)))));
					} else {
						sbEmpCostRate.append(", " + uF.formatIntoTwoDecimal(uF.parseToDouble(hmEmpCost.get(resourceList.get(a)))));
					}
					hmTaskCostORRateData.put("RESOURCE_COST_RATE", sbEmpCostRate.toString());
				}
			}
			// System.out.println("hmTaskCostORRateData ===>> " +
			// hmTaskCostORRateData);

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmTaskCostORRateData;
	}

	public String getProjectCostCalculationType(Connection con, String orgId, UtilityFunctions uF) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		String calType = "";
		try {
			StringBuilder sbQuery = new StringBuilder();
			sbQuery.append("select calculation_type from cost_calculation_settings where org_id =?");
			pst = con.prepareStatement(sbQuery.toString());
			pst.setInt(1, uF.parseToInt(orgId));
			// System.out.println("pst ===> " + pst);
			rs = pst.executeQuery();
			while (rs.next()) {
				calType = rs.getString("calculation_type");
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return calType;
	}

	public Map<String, String> getMonthlyProjectActualCostAndTime(Connection con, HttpServletRequest request, CommonFunctions CF, UtilityFunctions uF,
			String proId, Map<String, String> hmProjectData) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmProActualAndBillableCost = new HashMap<String, String>();
		try {

			pst = con.prepareStatement("select * from project_emp_details where pro_id=?");
			pst.setInt(1, uF.parseToInt(proId));
			rs = pst.executeQuery();
			Map<String, String> hmProEmpRate = new HashMap<String, String>();
			while (rs.next()) {
				hmProEmpRate.put(rs.getString("emp_id") + "_PER_HOUR", rs.getString("emp_actual_rate_per_hour"));
				hmProEmpRate.put(rs.getString("emp_id") + "_PER_DAY", rs.getString("emp_actual_rate_per_day"));
				hmProEmpRate.put(rs.getString("emp_id") + "_PER_MONTH", rs.getString("emp_actual_rate_per_month"));
				hmProEmpRate.put(rs.getString("emp_id") + "_RATE_PER_HOUR", rs.getString("emp_rate_per_hour"));
				hmProEmpRate.put(rs.getString("emp_id") + "_RATE_PER_DAY", rs.getString("emp_rate_per_day"));
				hmProEmpRate.put(rs.getString("emp_id") + "_RATE_PER_MONTH", rs.getString("emp_rate_per_month"));
			}
			// System.out.println(proId + "   hmProEmpRate ===>> " +
			// hmProEmpRate);
			rs.close();
			pst.close();

			Date dt1 = uF.getDateFormat(hmProjectData.get("PRO_START_DATE"), DATE_FORMAT);
			Date dt2 = uF.getDateFormat(hmProjectData.get("PRO_END_DATE"), DATE_FORMAT);
			Date currDt2 = uF.getCurrentDate(getStrTimeZone());
			if (dt2.after(currDt2)) {
				String currdate = uF.getDateFormat(uF.getCurrentDate(CF.getStrTimeZone()) + "", DBDATE, DATE_FORMAT);
				dt2 = uF.getDateFormat(currdate, DATE_FORMAT);
			}
			int cnt = uF.getMonthsDifference(dt1, dt2);
			String startPeriod = hmProjectData.get("PRO_START_DATE");
			String mSTDate = null;
			String mENDDate = null;
			String res = uF.getCurrentMonthMinMaxDate(startPeriod, DATE_FORMAT);
			int count = 0;
			for (int b = 0; b <= cnt; b++) {

				if (b > 0) {
					res = uF.getNextMonthMinMaxDate(startPeriod, DATE_FORMAT);
				}
				String[] FTdate = res.split("::::");
				Date minDt1 = uF.getDateFormat(FTdate[0], DATE_FORMAT);
				Date maxDt1 = uF.getDateFormat(FTdate[1], DATE_FORMAT);
				if (minDt1.before(dt1)) {
					mSTDate = hmProjectData.get("PRO_START_DATE");
				} else {
					mSTDate = FTdate[0];
				}

				if (maxDt1.before(currDt2)) {
					startPeriod = FTdate[0];
					mENDDate = FTdate[1];
					// System.out.println("Result :: " + res);
				} else if (maxDt1.after(dt2)) {
					mENDDate = uF.getDateFormat(dt2 + "", DBDATE, DATE_FORMAT);
					count++;
				} else {
					// System.out.println("Result :: " + res);
					mENDDate = uF.getDateFormat(currDt2 + "", DBDATE, DATE_FORMAT);
					count++;
				}
				// System.out.println("mSTDate :: "+ mSTDate
				// +" === mENDDate :: " + mENDDate);
				if (count <= 1) {
					pst = con
							.prepareStatement("select sum(a1.hrs) actual_hrs, sum(a1.days) actual_days, a1.emp_id from (select sum(ta.actual_hrs) hrs, count(distinct ta.task_date) days, "
									+ "ta.emp_id, ta.activity_id from task_activity ta group by ta.activity_id, ta.emp_id) as a1, activity_info ai "
									+ "where ai.task_id = a1.activity_id and ai.pro_id = ? group by a1.emp_id "); // task_date
																													// between
																													// ?
																													// and
																													// ?
																													// //
																													// and
					// (is_approved
					// = 1
					// or
					// is_approved
					// = 2)
					// pst.setDate(1, uF.getDateFormat(mSTDate, DATE_FORMAT));
					// pst.setDate(2, uF.getDateFormat(mENDDate, DATE_FORMAT));
					pst.setInt(1, uF.parseToInt(proId));
					// System.out.println("pst======>"+pst);
					rs = pst.executeQuery();
					Map<String, String> hmResourceActualTime = new HashMap<String, String>();
					Map<String, String> hmResourceActualTime30Days = new HashMap<String, String>();
					while (rs.next()) {
						if (hmProjectData != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE") != null
								&& hmProjectData.get("PRO_BILLING_ACTUAL_TYPE").equals("M")) {
							double dblActualDays = 0;
							if (hmProjectData.get("PRO_BILL_DAYS_TYPE") != null && hmProjectData.get("PRO_BILL_DAYS_TYPE").equals("2")
									&& uF.parseToDouble(hmProjectData.get("PRO_HOURS_FOR_BILL_DAY")) > 0) {
								dblActualDays = uF.parseToDouble(rs.getString("actual_hrs")) / uF.parseToDouble(hmProjectData.get("PRO_HOURS_FOR_BILL_DAY"));
							} else {
								dblActualDays = uF.parseToDouble(rs.getString("actual_days"));
							}

							Map<String, String> hmEmpLevelMap = getEmpLevelMap(con);
							Map<String, String> hmEmpWlocation = getEmpWlocationMap(con);
							Map<String, Set<String>> hmWeekEndHalfDates = new HashMap<String, Set<String>>();
							Map<String, Set<String>> hmWeekEnds = getWeekEndDateList(con, mSTDate, mENDDate, CF, uF, hmWeekEndHalfDates, null);
							List<String> alEmpCheckRosterWeektype = new ArrayList<String>();
							Map<String, Set<String>> hmRosterWeekEndDates = new HashMap<String, Set<String>>();
							getEmpRosterWeekOffTypeByDate(con, uF, CF, mSTDate, mENDDate, alEmpCheckRosterWeektype, hmRosterWeekEndDates, hmWeekEnds,
									hmEmpLevelMap, hmEmpWlocation, hmWeekEndHalfDates);

							String strWLocationId = CF.getEmpWlocationId(con, uF, rs.getString("emp_id"));

							Set<String> weeklyOffEndDate = hmWeekEnds.get(strWLocationId);
							if (weeklyOffEndDate == null)
								weeklyOffEndDate = new HashSet<String>();

							Set<String> rosterWeeklyOffSet = hmRosterWeekEndDates.get(rs.getString("emp_id"));
							if (rosterWeeklyOffSet == null)
								rosterWeeklyOffSet = new HashSet<String>();

							Map<String, String> hmHolidaysCnt = new HashMap<String, String>();
							Map<String, String> hmHolidayDates = new HashMap<String, String>();

							if (alEmpCheckRosterWeektype != null && alEmpCheckRosterWeektype.contains(rs.getString("emp_id"))) {
								CF.getHolidayListCount(con, request, mSTDate, mENDDate, CF, hmHolidayDates, hmHolidaysCnt, rosterWeeklyOffSet, true);
							} else {
								CF.getHolidayListCount(con, request, mSTDate, mENDDate, CF, hmHolidayDates, hmHolidaysCnt, weeklyOffEndDate, true);
							}

							String diffInDays = uF.dateDifference(mSTDate, DATE_FORMAT, mENDDate, DATE_FORMAT, CF.getStrTimeZone());

							int nWeekEnd = (alEmpCheckRosterWeektype != null && alEmpCheckRosterWeektype.contains(rs.getString("emp_id"))) ? rosterWeeklyOffSet
									.size() : weeklyOffEndDate.size();
							int nHolidayCnt = uF.parseToInt(hmHolidaysCnt.get(strWLocationId));

							double nWorkDays = (uF.parseToDouble(diffInDays) - nWeekEnd) - nHolidayCnt; // -
																										// nLeaveCnt
							String proCostCalType = getProjectCostCalculationType(con, hmProjectData.get("PRO_ORG_ID"), uF);
							if (uF.parseToInt(proCostCalType) == 1) {
								nWorkDays = 30;
							}

							double actualMonths = 0;
							if (nWorkDays > 0) {
								actualMonths = dblActualDays / nWorkDays;
							}

							hmResourceActualTime30Days.put(rs.getString("emp_id"), (dblActualDays / 30) + "");
							hmResourceActualTime.put(rs.getString("emp_id"), actualMonths + "");
						}
					}
					// System.out.println(proId +
					// "   hmResourceActualTime ===>> " + hmResourceActualTime);
					rs.close();
					pst.close();

					Iterator<String> it = hmResourceActualTime.keySet().iterator();
					double proActualCost = uF.parseToDouble(hmProActualAndBillableCost.get("proActualCost"));
					double proActualTime = uF.parseToDouble(hmProActualAndBillableCost.get("proActualTime"));
					while (it.hasNext()) {
						String empId = it.next();
						String actualTime30Days = hmResourceActualTime30Days.get(empId);
						String actualTime = hmResourceActualTime.get(empId);
						double taskResourceActualCost = 0;
						if (hmProjectData != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE") != null
								&& hmProjectData.get("PRO_BILLING_ACTUAL_TYPE").equals("M")) {
							taskResourceActualCost = uF.parseToDouble(actualTime) * uF.parseToDouble(hmProEmpRate.get(empId + "_PER_MONTH"));
						}

						proActualTime += uF.parseToDouble(actualTime30Days);
						proActualCost += taskResourceActualCost;
						// System.out.println(proId +"  empId ===>> " + empId +
						// "  actualTime ===>>> " + actualTime +
						// " taskResourceActualCost ===>> " +
						// taskResourceActualCost);
					}
					hmProActualAndBillableCost.put("proActualTime", "" + proActualTime);
					hmProActualAndBillableCost.put("proActualCost", "" + proActualCost);
				}
			}

			// System.out.println(proId + "   hmProActualAndBillableCost ===>> "
			// + hmProActualAndBillableCost);
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmProActualAndBillableCost;
	}

	public Map<String, String> getMonthlyProjectBillableCostAndTime(Connection con, HttpServletRequest request, CommonFunctions CF, UtilityFunctions uF,
			String proId, Map<String, String> hmProjectData) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmProActualAndBillableCost = new HashMap<String, String>();
		try {

			pst = con.prepareStatement("select * from project_emp_details where pro_id=?");
			pst.setInt(1, uF.parseToInt(proId));
			rs = pst.executeQuery();
			Map<String, String> hmProEmpRate = new HashMap<String, String>();
			while (rs.next()) {
				hmProEmpRate.put(rs.getString("emp_id") + "_PER_HOUR", rs.getString("emp_actual_rate_per_hour"));
				hmProEmpRate.put(rs.getString("emp_id") + "_PER_DAY", rs.getString("emp_actual_rate_per_day"));
				hmProEmpRate.put(rs.getString("emp_id") + "_PER_MONTH", rs.getString("emp_actual_rate_per_month"));
				hmProEmpRate.put(rs.getString("emp_id") + "_RATE_PER_HOUR", rs.getString("emp_rate_per_hour"));
				hmProEmpRate.put(rs.getString("emp_id") + "_RATE_PER_DAY", rs.getString("emp_rate_per_day"));
				hmProEmpRate.put(rs.getString("emp_id") + "_RATE_PER_MONTH", rs.getString("emp_rate_per_month"));
			}
			// System.out.println(proId + "   hmProEmpRate ===>> " +
			// hmProEmpRate);
			rs.close();
			pst.close();

			Date dt1 = uF.getDateFormat(hmProjectData.get("PRO_START_DATE"), DATE_FORMAT);
			Date dt2 = uF.getDateFormat(hmProjectData.get("PRO_END_DATE"), DATE_FORMAT);
			Date currDt2 = uF.getCurrentDate(getStrTimeZone());
			if (dt2.after(currDt2)) {
				String currdate = uF.getDateFormat(uF.getCurrentDate(CF.getStrTimeZone()) + "", DBDATE, DATE_FORMAT);
				dt2 = uF.getDateFormat(currdate, DATE_FORMAT);
			}
			int cnt = uF.getMonthsDifference(dt1, dt2);
			String startPeriod = hmProjectData.get("PRO_START_DATE");
			String mSTDate = null;
			String mENDDate = null;
			String res = uF.getCurrentMonthMinMaxDate(startPeriod, DATE_FORMAT);
			int count = 0;
			for (int b = 0; b <= cnt; b++) {

				if (b > 0) {
					res = uF.getNextMonthMinMaxDate(startPeriod, DATE_FORMAT);
				}
				String[] FTdate = res.split("::::");
				Date minDt1 = uF.getDateFormat(FTdate[0], DATE_FORMAT);
				Date maxDt1 = uF.getDateFormat(FTdate[1], DATE_FORMAT);
				if (minDt1.before(dt1)) {
					mSTDate = hmProjectData.get("PRO_START_DATE");
				} else {
					mSTDate = FTdate[0];
				}

				if (maxDt1.before(currDt2)) {
					startPeriod = FTdate[0];
					mENDDate = FTdate[1];
					// System.out.println("Result :: " + res);
				} else if (maxDt1.after(dt2)) {
					mENDDate = uF.getDateFormat(dt2 + "", DBDATE, DATE_FORMAT);
					count++;
				} else {
					// System.out.println("Result :: " + res);
					mENDDate = uF.getDateFormat(currDt2 + "", DBDATE, DATE_FORMAT);
					count++;
				}
				// System.out.println("mSTDate :: "+ mSTDate
				// +" === mENDDate :: " + mENDDate);
				if (count <= 1) {
					pst = con
							.prepareStatement("select sum(a1.hrs) billable_hrs, sum(a1.days) billable_days, a1.emp_id from ("
									+ "select sum(ta.billable_hrs) hrs, count(distinct ta.task_date) days, ta.emp_id, ta.activity_id from task_activity ta where ta.emp_id>0 and "
									+ "is_billable = true group by ta.activity_id, ta.emp_id) as a1, activity_info ai where ai.task_id = a1.activity_id " // task_date
																																							// between
																																							// ?
																																							// and
																																							// ?
																																							// and
									+ "and ai.pro_id = ? group by a1.emp_id ");
					// pst =
					// con.prepareStatement("select sum(a1.hrs) actual_hrs, sum(a1.days) actual_days, a1.emp_id from ("
					// +
					// "select sum(ta.actual_hrs) hrs, count(distinct ta.task_date) days, ta.emp_id, ta.activity_id from task_activity ta where "
					// +
					// "task_date between ? and ? group by ta.activity_id, ta.emp_id) as a1, activity_info ai where ai.task_id = a1.activity_id "
					// +
					// "and ai.pro_id = ? group by a1.emp_id "); // and
					// (is_approved = 1 or is_approved = 2)
					// pst.setDate(1, uF.getDateFormat(mSTDate, DATE_FORMAT));
					// pst.setDate(2, uF.getDateFormat(mENDDate, DATE_FORMAT));
					pst.setInt(1, uF.parseToInt(proId));
					// System.out.println("pst======>"+pst);
					rs = pst.executeQuery();
					Map<String, String> hmResourceActualTime = new HashMap<String, String>();
					Map<String, String> hmResourceActualTime30Days = new HashMap<String, String>();
					while (rs.next()) {
						if (hmProjectData != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE") != null
								&& hmProjectData.get("PRO_BILLING_ACTUAL_TYPE").equals("M")) {
							double dblActualDays = 0;
							if (hmProjectData.get("PRO_BILL_DAYS_TYPE") != null && hmProjectData.get("PRO_BILL_DAYS_TYPE").equals("2")
									&& uF.parseToDouble(hmProjectData.get("PRO_HOURS_FOR_BILL_DAY")) > 0) {
								dblActualDays = uF.parseToDouble(rs.getString("billable_hrs")) / uF.parseToDouble(hmProjectData.get("PRO_HOURS_FOR_BILL_DAY"));
							} else {
								dblActualDays = uF.parseToDouble(rs.getString("billable_days"));
							}

							Map<String, String> hmEmpLevelMap = getEmpLevelMap(con);
							Map<String, String> hmEmpWlocation = getEmpWlocationMap(con);
							Map<String, Set<String>> hmWeekEndHalfDates = new HashMap<String, Set<String>>();
							Map<String, Set<String>> hmWeekEnds = getWeekEndDateList(con, mSTDate, mENDDate, CF, uF, hmWeekEndHalfDates, null);
							List<String> alEmpCheckRosterWeektype = new ArrayList<String>();
							Map<String, Set<String>> hmRosterWeekEndDates = new HashMap<String, Set<String>>();
							getEmpRosterWeekOffTypeByDate(con, uF, CF, mSTDate, mENDDate, alEmpCheckRosterWeektype, hmRosterWeekEndDates, hmWeekEnds,
									hmEmpLevelMap, hmEmpWlocation, hmWeekEndHalfDates);

							String strWLocationId = CF.getEmpWlocationId(con, uF, rs.getString("emp_id"));

							Set<String> weeklyOffEndDate = hmWeekEnds.get(strWLocationId);
							if (weeklyOffEndDate == null)
								weeklyOffEndDate = new HashSet<String>();

							Set<String> rosterWeeklyOffSet = hmRosterWeekEndDates.get(rs.getString("emp_id"));
							if (rosterWeeklyOffSet == null)
								rosterWeeklyOffSet = new HashSet<String>();

							Map<String, String> hmHolidaysCnt = new HashMap<String, String>();
							Map<String, String> hmHolidayDates = new HashMap<String, String>();

							if (alEmpCheckRosterWeektype != null && alEmpCheckRosterWeektype.contains(rs.getString("emp_id"))) {
								CF.getHolidayListCount(con, request, mSTDate, mENDDate, CF, hmHolidayDates, hmHolidaysCnt, rosterWeeklyOffSet, true);
							} else {
								CF.getHolidayListCount(con, request, mSTDate, mENDDate, CF, hmHolidayDates, hmHolidaysCnt, weeklyOffEndDate, true);
							}

							String diffInDays = uF.dateDifference(mSTDate, DATE_FORMAT, mENDDate, DATE_FORMAT, CF.getStrTimeZone());

							int nWeekEnd = (alEmpCheckRosterWeektype != null && alEmpCheckRosterWeektype.contains(rs.getString("emp_id"))) ? rosterWeeklyOffSet
									.size() : weeklyOffEndDate.size();
							int nHolidayCnt = uF.parseToInt(hmHolidaysCnt.get(strWLocationId));

							double nWorkDays = (uF.parseToDouble(diffInDays) - nWeekEnd) - nHolidayCnt; // -
																										// nLeaveCnt
							String proCostCalType = getProjectCostCalculationType(con, hmProjectData.get("PRO_ORG_ID"), uF);
							if (uF.parseToInt(proCostCalType) == 1) {
								nWorkDays = 30;
							}

							double actualMonths = 0;
							if (nWorkDays > 0) {
								actualMonths = dblActualDays / nWorkDays;
							}

							hmResourceActualTime30Days.put(rs.getString("emp_id"), (dblActualDays / 30) + "");
							hmResourceActualTime.put(rs.getString("emp_id"), actualMonths + "");
						}
					}
					// System.out.println(proId +
					// "   hmResourceActualTime ===>> " + hmResourceActualTime);
					rs.close();
					pst.close();

					Iterator<String> it = hmResourceActualTime.keySet().iterator();
					double proActualCost = uF.parseToDouble(hmProActualAndBillableCost.get("proBillableCost"));
					double proActualTime = uF.parseToDouble(hmProActualAndBillableCost.get("proBillableTime"));
					while (it.hasNext()) {
						String empId = it.next();
						String actualTime30Days = hmResourceActualTime30Days.get(empId);
						String actualTime = hmResourceActualTime.get(empId);
						double taskResourceActualCost = 0;
						if (hmProjectData != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE") != null
								&& hmProjectData.get("PRO_BILLING_ACTUAL_TYPE").equals("M")) {
							taskResourceActualCost = uF.parseToDouble(actualTime) * uF.parseToDouble(hmProEmpRate.get(empId + "_RATE_PER_MONTH"));
						}

						proActualTime += uF.parseToDouble(actualTime30Days);
						proActualCost += taskResourceActualCost;
						// System.out.println(proId +"  empId ===>> " + empId +
						// "  actualTime ===>>> " + actualTime +
						// " taskResourceActualCost ===>> " +
						// taskResourceActualCost);
					}
					hmProActualAndBillableCost.put("proBillableTime", "" + proActualTime);
					hmProActualAndBillableCost.put("proBillableCost", "" + proActualCost);
				}
			}

			// System.out.println(proId + "   hmProActualAndBillableCost ===>> "
			// + hmProActualAndBillableCost);
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmProActualAndBillableCost;
	}

	public Map<String, Map<String, String>> getActualLeaveDates(Connection con, CommonFunctions CF, UtilityFunctions uF, String strD1, String strD2,
			Map<String, Map<String, String>> hmLeaveTypeDays, boolean isPaid, Map<String, String> hmMonthlyLeaves) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, Map<String, String>> hmLeaveDates = new HashMap<String, Map<String, String>>();
		try {
			StringBuilder sbQuery = new StringBuilder();
			sbQuery.append("select emp_id,_date,leave_no,lt.leave_type_id,lt.leave_type_code from leave_application_register lar, leave_type lt "
					+ "where lar.leave_type_id = lt.leave_type_id and _date between ? and ? and _type = true ");
			if (isPaid) {
				sbQuery.append(" and is_paid = true ");
			}
			sbQuery.append("and is_modify= false and lar.leave_type_id not in (select leave_type_id from leave_type where is_compensatory = true) "
					+ "and lar.leave_id in (select leave_id from emp_leave_entry) order by emp_id");
			pst = con.prepareStatement(sbQuery.toString());
			pst.setDate(1, uF.getDateFormat(strD1, DATE_FORMAT));
			pst.setDate(2, uF.getDateFormat(strD2, DATE_FORMAT));
			// System.out.println("pst ===>> " + pst);
			rs = pst.executeQuery();
			double dblLeaveCount = 0;
			while (rs.next()) {
				String strEmpId = rs.getString("emp_id");
				String strLeaveDate = uF.getDateFormat(rs.getString("_date"), DBDATE, DATE_FORMAT);
				String strLeaveNo = rs.getString("leave_no");
				String strLeaveTypeId = rs.getString("leave_type_id");
				String strLeaveTypeCode = rs.getString("leave_type_code");

				/**
				 * Leave Dates
				 * */
				Map<String, String> hmLeaveDateTemp = (Map<String, String>) hmLeaveDates.get(strEmpId);
				if (hmLeaveDateTemp == null)
					hmLeaveDateTemp = new HashMap<String, String>();
				hmLeaveDateTemp.put(strLeaveDate, strLeaveTypeCode);
				hmLeaveDates.put(strEmpId, hmLeaveDateTemp);

				/**
				 * Leave Type (Half day or Full day)
				 * */

				if (hmLeaveTypeDays != null) {
					Map<String, String> hmTempType = (Map<String, String>) hmLeaveTypeDays.get(strEmpId);
					if (hmTempType == null) {
						hmTempType = new HashMap<String, String>();
						dblLeaveCount = 0;
					} else {
						dblLeaveCount = uF.parseToDouble(hmTempType.get("COUNT"));
					}

					if (uF.parseToDouble(strLeaveNo) == 0.5) {
						hmTempType.put(strLeaveDate, "H");
						dblLeaveCount += 0.5;
						hmTempType.put("COUNT", dblLeaveCount + "");
					} else if (uF.parseToDouble(strLeaveNo) == 1) {
						hmTempType.put(strLeaveDate, "F");
						dblLeaveCount += 1;
						hmTempType.put("COUNT", dblLeaveCount + "");
					}
					hmLeaveTypeDays.put(strEmpId, hmTempType);
					/*if(uF.parseToInt(strEmpId) == 73) {
						 System.out.println("CF/26334-- hmLeaveTypeDays ===>> " + hmLeaveTypeDays.get(73+""));
					 }*/
				}

				/**
				 * Monthly leave type count
				 * */
				if (hmMonthlyLeaves != null) {
					double dblMontlycount = uF.parseToDouble(hmMonthlyLeaves.get(strEmpId + "_" + strLeaveTypeId));
					if (uF.parseToDouble(strLeaveNo) == 0.5) {
						dblMontlycount += 0.5;
					} else if (uF.parseToDouble(strLeaveNo) == 1) {
						dblMontlycount += 1;
					}
					hmMonthlyLeaves.put(strEmpId + "_" + strLeaveTypeId, dblMontlycount + "");
				}
			}
			rs.close();
			pst.close();

			sbQuery = new StringBuilder();
			sbQuery.append("select * from travel_application_register where _date between ? and ? and is_modify= false ");
			if (isPaid) {
				sbQuery.append(" and is_paid = true ");
			}
			sbQuery.append("order by emp_id");
			pst = con.prepareStatement(sbQuery.toString());
			pst.setDate(1, uF.getDateFormat(strD1, DATE_FORMAT));
			pst.setDate(2, uF.getDateFormat(strD2, DATE_FORMAT));
			// System.out.println("pst ===>> " + pst);
			rs = pst.executeQuery();
			dblLeaveCount = 0;
			while (rs.next()) {
				String strEmpId = rs.getString("emp_id");
				String strTravelDate = uF.getDateFormat(rs.getString("_date"), DBDATE, DATE_FORMAT);
				String strTravelNo = rs.getString("travel_no");

				/**
				 * Leave Dates
				 * */
				Map<String, String> hmLeaveDateTemp = (Map<String, String>) hmLeaveDates.get(strEmpId);
				if (hmLeaveDateTemp == null)
					hmLeaveDateTemp = new HashMap<String, String>();
				if (!hmLeaveDateTemp.containsKey(strTravelDate)) {
					hmLeaveDateTemp.put(strTravelDate, "T");
					hmLeaveDates.put(strEmpId, hmLeaveDateTemp);
				}
				/**
				 * Leave Type (Half day or Full day)
				 * */
				if (hmLeaveTypeDays != null) {
					Map<String, String> hmTempType = (Map<String, String>) hmLeaveTypeDays.get(strEmpId);
					if (hmTempType == null) {
						hmTempType = new HashMap<String, String>();
						dblLeaveCount = 0;
					} else {
						dblLeaveCount = uF.parseToDouble(hmTempType.get("COUNT"));
					}

					if (!hmTempType.containsKey(strTravelDate)) {
						if (uF.parseToDouble(strTravelNo) == 0.5) {
							hmTempType.put(strTravelDate, "H");
							dblLeaveCount += 0.5;
							hmTempType.put("COUNT", dblLeaveCount + "");
						} else if (uF.parseToDouble(strTravelNo) == 1) {
							hmTempType.put(strTravelDate, "F");
							dblLeaveCount += 1;
							hmTempType.put("COUNT", dblLeaveCount + "");
						}
						hmLeaveTypeDays.put(strEmpId, hmTempType);
					}
				}

				 
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmLeaveDates;
	}

	public Map<String, Map<String, String>> getActualLeaveDates(Connection con, CommonFunctions CF, UtilityFunctions uF, String strEmpId, String strLeaveId,
			String strD1, String strD2, Map<String, Map<String, String>> hmLeaveTypeDays, boolean isPaid, Map<String, String> hmMonthlyLeaves) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, Map<String, String>> hmLeaveDates = new HashMap<String, Map<String, String>>();
		try {
			StringBuilder sbQuery = new StringBuilder();
			sbQuery.append("select emp_id,_date,leave_no,lt.leave_type_id,lt.leave_type_code from leave_application_register lar, leave_type lt "
					+ "where lar.leave_type_id = lt.leave_type_id and _date between ? and ? and _type = true and lar.emp_id=? and lar.leave_type_id = ?");
			if (isPaid) {
				sbQuery.append(" and is_paid = true ");
			}
			sbQuery.append("and is_modify= false and lar.leave_type_id not in (select leave_type_id from leave_type where is_compensatory = true) "
					+ "and lar.leave_id in (select leave_id from emp_leave_entry) order by emp_id");
			pst = con.prepareStatement(sbQuery.toString());
			pst.setDate(1, uF.getDateFormat(strD1, DATE_FORMAT));
			pst.setDate(2, uF.getDateFormat(strD2, DATE_FORMAT));
			pst.setInt(3, uF.parseToInt(strEmpId));
			pst.setInt(4, uF.parseToInt(strLeaveId));
			rs = pst.executeQuery();
			String strLeaveDate = null;
			String strLeaveNo = null;
			String strLeaveTypeId = null;
			String strLeaveTypeCode = null;
			double dblLeaveCount = 0;
			while (rs.next()) {
				strLeaveDate = uF.getDateFormat(rs.getString("_date"), DBDATE, DATE_FORMAT);
				strLeaveNo = rs.getString("leave_no");
				strLeaveTypeId = rs.getString("leave_type_id");
				strLeaveTypeCode = rs.getString("leave_type_code");

				/**
				 * Leave Dates
				 * */
				Map<String, String> hmLeaveDateTemp = (Map<String, String>) hmLeaveDates.get(strEmpId);
				if (hmLeaveDateTemp == null)
					hmLeaveDateTemp = new HashMap<String, String>();
				hmLeaveDateTemp.put(strLeaveDate, strLeaveTypeCode);
				hmLeaveDates.put(strEmpId, hmLeaveDateTemp);

				/**
				 * Leave Type (Half day or Full day)
				 * */
				if (hmLeaveTypeDays != null) {
					Map<String, String> hmTempType = (Map<String, String>) hmLeaveTypeDays.get(strEmpId);
					if (hmTempType == null) {
						hmTempType = new HashMap<String, String>();
						dblLeaveCount = 0;
					}
					if (uF.parseToDouble(strLeaveNo) == 0.5) {
						hmTempType.put(strLeaveDate, "H");
						dblLeaveCount += 0.5;
						hmTempType.put("COUNT", dblLeaveCount + "");
					} else if (uF.parseToDouble(strLeaveNo) == 1) {
						hmTempType.put(strLeaveDate, "F");
						dblLeaveCount += 1;
						hmTempType.put("COUNT", dblLeaveCount + "");
					}
					hmLeaveTypeDays.put(strEmpId, hmTempType);
				}

				/**
				 * Monthly leave type count
				 * */
				if (hmMonthlyLeaves != null) {
					double dblMontlycount = uF.parseToDouble(hmMonthlyLeaves.get(strEmpId + "_" + strLeaveTypeId));
					if (uF.parseToDouble(strLeaveNo) == 0.5) {
						dblMontlycount += 0.5;
					} else if (uF.parseToDouble(strLeaveNo) == 1) {
						dblMontlycount += 1;
					}
					hmMonthlyLeaves.put(strEmpId + "_" + strLeaveTypeId, dblMontlycount + "");
				}
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmLeaveDates;
	}

	public Map<String, String> getProjectEmpTaskActualWorkedMonthsCostOrRate(Connection con, HttpServletRequest request, CommonFunctions CF, String taskId,
			String resourceId, Map<String, String> hmEmpCost, Map<String, String> hmProjectData) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		UtilityFunctions uF = new UtilityFunctions();
		Map<String, String> hmTaskCostORRateData = new LinkedHashMap<String, String>();
		try {
			// System.out.println("PRO_BILLING_ACTUAL_TYPE==>"+hmProjectData.get("PRO_ACTUAL_BILLING_TYPE"));
			Date dt1 = uF.getDateFormat(hmProjectData.get("PRO_START_DATE"), DATE_FORMAT);
			Date dt2 = uF.getDateFormat(hmProjectData.get("PRO_END_DATE"), DATE_FORMAT);
			Date currDt2 = uF.getCurrentDate(CF.getStrTimeZone());
			if (dt2.after(currDt2)) {
				String currdate = uF.getDateFormat(uF.getCurrentDate(CF.getStrTimeZone()) + "", DBDATE, DATE_FORMAT);
				dt2 = uF.getDateFormat(currdate, DATE_FORMAT);
			}
			int cnt = uF.getMonthsDifference(dt1, dt2);
			String startPeriod = hmProjectData.get("PRO_START_DATE");
			String mSTDate = null;
			String mENDDate = null;
			String res = uF.getCurrentMonthMinMaxDate(startPeriod, DATE_FORMAT);
			int count = 0;
			// System.out.println("startDate==>"+uF.getDateFormat(hmProjectData.get("PRO_START_DATE"),
			// DATE_FORMAT));
			// System.out.println("endDate==>"+uF.getDateFormat(hmProjectData.get("PRO_END_DATE"),
			// DATE_FORMAT));
			for (int b = 0; b <= cnt; b++) {

				if (b > 0) {
					res = uF.getNextMonthMinMaxDate(startPeriod, DATE_FORMAT);
				}

				String[] FTdate = res.split("::::");
				Date minDt1 = uF.getDateFormat(FTdate[0], DATE_FORMAT);
				Date maxDt1 = uF.getDateFormat(FTdate[1], DATE_FORMAT);

				if (minDt1.before(dt1)) {
					mSTDate = hmProjectData.get("PRO_START_DATE");
				} else {
					mSTDate = FTdate[0];
				}

				if (maxDt1.before(currDt2) && maxDt1.before(dt2)) {
					startPeriod = FTdate[0];
					mENDDate = FTdate[1];
					// System.out.println("Result :: " + res);
				} else if (maxDt1.after(dt2)) {
					mENDDate = uF.getDateFormat(dt2 + "", DBDATE, DATE_FORMAT);
					count++;
				} else {

					mENDDate = uF.getDateFormat(currDt2 + "", DBDATE, DATE_FORMAT);
					count++;
				}
				// System.out.println("mSTDate :: "+ mSTDate
				// +" === mENDDate :: " + mENDDate);
				// System.out.println("count==>"+count);
				if (count <= 1) {
					// System.out.println("inside count==>"+count);
					Map<String, String> hmResourcewiseData = new LinkedHashMap<String, String>();

					pst = con.prepareStatement("select sum(billable_hrs) as billable_hrs, count(distinct task_date) as task_date from "
							+ "task_activity where activity_id=? and task_date between ? and ? and emp_id=? and is_approved = 2 and "
							+ "is_billable = true and is_billable_approved = 2"); // and
																					// is_approved
																					// =
																					// 2
					pst.setInt(1, uF.parseToInt(taskId));
					pst.setDate(2, uF.getDateFormat(mSTDate, DATE_FORMAT));
					pst.setDate(3, uF.getDateFormat(mENDDate, DATE_FORMAT));
					pst.setInt(4, uF.parseToInt(resourceId));
					rs = pst.executeQuery();
					while (rs.next()) {
						double totBillableHrs = uF.parseToDouble(hmResourcewiseData.get(resourceId + "_BILLABLE_HRS"));
						totBillableHrs += rs.getDouble("billable_hrs");
						// System.out.println("totBillableHrs==>"+totBillableHrs);
						hmResourcewiseData.put(resourceId + "_BILLABLE_HRS", totBillableHrs + "");
					}
					rs.close();
					pst.close();

					pst = con.prepareStatement("select count(distinct task_date) as days from task_activity where activity_id=? "
							+ "and task_date between ? and ? and emp_id=? and is_approved = 2 and is_billable = true and "
							+ "is_billable_approved = 2 group by activity_id");// and
																				// is_approved
																				// =
																				// 2
					pst.setInt(1, uF.parseToInt(taskId));
					pst.setDate(2, uF.getDateFormat(mSTDate, DATE_FORMAT));
					pst.setDate(3, uF.getDateFormat(mENDDate, DATE_FORMAT));
					pst.setInt(4, uF.parseToInt(resourceId));
					rs = pst.executeQuery();
					// System.out.println("pst is_billable ===> " + pst);
					while (rs.next()) {
						double totBillableDays = uF.parseToDouble(hmResourcewiseData.get(resourceId + "_BILLABLE_DAYS"));
						totBillableDays += rs.getInt("days");
						hmResourcewiseData.put(resourceId + "_BILLABLE_DAYS", totBillableDays + "");
					}
					rs.close();
					pst.close();
					// System.out.println("hmResourcewiseData ==>> " +
					// hmResourcewiseData);

					if (hmProjectData.get("PRO_BILL_DAYS_TYPE") != null && hmProjectData.get("PRO_BILL_DAYS_TYPE").equals("2")
							&& uF.parseToDouble(hmProjectData.get("PRO_HOURS_FOR_BILL_DAY")) > 0) {
						double totBillableDays = uF.parseToDouble(hmResourcewiseData.get(resourceId + "_BILLABLE_HRS"))
								/ uF.parseToDouble(hmProjectData.get("PRO_HOURS_FOR_BILL_DAY"));
						hmResourcewiseData.put(resourceId + "_BILLABLE_DAYS", totBillableDays + "");
					}
					// System.out.println("hmResourcewiseData 111111 ===>> " +
					// hmResourcewiseData);
					// }

					if (hmProjectData.get("PRO_ACTUAL_BILLING_TYPE") != null && hmProjectData.get("PRO_ACTUAL_BILLING_TYPE").equals("M")) {
						System.out.println("inside monthly billing");
						Map<String, String> hmEmpLevelMap = CF.getEmpLevelMap(con);
						Map<String, String> hmEmpWlocation = CF.getEmpWlocationMap(con);
						Map<String, Set<String>> hmWeekEndHalfDates = new HashMap<String, Set<String>>();
						Map<String, Set<String>> hmWeekEnds = CF.getWeekEndDateList(con, mSTDate, mENDDate, CF, uF, hmWeekEndHalfDates, null);
						List<String> alEmpCheckRosterWeektype = new ArrayList<String>();
						Map<String, Set<String>> hmRosterWeekEndDates = new HashMap<String, Set<String>>();
						CF.getEmpRosterWeekOffTypeByDate(con, uF, CF, mSTDate, mENDDate, alEmpCheckRosterWeektype, hmRosterWeekEndDates, hmWeekEnds,
								hmEmpLevelMap, hmEmpWlocation, hmWeekEndHalfDates);

						String strWLocationId = CF.getEmpWlocationId(con, uF, resourceId);

						Set<String> weeklyOffEndDate = hmWeekEnds.get(strWLocationId);
						if (weeklyOffEndDate == null)
							weeklyOffEndDate = new HashSet<String>();

						Set<String> rosterWeeklyOffSet = hmRosterWeekEndDates.get(resourceId);
						if (rosterWeeklyOffSet == null)
							rosterWeeklyOffSet = new HashSet<String>();

						Map<String, String> hmHolidaysCnt = new HashMap<String, String>();
						Map<String, String> hmHolidayDates = new HashMap<String, String>();
						// List<String> empLeaveCountList = new
						// ArrayList<String>();
						// List<String> holidayDateList = new
						// ArrayList<String>();

						if (alEmpCheckRosterWeektype != null && alEmpCheckRosterWeektype.contains(resourceId)) {
							CF.getHolidayListCount(con, request, mSTDate, mENDDate, CF, hmHolidayDates, hmHolidaysCnt, rosterWeeklyOffSet, true);
						} else {
							CF.getHolidayListCount(con, request, mSTDate, mENDDate, CF, hmHolidayDates, hmHolidaysCnt, weeklyOffEndDate, true);
						}

						String diffInDays = uF.dateDifference(mSTDate, DATE_FORMAT, mENDDate, DATE_FORMAT, CF.getStrTimeZone());
						// System.out.println("diffInDays==>"+diffInDays);
						int nWeekEnd = (alEmpCheckRosterWeektype != null && alEmpCheckRosterWeektype.contains(resourceId))
								? rosterWeeklyOffSet.size()
								: weeklyOffEndDate.size();
						int nHolidayCnt = uF.parseToInt(hmHolidaysCnt.get(strWLocationId));
						// System.out.println("nWeekEnd==>"+nWeekEnd);
						// System.out.println("nHolidayCnt==>"+nHolidayCnt);
						// int nLeaveCnt = empLeaveCountList.size();
						double nWorkDays = (uF.parseToDouble(diffInDays) - nWeekEnd) - nHolidayCnt; // -
																									// nLeaveCnt
						// System.out.println("billing workdays==>"+nWorkDays);
						double billableMonths = 0;
						double billMonth = 0;
						double totBillableMonths = 0;
						double totBillMonth = 0;
						// System.out.println("nWorkDays ===>> " + nWorkDays);
						// System.out.println("_BILLABLE_DAYS ===>> " +
						// uF.parseToDouble(hmResourcewiseData.get(resourceList.get(a)+"_BILLABLE_DAYS"))
						// +" -- nWorkDays ===>> " + nWorkDays);
						// System.out.println("_ACTUAL_DAYS ===>> " +
						// uF.parseToDouble(hmResourcewiseData.get(resourceList.get(a)+"_ACTUAL_DAYS")));
						String proCostCalType = CF.getProjectCostCalculationType(con, hmProjectData.get("PRO_ORG_ID"), uF);
						if (uF.parseToInt(proCostCalType) == 1) {
							nWorkDays = 30;
						}
						if (nWorkDays > 0) {
							billableMonths = uF.parseToDouble(hmResourcewiseData.get(resourceId + "_BILLABLE_DAYS")) / nWorkDays;
						}
						billMonth = uF.parseToDouble(hmResourcewiseData.get(resourceId + "_BILLABLE_DAYS")) / 30;

						totBillMonth = uF.parseToDouble(hmTaskCostORRateData.get("BILL_WORKING"));
						totBillMonth += billMonth;

						totBillableMonths = uF.parseToDouble(hmTaskCostORRateData.get("BILLABLE_WORKING"));
						totBillableMonths += billableMonths;

						hmTaskCostORRateData.put("BILLABLE_WORKING", uF.formatIntoTwoDecimalWithOutComma(totBillableMonths));
						hmTaskCostORRateData.put("BILL_WORKING", uF.formatIntoTwoDecimalWithOutComma(totBillMonth));

						// System.out.println("BILLABLE_WORKING==>" +
						// uF.formatIntoTwoDecimalWithOutComma(totBillableMonths));

						double totBillableCost = uF.parseToDouble(hmTaskCostORRateData.get("BILLABLE_COST"));
						double billableCost = billableMonths * uF.parseToDouble(hmEmpCost.get(resourceId));
						totBillableCost += billableCost;
						// System.out.println("hmEmpCost ===>> " +
						// uF.parseToDouble(hmEmpCost.get(resourceList.get(a))));
						// System.out.println("billableCost ===>> " +
						// billableCost);
						hmTaskCostORRateData.put("BILLABLE_COST", uF.formatIntoTwoDecimalWithOutComma(totBillableCost));
					}
				}
			}
			// System.out.println("hmTaskCostORRateData ===>> " +
			// hmTaskCostORRateData);
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmTaskCostORRateData;
	}

	public Map<String, String> getProjectTaskTotalMonthsEmpwise(Connection con, HttpServletRequest request1, CommonFunctions CF, String taskId,
			String resourceId, Map<String, String> hmProjectData) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		UtilityFunctions uF = new UtilityFunctions();
		Map<String, String> hmTaskCostORRateData = new LinkedHashMap<String, String>();
		try {

			Date dt1 = uF.getDateFormat(hmProjectData.get("PRO_START_DATE"), DATE_FORMAT);
			Date dt2 = uF.getDateFormat(hmProjectData.get("PRO_END_DATE"), DATE_FORMAT);
			Date currDt2 = uF.getCurrentDate(CF.getStrTimeZone());
			if (dt2.after(currDt2)) {
				String currdate = uF.getDateFormat(uF.getCurrentDate(CF.getStrTimeZone()) + "", DBDATE, DATE_FORMAT);
				dt2 = uF.getDateFormat(currdate, DATE_FORMAT);
			}
			int cnt = uF.getMonthsDifference(dt1, dt2);
			String startPeriod = hmProjectData.get("PRO_START_DATE");
			String mSTDate = null;
			String mENDDate = null;
			String res = uF.getCurrentMonthMinMaxDate(startPeriod, DATE_FORMAT);
			int count = 0;
			for (int b = 0; b <= cnt; b++) {

				if (b > 0) {
					res = uF.getNextMonthMinMaxDate(startPeriod, DATE_FORMAT);
				}
				String[] FTdate = res.split("::::");
				Date minDt1 = uF.getDateFormat(FTdate[0], DATE_FORMAT);
				Date maxDt1 = uF.getDateFormat(FTdate[1], DATE_FORMAT);
				if (minDt1.before(dt1)) {
					mSTDate = hmProjectData.get("PRO_START_DATE");
				} else {
					mSTDate = FTdate[0];
				}

				if (maxDt1.before(currDt2) && maxDt1.before(dt2)) {
					startPeriod = FTdate[0];
					mENDDate = FTdate[1];
					// System.out.println("Result :: " + res);
				} else if (maxDt1.after(dt2)) {
					mENDDate = uF.getDateFormat(dt2 + "", DBDATE, DATE_FORMAT);
					count++;
				} else {
					// System.out.println("Result :: " + res);
					mENDDate = uF.getDateFormat(currDt2 + "", DBDATE, DATE_FORMAT);
					count++;
				}
				// System.out.println("mSTDate :: "+ mSTDate
				// +" === mENDDate :: " + mENDDate);
				if (count <= 1) {
					Map<String, String> hmResourcewiseData = new LinkedHashMap<String, String>();

					pst = con.prepareStatement("select sum(actual_hrs) as actual_hrs from task_activity where activity_id=? and task_date "
							+ "between ? and ? and emp_id=? "); // and
																// is_approved =
																// 2
					pst.setInt(1, uF.parseToInt(taskId));
					pst.setDate(2, uF.getDateFormat(mSTDate, DATE_FORMAT));
					pst.setDate(3, uF.getDateFormat(mENDDate, DATE_FORMAT));
					pst.setInt(4, uF.parseToInt(resourceId));
					rs = pst.executeQuery();
					while (rs.next()) {
						double totBillableHrs = uF.parseToDouble(hmResourcewiseData.get(resourceId + "_ACTUAL_HRS"));
						totBillableHrs += rs.getDouble("actual_hrs");
						hmResourcewiseData.put(resourceId + "_ACTUAL_HRS", totBillableHrs + "");
					}
					rs.close();
					pst.close();

					pst = con.prepareStatement("select count(distinct task_date) as days from task_activity where activity_id=? "
							+ "and task_date between ? and ? and emp_id=? group by activity_id");// and
																									// is_approved
																									// =
																									// 2
					pst.setInt(1, uF.parseToInt(taskId));
					pst.setDate(2, uF.getDateFormat(mSTDate, DATE_FORMAT));
					pst.setDate(3, uF.getDateFormat(mENDDate, DATE_FORMAT));
					pst.setInt(4, uF.parseToInt(resourceId));
					rs = pst.executeQuery();
					// System.out.println("pst is_billable ===> " + pst);
					while (rs.next()) {
						double totBillableDays = uF.parseToDouble(hmResourcewiseData.get(resourceId + "_ACTUAL_DAYS"));
						totBillableDays += rs.getInt("days");
						hmResourcewiseData.put(resourceId + "_ACTUAL_DAYS", totBillableDays + "");
					}
					rs.close();
					pst.close();
					// System.out.println("hmResourcewiseData ==>> " +
					// hmResourcewiseData);

					if (hmProjectData.get("PRO_BILL_DAYS_TYPE") != null && hmProjectData.get("PRO_BILL_DAYS_TYPE").equals("2")
							&& uF.parseToDouble(hmProjectData.get("PRO_HOURS_FOR_BILL_DAY")) > 0) {
						double totBillableDays = uF.parseToDouble(hmResourcewiseData.get(resourceId + "_ACTUAL_HRS"))
								/ uF.parseToDouble(hmProjectData.get("PRO_HOURS_FOR_BILL_DAY"));
						hmResourcewiseData.put(resourceId + "_ACTUAL_DAYS", totBillableDays + "");
					}
					// System.out.println("hmResourcewiseData 111111 ===>> " +
					// hmResourcewiseData);
					// }
					if (hmProjectData.get("PRO_BILLING_ACTUAL_TYPE") != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE").equals("M")) {

						Map<String, String> hmEmpLevelMap = CF.getEmpLevelMap(con);
						Map<String, String> hmEmpWlocation = CF.getEmpWlocationMap(con);
						Map<String, Set<String>> hmWeekEndHalfDates = new HashMap<String, Set<String>>();
						Map<String, Set<String>> hmWeekEnds = CF.getWeekEndDateList(con, mSTDate, mENDDate, CF, uF, hmWeekEndHalfDates, null);
						List<String> alEmpCheckRosterWeektype = new ArrayList<String>();
						Map<String, Set<String>> hmRosterWeekEndDates = new HashMap<String, Set<String>>();
						CF.getEmpRosterWeekOffTypeByDate(con, uF, CF, mSTDate, mENDDate, alEmpCheckRosterWeektype, hmRosterWeekEndDates, hmWeekEnds,
								hmEmpLevelMap, hmEmpWlocation, hmWeekEndHalfDates);

						String strWLocationId = CF.getEmpWlocationId(con, uF, resourceId);

						Set<String> weeklyOffEndDate = hmWeekEnds.get(strWLocationId);
						if (weeklyOffEndDate == null)
							weeklyOffEndDate = new HashSet<String>();

						Set<String> rosterWeeklyOffSet = hmRosterWeekEndDates.get(resourceId);
						if (rosterWeeklyOffSet == null)
							rosterWeeklyOffSet = new HashSet<String>();

						Map<String, String> hmHolidaysCnt = new HashMap<String, String>();
						Map<String, String> hmHolidayDates = new HashMap<String, String>();

						if (alEmpCheckRosterWeektype != null && alEmpCheckRosterWeektype.contains(resourceId)) {
							CF.getHolidayListCount(con, request1, mSTDate, mENDDate, CF, hmHolidayDates, hmHolidaysCnt, rosterWeeklyOffSet, true);
						} else {
							CF.getHolidayListCount(con, request1, mSTDate, mENDDate, CF, hmHolidayDates, hmHolidaysCnt, weeklyOffEndDate, true);
						}

						String diffInDays = uF.dateDifference(mSTDate, DATE_FORMAT, mENDDate, DATE_FORMAT, CF.getStrTimeZone());

						int nWeekEnd = (alEmpCheckRosterWeektype != null && alEmpCheckRosterWeektype.contains(resourceId))
								? rosterWeeklyOffSet.size()
								: weeklyOffEndDate.size();
						int nHolidayCnt = uF.parseToInt(hmHolidaysCnt.get(strWLocationId));

						// int nLeaveCnt = empLeaveCountList.size();
						double nWorkDays = (uF.parseToDouble(diffInDays) - nWeekEnd) - nHolidayCnt; // -
																									// nLeaveCnt

						double billableMonths = 0;
						double billMonth = 0;
						double totBillableMonths = 0;
						double totBillMonth = 0;
						String proCostCalType = CF.getProjectCostCalculationType(con, hmProjectData.get("PRO_ORG_ID"), uF);
						if (uF.parseToInt(proCostCalType) == 1) {
							nWorkDays = 30;
						}
						// System.out.println("nWorkDays ===>> " + nWorkDays);
						if (nWorkDays > 0) {
							billableMonths = uF.parseToDouble(hmResourcewiseData.get(resourceId + "_ACTUAL_DAYS")) / nWorkDays;
						}
						billMonth = uF.parseToDouble(hmResourcewiseData.get(resourceId + "_ACTUAL_DAYS")) / 30;

						totBillMonth = uF.parseToDouble(hmTaskCostORRateData.get("ACTUAL_WORKING"));
						totBillMonth += billMonth;

						totBillableMonths = uF.parseToDouble(hmTaskCostORRateData.get("ACT_WORKING"));
						totBillableMonths += billableMonths;
						// System.out.println("totActualMonths ===>> " +
						// totActualMonths);
						// System.out.println("totBillableMonths ===>> " +
						// totBillableMonths);

						hmTaskCostORRateData.put("ACT_WORKING", uF.formatIntoTwoDecimalWithOutComma(totBillableMonths));
						hmTaskCostORRateData.put("ACTUAL_WORKING", uF.formatIntoTwoDecimalWithOutComma(totBillMonth));
					}
				}
			}
			// System.out.println("hmTaskCostORRateData ===>> " +
			// hmTaskCostORRateData);
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmTaskCostORRateData;
	}

	public String getProjectTaskTotalDaysOrHoursEmpwise(Connection con, String taskId, String resourceId, Map<String, String> hmProjectDetails) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		UtilityFunctions uF = new UtilityFunctions();
		String totDayOrHrs = null;
		try {

			double totActualHrs = 0;
			double totActualDays = 0;

			pst = con.prepareStatement("select sum(actual_hrs) as actual_hrs from task_activity where activity_id=? and emp_id = ? and "
					+ "task_date between ? and ? ");
			pst.setInt(1, uF.parseToInt(taskId));
			pst.setInt(2, uF.parseToInt(resourceId));
			pst.setDate(3, uF.getDateFormat(hmProjectDetails.get("PRO_START_DATE"), DATE_FORMAT));
			pst.setDate(4, uF.getDateFormat(hmProjectDetails.get("PRO_END_DATE"), DATE_FORMAT));
			rs = pst.executeQuery();
			while (rs.next()) {
				totActualHrs += rs.getDouble("actual_hrs");
			}
			rs.close();
			pst.close();

			pst = con.prepareStatement("select count(distinct task_date) as days from task_activity where activity_id = ? and emp_id = ? and "
					+ "task_date between ? and ?");
			pst.setInt(1, uF.parseToInt(taskId));
			pst.setInt(2, uF.parseToInt(resourceId));
			pst.setDate(3, uF.getDateFormat(hmProjectDetails.get("PRO_START_DATE"), DATE_FORMAT));
			pst.setDate(4, uF.getDateFormat(hmProjectDetails.get("PRO_END_DATE"), DATE_FORMAT));
			rs = pst.executeQuery();
			while (rs.next()) {
				totActualDays += rs.getInt("days");
			}
			rs.close();
			pst.close();

			if (hmProjectDetails.get("PRO_BILL_DAYS_TYPE") != null && hmProjectDetails.get("PRO_BILL_DAYS_TYPE").equals("2")
					&& uF.parseToDouble(hmProjectDetails.get("PRO_HOURS_FOR_BILL_DAY")) > 0) {
				totActualDays = totActualHrs / uF.parseToDouble(hmProjectDetails.get("PRO_HOURS_FOR_BILL_DAY"));
			}

			if (hmProjectDetails.get("PRO_ACTUAL_BILLING_TYPE") != null && hmProjectDetails.get("PRO_ACTUAL_BILLING_TYPE").equals("D")) {
				totDayOrHrs = totActualDays + "";
			} else if (hmProjectDetails.get("PRO_ACTUAL_BILLING_TYPE") != null && hmProjectDetails.get("PRO_ACTUAL_BILLING_TYPE").equals("M")) {

			} 
			//====start parvez on 10-07-2021=====
			else if (hmProjectDetails.get("PRO_BILLING_ACTUAL_TYPE") != null && hmProjectDetails.get("PRO_BILLING_ACTUAL_TYPE").equals("D")) {
				totDayOrHrs = totActualDays + "";
			} 
			//====end parvez on 10-07-2021=====
			else {
				totDayOrHrs = totActualHrs + "";
			}

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return totDayOrHrs;
	}

	public String getProjectCategory(Connection con, UtilityFunctions uF, String alignWith) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		String proCategoryName = null;
		try {
			pst = con.prepareStatement("select project_category from project_category_details where project_category_id = ?");
			pst.setInt(1, uF.parseToInt(alignWith));
			rs = pst.executeQuery();
			while (rs.next()) {
				proCategoryName = rs.getString("project_category");
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return proCategoryName;
	}

	public String getProjectForcedTask(Connection con, String orgId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		String forcedTask = null;
		try {
			pst = con.prepareStatement("select forced_task from task_type_setting where org_id = ?");
			pst.setInt(1, uF.parseToInt(orgId));
			rs = pst.executeQuery();
			while (rs.next()) {
				forcedTask = rs.getString("forced_task");
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return forcedTask;
	}

	public String getProjectIdByTaskId(Connection con, String taskId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		String proId = null;
		try {
			pst = con.prepareStatement("select pro_id from activity_info where task_id=?");
			pst.setInt(1, uF.parseToInt(taskId));
			rs = pst.executeQuery();
			while (rs.next()) {
				proId = rs.getString("pro_id");
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return proId;
	}

	public Map<String, String> getFileIcon() {
		Map<String, String> hmFileIcon = new HashMap<String, String>();
		hmFileIcon.put("3gp", "3gp.png");
		hmFileIcon.put("7z", "7z.png");
		hmFileIcon.put("ae", "ae.png");
		hmFileIcon.put("ai", "ai.png");
		hmFileIcon.put("apk", "apk.png");
		hmFileIcon.put("asf", "asf.png");
		hmFileIcon.put("avi", "avi.png");
		hmFileIcon.put("bak", "bak.png");
		hmFileIcon.put("bmp", "bmp.png");
		hmFileIcon.put("cdr", "cdr.png");
		hmFileIcon.put("css", "css.png");
		hmFileIcon.put("csv", "csv.png");
		hmFileIcon.put("divx", "divx.png");
		hmFileIcon.put("dll", "dll.png");
		hmFileIcon.put("doc", "doc.png");
		hmFileIcon.put("docx", "docx.png");
		hmFileIcon.put("dw", "dw.png");
		hmFileIcon.put("dwg", "dwg.png");
		hmFileIcon.put("eps", "eps.png");
		hmFileIcon.put("exe", "exe.png");
		hmFileIcon.put("flv", "flv.png");
		hmFileIcon.put("fw", "fw.png");
		hmFileIcon.put("gif", "gif.png");
		hmFileIcon.put("gz", "gz.png");
		hmFileIcon.put("html", "html.png");
		hmFileIcon.put("ico", "ico.png");
		hmFileIcon.put("iso", "iso.png");
		hmFileIcon.put("jar", "jar.png");
		hmFileIcon.put("jpg", "jpg.png");
		hmFileIcon.put("jpeg", "jpg.png");
		hmFileIcon.put("js", "js.png");
		hmFileIcon.put("mov", "mov.png");
		hmFileIcon.put("mp3", "mp3.png");
		hmFileIcon.put("mp4", "mp4.png");
		hmFileIcon.put("mpeg", "mpeg.png");
		hmFileIcon.put("pdf", "pdf.png");
		hmFileIcon.put("php", "php.png");
		hmFileIcon.put("png", "png.png");
		hmFileIcon.put("ppt", "ppt.png");
		hmFileIcon.put("ps", "ps.png");
		hmFileIcon.put("psd", "psd.png");
		hmFileIcon.put("rar", "rar.png");
		hmFileIcon.put("svg", "svg.png");
		hmFileIcon.put("swf", "swf.png");
		hmFileIcon.put("sys", "sys.png");
		hmFileIcon.put("tar", "tar.png");
		hmFileIcon.put("tiff", "tiff.png");
		hmFileIcon.put("txt", "txt.png");
		hmFileIcon.put("wav", "wav.png");
		hmFileIcon.put("xls", "xls.png");
		hmFileIcon.put("xlsx", "xlsx.png");
		hmFileIcon.put("xml", "xml.png");
		hmFileIcon.put("zip", "zip.png");

		return hmFileIcon;
	}

	public Map<String, String> getCustomerUsersMap(Connection con) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmUsers = new HashMap<String, String>();

		try {
			pst = con.prepareStatement("SELECT * FROM user_details_customer");
			rs = pst.executeQuery();
			while (rs.next()) {
				hmUsers.put(rs.getString("user_id"), rs.getString("username"));
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmUsers;
	}

	public Map<String, String> getEmpEducations(Connection con) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmEmpEducations = new HashMap<String, String>();

		try {

			pst = con
					.prepareStatement("select eds.edu_id, eds.education_name,ed.emp_id from education_details ed , educational_details eds where ed.education_id = eds.edu_id and ed.emp_id >0 order by ed.emp_id");
			rs = pst.executeQuery();
			Map<String, List<List<String>>> hmEdu = new HashMap<String, List<List<String>>>();
			while (rs.next()) {
				List<List<String>> alList = (List<List<String>>) hmEdu.get(rs.getString("emp_id"));
				if (alList == null)
					alList = new ArrayList<List<String>>();

				List<String> al = new ArrayList<String>();
				al.add(rs.getString("edu_id"));
				al.add(rs.getString("education_name"));

				alList.add(al);

				hmEdu.put(rs.getString("emp_id"), alList);
			}
			rs.close();
			pst.close();

			Iterator<String> it = hmEdu.keySet().iterator();
			while (it.hasNext()) {
				String strEmpId = it.next();
				List<List<String>> alList = (List<List<String>>) hmEdu.get(strEmpId);
				if (alList == null)
					alList = new ArrayList<List<String>>();

				StringBuilder sbEduName = null;
				for (int i = 0; alList != null && i < alList.size(); i++) {
					List<String> al = (List<String>) alList.get(i);
					if (sbEduName == null) {
						sbEduName = new StringBuilder();
						sbEduName.append(al.get(1));
					} else {
						sbEduName.append(", " + al.get(1));
					}
				}

				hmEmpEducations.put(strEmpId, sbEduName != null ? sbEduName.toString() : "");
			}

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmEmpEducations;
	}

	public Map<String, String> getCustomerNameMap(Connection con) {

		Map<String, String> hmCustName = new HashMap<String, String>();

		PreparedStatement pst = null;
		ResultSet rs = null;

		try {
			pst = con
					.prepareStatement("select poc_id,contact_fname, contact_mname, contact_lname from client_poc cp, user_details_customer udc where cp.poc_id = udc.emp_id and status = 'ACTIVE'");
			// System.out.println("pst=====>"+pst);
			rs = pst.executeQuery();

			while (rs.next()) {
				if (rs.getInt("poc_id") < 0) {
					continue;
				}
				hmCustName.put(rs.getString("poc_id"),
						rs.getString("contact_fname") + " " + uF.showData(rs.getString("contact_mname"), "") + " " + rs.getString("contact_lname"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmCustName;
	}

	public Map<String, String> getProjectInformationDisplay(Connection con) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmInfoDisplay = new HashMap<String, String>();

		try {
			pst = con.prepareStatement("SELECT * FROM project_information_display");
			rs = pst.executeQuery();
			while (rs.next()) {
				hmInfoDisplay.put("ONLY_TEAM", rs.getString("only_team"));
				hmInfoDisplay.put("IS_COST", rs.getString("is_cost"));
				hmInfoDisplay.put("IS_RATE", rs.getString("is_rate"));
				// hmInfoDisplay.put("COST_RATE_DISP_USERTYPE",
				// rs.getString("cost_rate_disp_usertype"));
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmInfoDisplay;
	}

	public Map<String, String> getTaskProInfo(Connection con, String taskId, String proId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmTaskProData = new HashMap<String, String>();
		UtilityFunctions uF = new UtilityFunctions();

		try {

			if (taskId != null) {
				pst = con.prepareStatement("select activity_name, parent_task_id from activity_info where task_id = " + uF.parseToInt(taskId) + "");
				rs = pst.executeQuery();
				String strST = "";
				while (rs.next()) {
					if (uF.parseToInt(rs.getString("parent_task_id")) > 0) {
						strST = " [ST]";
					}
					hmTaskProData.put("TASK_NAME", rs.getString("activity_name") + strST);
				}
				rs.close();
				pst.close();
			}

			StringBuilder sbQuery = new StringBuilder();
			if (taskId != null) {
				sbQuery.append("select * from projectmntnc where pro_id = (select pro_id from activity_info where task_id = " + uF.parseToInt(taskId) + ")");
			} else {
				sbQuery.append("select * from projectmntnc where pro_id = " + uF.parseToInt(proId) + " ");
			}
			pst = con.prepareStatement(sbQuery.toString());
			rs = pst.executeQuery();
			String strProId = null;
			while (rs.next()) {
				strProId = rs.getString("pro_id");
				hmTaskProData.put("PRO_NAME", rs.getString("pro_name"));
				hmTaskProData.put("PROJECT_OWNER_ID", rs.getString("project_owner"));
				hmTaskProData.put("PROJECT_SPOC_ID", rs.getString("poc"));
			}
			rs.close();
			pst.close();

			if (uF.parseToInt(strProId) > 0) {

				pst = con.prepareStatement("select * from project_emp_details where pro_id = ? and _isteamlead = true");
				pst.setInt(1, uF.parseToInt(strProId));
				rs = pst.executeQuery();
				StringBuilder sbTL = null;
				while (rs.next()) {
					if (sbTL == null) {
						sbTL = new StringBuilder();
						sbTL.append(getEmpNameMapByEmpId(con, rs.getString("emp_id")));
					} else {
						sbTL.append(", " + getEmpNameMapByEmpId(con, rs.getString("emp_id")));
					}
				}
				rs.close();
				pst.close();
				if (sbTL != null) {
					hmTaskProData.put("TEAM_LEADER", sbTL.toString());
				} else {
					hmTaskProData.put("TEAM_LEADER", "");
				}
			}

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmTaskProData;
	}

	public List<String> getAvailableExtention() {
		List<String> availableExt = new ArrayList<String>();
		availableExt.add("tiff");
		availableExt.add("pdf");
		availableExt.add("ppt");
		availableExt.add("pptx");
		availableExt.add("pps");
		availableExt.add("doc");
		availableExt.add("docx");
		availableExt.add("txt");
		availableExt.add("xls");
		availableExt.add("xlsx");
		// availableExt.add("odt");
		return availableExt;
	}

	public boolean isWorkRig() {
		return isWorkRig;
	}

	public void setWorkRig(boolean isWorkRig) {
		this.isWorkRig = isWorkRig;
	}

	public boolean isTaskRig() {
		return isTaskRig;
	}

	public void setTaskRig(boolean isTaskRig) {
		this.isTaskRig = isTaskRig;
	}

	public Map<String, String> getProDocsNameMap(Connection con) {

		Map<String, String> hmProDocsName = new HashMap<String, String>();
		PreparedStatement pst = null;
		ResultSet rs = null;

		try {
			pst = con.prepareStatement("select * from project_document_details");
			// System.out.println("pst=====>"+pst);
			rs = pst.executeQuery();
			while (rs.next()) {
				hmProDocsName.put(rs.getString("pro_document_id"), rs.getString("document_name"));
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmProDocsName;
	}

	public String getProNamePlusFreqNameById(Connection con, String proFreqId) {
		UtilityFunctions uF = new UtilityFunctions();
		PreparedStatement pst = null;
		ResultSet rs = null;
		String proFreqName = null;
		try {
			pst = con
					.prepareStatement("select pro_freq_name,pro_name from projectmntnc_frequency pf, projectmntnc p where p.pro_id = pf.pro_id and pf.pro_freq_id = ?");
			pst.setInt(1, uF.parseToInt(proFreqId));
			rs = pst.executeQuery();
			while (rs.next()) {
				proFreqName = uF.showData(rs.getString("pro_name"), "-") + " (" + uF.showData(rs.getString("pro_freq_name"), "-") + ")";
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return proFreqName;
	}

	public String getProjectIdByProFreqId(Connection con, String proFreqId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		String proId = null;
		try {
			pst = con.prepareStatement("select pro_id from projectmntnc_frequency where pro_freq_id=?");
			pst.setInt(1, uF.parseToInt(proFreqId));
			rs = pst.executeQuery();
			while (rs.next()) {
				proId = rs.getString("pro_id");
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return proId;
	}

	public String getProjectIdByInvoiceId(Connection con, String invoiceId) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		String proId = null;
		try {
			pst = con.prepareStatement("select pro_id from promntc_invoice_details where promntc_invoice_id=?");
			pst.setInt(1, uF.parseToInt(invoiceId));
			rs = pst.executeQuery();
			while (rs.next()) {
				proId = rs.getString("pro_id");
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return proId;
	}

	public Map<String, String> getProInvoiceNameMap(Connection con) {

		Map<String, String> hmProInvoiceName = new HashMap<String, String>();
		PreparedStatement pst = null;
		ResultSet rs = null;
		try {
			pst = con.prepareStatement("select * from promntc_invoice_details");
			// System.out.println("pst=====>"+pst);
			rs = pst.executeQuery();
			while (rs.next()) {
				hmProInvoiceName.put(rs.getString("promntc_invoice_id"), rs.getString("invoice_code"));
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmProInvoiceName;
	}

	public Map<String, String> getBankAccountDetailsMap(Connection con, UtilityFunctions uF, String branchId) {

		PreparedStatement pst = null;
		ResultSet rs = null;

		Map<String, String> hmBankAccMap = new HashMap<String, String>();
		try {
			pst = con
					.prepareStatement("SELECT bbd.*, bd.bank_name as branch_bank_name, bd.bank_code FROM bank_details bd, branch_details bbd where bbd.bank_id=bd.bank_id and bbd.branch_id = ?");
			pst.setInt(1, uF.parseToInt(branchId));
			rs = pst.executeQuery();
			while (rs.next()) {
				hmBankAccMap.put("ACC_NO", uF.showData(rs.getString("bank_account_no"), ""));
				hmBankAccMap.put("BRANCH_NAME", uF.showData(rs.getString("bank_branch"), ""));
				hmBankAccMap.put("BANK_NAME", uF.showData(rs.getString("branch_bank_name"), ""));
				hmBankAccMap.put("BANK_CODE", uF.showData(rs.getString("bank_code"), ""));
				if (uF.parseToBoolean(rs.getString("is_ifsc"))) {
					hmBankAccMap.put("IFSC_CODE", uF.showData(rs.getString("bank_ifsc_code"), ""));
				}
				if (uF.parseToBoolean(rs.getString("is_swift"))) {
					hmBankAccMap.put("SWIFT_CODE", uF.showData(rs.getString("swift_code"), ""));
				}
				if (uF.parseToBoolean(rs.getString("is_clearing_code"))) {
					hmBankAccMap.put("CLEARING_CODE", uF.showData(rs.getString("bank_clearing_code"), ""));
				}
				hmBankAccMap.put("OTHER_INFO", uF.showData(rs.getString("other_information"), ""));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmBankAccMap;
	}

	public Map<String, String> getCustomerImageMap(Connection con) {

		Map<String, String> hmCustName = new HashMap<String, String>();
		PreparedStatement pst = null;
		ResultSet rs = null;

		try {
			pst = con.prepareStatement("select poc_id,contact_photo from client_poc");
			// System.out.println("pst=====>"+pst);
			rs = pst.executeQuery();

			while (rs.next()) {
				if (rs.getInt("poc_id") < 0) {
					continue;
				}
				hmCustName.put(rs.getString("poc_id"), rs.getString("contact_photo"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmCustName;
	}

	public String getClientIdBySPOCId(Connection con, UtilityFunctions uF, String spocId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		String clientId = null;
		try {
			pst = con.prepareStatement("select client_id from client_poc where poc_id=?");
			pst.setInt(1, uF.parseToInt(spocId));
			// System.out.println("pst=====>"+pst);
			rs = pst.executeQuery();
			while (rs.next()) {
				clientId = rs.getString("client_id");
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return clientId;
	}

	public String getOrgLocationIds(Connection con, UtilityFunctions uF, String orgId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		StringBuilder locationIds = null;
		try {
			pst = con.prepareStatement("select wlocation_id from work_location_info where org_id=?");
			pst.setInt(1, uF.parseToInt(orgId));
			// System.out.println("pst=====>"+pst);
			rs = pst.executeQuery();
			while (rs.next()) {
				if (locationIds == null) {
					locationIds = new StringBuilder();
					locationIds.append(rs.getString("wlocation_id"));
				} else {
					locationIds.append("," + rs.getString("wlocation_id"));
				}
			}
			rs.close();
			pst.close();

			if (locationIds == null) {
				locationIds = new StringBuilder();
			}
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return locationIds.toString();
	}

	public Map<String, String> getProjectBudgetedCost(Connection con, CommonFunctions CF, UtilityFunctions uF, String strProId,
			Map<String, String> hmProjectData, Map<String, String> hmProEmpRate) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmBudgetedCostAndTime = new HashMap<String, String>();
		try {

			double proVariableCost = CF.getProjectVariableCost(con, uF, strProId);

			// pst =
			// con.prepareStatement("select task_id, activity_name, resource_ids, idealtime, parent_task_id from activity_info where "
			// +
			// "task_id not in (select parent_task_id from activity_info where parent_task_id is not null) and (parent_task_id in ("
			// +
			// "select task_id from activity_info) or parent_task_id = 0) and pro_id = ? ");
			pst = con.prepareStatement("select task_id, activity_name, resource_ids, idealtime, parent_task_id from activity_info where "
					+ " parent_task_id = 0 and pro_id = ? ");
			pst.setInt(1, uF.parseToInt(strProId));
//			 System.out.println("pst======>"+pst);
			rs = pst.executeQuery();
			Map<String, Map<String, String>> hmTaskData = new HashMap<String, Map<String, String>>();
			while (rs.next()) {
				Map<String, String> hmInner = new HashMap<String, String>();
				hmInner.put(rs.getString("task_id") + "_IDEAL_TIME", rs.getString("idealtime"));
				hmInner.put(rs.getString("task_id") + "_RESOURCES", rs.getString("resource_ids"));
				hmTaskData.put(rs.getString("task_id"), hmInner);
			}
			rs.close();
			pst.close();

			Iterator<String> it = hmTaskData.keySet().iterator();
			double proBudgetedCost = 0;
			double proBudgetedTime = 0;
			// System.out.println("billType ===>> " + billType);
			while (it.hasNext()) {
				String taskId = it.next();
				Map<String, String> hmInner = hmTaskData.get(taskId);
				List<String> alResources = new ArrayList<String>();
				if (hmInner.get(taskId + "_RESOURCES") != null) {
					alResources = Arrays.asList(hmInner.get(taskId + "_RESOURCES").split(","));
				}
				int taskResourceCnt = 0;
				double taskResourceCost = 0;
				for (int i = 0; alResources != null && !alResources.isEmpty() && i < alResources.size(); i++) {
					if (alResources.get(i) != null && !alResources.get(i).equals("")) {
//						 System.out.println(taskId +"  -- alResources.get(i) ===>> " + alResources.get(i)); //+ " -- billType ===>> " + billType
						if (hmProjectData != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE") != null
								&& hmProjectData.get("PRO_BILLING_ACTUAL_TYPE").equals("H")) {
							taskResourceCost += uF.parseToDouble(hmProEmpRate.get(strProId + "_" + alResources.get(i) + "_PER_HOUR"));
						} else if (hmProjectData != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE") != null
								&& hmProjectData.get("PRO_BILLING_ACTUAL_TYPE").equals("D")) {
							taskResourceCost += uF.parseToDouble(hmProEmpRate.get(strProId + "_" + alResources.get(i) + "_PER_DAY"));
						} else if (hmProjectData != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE") != null
								&& hmProjectData.get("PRO_BILLING_ACTUAL_TYPE").equals("M")) {
							taskResourceCost += uF.parseToDouble(hmProEmpRate.get(strProId + "_" + alResources.get(i) + "_PER_MONTH"));
						}
						taskResourceCnt++;
					}
				}

				double dblTaskIdealTime = 0.0d;
				double dblTaskIdealTime1 = 0.0d;
				if (hmProjectData != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE") != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE").equals("H")) {
					dblTaskIdealTime = uF.parseToDouble(hmInner.get(taskId + "_IDEAL_TIME"));
					dblTaskIdealTime1 = uF.parseToDouble(hmInner.get(taskId + "_IDEAL_TIME"));
					proBudgetedTime += dblTaskIdealTime1;
				} else if (hmProjectData != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE") != null
						&& hmProjectData.get("PRO_BILLING_ACTUAL_TYPE").equals("D")) {
					dblTaskIdealTime1 = (uF.parseToDouble(hmInner.get(taskId + "_IDEAL_TIME")) * 8);
					dblTaskIdealTime = uF.parseToDouble(hmInner.get(taskId + "_IDEAL_TIME"));
					proBudgetedTime += dblTaskIdealTime1;
				} else if (hmProjectData != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE") != null
						&& hmProjectData.get("PRO_BILLING_ACTUAL_TYPE").equals("M")) {
					dblTaskIdealTime1 = (uF.parseToDouble(hmInner.get(taskId + "_IDEAL_TIME")) * 8 * 30);
					dblTaskIdealTime = uF.parseToDouble(hmInner.get(taskId + "_IDEAL_TIME"));
					proBudgetedTime += dblTaskIdealTime1;
				}
				// System.out.println(taskId + "  taskResourceCnt ===>> " +
				// taskResourceCnt + "  taskResourceCost ====>> " +
				// taskResourceCost +" IDEAL_TIME =>>>>> " + dblTaskIdealTime);
				double taskAvgResourceCost = 0;
				if (taskResourceCnt > 0) {
					taskAvgResourceCost = taskResourceCost / taskResourceCnt;
				}
				double taskBudgetedCost = taskAvgResourceCost * dblTaskIdealTime;
				// System.out.println(taskId + "  taskBudgetedCost ===>> " +
				// taskBudgetedCost);
				proBudgetedCost += taskBudgetedCost;

			}
			proBudgetedCost += proVariableCost;
			hmBudgetedCostAndTime.put("proBudgetedCost", proBudgetedCost + "");
			hmBudgetedCostAndTime.put("proBudgetedTime", proBudgetedTime + "");
			System.out.println("proBudgetedCost ===>> " + proBudgetedCost + " -- proBudgetedTime ===>> " + proBudgetedTime);
			// strBudgetedCost = proBudgetedCost+"";

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmBudgetedCostAndTime;
	}
	
	//===optimize by parvez date: 05-03-2022===
	//===start===	
		public Map<String, String> getProjectBudgetedCost1(Connection con, CommonFunctions CF, UtilityFunctions uF, String strProId,
				Map<String, String> hmProjectData, Map<String, String> hmProEmpRate, Map<String, Map<String, String>> hmTaskData, 
				Map<String, String> hmProVaribaleCost) {
			
			PreparedStatement pst = null;
			ResultSet rs = null;
			Map<String, String> hmBudgetedCostAndTime = new HashMap<String, String>();
			try {

				double proVariableCost = uF.parseToDouble(hmProVaribaleCost.get(strProId));
				
				if(hmTaskData != null){
					Iterator<String> it = hmTaskData.keySet().iterator();
					double proBudgetedCost = 0;
					double proBudgetedTime = 0;
					
					while (it.hasNext()) {
						String taskId = it.next();
						Map<String, String> hmInner = hmTaskData.get(taskId);
						List<String> alResources = new ArrayList<String>();
						if (hmInner.get(taskId + "_RESOURCES") != null) {
							alResources = Arrays.asList(hmInner.get(taskId + "_RESOURCES").split(","));
						}
						int taskResourceCnt = 0;
						double taskResourceCost = 0;
						for (int i = 0; alResources != null && !alResources.isEmpty() && i < alResources.size(); i++) {
							if (alResources.get(i) != null && !alResources.get(i).equals("")) {
								
								if (hmProjectData != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE") != null
										&& hmProjectData.get("PRO_BILLING_ACTUAL_TYPE").equals("H")) {
									taskResourceCost += uF.parseToDouble(hmProEmpRate.get(strProId + "_" + alResources.get(i) + "_PER_HOUR"));
								} else if (hmProjectData != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE") != null
										&& hmProjectData.get("PRO_BILLING_ACTUAL_TYPE").equals("D")) {
									taskResourceCost += uF.parseToDouble(hmProEmpRate.get(strProId + "_" + alResources.get(i) + "_PER_DAY"));
								} else if (hmProjectData != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE") != null
										&& hmProjectData.get("PRO_BILLING_ACTUAL_TYPE").equals("M")) {
									taskResourceCost += uF.parseToDouble(hmProEmpRate.get(strProId + "_" + alResources.get(i) + "_PER_MONTH"));
								}
								taskResourceCnt++;
							}
						}

						double dblTaskIdealTime = 0.0d;
						double dblTaskIdealTime1 = 0.0d;
						if (hmProjectData != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE") != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE").equals("H")) {
							dblTaskIdealTime = uF.parseToDouble(hmInner.get(taskId + "_IDEAL_TIME"));
							dblTaskIdealTime1 = uF.parseToDouble(hmInner.get(taskId + "_IDEAL_TIME"));
							proBudgetedTime += dblTaskIdealTime1;
						} else if (hmProjectData != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE") != null
								&& hmProjectData.get("PRO_BILLING_ACTUAL_TYPE").equals("D")) {
							dblTaskIdealTime1 = (uF.parseToDouble(hmInner.get(taskId + "_IDEAL_TIME")) * 8);
							dblTaskIdealTime = uF.parseToDouble(hmInner.get(taskId + "_IDEAL_TIME"));
							proBudgetedTime += dblTaskIdealTime1;
						} else if (hmProjectData != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE") != null
								&& hmProjectData.get("PRO_BILLING_ACTUAL_TYPE").equals("M")) {
							dblTaskIdealTime1 = (uF.parseToDouble(hmInner.get(taskId + "_IDEAL_TIME")) * 8 * 30);
							dblTaskIdealTime = uF.parseToDouble(hmInner.get(taskId + "_IDEAL_TIME"));
							proBudgetedTime += dblTaskIdealTime1;
						}
						
						double taskAvgResourceCost = 0;
						if (taskResourceCnt > 0) {
							taskAvgResourceCost = taskResourceCost / taskResourceCnt;
						}
						double taskBudgetedCost = taskAvgResourceCost * dblTaskIdealTime;
						
						proBudgetedCost += taskBudgetedCost;

					}
					proBudgetedCost += proVariableCost;
					hmBudgetedCostAndTime.put("proBudgetedCost", proBudgetedCost + "");
					hmBudgetedCostAndTime.put("proBudgetedTime", proBudgetedTime + "");
					
				}
				

			} catch (Exception e) {
				e.printStackTrace();
			} finally {
				if (rs != null) {
					try {
						rs.close();
					} catch (SQLException e1) {
						e1.printStackTrace();
					}
				}
				if (pst != null) {
					try {
						pst.close();
					} catch (SQLException e1) {
						e1.printStackTrace();
					}
				}
			}
			return hmBudgetedCostAndTime;
		}
	//===end===

	public Map<String, String> getProjectBillableCostAndTime(Connection con, CommonFunctions CF, UtilityFunctions uF, String strProId,
			Map<String, String> hmProjectData, boolean isSubmit, boolean isApprove, Map<String, String> hmProEmpRate, Map<String, String> hmEmpLevelMap,
			Map<String, String> hmEmpWlocation) { // , Map<String, String>
													// hmOrgCalType
		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmProBillableCost = new HashMap<String, String>();
		try {

			StringBuilder sbQuery = new StringBuilder();
			sbQuery.append("select sum(a1.hrs) billable_hrs, sum(a1.days) billable_days, a1.emp_id from (select sum(ta.billable_hrs) hrs, "
					+ "count(distinct ta.task_date) days, ta.emp_id, ta.activity_id from task_activity ta where task_date between ? and ? and "
					+ "is_billable = true ");
			if (isSubmit && isApprove) {
				sbQuery.append(" and (is_approved = 1 or is_approved = 2)");
			} else if (isSubmit) {
				sbQuery.append(" and is_approved = 1 ");
			} else if (isApprove) {
				sbQuery.append(" and is_approved = 2 ");
			}
			sbQuery.append(" group by ta.activity_id, ta.emp_id) as a1, activity_info ai where ai.task_id = a1.activity_id and ai.pro_id = ? "
					+ "group by a1.emp_id");
			pst = con.prepareStatement(sbQuery.toString()); // and (is_approved
															// = 1 or
															// is_approved = 2)
			pst.setDate(1, uF.getDateFormat(hmProjectData.get("PRO_START_DATE"), DATE_FORMAT));
			pst.setDate(2, uF.getDateFormat(hmProjectData.get("PRO_END_DATE"), DATE_FORMAT));
			pst.setInt(3, uF.parseToInt(strProId));
			// System.out.println("pst======>"+pst);
			rs = pst.executeQuery();
			Map<String, String> hmResourceBillableTime = new HashMap<String, String>();
			while (rs.next()) {
				if (hmProjectData != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE") != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE").equals("H")) {
					hmResourceBillableTime.put(rs.getString("emp_id"), rs.getString("billable_hrs"));
				} else if (hmProjectData != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE") != null
						&& hmProjectData.get("PRO_BILLING_ACTUAL_TYPE").equals("D")) {
					if (hmProjectData.get("PRO_BILL_DAYS_TYPE") != null && hmProjectData.get("PRO_BILL_DAYS_TYPE").equals("2")
							&& uF.parseToDouble(hmProjectData.get("PRO_HOURS_FOR_BILL_DAY")) > 0) {
						double dblActualDays = uF.parseToDouble(rs.getString("billable_hrs")) / uF.parseToDouble(hmProjectData.get("PRO_HOURS_FOR_BILL_DAY"));
						hmResourceBillableTime.put(rs.getString("emp_id"), dblActualDays + "");
					} else {
						hmResourceBillableTime.put(rs.getString("emp_id"), rs.getString("billable_days"));
					}
				} else if (hmProjectData != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE") != null
						&& hmProjectData.get("PRO_BILLING_ACTUAL_TYPE").equals("M")) {/*
																					 * double
																					 * dblBillableDays
																					 * =
																					 * 0
																					 * ;
																					 * if
																					 * (
																					 * hmProjectData
																					 * .
																					 * get
																					 * (
																					 * "PRO_BILL_DAYS_TYPE"
																					 * )
																					 * !=
																					 * null
																					 * &&
																					 * hmProjectData
																					 * .
																					 * get
																					 * (
																					 * "PRO_BILL_DAYS_TYPE"
																					 * )
																					 * .
																					 * equals
																					 * (
																					 * "2"
																					 * )
																					 * &&
																					 * uF
																					 * .
																					 * parseToDouble
																					 * (
																					 * hmProjectData
																					 * .
																					 * get
																					 * (
																					 * "PRO_HOURS_FOR_BILL_DAY"
																					 * )
																					 * )
																					 * >
																					 * 0
																					 * )
																					 * {
																					 * dblBillableDays
																					 * =
																					 * uF
																					 * .
																					 * parseToDouble
																					 * (
																					 * rs
																					 * .
																					 * getString
																					 * (
																					 * "billable_hrs"
																					 * )
																					 * )
																					 * /
																					 * uF
																					 * .
																					 * parseToDouble
																					 * (
																					 * hmProjectData
																					 * .
																					 * get
																					 * (
																					 * "PRO_HOURS_FOR_BILL_DAY"
																					 * )
																					 * )
																					 * ;
																					 * }
																					 * else
																					 * {
																					 * dblBillableDays
																					 * =
																					 * uF
																					 * .
																					 * parseToDouble
																					 * (
																					 * rs
																					 * .
																					 * getString
																					 * (
																					 * "billable_days"
																					 * )
																					 * )
																					 * ;
																					 * }
																					 * 
																					 * Map
																					 * <
																					 * String
																					 * ,
																					 * Set
																					 * <
																					 * String
																					 * >>
																					 * hmWeekEndHalfDates
																					 * =
																					 * new
																					 * HashMap
																					 * <
																					 * String
																					 * ,
																					 * Set
																					 * <
																					 * String
																					 * >>
																					 * (
																					 * )
																					 * ;
																					 * Map
																					 * <
																					 * String
																					 * ,
																					 * Set
																					 * <
																					 * String
																					 * >>
																					 * hmWeekEnds
																					 * =
																					 * CF
																					 * .
																					 * getWeekEndDateList
																					 * (
																					 * con
																					 * ,
																					 * hmProjectData
																					 * .
																					 * get
																					 * (
																					 * "PRO_START_DATE"
																					 * )
																					 * ,
																					 * hmProjectData
																					 * .
																					 * get
																					 * (
																					 * "PRO_END_DATE"
																					 * )
																					 * ,
																					 * CF
																					 * ,
																					 * uF
																					 * ,
																					 * hmWeekEndHalfDates
																					 * ,
																					 * null
																					 * )
																					 * ;
																					 * List
																					 * <
																					 * String
																					 * >
																					 * alEmpCheckRosterWeektype
																					 * =
																					 * new
																					 * ArrayList
																					 * <
																					 * String
																					 * >
																					 * (
																					 * )
																					 * ;
																					 * Map
																					 * <
																					 * String
																					 * ,
																					 * Set
																					 * <
																					 * String
																					 * >>
																					 * hmRosterWeekEndDates
																					 * =
																					 * new
																					 * HashMap
																					 * <
																					 * String
																					 * ,
																					 * Set
																					 * <
																					 * String
																					 * >>
																					 * (
																					 * )
																					 * ;
																					 * CF
																					 * .
																					 * getEmpRosterWeekOffTypeByDate
																					 * (
																					 * con
																					 * ,
																					 * uF
																					 * ,
																					 * CF
																					 * ,
																					 * hmProjectData
																					 * .
																					 * get
																					 * (
																					 * "PRO_START_DATE"
																					 * )
																					 * ,
																					 * hmProjectData
																					 * .
																					 * get
																					 * (
																					 * "PRO_END_DATE"
																					 * )
																					 * ,
																					 * alEmpCheckRosterWeektype
																					 * ,
																					 * hmRosterWeekEndDates
																					 * ,
																					 * hmWeekEnds
																					 * ,
																					 * hmEmpLevelMap
																					 * ,
																					 * hmEmpWlocation
																					 * ,
																					 * hmWeekEndHalfDates
																					 * )
																					 * ;
																					 * 
																					 * 
																					 * String
																					 * strWLocationId
																					 * =
																					 * CF
																					 * .
																					 * getEmpWlocationId
																					 * (
																					 * con
																					 * ,
																					 * uF
																					 * ,
																					 * rs
																					 * .
																					 * getString
																					 * (
																					 * "emp_id"
																					 * )
																					 * )
																					 * ;
																					 * 
																					 * Set
																					 * <
																					 * String
																					 * >
																					 * weeklyOffEndDate
																					 * =
																					 * hmWeekEnds
																					 * .
																					 * get
																					 * (
																					 * strWLocationId
																					 * )
																					 * ;
																					 * if
																					 * (
																					 * weeklyOffEndDate
																					 * ==
																					 * null
																					 * )
																					 * weeklyOffEndDate
																					 * =
																					 * new
																					 * HashSet
																					 * <
																					 * String
																					 * >
																					 * (
																					 * )
																					 * ;
																					 * 
																					 * Set
																					 * <
																					 * String
																					 * >
																					 * rosterWeeklyOffSet
																					 * =
																					 * hmRosterWeekEndDates
																					 * .
																					 * get
																					 * (
																					 * rs
																					 * .
																					 * getString
																					 * (
																					 * "emp_id"
																					 * )
																					 * )
																					 * ;
																					 * if
																					 * (
																					 * rosterWeeklyOffSet
																					 * ==
																					 * null
																					 * )
																					 * rosterWeeklyOffSet
																					 * =
																					 * new
																					 * HashSet
																					 * <
																					 * String
																					 * >
																					 * (
																					 * )
																					 * ;
																					 * 
																					 * Map
																					 * <
																					 * String
																					 * ,
																					 * String
																					 * >
																					 * hmHolidaysCnt
																					 * =
																					 * new
																					 * HashMap
																					 * <
																					 * String
																					 * ,
																					 * String
																					 * >
																					 * (
																					 * )
																					 * ;
																					 * Map
																					 * <
																					 * String
																					 * ,
																					 * String
																					 * >
																					 * hmHolidayDates
																					 * =
																					 * new
																					 * HashMap
																					 * <
																					 * String
																					 * ,
																					 * String
																					 * >
																					 * (
																					 * )
																					 * ;
																					 * 
																					 * if
																					 * (
																					 * alEmpCheckRosterWeektype
																					 * !=
																					 * null
																					 * &&
																					 * alEmpCheckRosterWeektype
																					 * .
																					 * contains
																					 * (
																					 * rs
																					 * .
																					 * getString
																					 * (
																					 * "emp_id"
																					 * )
																					 * )
																					 * )
																					 * {
																					 * CF
																					 * .
																					 * getHolidayListCount
																					 * (
																					 * con
																					 * ,
																					 * hmProjectData
																					 * .
																					 * get
																					 * (
																					 * "PRO_START_DATE"
																					 * )
																					 * ,
																					 * hmProjectData
																					 * .
																					 * get
																					 * (
																					 * "PRO_END_DATE"
																					 * )
																					 * ,
																					 * CF
																					 * ,
																					 * hmHolidayDates
																					 * ,
																					 * hmHolidaysCnt
																					 * ,
																					 * rosterWeeklyOffSet
																					 * ,
																					 * true
																					 * )
																					 * ;
																					 * }
																					 * else
																					 * {
																					 * CF
																					 * .
																					 * getHolidayListCount
																					 * (
																					 * con
																					 * ,
																					 * hmProjectData
																					 * .
																					 * get
																					 * (
																					 * "PRO_START_DATE"
																					 * )
																					 * ,
																					 * hmProjectData
																					 * .
																					 * get
																					 * (
																					 * "PRO_END_DATE"
																					 * )
																					 * ,
																					 * CF
																					 * ,
																					 * hmHolidayDates
																					 * ,
																					 * hmHolidaysCnt
																					 * ,
																					 * weeklyOffEndDate
																					 * ,
																					 * true
																					 * )
																					 * ;
																					 * }
																					 * 
																					 * String
																					 * diffInDays
																					 * =
																					 * uF
																					 * .
																					 * dateDifference
																					 * (
																					 * hmProjectData
																					 * .
																					 * get
																					 * (
																					 * "PRO_START_DATE"
																					 * )
																					 * ,
																					 * DATE_FORMAT
																					 * ,
																					 * hmProjectData
																					 * .
																					 * get
																					 * (
																					 * "PRO_END_DATE"
																					 * )
																					 * ,
																					 * DATE_FORMAT
																					 * ,
																					 * CF
																					 * .
																					 * getStrTimeZone
																					 * (
																					 * )
																					 * )
																					 * ;
																					 * 
																					 * int
																					 * nWeekEnd
																					 * =
																					 * (
																					 * alEmpCheckRosterWeektype
																					 * !=
																					 * null
																					 * &&
																					 * alEmpCheckRosterWeektype
																					 * .
																					 * contains
																					 * (
																					 * rs
																					 * .
																					 * getString
																					 * (
																					 * "emp_id"
																					 * )
																					 * )
																					 * )
																					 * ?
																					 * rosterWeeklyOffSet
																					 * .
																					 * size
																					 * (
																					 * )
																					 * :
																					 * weeklyOffEndDate
																					 * .
																					 * size
																					 * (
																					 * )
																					 * ;
																					 * int
																					 * nHolidayCnt
																					 * =
																					 * uF
																					 * .
																					 * parseToInt
																					 * (
																					 * hmHolidaysCnt
																					 * .
																					 * get
																					 * (
																					 * strWLocationId
																					 * )
																					 * )
																					 * ;
																					 * 
																					 * double
																					 * nWorkDays
																					 * =
																					 * (
																					 * uF
																					 * .
																					 * parseToDouble
																					 * (
																					 * diffInDays
																					 * )
																					 * -
																					 * nWeekEnd
																					 * )
																					 * -
																					 * nHolidayCnt
																					 * ;
																					 * /
																					 * /
																					 * -
																					 * nLeaveCnt
																					 * 
																					 * double
																					 * actualMonths
																					 * =
																					 * 0
																					 * ;
																					 * if
																					 * (
																					 * nWorkDays
																					 * >
																					 * 0
																					 * )
																					 * {
																					 * actualMonths
																					 * =
																					 * dblBillableDays
																					 * /
																					 * nWorkDays
																					 * ;
																					 * }
																					 * hmResourceBillableTime
																					 * .
																					 * put
																					 * (
																					 * rs
																					 * .
																					 * getString
																					 * (
																					 * "emp_id"
																					 * )
																					 * ,
																					 * actualMonths
																					 * +
																					 * ""
																					 * )
																					 * ;
																					 */
				}
			}
			// System.out.println(proId + "   hmResourceBillableTime ===>> " +
			// hmResourceBillableTime);
			rs.close();
			pst.close();

			Iterator<String> it = hmResourceBillableTime.keySet().iterator();
			double proBillableTime = 0;
			double proBillableCost = 0;
			while (it.hasNext()) {
				String empId = it.next();
				String billableTime = hmResourceBillableTime.get(empId);
				double taskResourceBillableCost = 0;
				if (hmProjectData != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE") != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE").equals("H")) {
					taskResourceBillableCost = uF.parseToDouble(billableTime) * uF.parseToDouble(hmProEmpRate.get(strProId + "_" + empId + "_RATE_PER_HOUR"));
				} else if (hmProjectData != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE") != null
						&& hmProjectData.get("PRO_BILLING_ACTUAL_TYPE").equals("D")) {
					taskResourceBillableCost = uF.parseToDouble(billableTime) * uF.parseToDouble(hmProEmpRate.get(strProId + "_" + empId + "_RATE_PER_DAY"));
				} else if (hmProjectData != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE") != null
						&& hmProjectData.get("PRO_BILLING_ACTUAL_TYPE").equals("M")) {
					taskResourceBillableCost = uF.parseToDouble(billableTime) * uF.parseToDouble(hmProEmpRate.get(strProId + "_" + empId + "_RATE_PER_MONTH"));
				}

				proBillableTime += uF.parseToDouble(billableTime);
				proBillableCost += taskResourceBillableCost;
				// System.out.println(proId +"  empId ===>> " + empId +
				// "  billableTime ===>>> " + billableTime +
				// " taskResourceBillableCost ===>> " +
				// taskResourceBillableCost);
			}

			hmProBillableCost.put("proBillableTime", "" + proBillableTime);
			hmProBillableCost.put("proBillableCost", "" + proBillableCost);
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmProBillableCost;
	}

	public Map<String, String> getProjectActualCostAndTime(Connection con, CommonFunctions CF, UtilityFunctions uF, String strProId,
			Map<String, String> hmProjectData, boolean isSubmit, boolean isApprove, Map<String, String> hmProEmpRate, Map<String, String> hmEmpLevelMap,
			Map<String, String> hmEmpWlocation) { // , Map<String, String>
													// hmOrgCalType
		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmProActualAndBillableCost = new HashMap<String, String>();
		try {

			StringBuilder sbQuery = new StringBuilder();
			sbQuery.append("select sum(a1.hrs) actual_hrs, sum(a1.days) actual_days, a1.emp_id from (select sum(ta.actual_hrs) hrs, "
					+ "count(distinct ta.task_date) days, ta.emp_id, ta.activity_id from task_activity ta where ta.emp_id>0 "); // task_date
																																// between
																																// ?
																																// and
																																// ?
			if (isSubmit && isApprove) {
				sbQuery.append(" and (is_approved = 1 or is_approved = 2)");
			} else if (isSubmit) {
				sbQuery.append(" and is_approved = 1 ");
			} else if (isApprove) {
				sbQuery.append(" and is_approved = 2 ");
			}
			sbQuery.append(" group by ta.activity_id, ta.emp_id) as a1, activity_info ai where ai.task_id = a1.activity_id and ai.pro_id = ? "
					+ "group by a1.emp_id");

			pst = con.prepareStatement(sbQuery.toString()); // and (is_approved
															// = 1 or
															// is_approved = 2)
															// pst.setDate(1,
															// uF.getDateFormat(hmProjectData.get("PRO_START_DATE"),
															// DATE_FORMAT));
			// pst.setDate(2,
			// uF.getDateFormat(hmProjectData.get("PRO_END_DATE"),
			// DATE_FORMAT));
			pst.setInt(1, uF.parseToInt(strProId));
			// System.out.println("pst======> " + pst);
			rs = pst.executeQuery();
			Map<String, String> hmResourceActualTime = new HashMap<String, String>();
			Map<String, String> hmResourceActualTime1 = new HashMap<String, String>();
			while (rs.next()) {
				hmResourceActualTime1.put(rs.getString("emp_id"), rs.getString("actual_hrs"));
				if (hmProjectData != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE") != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE").equals("H")) {
					hmResourceActualTime.put(rs.getString("emp_id"), rs.getString("actual_hrs"));
				} else if (hmProjectData != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE") != null
						&& hmProjectData.get("PRO_BILLING_ACTUAL_TYPE").equals("D")) {
					if (hmProjectData.get("PRO_BILL_DAYS_TYPE") != null && hmProjectData.get("PRO_BILL_DAYS_TYPE").equals("2")
							&& uF.parseToDouble(hmProjectData.get("PRO_HOURS_FOR_BILL_DAY")) > 0) {
						double dblActualDays = uF.parseToDouble(rs.getString("actual_hrs")) / uF.parseToDouble(hmProjectData.get("PRO_HOURS_FOR_BILL_DAY"));
						hmResourceActualTime.put(rs.getString("emp_id"), dblActualDays + "");
					} else {
						hmResourceActualTime.put(rs.getString("emp_id"), rs.getString("actual_days"));
					}
				}
			}
			// System.out.println(strProId + "   hmResourceActualTime1 ===>> " +
			// hmResourceActualTime1);
			rs.close();
			pst.close();

			Iterator<String> it = hmResourceActualTime1.keySet().iterator();
			double proActualCost = 0;
			double proActualTime = 0;
			while (it.hasNext()) {
				String empId = it.next();
				String actualTime = hmResourceActualTime.get(empId);
				String actualTime1 = hmResourceActualTime1.get(empId);
				double taskResourceActualCost = 0;
				if (hmProjectData != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE") != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE").equals("H")) {
					taskResourceActualCost = uF.parseToDouble(actualTime) * uF.parseToDouble(hmProEmpRate.get(strProId + "_" + empId + "_PER_HOUR"));
				} else if (hmProjectData != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE") != null
						&& hmProjectData.get("PRO_BILLING_ACTUAL_TYPE").equals("D")) {
					taskResourceActualCost = uF.parseToDouble(actualTime) * uF.parseToDouble(hmProEmpRate.get(strProId + "_" + empId + "_PER_DAY"));
				} else if (hmProjectData != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE") != null
						&& hmProjectData.get("PRO_BILLING_ACTUAL_TYPE").equals("M")) {
					taskResourceActualCost = uF.parseToDouble(actualTime) * uF.parseToDouble(hmProEmpRate.get(strProId + "_" + empId + "_PER_MONTH"));
				}

				proActualTime += uF.parseToDouble(actualTime1);
				proActualCost += taskResourceActualCost;
				// System.out.println(strProId + "  empId ===>> " + empId +
				// "  actualTime ===>>> " + actualTime +
				// " taskResourceActualCost ===>> " + taskResourceActualCost);
			}

			hmProActualAndBillableCost.put("proActualTime", "" + proActualTime);
			hmProActualAndBillableCost.put("proActualCost", "" + proActualCost);
			// System.out.println(proId + "   hmProActualAndBillableCost ===>> "
			// + hmProActualAndBillableCost);
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmProActualAndBillableCost;
	}
	
	
	//===optimize by parvez date: 05-03-2022===
	//===start===
		public Map<String, String> getProjectActualCostAndTime1(Connection con, CommonFunctions CF, UtilityFunctions uF, String strProId,
				Map<String, String> hmProjectData, Map<String, String> hmProEmpRate, Map<String, String> hmEmpLevelMap,
				Map<String, String> hmEmpWlocation,List<String> alEmpIds, Map<String, String> hmEmpTaskDetails) { 
			PreparedStatement pst = null;
			ResultSet rs = null;
			Map<String, String> hmProActualAndBillableCost = new HashMap<String, String>();
			try {

				
				Map<String, String> hmResourceActualTime = new HashMap<String, String>();
				Map<String, String> hmResourceActualTime1 = new HashMap<String, String>();
				for (int c=0; alEmpIds!=null && !alEmpIds.isEmpty() && c<alEmpIds.size(); c++) {
					hmResourceActualTime1.put(alEmpIds.get(c), hmEmpTaskDetails.get(strProId+alEmpIds.get(c)+"_HRS"));
					if (hmProjectData != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE") != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE").equals("H")) {
						hmResourceActualTime.put(alEmpIds.get(c), hmEmpTaskDetails.get(strProId+alEmpIds.get(c)+"_HRS"));
					} else if (hmProjectData != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE") != null
							&& hmProjectData.get("PRO_BILLING_ACTUAL_TYPE").equals("D")) {
						if (hmProjectData.get("PRO_BILL_DAYS_TYPE") != null && hmProjectData.get("PRO_BILL_DAYS_TYPE").equals("2")
								&& uF.parseToDouble(hmProjectData.get("PRO_HOURS_FOR_BILL_DAY")) > 0) {
							double dblActualDays = uF.parseToDouble(hmEmpTaskDetails.get(strProId+alEmpIds.get(c)+"_HRS")) / uF.parseToDouble(hmProjectData.get("PRO_HOURS_FOR_BILL_DAY"));
							hmResourceActualTime.put(alEmpIds.get(c), dblActualDays + "");
						} else {
							hmResourceActualTime.put(alEmpIds.get(c), hmEmpTaskDetails.get(strProId+alEmpIds.get(c)+"_DAYS"));
						}
					}
				}

				Iterator<String> it = hmResourceActualTime1.keySet().iterator();
				double proActualCost = 0;
				double proActualTime = 0;
				while (it.hasNext()) {
					String empId = it.next();
					String actualTime = hmResourceActualTime.get(empId);
					String actualTime1 = hmResourceActualTime1.get(empId);
					double taskResourceActualCost = 0;
					if (hmProjectData != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE") != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE").equals("H")) {
						taskResourceActualCost = uF.parseToDouble(actualTime) * uF.parseToDouble(hmProEmpRate.get(strProId + "_" + empId + "_PER_HOUR"));
					} else if (hmProjectData != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE") != null
							&& hmProjectData.get("PRO_BILLING_ACTUAL_TYPE").equals("D")) {
						taskResourceActualCost = uF.parseToDouble(actualTime) * uF.parseToDouble(hmProEmpRate.get(strProId + "_" + empId + "_PER_DAY"));
					} else if (hmProjectData != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE") != null
							&& hmProjectData.get("PRO_BILLING_ACTUAL_TYPE").equals("M")) {
						taskResourceActualCost = uF.parseToDouble(actualTime) * uF.parseToDouble(hmProEmpRate.get(strProId + "_" + empId + "_PER_MONTH"));
					}

					proActualTime += uF.parseToDouble(actualTime1);
					proActualCost += taskResourceActualCost;
					
				}

				hmProActualAndBillableCost.put("proActualTime", "" + proActualTime);
				hmProActualAndBillableCost.put("proActualCost", "" + proActualCost);
				
			} catch (Exception e) {
				e.printStackTrace();
			} finally {
				if (rs != null) {
					try {
						rs.close();
					} catch (SQLException e1) {
						e1.printStackTrace();
					}
				}
				if (pst != null) {
					try {
						pst.close();
					} catch (SQLException e1) {
						e1.printStackTrace();
					}
				}
			}
			return hmProActualAndBillableCost;
		}
	//===end===

	public Map<String, String> getMonthlyProjectBillableCostAndTime(Connection con, HttpServletRequest request, CommonFunctions CF, UtilityFunctions uF,
			String strProId, Map<String, String> hmProjectData, Map<String, String> hmProEmpRate, Map<String, String> hmEmpLevelMap,
			Map<String, String> hmEmpWlocation, Map<String, String> hmOrgCalType) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmProActualAndBillableCost = new HashMap<String, String>();
		try {

			Date dt1 = uF.getDateFormat(hmProjectData.get("PRO_START_DATE"), DATE_FORMAT);
			Date dt2 = uF.getDateFormat(hmProjectData.get("PRO_END_DATE"), DATE_FORMAT);
			Date currDt2 = uF.getCurrentDate(CF.getStrTimeZone());
			if (dt2 != null && dt2.after(currDt2)) {
				String currdate = uF.getDateFormat(uF.getCurrentDate(CF.getStrTimeZone()) + "", DBDATE, DATE_FORMAT);
				dt2 = uF.getDateFormat(currdate, DATE_FORMAT);
			}
			int cnt = uF.getMonthsDifference(dt1, dt2);
			String startPeriod = hmProjectData.get("PRO_START_DATE");
			String mSTDate = null;
			String mENDDate = null;
			String res = uF.getCurrentMonthMinMaxDate(startPeriod, DATE_FORMAT);
			int count = 0;
			for (int b = 0; b <= cnt; b++) {

				if (b > 0) {
					res = uF.getNextMonthMinMaxDate(startPeriod, DATE_FORMAT);
				}
				String[] FTdate = res.split("::::");
				Date minDt1 = uF.getDateFormat(FTdate[0], DATE_FORMAT);
				Date maxDt1 = uF.getDateFormat(FTdate[1], DATE_FORMAT);
				if (minDt1.before(dt1)) {
					mSTDate = hmProjectData.get("PRO_START_DATE");
				} else {
					mSTDate = FTdate[0];
				}

				if (maxDt1.before(currDt2)) {
					startPeriod = FTdate[0];
					mENDDate = FTdate[1];
					// System.out.println("Result :: " + res);
				} else if (maxDt1.after(dt2)) {
					mENDDate = uF.getDateFormat(dt2 + "", DBDATE, DATE_FORMAT);
					count++;
				} else {
					// System.out.println("Result :: " + res);
					mENDDate = uF.getDateFormat(currDt2 + "", DBDATE, DATE_FORMAT);
					count++;
				}
				// System.out.println("mSTDate :: "+ mSTDate
				// +" === mENDDate :: " + mENDDate);
				if (count <= 1) {

					pst = con
							.prepareStatement("select sum(a1.hrs) billable_hrs, sum(a1.days) billable_days, a1.emp_id from ("
									+ "select sum(ta.billable_hrs) hrs, count(distinct ta.task_date) days, ta.emp_id, ta.activity_id from task_activity ta where "
									+ "task_date between ? and ? and is_billable = true group by ta.activity_id, ta.emp_id) as a1, activity_info ai where ai.task_id = a1.activity_id "
									+ "and ai.pro_id = ? group by a1.emp_id ");
					// pst =
					// con.prepareStatement("select sum(a1.hrs) actual_hrs, sum(a1.days) actual_days, a1.emp_id from ("
					// +
					// "select sum(ta.actual_hrs) hrs, count(distinct ta.task_date) days, ta.emp_id, ta.activity_id from task_activity ta where "
					// +
					// "task_date between ? and ? group by ta.activity_id, ta.emp_id) as a1, activity_info ai where ai.task_id = a1.activity_id "
					// +
					// "and ai.pro_id = ? group by a1.emp_id "); // and
					// (is_approved = 1 or is_approved = 2)
					pst.setDate(1, uF.getDateFormat(mSTDate, DATE_FORMAT));
					pst.setDate(2, uF.getDateFormat(mENDDate, DATE_FORMAT));
					pst.setInt(3, uF.parseToInt(strProId));
					// System.out.println("pst======>"+pst);
					rs = pst.executeQuery();
					Map<String, String> hmResourceActualTime = new HashMap<String, String>();
					// Map<String, String> hmResourceActualTime30Days = new
					// HashMap<String,String>();
					while (rs.next()) {
						if (hmProjectData != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE") != null
								&& hmProjectData.get("PRO_BILLING_ACTUAL_TYPE").equals("M")) {
							double dblActualDays = 0;
							if (hmProjectData.get("PRO_BILL_DAYS_TYPE") != null && hmProjectData.get("PRO_BILL_DAYS_TYPE").equals("2")
									&& uF.parseToDouble(hmProjectData.get("PRO_HOURS_FOR_BILL_DAY")) > 0) {
								dblActualDays = uF.parseToDouble(rs.getString("billable_hrs")) / uF.parseToDouble(hmProjectData.get("PRO_HOURS_FOR_BILL_DAY"));
							} else {
								dblActualDays = uF.parseToDouble(rs.getString("billable_days"));
							}

							Map<String, Set<String>> hmWeekEndHalfDates = new HashMap<String, Set<String>>();
							Map<String, Set<String>> hmWeekEnds = CF.getWeekEndDateList(con, mSTDate, mENDDate, CF, uF, hmWeekEndHalfDates, null);
							List<String> alEmpCheckRosterWeektype = new ArrayList<String>();
							Map<String, Set<String>> hmRosterWeekEndDates = new HashMap<String, Set<String>>();
							CF.getEmpRosterWeekOffTypeByDate(con, uF, CF, mSTDate, mENDDate, alEmpCheckRosterWeektype, hmRosterWeekEndDates, hmWeekEnds,
									hmEmpLevelMap, hmEmpWlocation, hmWeekEndHalfDates);

							String strWLocationId = CF.getEmpWlocationId(con, uF, rs.getString("emp_id"));

							Set<String> weeklyOffEndDate = hmWeekEnds.get(strWLocationId);
							if (weeklyOffEndDate == null)
								weeklyOffEndDate = new HashSet<String>();

							Set<String> rosterWeeklyOffSet = hmRosterWeekEndDates.get(rs.getString("emp_id"));
							if (rosterWeeklyOffSet == null)
								rosterWeeklyOffSet = new HashSet<String>();

							Map<String, String> hmHolidaysCnt = new HashMap<String, String>();
							Map<String, String> hmHolidayDates = new HashMap<String, String>();

							if (alEmpCheckRosterWeektype != null && alEmpCheckRosterWeektype.contains(rs.getString("emp_id"))) {
								CF.getHolidayListCount(con, request, mSTDate, mENDDate, CF, hmHolidayDates, hmHolidaysCnt, rosterWeeklyOffSet, true);
							} else {
								CF.getHolidayListCount(con, request, mSTDate, mENDDate, CF, hmHolidayDates, hmHolidaysCnt, weeklyOffEndDate, true);
							}

							String diffInDays = uF.dateDifference(mSTDate, DATE_FORMAT, mENDDate, DATE_FORMAT, CF.getStrTimeZone());

							int nWeekEnd = (alEmpCheckRosterWeektype != null && alEmpCheckRosterWeektype.contains(rs.getString("emp_id"))) ? rosterWeeklyOffSet
									.size() : weeklyOffEndDate.size();
							int nHolidayCnt = uF.parseToInt(hmHolidaysCnt.get(strWLocationId));

							double nWorkDays = (uF.parseToDouble(diffInDays) - nWeekEnd) - nHolidayCnt; // -
																										// nLeaveCnt
							// String proCostCalType =
							// getProjectCostCalculationType(con,
							// hmProjectData.get("PRO_ORG_ID"), uF);
							String proCostCalType = uF.showData(hmOrgCalType.get(hmProjectData.get("PRO_ORG_ID")), "");
							if (uF.parseToInt(proCostCalType) == 1) {
								nWorkDays = 30;
							} else if (uF.parseToInt(proCostCalType) == 3) {
								nWorkDays = uF.parseToDouble(hmOrgCalType.get(hmProjectData.get("PRO_ORG_ID") + "_DAYS"));
							}

							double actualMonths = 0;
							if (nWorkDays > 0) {
								actualMonths = dblActualDays / nWorkDays;
							}

							// hmResourceActualTime30Days.put(rs.getString("emp_id"),
							// (dblActualDays/30)+"");
							hmResourceActualTime.put(rs.getString("emp_id"), actualMonths + "");
						}
					}
					// System.out.println(proId +
					// "   hmResourceActualTime ===>> " + hmResourceActualTime);
					rs.close();
					pst.close();

					Iterator<String> it = hmResourceActualTime.keySet().iterator();
					double proActualCost = uF.parseToDouble(hmProActualAndBillableCost.get("proBillableCost"));
					double proActualTime = uF.parseToDouble(hmProActualAndBillableCost.get("proBillableTime"));
					while (it.hasNext()) {
						String empId = it.next();
						// String actualTime30Days =
						// hmResourceActualTime30Days.get(empId);
						String actualTime = hmResourceActualTime.get(empId);
						double taskResourceActualCost = 0;
						if (hmProjectData != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE") != null
								&& hmProjectData.get("PRO_BILLING_ACTUAL_TYPE").equals("M")) {
							taskResourceActualCost = uF.parseToDouble(actualTime)
									* uF.parseToDouble(hmProEmpRate.get(strProId + "_" + empId + "_RATE_PER_MONTH"));
						}

						proActualTime += uF.parseToDouble(actualTime); // actualTime30Days
						proActualCost += taskResourceActualCost;
						// System.out.println(proId +"  empId ===>> " + empId +
						// "  actualTime ===>>> " + actualTime +
						// " taskResourceActualCost ===>> " +
						// taskResourceActualCost);
					}
					hmProActualAndBillableCost.put("proBillableTime", "" + proActualTime);
					hmProActualAndBillableCost.put("proBillableCost", "" + proActualCost);
				}
			}

			// System.out.println(proId + "   hmProActualAndBillableCost ===>> "
			// + hmProActualAndBillableCost);
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmProActualAndBillableCost;
	}

	public Map<String, String> getMonthlyProjectActualCostAndTime(Connection con, HttpServletRequest request, CommonFunctions CF, UtilityFunctions uF,
			String strProId, Map<String, String> hmProjectData, Map<String, String> hmProEmpRate, Map<String, String> hmEmpLevelMap,
			Map<String, String> hmEmpWlocation, Map<String, String> hmOrgCalType) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmProActualAndBillableCost = new HashMap<String, String>();
		try {

			Date dt1 = uF.getDateFormat(hmProjectData.get("PRO_START_DATE"), DATE_FORMAT);
			Date dt2 = uF.getDateFormat(hmProjectData.get("PRO_END_DATE"), DATE_FORMAT);
			Date currDt2 = uF.getCurrentDate(CF.getStrTimeZone());
			if (dt2 != null && dt2.after(currDt2)) {
				String currdate = uF.getDateFormat(uF.getCurrentDate(CF.getStrTimeZone()) + "", DBDATE, DATE_FORMAT);
				dt2 = uF.getDateFormat(currdate, DATE_FORMAT);
			}
			int cnt = uF.getMonthsDifference(dt1, dt2);
			String startPeriod = hmProjectData.get("PRO_START_DATE");
			String mSTDate = null;
			String mENDDate = null;
			String res = uF.getCurrentMonthMinMaxDate(startPeriod, DATE_FORMAT);
			int count = 0;

			for (int b = 0; b <= cnt; b++) {

				if (b > 0) {
					res = uF.getNextMonthMinMaxDate(startPeriod, DATE_FORMAT);
				}
				String[] FTdate = res.split("::::");
				Date minDt1 = uF.getDateFormat(FTdate[0], DATE_FORMAT);
				Date maxDt1 = uF.getDateFormat(FTdate[1], DATE_FORMAT);
				if (minDt1.before(dt1)) {
					mSTDate = hmProjectData.get("PRO_START_DATE");
				} else {
					mSTDate = FTdate[0];
				}

				if (maxDt1.before(currDt2)) {
					startPeriod = FTdate[0];
					mENDDate = FTdate[1];
					// System.out.println("Result :: " + res);
				} else if (maxDt1.after(dt2)) {
					mENDDate = uF.getDateFormat(dt2 + "", DBDATE, DATE_FORMAT);
					count++;
				} else {
					// System.out.println("Result :: " + res);
					mENDDate = uF.getDateFormat(currDt2 + "", DBDATE, DATE_FORMAT);
					count++;
				}
				// System.out.println("mSTDate :: "+ mSTDate
				// +" === mENDDate :: " + mENDDate);
				if (count <= 1) {

					pst = con.prepareStatement("select sum(a1.hrs) actual_hrs, sum(a1.days) actual_days, a1.emp_id from ("
							+ "select sum(ta.actual_hrs) hrs, count(distinct ta.task_date) days, ta.emp_id, ta.activity_id from task_activity ta "
							+ " group by ta.activity_id, ta.emp_id) as a1, activity_info ai where ai.task_id = a1.activity_id "
							+ "and ai.pro_id = ? group by a1.emp_id "); // task_date
																		// between
																		// ? and
																		// ? //
																		// and
																		// (is_approved
																		// = 1
																		// or
																		// is_approved
																		// = 2)
					// pst.setDate(1, uF.getDateFormat(mSTDate, DATE_FORMAT));
					// pst.setDate(2, uF.getDateFormat(mENDDate, DATE_FORMAT));
					pst.setInt(1, uF.parseToInt(strProId));
					// System.out.println("pst======>"+pst);
					rs = pst.executeQuery();
					Map<String, String> hmResourceActualTime = new HashMap<String, String>();
					// Map<String, String> hmResourceActualTime30Days = new
					// HashMap<String,String>();
					while (rs.next()) {
						if (hmProjectData != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE") != null
								&& hmProjectData.get("PRO_BILLING_ACTUAL_TYPE").equals("M")) {
							double dblActualDays = 0;
							if (hmProjectData.get("PRO_BILL_DAYS_TYPE") != null && hmProjectData.get("PRO_BILL_DAYS_TYPE").equals("2")
									&& uF.parseToDouble(hmProjectData.get("PRO_HOURS_FOR_BILL_DAY")) > 0) {
								dblActualDays = uF.parseToDouble(rs.getString("actual_hrs")) / uF.parseToDouble(hmProjectData.get("PRO_HOURS_FOR_BILL_DAY"));
							} else {
								dblActualDays = uF.parseToDouble(rs.getString("actual_days"));
							}

							Map<String, Set<String>> hmWeekEndHalfDates = new HashMap<String, Set<String>>();
							Map<String, Set<String>> hmWeekEnds = CF.getWeekEndDateList(con, mSTDate, mENDDate, CF, uF, hmWeekEndHalfDates, null);
							List<String> alEmpCheckRosterWeektype = new ArrayList<String>();
							Map<String, Set<String>> hmRosterWeekEndDates = new HashMap<String, Set<String>>();
							CF.getEmpRosterWeekOffTypeByDate(con, uF, CF, mSTDate, mENDDate, alEmpCheckRosterWeektype, hmRosterWeekEndDates, hmWeekEnds,
									hmEmpLevelMap, hmEmpWlocation, hmWeekEndHalfDates);

							String strWLocationId = CF.getEmpWlocationId(con, uF, rs.getString("emp_id"));

							Set<String> weeklyOffEndDate = hmWeekEnds.get(strWLocationId);
							if (weeklyOffEndDate == null)
								weeklyOffEndDate = new HashSet<String>();

							Set<String> rosterWeeklyOffSet = hmRosterWeekEndDates.get(rs.getString("emp_id"));
							if (rosterWeeklyOffSet == null)
								rosterWeeklyOffSet = new HashSet<String>();

							Map<String, String> hmHolidaysCnt = new HashMap<String, String>();
							Map<String, String> hmHolidayDates = new HashMap<String, String>();

							if (alEmpCheckRosterWeektype != null && alEmpCheckRosterWeektype.contains(rs.getString("emp_id"))) {
								CF.getHolidayListCount(con, request, mSTDate, mENDDate, CF, hmHolidayDates, hmHolidaysCnt, rosterWeeklyOffSet, true);
							} else {
								CF.getHolidayListCount(con, request, mSTDate, mENDDate, CF, hmHolidayDates, hmHolidaysCnt, weeklyOffEndDate, true);
							}

							String diffInDays = uF.dateDifference(mSTDate, DATE_FORMAT, mENDDate, DATE_FORMAT, CF.getStrTimeZone());

							int nWeekEnd = (alEmpCheckRosterWeektype != null && alEmpCheckRosterWeektype.contains(rs.getString("emp_id"))) ? rosterWeeklyOffSet
									.size() : weeklyOffEndDate.size();
							int nHolidayCnt = uF.parseToInt(hmHolidaysCnt.get(strWLocationId));

							double nWorkDays = (uF.parseToDouble(diffInDays) - nWeekEnd) - nHolidayCnt; // -
																										// nLeaveCnt
							// String proCostCalType =
							// getProjectCostCalculationType(con,
							// hmProjectData.get("PRO_ORG_ID"), uF);
							String proCostCalType = uF.showData(hmOrgCalType.get(hmProjectData.get("PRO_ORG_ID")), "");
							if (uF.parseToInt(proCostCalType) == 1) {
								nWorkDays = 30;
							} else if (uF.parseToInt(proCostCalType) == 3) {
								nWorkDays = uF.parseToDouble(hmOrgCalType.get(hmProjectData.get("PRO_ORG_ID") + "_DAYS"));
							}

							double actualMonths = 0;
							if (nWorkDays > 0) {
								actualMonths = dblActualDays / nWorkDays;
							}

							// hmResourceActualTime30Days.put(rs.getString("emp_id"),
							// (dblActualDays/30)+"");
							hmResourceActualTime.put(rs.getString("emp_id"), actualMonths + "");
						}
					}
					// System.out.println(proId +
					// "   hmResourceActualTime ===>> " + hmResourceActualTime);
					rs.close();
					pst.close();

					Iterator<String> it = hmResourceActualTime.keySet().iterator();
					double proActualCost = uF.parseToDouble(hmProActualAndBillableCost.get("proActualCost"));
					double proActualTime = uF.parseToDouble(hmProActualAndBillableCost.get("proActualTime"));
					while (it.hasNext()) {
						String empId = it.next();
						// String actualTime30Days =
						// hmResourceActualTime30Days.get(empId);
						String actualTime = hmResourceActualTime.get(empId);
						double taskResourceActualCost = 0;
						if (hmProjectData != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE") != null
								&& hmProjectData.get("PRO_BILLING_ACTUAL_TYPE").equals("M")) {
							taskResourceActualCost = uF.parseToDouble(actualTime) * uF.parseToDouble(hmProEmpRate.get(strProId + "_" + empId + "_PER_MONTH"));
						}

						proActualTime += uF.parseToDouble(actualTime); // actualTime30Days
						proActualCost += taskResourceActualCost;
						// System.out.println(proId +"  empId ===>> " + empId +
						// "  actualTime ===>>> " + actualTime +
						// " taskResourceActualCost ===>> " +
						// taskResourceActualCost);
					}
					hmProActualAndBillableCost.put("proActualTime", "" + proActualTime);
					hmProActualAndBillableCost.put("proActualCost", "" + proActualCost);
				}
			}

			// System.out.println(proId + "   hmProActualAndBillableCost ===>> "
			// + hmProActualAndBillableCost);
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmProActualAndBillableCost;
	}
	
	//===optimize by parvez date: 05-03-2022===
	//===start===	
		public Map<String, String> getMonthlyProjectActualCostAndTime1(Connection con, HttpServletRequest request, CommonFunctions CF, UtilityFunctions uF,
				String strProId, Map<String, String> hmProjectData, Map<String, String> hmProEmpRate, Map<String, String> hmEmpLevelMap,
				Map<String, String> hmEmpWlocation, Map<String, String> hmOrgCalType, List<String> alEmpIds, Map<String, String> hmEmpTaskDetails) {
			
			PreparedStatement pst = null;
			ResultSet rs = null;
			Map<String, String> hmProActualAndBillableCost = new HashMap<String, String>();
			try {

				Date dt1 = uF.getDateFormat(hmProjectData.get("PRO_START_DATE"), DATE_FORMAT);
				Date dt2 = uF.getDateFormat(hmProjectData.get("PRO_END_DATE"), DATE_FORMAT);
				Date currDt2 = uF.getCurrentDate(CF.getStrTimeZone());
				if (dt2 != null && dt2.after(currDt2)) {
					String currdate = uF.getDateFormat(uF.getCurrentDate(CF.getStrTimeZone()) + "", DBDATE, DATE_FORMAT);
					dt2 = uF.getDateFormat(currdate, DATE_FORMAT);
				}
				int cnt = uF.getMonthsDifference(dt1, dt2);
				String startPeriod = hmProjectData.get("PRO_START_DATE");
				String mSTDate = null;
				String mENDDate = null;
				String res = uF.getCurrentMonthMinMaxDate(startPeriod, DATE_FORMAT);
				int count = 0;

				for (int b = 0; b <= cnt; b++) {

					if (b > 0) {
						res = uF.getNextMonthMinMaxDate(startPeriod, DATE_FORMAT);
					}
					String[] FTdate = res.split("::::");
					Date minDt1 = uF.getDateFormat(FTdate[0], DATE_FORMAT);
					Date maxDt1 = uF.getDateFormat(FTdate[1], DATE_FORMAT);
					if (minDt1.before(dt1)) {
						mSTDate = hmProjectData.get("PRO_START_DATE");
					} else {
						mSTDate = FTdate[0];
					}

					if (maxDt1.before(currDt2)) {
						startPeriod = FTdate[0];
						mENDDate = FTdate[1];
						
					} else if (maxDt1.after(dt2)) {
						mENDDate = uF.getDateFormat(dt2 + "", DBDATE, DATE_FORMAT);
						count++;
					} else {
						
						mENDDate = uF.getDateFormat(currDt2 + "", DBDATE, DATE_FORMAT);
						count++;
					}
					
					if (count <= 1) {

						Map<String, String> hmResourceActualTime = new HashMap<String, String>();
						
						for(int c=0; alEmpIds!=null && !alEmpIds.isEmpty() && c<alEmpIds.size(); c++) {
							if (hmProjectData != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE") != null
									&& hmProjectData.get("PRO_BILLING_ACTUAL_TYPE").equals("M")) {
								double dblActualDays = 0;
								if (hmProjectData.get("PRO_BILL_DAYS_TYPE") != null && hmProjectData.get("PRO_BILL_DAYS_TYPE").equals("2")
										&& uF.parseToDouble(hmProjectData.get("PRO_HOURS_FOR_BILL_DAY")) > 0) {
									dblActualDays = uF.parseToDouble(hmEmpTaskDetails.get(strProId+alEmpIds.get(c)+"_HRS")) / uF.parseToDouble(hmProjectData.get("PRO_HOURS_FOR_BILL_DAY"));
								} else {
									dblActualDays = uF.parseToDouble(hmEmpTaskDetails.get(strProId+alEmpIds.get(c)+"_DAYS"));
								}

								Map<String, Set<String>> hmWeekEndHalfDates = new HashMap<String, Set<String>>();
								Map<String, Set<String>> hmWeekEnds = CF.getWeekEndDateList(con, mSTDate, mENDDate, CF, uF, hmWeekEndHalfDates, null);
								List<String> alEmpCheckRosterWeektype = new ArrayList<String>();
								Map<String, Set<String>> hmRosterWeekEndDates = new HashMap<String, Set<String>>();
								CF.getEmpRosterWeekOffTypeByDate(con, uF, CF, mSTDate, mENDDate, alEmpCheckRosterWeektype, hmRosterWeekEndDates, hmWeekEnds,
										hmEmpLevelMap, hmEmpWlocation, hmWeekEndHalfDates);

								String strWLocationId = CF.getEmpWlocationId(con, uF, alEmpIds.get(c));

								Set<String> weeklyOffEndDate = hmWeekEnds.get(strWLocationId);
								if (weeklyOffEndDate == null)
									weeklyOffEndDate = new HashSet<String>();

								Set<String> rosterWeeklyOffSet = hmRosterWeekEndDates.get(alEmpIds.get(c));
								if (rosterWeeklyOffSet == null)
									rosterWeeklyOffSet = new HashSet<String>();

								Map<String, String> hmHolidaysCnt = new HashMap<String, String>();
								Map<String, String> hmHolidayDates = new HashMap<String, String>();

								if (alEmpCheckRosterWeektype != null && alEmpCheckRosterWeektype.contains(alEmpIds.get(c))) {
									CF.getHolidayListCount(con, request, mSTDate, mENDDate, CF, hmHolidayDates, hmHolidaysCnt, rosterWeeklyOffSet, true);
								} else {
									CF.getHolidayListCount(con, request, mSTDate, mENDDate, CF, hmHolidayDates, hmHolidaysCnt, weeklyOffEndDate, true);
								}

								String diffInDays = uF.dateDifference(mSTDate, DATE_FORMAT, mENDDate, DATE_FORMAT, CF.getStrTimeZone());

								int nWeekEnd = (alEmpCheckRosterWeektype != null && alEmpCheckRosterWeektype.contains(alEmpIds.get(c))) ? rosterWeeklyOffSet
										.size() : weeklyOffEndDate.size();
								int nHolidayCnt = uF.parseToInt(hmHolidaysCnt.get(strWLocationId));

								double nWorkDays = (uF.parseToDouble(diffInDays) - nWeekEnd) - nHolidayCnt; // -
																											// nLeaveCnt
								
								String proCostCalType = uF.showData(hmOrgCalType.get(hmProjectData.get("PRO_ORG_ID")), "");
								if (uF.parseToInt(proCostCalType) == 1) {
									nWorkDays = 30;
								} else if (uF.parseToInt(proCostCalType) == 3) {
									nWorkDays = uF.parseToDouble(hmOrgCalType.get(hmProjectData.get("PRO_ORG_ID") + "_DAYS"));
								}

								double actualMonths = 0;
								if (nWorkDays > 0) {
									actualMonths = dblActualDays / nWorkDays;
								}

								
								hmResourceActualTime.put(alEmpIds.get(c), actualMonths + "");
							}
						}
						

						Iterator<String> it = hmResourceActualTime.keySet().iterator();
						double proActualCost = uF.parseToDouble(hmProActualAndBillableCost.get("proActualCost"));
						double proActualTime = uF.parseToDouble(hmProActualAndBillableCost.get("proActualTime"));
						while (it.hasNext()) {
							String empId = it.next();
							
							String actualTime = hmResourceActualTime.get(empId);
							double taskResourceActualCost = 0;
							if (hmProjectData != null && hmProjectData.get("PRO_BILLING_ACTUAL_TYPE") != null
									&& hmProjectData.get("PRO_BILLING_ACTUAL_TYPE").equals("M")) {
								taskResourceActualCost = uF.parseToDouble(actualTime) * uF.parseToDouble(hmProEmpRate.get(strProId + "_" + empId + "_PER_MONTH"));
							}

							proActualTime += uF.parseToDouble(actualTime); // actualTime30Days
							proActualCost += taskResourceActualCost;
							
						}
						hmProActualAndBillableCost.put("proActualTime", "" + proActualTime);
						hmProActualAndBillableCost.put("proActualCost", "" + proActualCost);
					}
				}

				
			} catch (Exception e) {
				e.printStackTrace();
			} finally {
				if (rs != null) {
					try {
						rs.close();
					} catch (SQLException e1) {
						e1.printStackTrace();
					}
				}
				if (pst != null) {
					try {
						pst.close();
					} catch (SQLException e1) {
						e1.printStackTrace();
					}
				}
			}
			return hmProActualAndBillableCost;
		}
	//===end===

	public void getCommonFunctionsDetails(CommonFunctions CF, HttpServletRequest request) {

		Connection con = null;
		PreparedStatement pst = null;
		Database db = new Database();
		db.setRequest(request);
		ResultSet rs = null;
		UtilityFunctions uF = new UtilityFunctions();

		try {
			con = db.makeConnection(con);
			pst = con.prepareStatement(selectSettings);
			rs = pst.executeQuery();

			while (rs.next()) {
				if (rs.getString("options").equalsIgnoreCase(O_TIME_ZONE)) {
				} else if (rs.getString("options").equalsIgnoreCase(O_SHORT_CURR)) {
					CF.setStrCURRENCY_SHORT(rs.getString("value"));
				} else if (rs.getString("options").equalsIgnoreCase(O_LONG_CURR)) {
					CF.setStrCURRENCY_FULL(rs.getString("value"));
				} else if (rs.getString("options").equalsIgnoreCase(O_DATE_FORMAT)) {
					CF.setStrReportDateFormat(rs.getString("value"));
				} else if (rs.getString("options").equalsIgnoreCase(O_TIME_FORMAT)) {
					CF.setStrReportTimeFormat(rs.getString("value"));
				} else if (rs.getString("options").equalsIgnoreCase(O_DAY_FORMAT)) {
					CF.setStrReportDayFormat(rs.getString("value"));
				} else if (rs.getString("options").equalsIgnoreCase(O_PAYCYCLE_DURATION)) {
					CF.setStrPaycycleDuration(rs.getString("value"));
				} else if (rs.getString("options").equalsIgnoreCase(O_DISPLAY_PAYCYCLE)) {
					CF.setStrDisplayPayCycle(rs.getString("value"));
				}
				// else
				// if(rs.getString("options").equalsIgnoreCase(O_FINANCIAL_YEAR_START)){
				// CF.setStrFinancialYearFrom(rs.getString("value"));
				// }else
				// if(rs.getString("options").equalsIgnoreCase(O_FINANCIAL_YEAR_END)){
				// CF.setStrFinancialYearTo(rs.getString("value"));
				// }
				else if (rs.getString("options").equalsIgnoreCase(O_ORG_LOGO)) {
					CF.setStrOrgLogo(rs.getString("value"));
				} else if (rs.getString("options").equalsIgnoreCase(O_ORG_FULL_NAME)) {
					CF.setStrOrgName(rs.getString("value"));
				} else if (rs.getString("options").equalsIgnoreCase(O_ORG_SUB_TITLE)) {
					CF.setStrOrgSubTitle(rs.getString("value"));
				} else if (rs.getString("options").equalsIgnoreCase(O_EMP_CODE_ALPHA)) {
					CF.setStrOEmpCodeAlpha(rs.getString("value"));
				} else if (rs.getString("options").equalsIgnoreCase(O_ORG_FULL_ADDRESS)) {
					CF.setStrOrgAddress(rs.getString("value"));
				} else if (rs.getString("options").equalsIgnoreCase(O_SALARY_CALCULATION)) {
					CF.setStrOSalaryCalculationType(rs.getString("value"));
				} else if (rs.getString("options").equalsIgnoreCase(O_EMAIL_LOCAL_HOST)) {
					CF.setStrEmailLocalHost(rs.getString("value"));
				} else if (rs.getString("options").equalsIgnoreCase(O_STANDARD_FULL_TIME_HOURS)) {
					CF.setStrStandardHrs(rs.getString("value"));
				} else if (rs.getString("options").equalsIgnoreCase(O_ATTENDANCE_INTEGRATED_WITH_ACTIVITY)) {
					CF.setStrAttendanceIntegratedWithActivity(rs.getString("value"));
				} else if (rs.getString("options").equalsIgnoreCase(O_USERNAME_FORMAT)) {
					CF.setStrUserNameFormat(rs.getString("value"));
				} else if (rs.getString("options").equalsIgnoreCase(O_COMMON_ATTEN_FORMAT)) {
					CF.setStrCommonAttendanceFormat(rs.getString("value"));
				} else if (rs.getString("options").equalsIgnoreCase(O_IS_WORKFLOW)) {
					CF.setIsWorkFlow(rs.getString("value"));
				} else if (rs.getString("options").equalsIgnoreCase(O_IS_BONUS_PAYROLL)) {
					CF.setIsBonusPaidWithPayroll(rs.getString("value"));
				} else if (rs.getString("options").equalsIgnoreCase(O_IS_SPECIFIC_EMP)) {
					CF.setIsSpecificEmp(rs.getString("value"));
				} else if (rs.getString("options").equalsIgnoreCase(O_BACKUP_LOCATION)) {
					CF.setBackUpLocation(rs.getString("value"));
				} else if (rs.getString("options").equalsIgnoreCase(O_PGDUMP_LOCATION)) {
					CF.setDumpLocation(rs.getString("value"));
				} else if (rs.getString("options").equalsIgnoreCase(O_IS_PAYCYCLE_MONTH_ADJUSTMENT)) {
					CF.setIsPaycycleAdjustment(rs.getString("value"));
				} else if (rs.getString("options").equalsIgnoreCase(O_DOC_RETRIVE_LOCATION)) {
					CF.setStrDocRetriveLocation(rs.getString("value"));
				} else if (rs.getString("options").equalsIgnoreCase(O_DOC_SAVE_LOCATION)) {
					CF.setStrDocSaveLocation(rs.getString("value"));
				} else if (rs.getString("options").equalsIgnoreCase(O_IS_REMOTE_LOCATION)) {
					CF.setIsRemoteLocation(uF.parseToBoolean(rs.getString("value")));
				} else if (rs.getString("options").equalsIgnoreCase(O_EPF_CONDITION_1)) {
					CF.setEPF_Condition1(uF.parseToBoolean(rs.getString("value")));
				} else if (rs.getString("options").equalsIgnoreCase(FIXED_MONTH_DAYS)) {
					CF.setStrOSalaryCalculationDays(rs.getString("value"));
				} else if (rs.getString("options").equalsIgnoreCase(O_EXCEPTION_IS_AUTO_APPROVE)) {
					CF.setIsExceptionAutoApprove(rs.getString("value"));
				} else if (rs.getString("options").equalsIgnoreCase(O_IS_ARREAR)) {
					CF.setIsArrear(rs.getString("value"));
				} else if (rs.getString("options").equalsIgnoreCase(O_IS_BREAK_POLICY)) {
					CF.setIsBreakPolicy(rs.getString("value"));
				} else if (rs.getString("options").equalsIgnoreCase(MAX_TIME_LIMIT_OUT)) {
					CF.setMaxTimeLimitOUT(rs.getString("value"));
				} else if (rs.getString("options").equalsIgnoreCase(O_PROJECT_DOCUMENT_FOLDER)) {
					CF.setProjectDocumentFolder(rs.getString("value"));
				} else if (rs.getString("options").equalsIgnoreCase(O_RETRIVE_PROJECT_DOCUMENT_FOLDER)) {
					CF.setRetriveProjectDocumentFolder(rs.getString("value"));
				} else if (rs.getString("options").equalsIgnoreCase(O_BACKUP_RETRIVE_LOCATION)) {
					CF.setBackUpRetriveLocation(rs.getString("value"));
				} else if (rs.getString("options").equalsIgnoreCase(O_HOST_PORT)) {
					CF.setStrHostPort(rs.getString("value"));
				} else if (rs.getString("options").equalsIgnoreCase(O_IS_WORKRIG)) {
					CF.setWorkRig(uF.parseToBoolean(rs.getString("value")));
				} else if (rs.getString("options").equalsIgnoreCase(O_IS_TASKRIG)) {
					CF.setTaskRig(uF.parseToBoolean(rs.getString("value")));
				} else if (rs.getString("options").equalsIgnoreCase(O_IS_CLOUD)) {
					CF.setCloud(uF.parseToBoolean(rs.getString("value")));
				} else if (rs.getString("options").equalsIgnoreCase(O_IS_OFFICE_365_SMTP)) {
					CF.setOffice365Smtp(uF.parseToBoolean(rs.getString("value")));
				}
			}
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			db.closeResultSet(rs);
			db.closeStatements(pst);
			db.closeConnection(con);
		}
	}

	public Map<String, Map<String, String>> getTravelDetails(Connection con, UtilityFunctions uF, String strDate1, String strDate2) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, Map<String, String>> getMap = new HashMap<String, Map<String, String>>();
		try {
			pst = con
					.prepareStatement("select * from travel_application_register where (is_modify is null or is_modify = false) and _date between ? and ? order by emp_id");
			pst.setDate(1, uF.getDateFormat(strDate1, DATE_FORMAT));
			pst.setDate(2, uF.getDateFormat(strDate2, DATE_FORMAT));
			rs = pst.executeQuery();
			while (rs.next()) {
				Map<String, String> a = getMap.get(rs.getString("emp_id"));
				if (a == null)
					a = new HashMap<String, String>();

				a.put(uF.getDateFormat(rs.getString("_date"), DBDATE, DATE_FORMAT), "T");
				getMap.put(rs.getString("emp_id"), a);
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
		}
		return getMap;
	}

	public String getAssessmentSubjectNameById(Connection con, String subjectId) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		String subjectName = null;
		try {
			pst = con.prepareStatement("select * from course_subject_details where course_subject_id = ?");
			pst.setInt(1, uF.parseToInt(subjectId));
			rs = pst.executeQuery();
			while (rs.next()) {
				subjectName = rs.getString("course_subject_name");
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
		}
		return subjectName;
	}

	public Map<String, String> getCandidateImageMap(Connection con) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmCandiImage = new HashMap<String, String>();
		try {
			pst = con.prepareStatement("SELECT emp_per_id, emp_image FROM candidate_personal_details ");
			rs = pst.executeQuery();
			while (rs.next()) {
				hmCandiImage.put(rs.getString("emp_per_id"), rs.getString("emp_image"));
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmCandiImage;
	}

	public Map<String, String> getTaskNameMap(Connection con) {
		PreparedStatement pst = null;
		ResultSet rst = null;
		UtilityFunctions uF = new UtilityFunctions();
		Map<String, String> hmTaskName = new HashMap<String, String>();
		try {
			pst = con.prepareStatement("select task_id,activity_name from activity_info");
			rst = pst.executeQuery();
			while (rst.next()) {
				hmTaskName.put(rst.getString("task_id"), rst.getString("activity_name"));
			}
			// System.out.println("scree-"+ScreenShotName);
			rst.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rst != null) {
				try {
					rst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmTaskName;
	}

	public Map<String, String> getScreenShotNameMap(Connection con) {
		PreparedStatement pst = null;
		ResultSet rst = null;
		UtilityFunctions uF = new UtilityFunctions();
		Map<String, String> hmScreenShotName = new HashMap<String, String>();
		try {
			pst = con.prepareStatement("select screenshot_id,screenshot_name from task_screenshot_details");
			rst = pst.executeQuery();
			while (rst.next()) {
				hmScreenShotName.put(rst.getString("screenshot_id"), rst.getString("screenshot_name").trim());
			}
			// System.out.println("scree-"+ScreenShotName);
			rst.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rst != null) {
				try {
					rst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmScreenShotName;
	}

	public Map<String, String> getFeatureStatusMap(HttpServletRequest request) {
		Connection con = null;
		Database db = new Database();
		db.setRequest(request);
		PreparedStatement pst = null;
		ResultSet rst = null;
		UtilityFunctions uF = new UtilityFunctions();
		Map<String, String> hmFeatureStatus = new HashMap<String, String>();
		Map<String, List<String>> hmFeatureUserTypeId = new HashMap<String, List<String>>();
		try {
			con = db.makeConnection(con);
			pst = con.prepareStatement("select feature_name,feature_status,user_type_id,emp_ids from feature_management");
			rst = pst.executeQuery();
			while (rst.next()) {
				hmFeatureStatus.put(rst.getString("feature_name"), rst.getString("feature_status"));
				List<String> innerList = new ArrayList<String>();
				List<String> innerList1 = new ArrayList<String>();
				if (rst.getString("user_type_id") != null) {
					innerList = Arrays.asList(rst.getString("user_type_id").split(","));
				}
				if (rst.getString("emp_ids") != null) {
					innerList1 = Arrays.asList(rst.getString("emp_ids").split(","));
				}
				hmFeatureUserTypeId.put(rst.getString("feature_name"), innerList);
				hmFeatureUserTypeId.put(rst.getString("feature_name") + "_USER_IDS", innerList1);
			}
			// System.out.println("scree-"+ScreenShotName);
			rst.close();
			pst.close();

			request.setAttribute("hmFeatureUserTypeId", hmFeatureUserTypeId);

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			db.closeResultSet(rst);
			db.closeStatements(pst);
			db.closeConnection(con);
		}
		return hmFeatureStatus;
	}

	public Map<String, String> getFeatureStatusMap(Connection con, HttpServletRequest request) {
		PreparedStatement pst = null;
		ResultSet rst = null;
		UtilityFunctions uF = new UtilityFunctions();
		Map<String, String> hmFeatureStatus = new HashMap<String, String>();
		Map<String, List<String>> hmFeatureUserTypeId = new HashMap<String, List<String>>();
		try {
			pst = con.prepareStatement("select feature_name,feature_status,user_type_id,emp_ids from feature_management");
			rst = pst.executeQuery();
			while (rst.next()) {
				hmFeatureStatus.put(rst.getString("feature_name"), rst.getString("feature_status"));
				List<String> innerList = new ArrayList<String>();
				List<String> innerList1 = new ArrayList<String>();
				if (rst.getString("user_type_id") != null) {
					innerList = Arrays.asList(rst.getString("user_type_id").split(","));
				}
				if (rst.getString("emp_ids") != null) {
					innerList1 = Arrays.asList(rst.getString("emp_ids").split(","));
				}
				hmFeatureUserTypeId.put(rst.getString("feature_name"), innerList);
				hmFeatureUserTypeId.put(rst.getString("feature_name") + "_USER_IDS", innerList1);
			}
			// System.out.println("scree-"+ScreenShotName);
			rst.close();
			pst.close();

			request.setAttribute("hmFeatureUserTypeId", hmFeatureUserTypeId);

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rst != null) {
				try {
					rst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmFeatureStatus;
	}

	public Map<String, String> getFeatureStatusMap(Connection con) {
		PreparedStatement pst = null;
		ResultSet rst = null;
		UtilityFunctions uF = new UtilityFunctions();
		Map<String, String> hmFeatureStatus = new HashMap<String, String>();
		Map<String, List<String>> hmFeatureUserTypeId = new HashMap<String, List<String>>();
		try {
			pst = con.prepareStatement("select feature_name,feature_status,user_type_id from feature_management");
			rst = pst.executeQuery();
			while (rst.next()) {
				hmFeatureStatus.put(rst.getString("feature_name"), rst.getString("feature_status"));
				List<String> innerList = new ArrayList<String>();
				if (rst.getString("user_type_id") != null) {
					innerList = Arrays.asList(rst.getString("user_type_id").split(","));
				}
				hmFeatureUserTypeId.put(rst.getString("feature_name"), innerList);
			}
			// System.out.println("scree-"+ScreenShotName);
			rst.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rst != null) {
				try {
					rst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmFeatureStatus;
	}

	public Map<String, String> getAttributeMap(Connection con) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmAttribute = new HashMap<String, String>();
		try {
			pst = con.prepareStatement("select * from appraisal_attribute where status = true");
			rs = pst.executeQuery();
			while (rs.next()) {
				hmAttribute.put(rs.getString("arribute_id"), rs.getString("attribute_name"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmAttribute;
	}

	public String getAppendNames(List<String> alList, Map<String, String> hmMap) {

		StringBuilder sbNames = new StringBuilder();
		int cnt = 0;
		for (int i = 0; alList != null && !alList.isEmpty() && i < alList.size(); i++) {
			if (!alList.get(i).trim().equals("")) {
				if (cnt == 0) {
					sbNames.append(hmMap.get(alList.get(i).trim()));
					cnt++;
				} else {
					sbNames.append(", " + hmMap.get(alList.get(i).trim()));
				}
			}
		}
		return sbNames.toString();
	}

	public Map<String, String> getActivityNode(Connection con) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmActivityNode = new HashMap<String, String>();
		try {
			pst = con.prepareStatement("select * from nodes");
			rs = pst.executeQuery();
			while (rs.next()) {
				hmActivityNode.put(rs.getString("mapped_activity_id"), rs.getString("node_id"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmActivityNode;
	}

	public Map<String, String> getGoalNameMap(Connection con, UtilityFunctions uF) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmGoalName = new HashMap<String, String>();
		try {
			pst = con.prepareStatement("select goal_id,goal_title from goal_details");
			rs = pst.executeQuery();
			while (rs.next()) {
				hmGoalName.put(rs.getString("goal_id"), rs.getString("goal_title"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmGoalName;
	}

	public Map<String, String> getDocActivityName(Connection con) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmDocActivity = new HashMap<String, String>();

		try {
			pst = con
					.prepareStatement("select activity_id,activity_name from activity_details ad, nodes n where ad.activity_id=n.mapped_activity_id and ad.isactivity=true order by activity_name");
			rs = pst.executeQuery();
			while (rs.next()) {
				hmDocActivity.put(rs.getString("activity_id"), rs.getString("activity_name"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

		return hmDocActivity;
	}

	public Map<String, String> getRecruitmentNameMap(Connection con, UtilityFunctions uF) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmRecruitName = new HashMap<String, String>();
		try {
			pst = con.prepareStatement("select recruitment_id,job_code from recruitment_details");
			rs = pst.executeQuery();
			while (rs.next()) {
				hmRecruitName.put(rs.getString("recruitment_id"), rs.getString("job_code"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmRecruitName;
	}

	public Map<String, String> getAllowanceCondition() {
		Map<String, String> hm = new HashMap<String, String>();
		hm.put("" + A_NO_OF_DAYS_ID, A_NO_OF_DAYS);
		hm.put("" + A_NO_OF_HOURS_ID, A_NO_OF_HOURS);
		hm.put("" + A_CUSTOM_FACTOR_ID, A_CUSTOM_FACTOR);
		hm.put("" + A_GOAL_KRA_TARGET_ID, A_GOAL_KRA_TARGET);
		hm.put("" + A_KRA_ID, A_KRA);
		hm.put("" + A_NO_OF_DAYS_ABSENT_ID, A_NO_OF_DAYS_ABSENT);

		return hm;
	}

	public Map<String, String> getLevelCodeName(Connection con, UtilityFunctions uF) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmLevelCodeMap = new LinkedHashMap<String, String>();
		try {

			pst = con.prepareStatement("SELECT * FROM level_details ");
			rs = pst.executeQuery();
			while (rs.next()) {
				hmLevelCodeMap.put(rs.getString("level_id"), "[" + rs.getString("level_code") + "]" + rs.getString("level_name"));

			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

		return hmLevelCodeMap;
	}

	public List<String> getLevelList(Connection con, UtilityFunctions uF) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		List<String> hmLevelCodeMap = new ArrayList<String>();
		try {
			pst = con.prepareStatement("SELECT * FROM level_details ");
			rs = pst.executeQuery();
			while (rs.next()) {
				hmLevelCodeMap.add("[" + rs.getString("level_code") + "]" + rs.getString("level_name"));
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmLevelCodeMap;
	}

	public Map<String, String> getAllowancePaymentLogic() {
		Map<String, String> hm = new HashMap<String, String>();

		hm.put("" + A_FIXED_ONLY_ID, A_FIXED_ONLY);
		hm.put("" + A_FIXED_X_DAYS_ID, A_FIXED_X_DAYS);
		hm.put("" + A_FIXED_X_HOURS_ID, A_FIXED_X_HOURS);
		hm.put("" + A_FIXED_X_CUSTOM_ID, A_FIXED_X_CUSTOM);
		hm.put("" + A_EQUAL_TO_SALARY_HEAD_ID, A_EQUAL_TO_SALARY_HEAD);
		hm.put("" + A_SALARY_HEAD_X_DAYS_ID, A_SALARY_HEAD_X_DAYS);
		hm.put("" + A_SALARY_HEAD_X_HOURS_ID, A_SALARY_HEAD_X_HOURS);
		hm.put("" + A_SALARY_HEAD_X_CUSTOM_ID, A_SALARY_HEAD_X_CUSTOM);
		hm.put("" + A_FIXED_X_ACHIEVED_ID, A_FIXED_X_ACHIEVED);
		hm.put("" + A_SALARY_HEAD_X_ACHIEVED_ID, A_SALARY_HEAD_X_ACHIEVED);
		hm.put("" + A_FIXED_AND_PER_HOUR_ID, A_FIXED_AND_PER_HOUR);
		hm.put("" + A_FIXED_AND_PER_DAY_ID, A_FIXED_AND_PER_DAY);
		hm.put("" + A_FIXED_ONLY_DEDUCTION_ID, A_FIXED_ONLY_DEDUCTION);

		return hm;
	}

	public List<String> isCommAvailable(Connection con, UtilityFunctions uF, String comm) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		List<String> alInner = new ArrayList<String>();
		try {
			StringBuilder sbquery = new StringBuilder();
			if (comm != null && comm.equalsIgnoreCase("Events")) {
				sbquery.append("select max(event_id) as max_id from events");
			} else if (comm != null && comm.equalsIgnoreCase("Announcements")) {
				sbquery.append("select max(notice_id) as max_id from notices");
			} else if (comm != null && comm.equalsIgnoreCase("Quotes")) {
				sbquery.append("select max(thought_id) as max_id from daythoughts");
			} else if (comm != null && comm.equalsIgnoreCase("Feeds")) {
				sbquery.append("select max(communication_id) as max_id from communication_1");
			}
			int max_id = 0;
			pst = con.prepareStatement(sbquery.toString());
			rs = pst.executeQuery();
			while (rs.next()) {
				max_id = rs.getInt("max_id");
			}
			rs.close();
			pst.close();

			if (comm != null && comm.equalsIgnoreCase("Events")) {
				StringBuilder query = new StringBuilder();
				query.append("select * from events where event_id = ?");
				pst = con.prepareStatement(query.toString());
				pst.setInt(1, max_id);
				rs = pst.executeQuery();
				while (rs.next()) {
					alInner.add(Integer.toString(rs.getInt("event_id")));// 0
					alInner.add(uF.getDateFormat(rs.getString("event_date"), DBDATE, DATE_FORMAT));// 1
					alInner.add(uF.getDateFormat(rs.getString("event_end_date"), DBDATE, DATE_FORMAT));// 2
					alInner.add(rs.getString("event_title"));// 3
					alInner.add(rs.getString("event_desc"));// 4
					alInner.add(rs.getString("sharing_level"));// 5
					alInner.add(rs.getString("location"));// 6
					alInner.add(rs.getString("from_time"));// 7
					alInner.add(rs.getString("to_time"));// 8
					alInner.add(rs.getString("added_by"));// 9
				}
				rs.close();
				pst.close();
			} else if (comm != null && comm.equalsIgnoreCase("Announcements")) {
				StringBuilder query = new StringBuilder();
				query.append("select * from notices where notice_id = ?");
				pst = con.prepareStatement(query.toString());
				pst.setInt(1, max_id);
				rs = pst.executeQuery();
				while (rs.next()) {
					alInner.add(Integer.toString(rs.getInt("notice_id")));// 0
					alInner.add(uF.getDateFormat(rs.getString("display_date"), DBDATE, DATE_FORMAT));// 1
					alInner.add(uF.getDateFormat(rs.getString("display_end_date"), DBDATE, DATE_FORMAT));// 2
					alInner.add(rs.getString("heading"));// 3
					alInner.add(rs.getString("content"));// 4
					alInner.add(rs.getString("ispublish"));// 5
					alInner.add(rs.getString("added_by"));// 6
				}
				rs.close();
				pst.close();
			} else if (comm != null && comm.equalsIgnoreCase("Quotes")) {

				StringBuilder query = new StringBuilder();
				query.append("select * from daythoughts where thought_id = ?");
				pst = con.prepareStatement(query.toString());
				pst.setInt(1, max_id);
				rs = pst.executeQuery();
				while (rs.next()) {
					alInner.add(Integer.toString(rs.getInt("thought_id")));// 0
					alInner.add(rs.getString("entry_date"));// 1
					alInner.add(rs.getString("thought_by"));// 2
					alInner.add(rs.getString("thought_text"));// 3
					alInner.add(rs.getString("posted_date"));// 4
					alInner.add(rs.getString("added_by"));// 5
				}
				rs.close();
				pst.close();
			} else if (comm != null && comm.equalsIgnoreCase("Feeds")) {

				StringBuilder query = new StringBuilder();
				query.append("select * from communication_1 where communication_id = ?");
				pst = con.prepareStatement(query.toString());
				pst.setInt(1, max_id);
				rs = pst.executeQuery();
				while (rs.next()) {
					alInner.add(Integer.toString(rs.getInt("communication_id")));// 0

					alInner.add(rs.getString("communication"));// 1
					alInner.add(rs.getString("created_by"));// 2
				}
				rs.close();
				pst.close();
			}

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

		return alInner;
	}

	public void getNewsAndAlerts(CommonFunctions CF, String empType, String empId, HttpServletRequest request) {
		Connection con = null;
		Database db = new Database();
		db.setRequest(request);
		PreparedStatement pst = null;
		ResultSet rs = null;
		try {
			con = db.makeConnection(con);

			StringBuilder sbQuery = new StringBuilder();
			sbQuery.append("select count(*) as cnt from taskrig_user_alerts where type = 'NA' and alert_data is not null and alert_action is not null ");
			if (empType != null && empType.equalsIgnoreCase(CUSTOMER)) {
				sbQuery.append(" and customer_id=?");
			} else {
				sbQuery.append(" and resource_id=?");
			}
			pst = con.prepareStatement(sbQuery.toString());
			pst.setInt(1, uF.parseToInt(empId));
			// System.out.println("pst ===> " +pst);
			rs = pst.executeQuery();
			int notificationCount = 0;
			while (rs.next()) {
				notificationCount = rs.getInt("cnt");
			}
			rs.close();
			pst.close();
			request.setAttribute("newsCount", notificationCount + "");

			sbQuery = new StringBuilder();
			sbQuery.append("select * from taskrig_user_alerts where resource_id = ? and type = ? order by alerts_id desc limit 25");
			pst = con.prepareStatement(sbQuery.toString());
			pst.setInt(1, uF.parseToInt(empId));
			pst.setString(2, "NA");
			rs = pst.executeQuery();
			StringBuilder sbAllNoti = new StringBuilder();
			while (rs.next()) {
				if (rs.getString("alert_data") != null && !rs.getString("alert_data").equals("null") && !rs.getString("alert_data").equals("")
						&& rs.getString("alert_action") != null && !rs.getString("alert_action").equals("null") && !rs.getString("alert_action").equals("")) {
					sbAllNoti.append("<div style=\"float: left; width: 99%; border: 1px solid #CCCCCC; border-radius: 4px; margin: 2px 0px; padding: 5px;\"");
					sbAllNoti
							.append("onmouseover=\"javascript:this.style.backgroundColor='#D4D4D4'\" onmouseout=\"javascript:this.style.backgroundColor=''\" >");
					sbAllNoti.append("<a href=\"" + rs.getString("alert_action") + "&alertID=" + rs.getString("alerts_id")
							+ "\" style=\"color: black; font-weight: normal; width: 100%;\">");
					sbAllNoti.append(rs.getString("alert_data"));
					sbAllNoti.append("</a>");
					sbAllNoti.append("</div>");
				}
			}
			rs.close();
			pst.close();
			// System.out.println("newsCount");

			request.setAttribute("newsAndalerts", sbAllNoti.toString());
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			db.closeResultSet(rs);
			db.closeStatements(pst);
			db.closeConnection(con);
		}
	}

	public void appendMultipleCalType(UtilityFunctions uF, StringBuilder sbMulcalType, String[] strMulCalTemp, Map<String, String> hmSalaryMap,
			List<String> alAnnualSalaryHead) {
		if (alAnnualSalaryHead == null)
			alAnnualSalaryHead = new ArrayList<String>();

		if (hmSalaryMap.containsKey(strMulCalTemp[0])) {
			String strAnnualMonth1 = "";
			if (alAnnualSalaryHead.contains(strMulCalTemp[0])) {
				strAnnualMonth1 = "(Calculated Monthly)";
			}
			sbMulcalType.append(uF.showData(hmSalaryMap.get(strMulCalTemp[0]), "") + strAnnualMonth1);
			if (hmSalaryMap.containsKey(strMulCalTemp[2])) {
				String strAnnualMonth = "";
				if (alAnnualSalaryHead.contains(strMulCalTemp[2])) {
					strAnnualMonth = "(Calculated Monthly)";
				}
				sbMulcalType.append(" " + strMulCalTemp[1] + " " + uF.showData(hmSalaryMap.get(strMulCalTemp[2]), "") + strAnnualMonth);
			}
			if (hmSalaryMap.containsKey(strMulCalTemp[4])) {
				String strAnnualMonth = "";
				if (alAnnualSalaryHead.contains(strMulCalTemp[4])) {
					strAnnualMonth = "(Calculated Monthly)";
				}
				sbMulcalType.append(" " + strMulCalTemp[3] + " " + uF.showData(hmSalaryMap.get(strMulCalTemp[4]), "") + strAnnualMonth);
			}
			if (hmSalaryMap.containsKey(strMulCalTemp[6])) {
				String strAnnualMonth = "";
				if (alAnnualSalaryHead.contains(strMulCalTemp[6])) {
					strAnnualMonth = "(Calculated Monthly)";
				}
				sbMulcalType.append(" " + strMulCalTemp[5] + " " + uF.showData(hmSalaryMap.get(strMulCalTemp[6]), "") + strAnnualMonth);
			}
			if (hmSalaryMap.containsKey(strMulCalTemp[8])) {
				String strAnnualMonth = "";
				if (alAnnualSalaryHead.contains(strMulCalTemp[8])) {
					strAnnualMonth = "(Calculated Monthly)";
				}
				sbMulcalType.append(" " + strMulCalTemp[7] + " " + uF.showData(hmSalaryMap.get(strMulCalTemp[8]), "") + strAnnualMonth);
			}
			if (hmSalaryMap.containsKey(strMulCalTemp[10])) {
				String strAnnualMonth = "";
				if (alAnnualSalaryHead.contains(strMulCalTemp[10])) {
					strAnnualMonth = "(Calculated Monthly)";
				}
				sbMulcalType.append(" " + strMulCalTemp[9] + " " + uF.showData(hmSalaryMap.get(strMulCalTemp[10]), "") + strAnnualMonth);
			}
			if (hmSalaryMap.containsKey(strMulCalTemp[12])) {
				String strAnnualMonth = "";
				if (alAnnualSalaryHead.contains(strMulCalTemp[12])) {
					strAnnualMonth = "(Calculated Monthly)";
				}
				sbMulcalType.append(" " + strMulCalTemp[11] + " " + uF.showData(hmSalaryMap.get(strMulCalTemp[12]), "") + strAnnualMonth);
			}
			if (hmSalaryMap.containsKey(strMulCalTemp[14])) {
				String strAnnualMonth = "";
				if (alAnnualSalaryHead.contains(strMulCalTemp[14])) {
					strAnnualMonth = "(Calculated Monthly)";
				}
				sbMulcalType.append(" " + strMulCalTemp[13] + " " + uF.showData(hmSalaryMap.get(strMulCalTemp[14]), "") + strAnnualMonth);
			}
			if (hmSalaryMap.containsKey(strMulCalTemp[16])) {
				String strAnnualMonth = "";
				if (alAnnualSalaryHead.contains(strMulCalTemp[16])) {
					strAnnualMonth = "(Calculated Monthly)";
				}
				sbMulcalType.append(" " + strMulCalTemp[15] + " " + uF.showData(hmSalaryMap.get(strMulCalTemp[16]), "") + strAnnualMonth);
			}
			if (hmSalaryMap.containsKey(strMulCalTemp[18])) {
				String strAnnualMonth = "";
				if (alAnnualSalaryHead.contains(strMulCalTemp[18])) {
					strAnnualMonth = "(Calculated Monthly)";
				}
				sbMulcalType.append(" " + strMulCalTemp[17] + " " + uF.showData(hmSalaryMap.get(strMulCalTemp[18]), "") + strAnnualMonth);
			}
		} else if (hmSalaryMap.containsKey(strMulCalTemp[2])) {
			String strAnnualMonth1 = "";
			if (alAnnualSalaryHead.contains(strMulCalTemp[2])) {
				strAnnualMonth1 = "(Calculated Monthly)";
			}
			sbMulcalType.append(uF.showData(hmSalaryMap.get(strMulCalTemp[2]), "") + strAnnualMonth1);

			if (hmSalaryMap.containsKey(strMulCalTemp[4])) {
				String strAnnualMonth = "";
				if (alAnnualSalaryHead.contains(strMulCalTemp[4])) {
					strAnnualMonth = "(Calculated Monthly)";
				}
				sbMulcalType.append(" " + strMulCalTemp[3] + " " + uF.showData(hmSalaryMap.get(strMulCalTemp[4]), "") + strAnnualMonth);
			}
			if (hmSalaryMap.containsKey(strMulCalTemp[6])) {
				String strAnnualMonth = "";
				if (alAnnualSalaryHead.contains(strMulCalTemp[6])) {
					strAnnualMonth = "(Calculated Monthly)";
				}
				sbMulcalType.append(" " + strMulCalTemp[5] + " " + uF.showData(hmSalaryMap.get(strMulCalTemp[6]), "") + strAnnualMonth);
			}
			if (hmSalaryMap.containsKey(strMulCalTemp[8])) {
				String strAnnualMonth = "";
				if (alAnnualSalaryHead.contains(strMulCalTemp[8])) {
					strAnnualMonth = "(Calculated Monthly)";
				}
				sbMulcalType.append(" " + strMulCalTemp[7] + " " + uF.showData(hmSalaryMap.get(strMulCalTemp[8]), "") + strAnnualMonth);
			}
			if (hmSalaryMap.containsKey(strMulCalTemp[10])) {
				String strAnnualMonth = "";
				if (alAnnualSalaryHead.contains(strMulCalTemp[10])) {
					strAnnualMonth = "(Calculated Monthly)";
				}
				sbMulcalType.append(" " + strMulCalTemp[9] + " " + uF.showData(hmSalaryMap.get(strMulCalTemp[10]), "") + strAnnualMonth);
			}
			if (hmSalaryMap.containsKey(strMulCalTemp[12])) {
				String strAnnualMonth = "";
				if (alAnnualSalaryHead.contains(strMulCalTemp[12])) {
					strAnnualMonth = "(Calculated Monthly)";
				}
				sbMulcalType.append(" " + strMulCalTemp[11] + " " + uF.showData(hmSalaryMap.get(strMulCalTemp[12]), "") + strAnnualMonth);
			}
			if (hmSalaryMap.containsKey(strMulCalTemp[14])) {
				String strAnnualMonth = "";
				if (alAnnualSalaryHead.contains(strMulCalTemp[14])) {
					strAnnualMonth = "(Calculated Monthly)";
				}
				sbMulcalType.append(" " + strMulCalTemp[13] + " " + uF.showData(hmSalaryMap.get(strMulCalTemp[14]), "") + strAnnualMonth);
			}
			if (hmSalaryMap.containsKey(strMulCalTemp[16])) {
				String strAnnualMonth = "";
				if (alAnnualSalaryHead.contains(strMulCalTemp[16])) {
					strAnnualMonth = "(Calculated Monthly)";
				}
				sbMulcalType.append(" " + strMulCalTemp[15] + " " + uF.showData(hmSalaryMap.get(strMulCalTemp[16]), "") + strAnnualMonth);
			}
			if (hmSalaryMap.containsKey(strMulCalTemp[18])) {
				String strAnnualMonth = "";
				if (alAnnualSalaryHead.contains(strMulCalTemp[18])) {
					strAnnualMonth = "(Calculated Monthly)";
				}
				sbMulcalType.append(" " + strMulCalTemp[17] + " " + uF.showData(hmSalaryMap.get(strMulCalTemp[18]), "") + strAnnualMonth);
			}
		} else if (hmSalaryMap.containsKey(strMulCalTemp[4])) {
			String strAnnualMonth1 = "";
			if (alAnnualSalaryHead.contains(strMulCalTemp[4])) {
				strAnnualMonth1 = "(Calculated Monthly)";
			}
			sbMulcalType.append(uF.showData(hmSalaryMap.get(strMulCalTemp[4]), "") + strAnnualMonth1);

			if (hmSalaryMap.containsKey(strMulCalTemp[6])) {
				String strAnnualMonth = "";
				if (alAnnualSalaryHead.contains(strMulCalTemp[6])) {
					strAnnualMonth = "(Calculated Monthly)";
				}
				sbMulcalType.append(" " + strMulCalTemp[5] + " " + uF.showData(hmSalaryMap.get(strMulCalTemp[6]), "") + strAnnualMonth);
			}
			if (hmSalaryMap.containsKey(strMulCalTemp[8])) {
				String strAnnualMonth = "";
				if (alAnnualSalaryHead.contains(strMulCalTemp[8])) {
					strAnnualMonth = "(Calculated Monthly)";
				}
				sbMulcalType.append(" " + strMulCalTemp[7] + " " + uF.showData(hmSalaryMap.get(strMulCalTemp[8]), "") + strAnnualMonth);
			}
			if (hmSalaryMap.containsKey(strMulCalTemp[10])) {
				String strAnnualMonth = "";
				if (alAnnualSalaryHead.contains(strMulCalTemp[10])) {
					strAnnualMonth = "(Calculated Monthly)";
				}
				sbMulcalType.append(" " + strMulCalTemp[9] + " " + uF.showData(hmSalaryMap.get(strMulCalTemp[10]), "") + strAnnualMonth);
			}
			if (hmSalaryMap.containsKey(strMulCalTemp[12])) {
				String strAnnualMonth = "";
				if (alAnnualSalaryHead.contains(strMulCalTemp[12])) {
					strAnnualMonth = "(Calculated Monthly)";
				}
				sbMulcalType.append(" " + strMulCalTemp[11] + " " + uF.showData(hmSalaryMap.get(strMulCalTemp[12]), "") + strAnnualMonth);
			}
			if (hmSalaryMap.containsKey(strMulCalTemp[14])) {
				String strAnnualMonth = "";
				if (alAnnualSalaryHead.contains(strMulCalTemp[14])) {
					strAnnualMonth = "(Calculated Monthly)";
				}
				sbMulcalType.append(" " + strMulCalTemp[13] + " " + uF.showData(hmSalaryMap.get(strMulCalTemp[14]), "") + strAnnualMonth);
			}
			if (hmSalaryMap.containsKey(strMulCalTemp[16])) {
				String strAnnualMonth = "";
				if (alAnnualSalaryHead.contains(strMulCalTemp[16])) {
					strAnnualMonth = "(Calculated Monthly)";
				}
				sbMulcalType.append(" " + strMulCalTemp[15] + " " + uF.showData(hmSalaryMap.get(strMulCalTemp[16]), "") + strAnnualMonth);
			}
			if (hmSalaryMap.containsKey(strMulCalTemp[18])) {
				String strAnnualMonth = "";
				if (alAnnualSalaryHead.contains(strMulCalTemp[18])) {
					strAnnualMonth = "(Calculated Monthly)";
				}
				sbMulcalType.append(" " + strMulCalTemp[17] + " " + uF.showData(hmSalaryMap.get(strMulCalTemp[18]), "") + strAnnualMonth);
			}
		} else if (hmSalaryMap.containsKey(strMulCalTemp[6])) {
			String strAnnualMonth1 = "";
			if (alAnnualSalaryHead.contains(strMulCalTemp[6])) {
				strAnnualMonth1 = "(Calculated Monthly)";
			}
			sbMulcalType.append(uF.showData(hmSalaryMap.get(strMulCalTemp[6]), "") + strAnnualMonth1);

			if (hmSalaryMap.containsKey(strMulCalTemp[8])) {
				String strAnnualMonth = "";
				if (alAnnualSalaryHead.contains(strMulCalTemp[8])) {
					strAnnualMonth = "(Calculated Monthly)";
				}
				sbMulcalType.append(" " + strMulCalTemp[7] + " " + uF.showData(hmSalaryMap.get(strMulCalTemp[8]), "") + strAnnualMonth);
			}
			if (hmSalaryMap.containsKey(strMulCalTemp[10])) {
				String strAnnualMonth = "";
				if (alAnnualSalaryHead.contains(strMulCalTemp[10])) {
					strAnnualMonth = "(Calculated Monthly)";
				}
				sbMulcalType.append(" " + strMulCalTemp[9] + " " + uF.showData(hmSalaryMap.get(strMulCalTemp[10]), "") + strAnnualMonth);
			}
			if (hmSalaryMap.containsKey(strMulCalTemp[12])) {
				String strAnnualMonth = "";
				if (alAnnualSalaryHead.contains(strMulCalTemp[12])) {
					strAnnualMonth = "(Calculated Monthly)";
				}
				sbMulcalType.append(" " + strMulCalTemp[11] + " " + uF.showData(hmSalaryMap.get(strMulCalTemp[12]), "") + strAnnualMonth);
			}
			if (hmSalaryMap.containsKey(strMulCalTemp[14])) {
				String strAnnualMonth = "";
				if (alAnnualSalaryHead.contains(strMulCalTemp[14])) {
					strAnnualMonth = "(Calculated Monthly)";
				}
				sbMulcalType.append(" " + strMulCalTemp[13] + " " + uF.showData(hmSalaryMap.get(strMulCalTemp[14]), "") + strAnnualMonth);
			}
			if (hmSalaryMap.containsKey(strMulCalTemp[16])) {
				String strAnnualMonth = "";
				if (alAnnualSalaryHead.contains(strMulCalTemp[16])) {
					strAnnualMonth = "(Calculated Monthly)";
				}
				sbMulcalType.append(" " + strMulCalTemp[15] + " " + uF.showData(hmSalaryMap.get(strMulCalTemp[16]), "") + strAnnualMonth);
			}
			if (hmSalaryMap.containsKey(strMulCalTemp[18])) {
				String strAnnualMonth = "";
				if (alAnnualSalaryHead.contains(strMulCalTemp[18])) {
					strAnnualMonth = "(Calculated Monthly)";
				}
				sbMulcalType.append(" " + strMulCalTemp[17] + " " + uF.showData(hmSalaryMap.get(strMulCalTemp[18]), "") + strAnnualMonth);
			}
		} else if (hmSalaryMap.containsKey(strMulCalTemp[8])) {
			String strAnnualMonth1 = "";
			if (alAnnualSalaryHead.contains(strMulCalTemp[8])) {
				strAnnualMonth1 = "(Calculated Monthly)";
			}
			sbMulcalType.append(uF.showData(hmSalaryMap.get(strMulCalTemp[8]), "") + strAnnualMonth1);

			if (hmSalaryMap.containsKey(strMulCalTemp[10])) {
				String strAnnualMonth = "";
				if (alAnnualSalaryHead.contains(strMulCalTemp[10])) {
					strAnnualMonth = "(Calculated Monthly)";
				}
				sbMulcalType.append(" " + strMulCalTemp[9] + " " + uF.showData(hmSalaryMap.get(strMulCalTemp[10]), "") + strAnnualMonth);
			}
			if (hmSalaryMap.containsKey(strMulCalTemp[12])) {
				String strAnnualMonth = "";
				if (alAnnualSalaryHead.contains(strMulCalTemp[12])) {
					strAnnualMonth = "(Calculated Monthly)";
				}
				sbMulcalType.append(" " + strMulCalTemp[11] + " " + uF.showData(hmSalaryMap.get(strMulCalTemp[12]), "") + strAnnualMonth);
			}
			if (hmSalaryMap.containsKey(strMulCalTemp[14])) {
				String strAnnualMonth = "";
				if (alAnnualSalaryHead.contains(strMulCalTemp[14])) {
					strAnnualMonth = "(Calculated Monthly)";
				}
				sbMulcalType.append(" " + strMulCalTemp[13] + " " + uF.showData(hmSalaryMap.get(strMulCalTemp[14]), "") + strAnnualMonth);
			}
			if (hmSalaryMap.containsKey(strMulCalTemp[16])) {
				String strAnnualMonth = "";
				if (alAnnualSalaryHead.contains(strMulCalTemp[16])) {
					strAnnualMonth = "(Calculated Monthly)";
				}
				sbMulcalType.append(" " + strMulCalTemp[15] + " " + uF.showData(hmSalaryMap.get(strMulCalTemp[16]), "") + strAnnualMonth);
			}
			if (hmSalaryMap.containsKey(strMulCalTemp[18])) {
				String strAnnualMonth = "";
				if (alAnnualSalaryHead.contains(strMulCalTemp[18])) {
					strAnnualMonth = "(Calculated Monthly)";
				}
				sbMulcalType.append(" " + strMulCalTemp[17] + " " + uF.showData(hmSalaryMap.get(strMulCalTemp[18]), "") + strAnnualMonth);
			}
		} else if (hmSalaryMap.containsKey(strMulCalTemp[10])) {
			String strAnnualMonth1 = "";
			if (alAnnualSalaryHead.contains(strMulCalTemp[10])) {
				strAnnualMonth1 = "(Calculated Monthly)";
			}
			sbMulcalType.append(uF.showData(hmSalaryMap.get(strMulCalTemp[10]), "") + strAnnualMonth1);

			if (hmSalaryMap.containsKey(strMulCalTemp[12])) {
				String strAnnualMonth = "";
				if (alAnnualSalaryHead.contains(strMulCalTemp[12])) {
					strAnnualMonth = "(Calculated Monthly)";
				}
				sbMulcalType.append(" " + strMulCalTemp[11] + " " + uF.showData(hmSalaryMap.get(strMulCalTemp[12]), "") + strAnnualMonth);
			}
			if (hmSalaryMap.containsKey(strMulCalTemp[14])) {
				String strAnnualMonth = "";
				if (alAnnualSalaryHead.contains(strMulCalTemp[14])) {
					strAnnualMonth = "(Calculated Monthly)";
				}
				sbMulcalType.append(" " + strMulCalTemp[13] + " " + uF.showData(hmSalaryMap.get(strMulCalTemp[14]), "") + strAnnualMonth);
			}
			if (hmSalaryMap.containsKey(strMulCalTemp[16])) {
				String strAnnualMonth = "";
				if (alAnnualSalaryHead.contains(strMulCalTemp[16])) {
					strAnnualMonth = "(Calculated Monthly)";
				}
				sbMulcalType.append(" " + strMulCalTemp[15] + " " + uF.showData(hmSalaryMap.get(strMulCalTemp[16]), "") + strAnnualMonth);
			}
			if (hmSalaryMap.containsKey(strMulCalTemp[18])) {
				String strAnnualMonth = "";
				if (alAnnualSalaryHead.contains(strMulCalTemp[18])) {
					strAnnualMonth = "(Calculated Monthly)";
				}
				sbMulcalType.append(" " + strMulCalTemp[17] + " " + uF.showData(hmSalaryMap.get(strMulCalTemp[18]), "") + strAnnualMonth);
			}
		} else if (hmSalaryMap.containsKey(strMulCalTemp[12])) {
			String strAnnualMonth1 = "";
			if (alAnnualSalaryHead.contains(strMulCalTemp[12])) {
				strAnnualMonth1 = "(Calculated Monthly)";
			}
			sbMulcalType.append(uF.showData(hmSalaryMap.get(strMulCalTemp[12]), "") + strAnnualMonth1);

			if (hmSalaryMap.containsKey(strMulCalTemp[14])) {
				String strAnnualMonth = "";
				if (alAnnualSalaryHead.contains(strMulCalTemp[14])) {
					strAnnualMonth = "(Calculated Monthly)";
				}
				sbMulcalType.append(" " + strMulCalTemp[13] + " " + uF.showData(hmSalaryMap.get(strMulCalTemp[14]), "") + strAnnualMonth);
			}
			if (hmSalaryMap.containsKey(strMulCalTemp[16])) {
				String strAnnualMonth = "";
				if (alAnnualSalaryHead.contains(strMulCalTemp[16])) {
					strAnnualMonth = "(Calculated Monthly)";
				}
				sbMulcalType.append(" " + strMulCalTemp[15] + " " + uF.showData(hmSalaryMap.get(strMulCalTemp[16]), "") + strAnnualMonth);
			}
			if (hmSalaryMap.containsKey(strMulCalTemp[18])) {
				String strAnnualMonth = "";
				if (alAnnualSalaryHead.contains(strMulCalTemp[18])) {
					strAnnualMonth = "(Calculated Monthly)";
				}
				sbMulcalType.append(" " + strMulCalTemp[17] + " " + uF.showData(hmSalaryMap.get(strMulCalTemp[18]), "") + strAnnualMonth);
			}
		} else if (hmSalaryMap.containsKey(strMulCalTemp[14])) {
			String strAnnualMonth1 = "";
			if (alAnnualSalaryHead.contains(strMulCalTemp[14])) {
				strAnnualMonth1 = "(Calculated Monthly)";
			}
			sbMulcalType.append(uF.showData(hmSalaryMap.get(strMulCalTemp[14]), "") + strAnnualMonth1);

			if (hmSalaryMap.containsKey(strMulCalTemp[16])) {
				String strAnnualMonth = "";
				if (alAnnualSalaryHead.contains(strMulCalTemp[16])) {
					strAnnualMonth = "(Calculated Monthly)";
				}
				sbMulcalType.append(" " + strMulCalTemp[15] + " " + uF.showData(hmSalaryMap.get(strMulCalTemp[16]), "") + strAnnualMonth);
			}
			if (hmSalaryMap.containsKey(strMulCalTemp[18])) {
				String strAnnualMonth = "";
				if (alAnnualSalaryHead.contains(strMulCalTemp[18])) {
					strAnnualMonth = "(Calculated Monthly)";
				}
				sbMulcalType.append(" " + strMulCalTemp[17] + " " + uF.showData(hmSalaryMap.get(strMulCalTemp[18]), "") + strAnnualMonth);
			}
		} else if (hmSalaryMap.containsKey(strMulCalTemp[16])) {
			String strAnnualMonth1 = "";
			if (alAnnualSalaryHead.contains(strMulCalTemp[16])) {
				strAnnualMonth1 = "(Calculated Monthly)";
			}
			sbMulcalType.append(uF.showData(hmSalaryMap.get(strMulCalTemp[16]), "") + strAnnualMonth1);

			if (hmSalaryMap.containsKey(strMulCalTemp[18])) {
				String strAnnualMonth = "";
				if (alAnnualSalaryHead.contains(strMulCalTemp[18])) {
					strAnnualMonth = "(Calculated Monthly)";
				}
				sbMulcalType.append(" " + strMulCalTemp[17] + " " + uF.showData(hmSalaryMap.get(strMulCalTemp[18]), "") + strAnnualMonth);
			}
		} else if (hmSalaryMap.containsKey(strMulCalTemp[18])) {
			String strAnnualMonth = "";
			if (alAnnualSalaryHead.contains(strMulCalTemp[18])) {
				strAnnualMonth = "(Calculated Monthly)";
			}
			sbMulcalType.append(uF.showData(hmSalaryMap.get(strMulCalTemp[18]), "") + strAnnualMonth);
		}
	}

	public void getAlertUpdates(CommonFunctions CF, String empId, HttpServletRequest request, String strUserType) {

		Map<String, List<String>> hmEventUpdates = new LinkedHashMap<String, List<String>>();
		Map<String, List<String>> hmQuoteUpdates = new LinkedHashMap<String, List<String>>();
		Map<String, List<String>> hmNoticeUpdates = new LinkedHashMap<String, List<String>>();
		List<String> holidayList = new ArrayList<String>();

		Connection con = null;
		Database db = new Database();
		db.setRequest(request);
		PreparedStatement pst = null;
		ResultSet rs = null, rst = null;
		UtilityFunctions uF = new UtilityFunctions();
		try {
			con = db.makeConnection(con);
			Map<String, String> hmResourceName = CF.getEmpNameMap(con, null, null);
			Map<String, String> hmEmpLevelMap = getEmpLevelMap(con);
			String logUserLevel = hmEmpLevelMap.get(empId);
			Calendar cal = GregorianCalendar.getInstance(TimeZone.getTimeZone(CF.getStrTimeZone()));

			StringBuilder sbQuery1 = new StringBuilder();
			sbQuery1.append("SELECT * from daythoughts where  day_id = ? and year = ? order by thought_id desc");
			pst = con.prepareStatement(sbQuery1.toString());
			pst.setInt(1, cal.get(Calendar.DAY_OF_YEAR));
			pst.setInt(2, cal.get(Calendar.YEAR));
			rs = pst.executeQuery();
			String quote_alert_action = "Hub.action?type=Q";
			while (rs.next()) {
				List<String> innerList = new ArrayList<String>();
				innerList.add(quote_alert_action);// 0
				innerList.add(rs.getString("thought_text"));// 1
				innerList.add(rs.getString("thought_by"));// 2
				innerList.add(hmResourceName.get(rs.getString("added_by")));// 3
				//===start parvez date: 24-12-2021===		
				innerList.add(uF.getDateFormat(rs.getString("entry_date"), DBDATE, "dd"));// 4
				innerList.add(uF.getDateFormat(rs.getString("entry_date"), DBDATE, "MMM"));// 5
				//===end parvez date: 24-12-2021===	
				hmQuoteUpdates.put(rs.getString("thought_id"), innerList);

			}
			rs.close();
			pst.close();
			request.setAttribute("quoteUpdates", hmQuoteUpdates);

			StringBuilder sbQuery2 = new StringBuilder();
			sbQuery2.append("select * from notices where (added_by = " + empId + " or ispublish='t') and _date = ? order by notice_id desc");
			pst = con.prepareStatement(sbQuery2.toString());
			pst.setDate(1, uF.getCurrentDate(CF.getStrTimeZone()));
			rs = pst.executeQuery();
			String notice_alert_action = "Hub.action?type=A";
			while (rs.next()) {
				List<String> innerList = new ArrayList<String>();
				innerList.add(notice_alert_action);// 0
				innerList.add(rs.getString("content"));// 1
				innerList.add(rs.getString("heading"));// 2
				innerList.add(hmResourceName.get(rs.getString("added_by")));// 3
				innerList.add(uF.getDateFormat(rs.getString("posted_date"), DBTIMESTAMP, DATE_FORMAT_STR + " " + TIME_FORMAT_AM_PM));// 4
				innerList.add(hmResourceName.get(rs.getString("added_by")));// 5
				innerList.add(uF.getDateFormat(rs.getString("display_date"), DBDATE, CF.getStrReportDateFormat()));// 6
				innerList.add(uF.getDateFormat(rs.getString("display_end_date"), DBDATE, CF.getStrReportDateFormat()));// 7
				innerList.add(uF.getDateFormat(rs.getString("display_date"), DBDATE, "dd"));// 8
				innerList.add(uF.getDateFormat(rs.getString("display_date"), DBDATE, "MMM"));// 9
				hmNoticeUpdates.put(rs.getString("notice_id"), innerList);
			}
			rs.close();
			pst.close();
			request.setAttribute("noticeUpdates", hmNoticeUpdates);

			StringBuilder sbQuery3 = new StringBuilder();

			sbQuery3.append("select * from events where (sharing_level is null or length(trim(sharing_level))=0 or sharing_level like '%," + logUserLevel
					+ "%' or added_by = " + empId + ") and entry_date = ? order by event_id desc");
			pst = con.prepareStatement(sbQuery3.toString());
			pst.setDate(1, uF.getCurrentDate(CF.getStrTimeZone()));
			rs = pst.executeQuery();
			String event_alert_action = "Hub.action?type=E";
			while (rs.next()) {
				List<String> innerList = new ArrayList<String>();
				innerList.add(event_alert_action);// 0
				innerList.add(rs.getString("event_desc"));// 1
				innerList.add(rs.getString("event_title"));// 2
				innerList.add(hmResourceName.get(rs.getString("added_by")));// 3
				innerList.add(uF.getDateFormat(rs.getString("event_date"), DBDATE, DATE_FORMAT));// 4
				innerList.add(uF.getDateFormat(rs.getString("event_end_date"), DBDATE, DATE_FORMAT));// 5
				innerList.add(rs.getString("location"));// 6
				innerList.add(uF.getDateFormat(rs.getString("posted_date"), DBTIMESTAMP, DATE_FORMAT_STR + " " + TIME_FORMAT_AM_PM));// 7
				hmEventUpdates.put(rs.getString("event_id"), innerList);
			}
			rs.close();
			pst.close();
			request.setAttribute("eventUpdates", hmEventUpdates);

			Date nextDate = uF.getFutureDate(CF.getStrTimeZone(), 1);
			Date afterNextDate = uF.getFutureDate(CF.getStrTimeZone(), 2);
			String strNextDate = uF.getDateFormatUtil(nextDate, DBDATE);
			String strAfterNextDate = uF.getDateFormatUtil(afterNextDate, DBDATE);
			String strCurrDate = "" + uF.getCurrentDate(CF.getStrTimeZone());

			Map<String, String> hmWlocationMap = getWLocationMap(con, null, null);
			Map<String, String> hmOrgMap = getOrgName(con);
			HttpSession session = request.getSession();
			StringBuilder sbQuery4 = new StringBuilder();
			sbQuery4.append("select * from holidays where (_date=? or _date =? or _date = ?) and _year = ? ");

			if (strUserType != null && strUserType.equalsIgnoreCase(HRMANAGER) && (String) session.getAttribute(ORG_ACCESS) != null) {
				sbQuery4.append(" and org_id in (" + (String) session.getAttribute(ORG_ACCESS) + ")");
			} else if (strUserType != null && !strUserType.equalsIgnoreCase(ADMIN)) {
				sbQuery4.append(" and org_id in (" + (String) session.getAttribute(ORGID) + ")");
			}
			if (strUserType != null && strUserType.equalsIgnoreCase(HRMANAGER) && (String) session.getAttribute(WLOCATION_ACCESS) != null) {
				sbQuery4.append(" and wlocation_id in (" + (String) session.getAttribute(WLOCATION_ACCESS) + ")");
			} else if (strUserType != null && !strUserType.equalsIgnoreCase(ADMIN)) {
				sbQuery4.append(" and wlocation_id in (" + (String) session.getAttribute(WLOCATIONID) + ")");
			}

			pst = con.prepareStatement(sbQuery4.toString());
			pst.setDate(1, uF.getCurrentDate(CF.getStrTimeZone()));
			pst.setDate(2, nextDate);
			pst.setDate(3, afterNextDate);
			pst.setInt(4, cal.get(Calendar.YEAR));
			rs = pst.executeQuery();
			while (rs.next()) {
				String holidayType = "[Full day]";
				if (rs.getString("holiday_type") != null && rs.getString("holiday_type").equals("HD")) {
					holidayType = "[Half day]";
				}

				if (strUserType != null && (strUserType.equalsIgnoreCase(HRMANAGER) || strUserType.equalsIgnoreCase(ADMIN))) {
					if (strCurrDate.equalsIgnoreCase(rs.getString("_date"))) {
						holidayList.add("Today is holiday " + holidayType + " for " + rs.getString("description") + " ("
								+ (rs.getBoolean("is_optional_holiday") ? "Optional" : "Compulsary") + ") for "
								+ hmWlocationMap.get(rs.getString("wlocation_id")) + " location of " + hmOrgMap.get(rs.getString("org_id")));
					}
					if (strNextDate.equalsIgnoreCase(rs.getString("_date"))) {
						holidayList.add("Tomorrow is holiday " + holidayType + " for " + rs.getString("description") + " ("
								+ (rs.getBoolean("is_optional_holiday") ? "Optional" : "Compulsary") + ") for "
								+ hmWlocationMap.get(rs.getString("wlocation_id")) + " location of " + hmOrgMap.get(rs.getString("org_id")));
					}
					if (strAfterNextDate.equalsIgnoreCase(rs.getString("_date"))) {
						holidayList.add("Day after Tomorrow is holiday " + holidayType + " for " + rs.getString("description") + " ("
								+ (rs.getBoolean("is_optional_holiday") ? "Optional" : "Compulsary") + ")for "
								+ hmWlocationMap.get(rs.getString("wlocation_id")) + " location of " + hmOrgMap.get(rs.getString("org_id")));
					}
				} else {

					if (strCurrDate.equalsIgnoreCase(rs.getString("_date"))) {
						holidayList.add("Today is holiday " + holidayType + " for " + rs.getString("description") + " ("
								+ (rs.getBoolean("is_optional_holiday") ? "Optional" : "Compulsary") + ")");
					}

					if (strNextDate.equalsIgnoreCase(rs.getString("_date"))) {
						holidayList.add("Tomorrow is holiday " + holidayType + " for " + rs.getString("description") + " ("
								+ (rs.getBoolean("is_optional_holiday") ? "Optional" : "Compulsary") + ")");
					}
					if (strAfterNextDate.equalsIgnoreCase(rs.getString("_date"))) {
						holidayList.add("Day after Tomorrow is holiday " + holidayType + " for " + rs.getString("description") + " ("
								+ (rs.getBoolean("is_optional_holiday") ? "Optional" : "Compulsary") + ")");
					}
				}
			}
			rs.close();
			pst.close();
			request.setAttribute("holidays", holidayList);

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			db.closeResultSet(rs);
			db.closeStatements(pst);
			db.closeConnection(con);
		}

	}

	public void getThoughtByEmp(CommonFunctions CF, UtilityFunctions uF, String strEmpId, HttpServletRequest request) {

		Connection con = null;
		PreparedStatement pst = null;
		ResultSet rs = null;
		Database db = new Database();
		db.setRequest(request);
		Map<String, List<String>> hmthoughts = new LinkedHashMap<String, List<String>>();
		try {
			Calendar cal = GregorianCalendar.getInstance(TimeZone.getTimeZone(CF.getStrTimeZone()));
			con = db.makeConnection(con);
			pst = con.prepareStatement("SELECT * from daythoughts where day_id = ? and year = ?");

			pst.setInt(1, cal.get(Calendar.DAY_OF_YEAR));
			pst.setInt(2, cal.get(Calendar.YEAR));

			rs = pst.executeQuery();
			while (rs.next()) {
				List<String> thoughtList = new ArrayList<String>();
				thoughtList.add(rs.getString("thought_text"));
				thoughtList.add(rs.getString("thought_by"));
				hmthoughts.put(rs.getString("thought_id"), thoughtList);
			}
			request.setAttribute("hmthoughts", hmthoughts);
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			db.closeResultSet(rs);
			db.closeStatements(pst);
			db.closeConnection(con);
		}
	}

	public Map<String, String> getAnswerTypeMap(HttpServletRequest request) {

		Map<String, String> hmAnswerTypes = new HashMap<String, String>();
		PreparedStatement pst = null;
		ResultSet rs = null;
		Connection con = null;
		Database db = new Database();
		db.setRequest(request);

		try {

			con = db.makeConnection(con);
			pst = con.prepareStatement("select * from appraisal_answer_type");
			rs = pst.executeQuery();
			while (rs.next()) {
				hmAnswerTypes.put(rs.getString("appraisal_answer_type_id"), rs.getString("appraisal_answer_type_name"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			db.closeResultSet(rs);
			db.closeStatements(pst);
			db.closeConnection(con);
		}
		return hmAnswerTypes;

	}

	public Map<String, String> getQuestionBank(Connection con, UtilityFunctions uF) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmQuestionBank = new HashMap<String, String>();
		try {
			pst = con.prepareStatement("select question_bank_id,question_text from question_bank");
			rs = pst.executeQuery();
			while (rs.next()) {
				hmQuestionBank.put(rs.getString("question_bank_id"), uF.showData(rs.getString("question_text"), ""));
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
		}
		return hmQuestionBank;
	}

	public Map<String, String> getCustNameMap(Connection con) {

		Map<String, String> hmCustName = new HashMap<String, String>();

		PreparedStatement pst = null;
		ResultSet rs = null;

		try {
			pst = con.prepareStatement("select * from client_poc ");
			// System.out.println("pst=====>"+pst);
			rs = pst.executeQuery();

			while (rs.next()) {
				if (rs.getInt("poc_id") < 0) {
					continue;
				}
				hmCustName.put(rs.getString("poc_id"),
						rs.getString("contact_fname") + " " + uF.showData(rs.getString("contact_mname"), "") + " " + rs.getString("contact_lname"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmCustName;
	}

	public Map<String, String> getAnswerTypeMap(Connection con) {

		Map<String, String> hmAnswerTypes = new HashMap<String, String>();
		PreparedStatement pst = null;
		ResultSet rs = null;
		try {

			pst = con.prepareStatement("select * from appraisal_answer_type");
			rs = pst.executeQuery();
			while (rs.next()) {
				hmAnswerTypes.put(rs.getString("appraisal_answer_type_id"), rs.getString("appraisal_answer_type_name"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmAnswerTypes;
	}

	public Map<String, String> getEmpIdCodeMap(Connection con) {

		Map<String, String> hmEmpIdCode = new HashMap<String, String>();
		PreparedStatement pst = null;
		ResultSet rs = null;
		try {

			pst = con.prepareStatement("select * from employee_personal_details");
			rs = pst.executeQuery();
			while (rs.next()) {
				hmEmpIdCode.put(rs.getString("emp_per_id"), rs.getString("empcode"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmEmpIdCode;
	}

	public Map<String, String> getCandNameMap(Connection con, String struserType, String strEmpId) {

		Map<String, String> hmCandNameMap = new HashMap<String, String>();
		PreparedStatement pst = null;
		ResultSet rs = null;

		try {

			Map<String, String> hmFeatureStatus = getFeatureStatusMap(con);
			boolean flagMiddleName = uF.parseToBoolean(hmFeatureStatus.get(F_SHOW_EMPLOYEE_MIDDLE_NAME));

			pst = con.prepareStatement("select * from candidate_personal_details");
			rs = pst.executeQuery();
			while (rs.next()) {

				String strEmpMName = "";

				if (flagMiddleName) {
					if (rs.getString("emp_mname") != null && rs.getString("emp_mname").trim().length() > 0) {
						strEmpMName = " " + rs.getString("emp_mname");
					}
				}

				hmCandNameMap.put(rs.getString("emp_per_id"), rs.getString("emp_fname") + strEmpMName + " " + rs.getString("emp_lname"));
			}

			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmCandNameMap;
	}

	public Map<String, String> getEmpUserIdMap(Connection con) {

		PreparedStatement pst = null;
		ResultSet rs = null;

		Map<String, String> hmEmpUserId = new HashMap<String, String>();

		try {
			pst = con.prepareStatement("SELECT * FROM user_details");
			rs = pst.executeQuery();
			while (rs.next()) {
				hmEmpUserId.put(rs.getString("emp_id"), rs.getString("usertype_id"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

		return hmEmpUserId;
	}

	/*
	 * public void getHolidayList(Connection con,String strD1, String strD2,
	 * CommonFunctions CF, Map<String, String> hmHolidayDates, Map<String,
	 * String> hmHolidays, boolean isWithLocation) {
	 * 
	 * PreparedStatement pst = null; ResultSet rs = null;
	 * 
	 * try {
	 * 
	 * HttpSession session = request.getSession(true); //
	 * System.out.println("orgId==>"+ (String)session.getAttribute(ORGID)); if
	 * (strD1 != null && strD2 != null) { pst =
	 * con.prepareStatement(selectHolidaysR2); pst.setDate(1,
	 * uF.getDateFormat(strD1, DATE_FORMAT)); pst.setDate(2,
	 * uF.getDateFormat(strD2, DATE_FORMAT)); pst.setInt(3,
	 * uF.parseToInt((String)session.getAttribute(ORGID))); } else { pst =
	 * con.prepareStatement(selectHolidaysR1); pst.setInt(1,
	 * uF.parseToInt(uF.getDateFormat(uF.getCurrentDate(CF.getStrTimeZone()) +
	 * "", DBDATE, "yyyy"))); pst.setInt(2,
	 * uF.parseToInt((String)session.getAttribute(ORGID))); } //
	 * System.out.println("pst======>"+pst); rs = pst.executeQuery();
	 * 
	 * while (rs.next()) {
	 * 
	 * if (isWithLocation) { if (hmHolidayDates != null &&
	 * !hmHolidayDates.containsKey(uF.getDateFormat(rs.getString("_date"),
	 * DBDATE, CF.getStrReportDateFormat()) + "_" +
	 * rs.getString("wlocation_id"))) {
	 * hmHolidayDates.put(uF.getDateFormat(rs.getString("_date"), DBDATE,
	 * CF.getStrReportDateFormat()) + "_" + rs.getString("wlocation_id"),
	 * rs.getString("colour_code")); int count = uF.parseToInt(
	 * hmHolidays.get(rs.getString("wlocation_id")));
	 * hmHolidays.put(rs.getString("wlocation_id"), (count + 1) + ""); } } else
	 * { if (hmHolidayDates != null &&
	 * !hmHolidayDates.containsKey(uF.getDateFormat(rs.getString("_date"),
	 * DBDATE, CF.getStrReportDateFormat()))) {
	 * hmHolidayDates.put(uF.getDateFormat(rs.getString("_date"), DBDATE,
	 * CF.getStrReportDateFormat()), rs.getString("colour_code")); int count =
	 * uF.parseToInt( hmHolidays.get(rs.getString("wlocation_id")));
	 * hmHolidays.put(rs.getString("wlocation_id"), (count + 1) + ""); } }
	 * 
	 * } rs.close(); pst.close();
	 * 
	 * } catch (Exception e) { e.printStackTrace(); } finally { if(rs != null) {
	 * try { rs.close(); } catch (SQLException e1) { e1.printStackTrace(); } }
	 * if(pst != null) { try { pst.close(); } catch (SQLException e1) {
	 * e1.printStackTrace(); } } } }
	 */

	public Map<String, String> getLevelLeaveTypeBalanceForEmp(Connection con, CommonFunctions CF, UtilityFunctions uF, int orgId, int wLocationId, int levelId,
			String joiningDate, String empStatus, String strLeaves) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		PreparedStatement pst1 = null;
		ResultSet rs1 = null;
		
		Map<String, String> hmProRataLeaveBalance = new HashMap<String, String>();
		try {
			
			Map<String, String> hmFeatureStatus = CF.getFeatureStatusMap(con);

			List<String> alEmpLeaves = null;
			if (strLeaves != null && strLeaves.length() > 0) {
				alEmpLeaves = Arrays.asList(strLeaves.split(","));
			}
			if (alEmpLeaves == null)
				alEmpLeaves = new ArrayList<String>();

			StringBuilder sbLeaves = null;
			for (String strLeaveId : alEmpLeaves) {
				if (sbLeaves == null) {
					sbLeaves = new StringBuilder();
					sbLeaves.append(strLeaveId);
				} else {
					sbLeaves.append("," + strLeaveId);
				}
			}

			if (sbLeaves != null) {
				String strCurrentDate = uF.getDateFormat("" + uF.getCurrentDate(CF.getStrTimeZone()), DBDATE, DATE_FORMAT);

				StringBuilder sbQuery = new StringBuilder();
				sbQuery.append("select * from emp_leave_type elt, leave_type lt where level_id = ? "
						+ "and wlocation_id = ? and elt.org_id = ? and elt.leave_type_id = lt.leave_type_id"
						+ " and lt.is_compensatory=false and elt.is_constant_balance=false ");
				sbQuery.append(" and (elt.leave_available like '%,0,%' OR elt.leave_available like '%," + uF.parseToInt(empStatus) + ",%')"
						+ " and (lt.is_leave_opt_holiday is null or lt.is_leave_opt_holiday = false) ");
				pst = con.prepareStatement(sbQuery.toString());
				pst.setInt(1, levelId);
				pst.setInt(2, wLocationId);
				pst.setInt(3, orgId);
//				 System.out.println("CF/31328 pst ========>> " + pst);
				rs = pst.executeQuery();
				while (rs.next()) {
					double dblTotal = 0;

					if (uF.parseToBoolean(rs.getString("is_leave_accrual"))) {
						if (uF.parseToInt(rs.getString("accrual_type")) == 2 && uF.parseToBoolean(rs.getString("is_accrued_cal_days"))) {
							if ("CY".equalsIgnoreCase(rs.getString("effective_date_type"))) {
								java.util.Date dateJoin = uF.getDateFormatUtil(joiningDate, DATE_FORMAT);
								java.util.Date dateCY = uF.getDateFormatUtil("01/01/" + uF.getYear(), DATE_FORMAT);
								String strJoinDate = joiningDate;
								if (dateJoin.before(dateCY)) {
									strJoinDate = "01/01/" + uF.getYear();
								}
								dblTotal = CF.getAccuralLeavesCount(CF, uF, strJoinDate, strCurrentDate, rs.getDouble("no_of_leave_monthly"));
								// System.out.println("joiningDate==>>"+joiningDate+"--strJoinDate==>>"+strJoinDate+"--dblTotal==>"+dblTotal);
							} else if ("FY".equalsIgnoreCase(rs.getString("effective_date_type"))) {
								java.util.Date dateJoin = uF.getDateFormatUtil(joiningDate, DATE_FORMAT);
								java.util.Date dateCY = uF.getDateFormatUtil(CF.getStrFinancialYearTo(), DATE_FORMAT);
								String strJoinDate = joiningDate;
								if (dateJoin.before(dateCY)) {
									strJoinDate = "01/04/" + uF.getYear();
								}
								dblTotal = CF.getAccuralLeavesCount(CF, uF, strJoinDate, strCurrentDate, rs.getDouble("no_of_leave_monthly"));
								// System.out.println("FY dblTotal ========>> "
								// +
								// dblTotal+"--uF.getYear()==>"+uF.getYear()+"--no_of_leave==>"+rs.getDouble("no_of_leave"));
							} else {
								java.util.Date dateJoin = uF.getDateFormatUtil(joiningDate, DATE_FORMAT);
								java.util.Date dateCY = uF.getDateFormatUtil("01/01/" + uF.getYear(), DATE_FORMAT);
								String strJoinDate = joiningDate;
								if (dateJoin.before(dateCY)) {
									strJoinDate = "01/01/" + uF.getYear();
								}
								dblTotal = CF.getAccuralLeavesCount(CF, uF, strJoinDate, strCurrentDate, rs.getDouble("no_of_leave_monthly"));
							}
						} else if (uF.parseToInt(rs.getString("accrual_type")) == 1) {
							if ("CY".equalsIgnoreCase(rs.getString("effective_date_type"))) {
								java.util.Date dateJoin = uF.getDateFormatUtil(joiningDate, DATE_FORMAT);
								java.util.Date dateCY = uF.getDateFormatUtil("01/01/" + uF.getYear(), DATE_FORMAT);
								String strJoinDate = joiningDate;
								if (dateJoin.before(dateCY)) {
									strJoinDate = "01/01/" + uF.getYear();
								}
//								dblTotal = CF.getLeavesCount1(strJoinDate, strCurrentDate, rs.getDouble("no_of_leave"), rs.getBoolean("is_carryforward"), CF);
								
								if(hmFeatureStatus!=null && uF.parseToBoolean(hmFeatureStatus.get(F_LEAVE_BALANCE_FOR_EMPLOYEE_JOINING_MONTH))){
									int nday = uF.parseToInt(uF.getDateFormat(joiningDate, DATE_FORMAT, "dd"));
//									System.out.println("CF/31402---nday=="+nday+"---joining_month_day_date=="+rs.getString("joining_month_day_date"));
									if(uF.parseToInt(rs.getString("joining_month_day_date")) > 0 && nday > uF.parseToInt(rs.getString("joining_month_day_date"))){
//										dblTotal = rs.getDouble("joining_month_balance");
										dblTotal = CF.getLeavesCount11(strJoinDate, strCurrentDate, rs.getDouble("no_of_leave"), rs.getDouble("joining_month_balance"), rs.getBoolean("is_carryforward"), CF);
									} else{
										dblTotal = CF.getLeavesCount1(strJoinDate, strCurrentDate, rs.getDouble("no_of_leave"), rs.getBoolean("is_carryforward"), CF);
									}
								} else{
									dblTotal = CF.getLeavesCount1(strJoinDate, strCurrentDate, rs.getDouble("no_of_leave"), rs.getBoolean("is_carryforward"), CF);
								}
							} else if ("FY".equalsIgnoreCase(rs.getString("effective_date_type"))) {
								java.util.Date dateJoin = uF.getDateFormatUtil(joiningDate, DATE_FORMAT);
								java.util.Date dateCY = uF.getDateFormatUtil(CF.getStrFinancialYearTo(), DATE_FORMAT);
								String strJoinDate = joiningDate;
								if (dateJoin.before(dateCY)) {
									strJoinDate = "01/04/" + uF.getYear();
								}
//								dblTotal = CF.getLeavesCount1(strJoinDate, strCurrentDate, rs.getDouble("no_of_leave"), rs.getBoolean("is_carryforward"), CF);
								if(hmFeatureStatus!=null && uF.parseToBoolean(hmFeatureStatus.get(F_LEAVE_BALANCE_FOR_EMPLOYEE_JOINING_MONTH))){
									int nday = uF.parseToInt(uF.getDateFormat(joiningDate, DATE_FORMAT, "dd"));
									if(uF.parseToInt(rs.getString("joining_month_day_date")) > 0 && nday > uF.parseToInt(rs.getString("joining_month_day_date"))){
//										dblTotal = rs.getDouble("joining_month_balance");
										dblTotal = CF.getLeavesCount11(strJoinDate, strCurrentDate, rs.getDouble("no_of_leave"), rs.getDouble("joining_month_balance"), rs.getBoolean("is_carryforward"), CF);
									} else{
										dblTotal = CF.getLeavesCount1(strJoinDate, strCurrentDate, rs.getDouble("no_of_leave"), rs.getBoolean("is_carryforward"), CF);
									}
								} else{
									dblTotal = CF.getLeavesCount1(strJoinDate, strCurrentDate, rs.getDouble("no_of_leave"), rs.getBoolean("is_carryforward"), CF);
								}
							} else {
								java.util.Date dateJoin = uF.getDateFormatUtil(joiningDate, DATE_FORMAT);
								java.util.Date dateCY = uF.getDateFormatUtil("01/01/" + uF.getYear(), DATE_FORMAT);
								String strJoinDate = joiningDate;
								if (dateJoin.before(dateCY)) {
									strJoinDate = "01/01/" + uF.getYear();
								}
//								dblTotal = CF.getLeavesCount1(strJoinDate, strCurrentDate, rs.getDouble("no_of_leave"), rs.getBoolean("is_carryforward"), CF);
								if(hmFeatureStatus!=null && uF.parseToBoolean(hmFeatureStatus.get(F_LEAVE_BALANCE_FOR_EMPLOYEE_JOINING_MONTH))){
									int nday = uF.parseToInt(uF.getDateFormat(joiningDate, DATE_FORMAT, "dd"));
									if(uF.parseToInt(rs.getString("joining_month_day_date")) > 0 && nday > uF.parseToInt(rs.getString("joining_month_day_date"))){
//										dblTotal = rs.getDouble("joining_month_balance");
										dblTotal = CF.getLeavesCount11(strJoinDate, strCurrentDate, rs.getDouble("no_of_leave"), rs.getDouble("joining_month_balance"), rs.getBoolean("is_carryforward"), CF);
									} else{
										dblTotal = CF.getLeavesCount1(strJoinDate, strCurrentDate, rs.getDouble("no_of_leave"), rs.getBoolean("is_carryforward"), CF);
									}
								} else{
									dblTotal = CF.getLeavesCount1(strJoinDate, strCurrentDate, rs.getDouble("no_of_leave"), rs.getBoolean("is_carryforward"), CF);
								}
							}
						}
					} else {
						if (uF.parseToBoolean(rs.getString("is_prorata"))) {
							if ("CY".equalsIgnoreCase(rs.getString("effective_date_type"))) {
								java.util.Date dateJoin = uF.getDateFormatUtil(joiningDate, DATE_FORMAT);
								java.util.Date dateCY = uF.getDateFormatUtil("01/01/" + uF.getYear(), DATE_FORMAT);
								String strJoinDate = joiningDate;
								if (dateJoin.before(dateCY)) {
									strJoinDate = "01/01/" + uF.getYear();
								}
								dblTotal = CF.getLeavesCount1(strJoinDate, uF.getDateFormat("31/12/" + uF.getYear(), DATE_FORMAT, DATE_FORMAT),
										rs.getDouble("no_of_leave"), rs.getBoolean("is_carryforward"), CF);
							} else if ("FY".equalsIgnoreCase(rs.getString("effective_date_type"))) {
								java.util.Date dateJoin = uF.getDateFormatUtil(joiningDate, DATE_FORMAT);
								java.util.Date dateCY = uF.getDateFormatUtil(CF.getStrFinancialYearTo(), DATE_FORMAT);
								String strJoinDate = joiningDate;
								if (dateJoin.before(dateCY)) {
									strJoinDate = "01/04/" + uF.getYear();
								}
								dblTotal = CF.getLeavesCount1(strJoinDate, CF.getStrFinancialYearTo(), rs.getDouble("no_of_leave"),
										rs.getBoolean("is_carryforward"), CF);
							} else {
								java.util.Date dateJoin = uF.getDateFormatUtil(joiningDate, DATE_FORMAT);
								java.util.Date dateCY = uF.getDateFormatUtil("01/01/" + uF.getYear(), DATE_FORMAT);
								String strJoinDate = joiningDate;
								if (dateJoin.before(dateCY)) {
									strJoinDate = "01/01/" + uF.getYear();
								}
								dblTotal = CF.getLeavesCount1(strJoinDate, uF.getDateFormat("31/12/" + uF.getYear(), DATE_FORMAT, DATE_FORMAT),
										rs.getDouble("no_of_leave"), rs.getBoolean("is_carryforward"), CF);
							}
						} else {
							if (!uF.parseToBoolean(rs.getString("is_leave_accrual"))) {
								dblTotal = rs.getDouble("no_of_leave");
							}
						}
					}

					if (rs.getInt("leave_type_id") > 0 && dblTotal > 0) {
						hmProRataLeaveBalance.put(rs.getString("leave_type_id"), "" + dblTotal);
					}
				}
				rs.close();
				pst.close();
//				System.out.println("hmProRataLeaveBalance ==========>> " + hmProRataLeaveBalance);
				
				int strDistributedMonth = 0;
				pst1 = con.prepareStatement("select * from emp_leave_type where level_id=? and wlocation_id=? and org_id=? and distributed_month>0");
				pst1.setInt(1, levelId);
				pst1.setInt(2, wLocationId);
				pst1.setInt(3, orgId);
				rs1 = pst1.executeQuery();
				while(rs1.next()){
					strDistributedMonth = uF.parseToInt(rs1.getString("distributed_month"));
				
					if(strDistributedMonth > 0){
						java.util.Date empJoinDate = uF.getDateFormatUtil(joiningDate, DATE_FORMAT);
						java.util.Date dateCY1 = uF.getDateFormatUtil("01/01/" + uF.getYear(), DATE_FORMAT);
						if(empJoinDate.after(dateCY1)){
							int distributedMonth = 12/strDistributedMonth;
	//						System.out.println("CF/20645--distributedMoth="+distributedMonth);
	//						System.out.println("CF/20645--strDistributedMonth="+strDistributedMonth);
							String strLeaveBalance = rs1.getString("no_of_leave");
//							System.out.println("strLeaveBalance ===>> " + strLeaveBalance);
							double leaveBalance1 = uF.parseToDouble(strLeaveBalance) / distributedMonth;
							List<List<String>> distributedMonthList = new ArrayList<List<String>>();
							List<String> monthList = new ArrayList<String>();
							int mnthCnt=0;
							for(int i = 1; i <= 12; i++){
	//							System.out.println("CF/20651--uF.getMonth(i)="+uF.getMonth(i));
								monthList.add(uF.getMonth(i));
//								System.out.println("CF/20651--monthList="+monthList);
								mnthCnt++;
								if(mnthCnt == strDistributedMonth) {
									distributedMonthList.add(monthList);
									monthList = new ArrayList<String>();
	//								System.out.println("CF/20655--monthList="+monthList);
									mnthCnt=0;
								}
							}
							
//							System.out.println("distributedMonthList ===>> "+ distributedMonthList);
//							System.out.println("leaveBalance1 ===>> " + leaveBalance1);
							int leaveDistCnt = 0;
							int joinMonth = empJoinDate.getMonth()+1;
//							System.out.println("CF/20663--joinMonth="+joinMonth);
							for(int i=0; distributedMonthList!=null && i<distributedMonthList.size(); i++) {
								List<String> innerList = distributedMonthList.get(i);
//								System.out.println("CF/20666--innerList="+innerList);
								if(innerList.contains(uF.getMonth(joinMonth))){
									leaveDistCnt = distributedMonthList.size()-i;
//									System.out.println("CF/20669--leaveDistCnt="+leaveDistCnt);
									break;
								}
							}
							
							strLeaveBalance = ""+(leaveBalance1 * leaveDistCnt);
							
//							System.out.println("CF/20647--strLeaveBalance="+strLeaveBalance);
							hmProRataLeaveBalance.put(rs1.getString("leave_type_id"), strLeaveBalance);
						}
					}
				}
				rs1.close();
				pst1.close();
				
				/*//===start parvez on 31-07-2021===
				int strDistributedMonth = 0;
				pst = con.prepareStatement("select * from emp_leave_type where level_id=? and wlocation_id=? and org_id=? and distributed_month>0");
				pst.setInt(1, levelId);
				pst.setInt(2, wLocationId);
				pst.setInt(3, orgId);
				rs = pst.executeQuery();
				while(rs.next()){
					strDistributedMonth = uF.parseToInt(rs.getString("distributed_month"));
//					if(strDistributedMonth > 0){
						java.util.Date empJoinDate = uF.getDateFormatUtil(joiningDate, DATE_FORMAT);
						java.util.Date dateCY1 = uF.getDateFormatUtil("01/01/" + uF.getYear(), DATE_FORMAT);
						if(empJoinDate.after(dateCY1)){
							int distributedMonth = 12/strDistributedMonth;
							System.out.println("CF/31024--distributedMoth="+distributedMonth);
							System.out.println("CF/31025--strDistributedMonth="+strDistributedMonth);
							String strLeaveBalance = hmProRataLeaveBalance.get(rs.getString("leave_type_id"));
							double leaveBalance1 = uF.parseToDouble(strLeaveBalance) / distributedMonth;
							System.out.println("CF/31028--strLeaveBalance="+strLeaveBalance);
							System.out.println("CF/31029--leaveBalance1="+leaveBalance1);
							List<List<String>> distributedMonthList = new ArrayList<List<String>>();
							List<String> monthList = new ArrayList<String>();
							int mnthCnt=0;
							for(int i = 1; i <= 12; i++){
//								System.out.println("CF/20651--uF.getMonth(i)="+uF.getMonth(i));
								monthList.add(uF.getMonth(i));
//								System.out.println("CF/31034--monthList="+monthList);
								mnthCnt++;
								if(mnthCnt == strDistributedMonth) {
									distributedMonthList.add(monthList);
									monthList = new ArrayList<String>();
//									System.out.println("CF/20655--monthList="+monthList);
									mnthCnt=0;
								}
							}
							
							System.out.println("distributedMonthList ===>> "+ distributedMonthList);
							
							int leaveDistCnt = 0;
							int joinMonth = empJoinDate.getMonth()+1;
							System.out.println("CF/31048--joinMonth="+joinMonth);
							for(int i=0; distributedMonthList!=null && i<distributedMonthList.size(); i++) {
								List<String> innerList = distributedMonthList.get(i);
//								leaveDistCnt++;
								System.out.println("CF/31052--innerList="+innerList);
								if(innerList.contains(uF.getMonth(joinMonth))){
									leaveDistCnt = distributedMonthList.size()-i;
									System.out.println("CF/31055--leaveDistCnt="+leaveDistCnt);
									if(strDistributedMonth == 3 && (uF.getMonth(joinMonth).equalsIgnoreCase("July")||
											uF.getMonth(joinMonth).equalsIgnoreCase("August")||uF.getMonth(joinMonth).equalsIgnoreCase("September"))){
										leaveDistCnt = leaveDistCnt+1;
										System.out.println("CF/31059--====>>>XXX="+distributedMonthList);
									}
									break;
								}
							}
							
							strLeaveBalance = ""+(leaveBalance1 * leaveDistCnt);
							hmProRataLeaveBalance.put(rs.getString("leave_type_id"), strLeaveBalance);
							System.out.println("CF/31067--strLeaveBalance="+strLeaveBalance);
						}
//					}
				}
				rs.close();
				pst.close();
				
				//===end parvez on 31-07-2021===
*/
				// System.out.println("alExistLeave ========>> " +
				// alExistLeave);
			}
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmProRataLeaveBalance;
	}

	public Map<String, String> getLevelLeaveTypeBalanceForEmp(Connection con, CommonFunctions CF, UtilityFunctions uF, int nEmpId, int orgId, int wLocationId,
			int levelId, String joiningDate, String empStatus, String strLeaves, List<String> alExistLeave) {

		PreparedStatement pst = null,pst1 = null;
		ResultSet rs = null, rs1 = null;
		Map<String, String> hmProRataLeaveBalance = new HashMap<String, String>();
		try {

			Map<String, String> hmFeatureStatus = CF.getFeatureStatusMap(con);
			List<String> alEmpLeaves1 = null;
			if (strLeaves != null && strLeaves.length() > 0) {
				alEmpLeaves1 = Arrays.asList(strLeaves.split(","));
			}
			if (alEmpLeaves1 == null)
				alEmpLeaves1 = new ArrayList<String>();

			StringBuilder sbLeaves = null;
			for (String strLeaveId : alEmpLeaves1) {
				if (sbLeaves == null) {
					sbLeaves = new StringBuilder();
					sbLeaves.append(strLeaveId);
				} else {
					sbLeaves.append("," + strLeaveId);
				}
			}

			if (sbLeaves != null) {
				String strCurrentDate = uF.getDateFormat("" + uF.getCurrentDate(CF.getStrTimeZone()), DBDATE, DATE_FORMAT);

				pst = con.prepareStatement("select * from probation_policy where emp_id = ?");
				pst.setInt(1, nEmpId);
				rs = pst.executeQuery();
				String strAllowedLeaves = null;
				boolean isProbation = false;
				while (rs.next()) {
					strAllowedLeaves = rs.getString("leaves_types_allowed");
					isProbation = true;
				}
				rs.close();
				pst.close();
				// System.out.println("strAllowedLeaves ===>> " +
				// strAllowedLeaves);
				// System.out.println("isProbation ===>> " + isProbation);

				List<String> alEmpLeaves = null;
				if (strAllowedLeaves != null && strAllowedLeaves.length() > 0) {
					alEmpLeaves = Arrays.asList(strAllowedLeaves.split(","));
				}
				if (alEmpLeaves == null)
					alEmpLeaves = new ArrayList<String>();

				StringBuilder sbQuery = new StringBuilder();
				sbQuery.append("select * from emp_leave_type elt, leave_type lt where level_id = ? "
						+ "and wlocation_id = ? and elt.org_id = ? and elt.leave_type_id = lt.leave_type_id"
						+ " and lt.is_compensatory=false and elt.is_constant_balance=false ");
				sbQuery.append(" and (elt.leave_available like '%,0,%' OR elt.leave_available like '%," + uF.parseToInt(empStatus) + ",%')"
						+ " and (lt.is_leave_opt_holiday is null or lt.is_leave_opt_holiday = false) ");
				pst = con.prepareStatement(sbQuery.toString());
				pst.setInt(1, levelId);
				pst.setInt(2, wLocationId);
				pst.setInt(3, orgId);
//				 System.out.println("CF/31648--pst ========>> " + pst);
				rs = pst.executeQuery();
				while (rs.next()) {
					// if (isProbation &&
					// !alEmpLeaves.contains(rs.getString("leave_type_id"))) {
					// continue;
					// }

					double dblTotal = 0;
					
//					 System.out.println("CF/31657---leave_name="+ rs.getString("leave_type_name") +"--is_leave_accrual ===>> " + rs.getString("is_leave_accrual")+"--is_prorata ===>> " + rs.getString("is_prorata"));
					if (uF.parseToBoolean(rs.getString("is_leave_accrual"))) {
						if (uF.parseToInt(rs.getString("accrual_type")) == 2 && uF.parseToBoolean(rs.getString("is_accrued_cal_days"))) {
							if ("CY".equalsIgnoreCase(rs.getString("effective_date_type"))) {
								java.util.Date dateJoin = uF.getDateFormatUtil(joiningDate, DATE_FORMAT);
								java.util.Date dateCY = uF.getDateFormatUtil("01/01/" + uF.getYear(), DATE_FORMAT);
								String strJoinDate = joiningDate;
								if (dateJoin.before(dateCY)) {
									strJoinDate = "01/01/" + uF.getYear();
								}
								dblTotal = CF.getAccuralLeavesCount(CF, uF, strJoinDate, strCurrentDate, rs.getDouble("no_of_leave_monthly"));
							} else if ("FY".equalsIgnoreCase(rs.getString("effective_date_type"))) {
								java.util.Date dateJoin = uF.getDateFormatUtil(joiningDate, DATE_FORMAT);
								java.util.Date dateCY = uF.getDateFormatUtil(CF.getStrFinancialYearTo(), DATE_FORMAT);
								String strJoinDate = joiningDate;
								if (dateJoin.before(dateCY)) {
									strJoinDate = "01/04/" + uF.getYear();
								}
								dblTotal = CF.getAccuralLeavesCount(CF, uF, strJoinDate, strCurrentDate, rs.getDouble("no_of_leave_monthly"));
								// System.out.println("FY dblTotal ========>> "+dblTotal+"--uF.getYear()==>"+uF.getYear()+"--no_of_leave==>"+rs.getDouble("no_of_leave"));
							} else {
								java.util.Date dateJoin = uF.getDateFormatUtil(joiningDate, DATE_FORMAT);
								java.util.Date dateCY = uF.getDateFormatUtil("01/01/" + uF.getYear(), DATE_FORMAT);
								String strJoinDate = joiningDate;
								if (dateJoin.before(dateCY)) {
									strJoinDate = "01/01/" + uF.getYear();
								}
								dblTotal = CF.getAccuralLeavesCount(CF, uF, strJoinDate, strCurrentDate, rs.getDouble("no_of_leave_monthly"));
							}
						} else if (uF.parseToInt(rs.getString("accrual_type")) == 1) {
							if ("CY".equalsIgnoreCase(rs.getString("effective_date_type"))) {
								java.util.Date dateJoin = uF.getDateFormatUtil(joiningDate, DATE_FORMAT);
								java.util.Date dateCY = uF.getDateFormatUtil("01/01/" + uF.getYear(), DATE_FORMAT);
								String strJoinDate = joiningDate;
								if (dateJoin.before(dateCY)) {
									strJoinDate = "01/01/" + uF.getYear();
								}
								
//								dblTotal = CF.getLeavesCount1(strJoinDate, strCurrentDate, rs.getDouble("no_of_leave"), rs.getBoolean("is_carryforward"), CF);
//								System.out.println("CF/31711----leave_type_id===>"+rs.getString("leave_type_id"));
								if(hmFeatureStatus!=null && uF.parseToBoolean(hmFeatureStatus.get(F_LEAVE_BALANCE_FOR_EMPLOYEE_JOINING_MONTH))){
									int nday = uF.parseToInt(uF.getDateFormat(joiningDate, DATE_FORMAT, "dd"));
									if(uF.parseToInt(rs.getString("joining_month_day_date")) > 0 && nday > uF.parseToInt(rs.getString("joining_month_day_date"))){
//										dblTotal = rs.getDouble("joining_month_balance");
										dblTotal = getLeavesCount11(strJoinDate, strCurrentDate, rs.getDouble("no_of_leave"), rs.getDouble("joining_month_balance"), rs.getBoolean("is_carryforward"), CF);
									} else{
										dblTotal = CF.getLeavesCount1(strJoinDate, strCurrentDate, rs.getDouble("no_of_leave"), rs.getBoolean("is_carryforward"), CF);
									}
								} else{
									dblTotal = CF.getLeavesCount1(strJoinDate, strCurrentDate, rs.getDouble("no_of_leave"), rs.getBoolean("is_carryforward"), CF);
								}
							} else if ("FY".equalsIgnoreCase(rs.getString("effective_date_type"))) {
								java.util.Date dateJoin = uF.getDateFormatUtil(joiningDate, DATE_FORMAT);
								java.util.Date dateCY = uF.getDateFormatUtil(CF.getStrFinancialYearTo(), DATE_FORMAT);
								String strJoinDate = joiningDate;
								if (dateJoin.before(dateCY)) {
									strJoinDate = "01/04/" + uF.getYear();
								}
//								dblTotal = CF.getLeavesCount1(strJoinDate, strCurrentDate, rs.getDouble("no_of_leave"), rs.getBoolean("is_carryforward"), CF);
								if(hmFeatureStatus!=null && uF.parseToBoolean(hmFeatureStatus.get(F_LEAVE_BALANCE_FOR_EMPLOYEE_JOINING_MONTH))){
									int nday = uF.parseToInt(uF.getDateFormat(joiningDate, DATE_FORMAT, "dd"));
									if(uF.parseToInt(rs.getString("joining_month_day_date")) > 0 && nday > uF.parseToInt(rs.getString("joining_month_day_date"))){
//										dblTotal = rs.getDouble("joining_month_balance");
										dblTotal = getLeavesCount11(strJoinDate, strCurrentDate, rs.getDouble("no_of_leave"), rs.getDouble("joining_month_balance"), rs.getBoolean("is_carryforward"), CF);
									} else{
										dblTotal = CF.getLeavesCount1(strJoinDate, strCurrentDate, rs.getDouble("no_of_leave"), rs.getBoolean("is_carryforward"), CF);
									}
								} else{
									dblTotal = CF.getLeavesCount1(strJoinDate, strCurrentDate, rs.getDouble("no_of_leave"), rs.getBoolean("is_carryforward"), CF);
								}
							} else {
								java.util.Date dateJoin = uF.getDateFormatUtil(joiningDate, DATE_FORMAT);
								java.util.Date dateCY = uF.getDateFormatUtil("01/01/" + uF.getYear(), DATE_FORMAT);
								String strJoinDate = joiningDate;
								if (dateJoin.before(dateCY)) {
									strJoinDate = "01/01/" + uF.getYear();
								}
//								dblTotal = CF.getLeavesCount1(strJoinDate, strCurrentDate, rs.getDouble("no_of_leave"), rs.getBoolean("is_carryforward"), CF);
								if(hmFeatureStatus!=null && uF.parseToBoolean(hmFeatureStatus.get(F_LEAVE_BALANCE_FOR_EMPLOYEE_JOINING_MONTH))){
									int nday = uF.parseToInt(uF.getDateFormat(joiningDate, DATE_FORMAT, "dd"));
									if(uF.parseToInt(rs.getString("joining_month_day_date")) > 0 && nday > uF.parseToInt(rs.getString("joining_month_day_date"))){
//										dblTotal = rs.getDouble("joining_month_balance");
										dblTotal = getLeavesCount11(strJoinDate, strCurrentDate, rs.getDouble("no_of_leave"), rs.getDouble("joining_month_balance"), rs.getBoolean("is_carryforward"), CF);
									} else{
										dblTotal = CF.getLeavesCount1(strJoinDate, strCurrentDate, rs.getDouble("no_of_leave"), rs.getBoolean("is_carryforward"), CF);
									}
								} else{
									dblTotal = CF.getLeavesCount1(strJoinDate, strCurrentDate, rs.getDouble("no_of_leave"), rs.getBoolean("is_carryforward"), CF);
								}
							}
						}
					} else {
						if (uF.parseToBoolean(rs.getString("is_prorata"))) {
							if(rs.getInt("leave_type_id")==1){
								System.out.println("CF/31741---Pro_Rata=="+rs.getString("is_prorata"));
							}
							
							if ("CY".equalsIgnoreCase(rs.getString("effective_date_type"))) {
								java.util.Date dateJoin = uF.getDateFormatUtil(joiningDate, DATE_FORMAT);
								java.util.Date dateCY = uF.getDateFormatUtil("01/01/" + uF.getYear(), DATE_FORMAT);
								String strJoinDate = joiningDate;
								if (dateJoin.before(dateCY)) {
									strJoinDate = "01/01/" + uF.getYear();
								}
								dblTotal = CF.getLeavesCount1(strJoinDate, uF.getDateFormat("31/12/" + uF.getYear(), DATE_FORMAT, DATE_FORMAT),
										rs.getDouble("no_of_leave"), rs.getBoolean("is_carryforward"), CF);
								// System.out.println("CY dblTotal ========>> "
								// +
								// dblTotal+"--uF.getYear()==>"+uF.getYear()+"--no_of_leave==>"+rs.getDouble("no_of_leave"));
							} else if ("FY".equalsIgnoreCase(rs.getString("effective_date_type"))) {
								java.util.Date dateJoin = uF.getDateFormatUtil(joiningDate, DATE_FORMAT);
								java.util.Date dateCY = uF.getDateFormatUtil(CF.getStrFinancialYearTo(), DATE_FORMAT);
								String strJoinDate = joiningDate;
								if (dateJoin.before(dateCY)) {
									strJoinDate = "01/04/" + uF.getYear();
								}
								dblTotal = CF.getLeavesCount1(strJoinDate, CF.getStrFinancialYearTo(), rs.getDouble("no_of_leave"),
										rs.getBoolean("is_carryforward"), CF);
								// System.out.println("FY dblTotal ========>> "
								// +
								// dblTotal+"--uF.getYear()==>"+uF.getYear()+"--no_of_leave==>"+rs.getDouble("no_of_leave"));
							} else {
								java.util.Date dateJoin = uF.getDateFormatUtil(joiningDate, DATE_FORMAT);
								java.util.Date dateCY = uF.getDateFormatUtil("01/01/" + uF.getYear(), DATE_FORMAT);
								String strJoinDate = joiningDate;
								if (dateJoin.before(dateCY)) {
									strJoinDate = "01/01/" + uF.getYear();
								}
								dblTotal = CF.getLeavesCount1(strJoinDate, uF.getDateFormat("31/12/" + uF.getYear(), DATE_FORMAT, DATE_FORMAT),
										rs.getDouble("no_of_leave"), rs.getBoolean("is_carryforward"), CF);
								// System.out.println("else dblTotal ========>> "
								// +
								// dblTotal+"--uF.getYear()==>"+uF.getYear()+"--no_of_leave==>"+rs.getDouble("no_of_leave"));
							}
						} else {
							// System.out.println("else main dblTotal ========>> "
							// +
							// dblTotal+"--uF.getYear()==>"+uF.getYear()+"--no_of_leave==>"+rs.getDouble("no_of_leave"));
							// System.out.println(" else else is_leave_accrual ===>> "
							// + rs.getString("is_leave_accrual"));
							if (!uF.parseToBoolean(rs.getString("is_leave_accrual"))) {
								dblTotal = rs.getDouble("no_of_leave");
							}
						}
					}
					// System.out.println("leave_type_id =====>> " +
					// rs.getInt("leave_type_id") +" -- dblTotal ===>> " +
					// dblTotal);
					if (rs.getInt("leave_type_id") > 0 && dblTotal > 0) {
						hmProRataLeaveBalance.put(rs.getString("leave_type_id"), "" + dblTotal);

						if (!alExistLeave.contains(rs.getString("leave_type_id"))) {
							alExistLeave.add(rs.getString("leave_type_id"));
						}
					}
				}
				rs.close();
				pst.close();
				
				
				int strDistributedMonth = 0;
				pst1 = con.prepareStatement("select * from emp_leave_type where level_id=? and wlocation_id=? and org_id=? and distributed_month>0");
				pst1.setInt(1, levelId);
				pst1.setInt(2, wLocationId);
				pst1.setInt(3, orgId);
				rs1 = pst1.executeQuery();
				while(rs1.next()){
					strDistributedMonth = uF.parseToInt(rs1.getString("distributed_month"));
				
					if(strDistributedMonth > 0){
						java.util.Date empJoinDate = uF.getDateFormatUtil(joiningDate, DATE_FORMAT);
						java.util.Date dateCY1 = uF.getDateFormatUtil("01/01/" + uF.getYear(), DATE_FORMAT);
						if(empJoinDate.after(dateCY1)){
							int distributedMonth = 12/strDistributedMonth;
	//						System.out.println("CF/20645--distributedMoth="+distributedMonth);
	//						System.out.println("CF/20645--strDistributedMonth="+strDistributedMonth);
							String strLeaveBalance = rs1.getString("no_of_leave");
//							System.out.println("strLeaveBalance ===>> " + strLeaveBalance);
							double leaveBalance1 = uF.parseToDouble(strLeaveBalance) / distributedMonth;
							List<List<String>> distributedMonthList = new ArrayList<List<String>>();
							List<String> monthList = new ArrayList<String>();
							int mnthCnt=0;
							for(int i = 1; i <= 12; i++){
	//							System.out.println("CF/20651--uF.getMonth(i)="+uF.getMonth(i));
								monthList.add(uF.getMonth(i));
//								System.out.println("CF/20651--monthList="+monthList);
								mnthCnt++;
								if(mnthCnt == strDistributedMonth) {
									distributedMonthList.add(monthList);
									monthList = new ArrayList<String>();
	//								System.out.println("CF/20655--monthList="+monthList);
									mnthCnt=0;
								}
							}
							
//							System.out.println("distributedMonthList ===>> "+ distributedMonthList);
//							System.out.println("leaveBalance1 ===>> " + leaveBalance1);
							int leaveDistCnt = 0;
							int joinMonth = empJoinDate.getMonth()+1;
//							System.out.println("CF/20663--joinMonth="+joinMonth);
							for(int i=0; distributedMonthList!=null && i<distributedMonthList.size(); i++) {
								List<String> innerList = distributedMonthList.get(i);
//								System.out.println("CF/20666--innerList="+innerList);
								if(innerList.contains(uF.getMonth(joinMonth))){
									leaveDistCnt = distributedMonthList.size()-i;
//									System.out.println("CF/20669--leaveDistCnt="+leaveDistCnt);
									break;
								}
							}
							
							strLeaveBalance = ""+(leaveBalance1 * leaveDistCnt);
							
//							System.out.println("CF/20647--strLeaveBalance="+strLeaveBalance);
							hmProRataLeaveBalance.put(rs1.getString("leave_type_id"), strLeaveBalance);
						}
					}
				}
				rs1.close();
				pst1.close();
				
				// System.out.println("alExistLeave ========>> " +
				// alExistLeave);
				// System.out.println("hmProRataLeaveBalance ========>> " +
				// hmProRataLeaveBalance);
			}
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmProRataLeaveBalance;
	}

	private double getAccuralLeavesCount(CommonFunctions CF, UtilityFunctions uF, String strJoinDate, String strCurrentDate, double nNumberOfLeaves) {

		double empAnnualyLeaveBal = 0;
		try {
			int nDays = uF.parseToInt(uF.dateDifference(strJoinDate, DATE_FORMAT, strCurrentDate, DATE_FORMAT, CF.getStrTimeZone()));

			empAnnualyLeaveBal = nNumberOfLeaves * nDays;
			// System.out.println("nNumberOfLeaves=>" + nNumberOfLeaves +
			// "--strJoinDate=>" + strJoinDate + "--strCurrentDate==>" +
			// strCurrentDate + "--nDays==>"
			// + nDays + "--empAnnualyLeaveBal==>" + empAnnualyLeaveBal);
		} catch (Exception e) {
			e.printStackTrace();
		}

		// return Math.round(empAnnualyLeaveBal);
		return empAnnualyLeaveBal;
	}

	public List<List<String>> getLevelLeaveTypeBalanceForEmp(Connection con, String strLevel, String strEmpId, CommonFunctions CF, List<String> alExistLeave) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		UtilityFunctions uF = new UtilityFunctions();
		List<List<String>> leaveTypeListWithBalance = new ArrayList<List<String>>();
		try {
			// Map<String, String> hmEmpLeaveStartDateMap =
			// CF.getEmpJoiningDateMap(con, uF);
			int orgId = 0;
			int wLocationId = 0;
			String joiningDate = "";
			String empStatus = "";
			pst = con.prepareStatement("select wlocation_id,org_id,joining_date,emp_status from employee_personal_details epd, "
					+ "employee_official_details eod where emp_id = ? and epd.emp_per_id = eod.emp_id");
			pst.setInt(1, uF.parseToInt(strEmpId));
			// System.out.println("pst ===>> " + pst); ?
			rs = pst.executeQuery();
			while (rs.next()) {
				wLocationId = rs.getInt("wlocation_id");
				orgId = rs.getInt("org_id");
				joiningDate = uF.getDateFormat(rs.getString("joining_date"), DBDATE, DATE_FORMAT);
				empStatus = rs.getString("emp_status");
			}
			rs.close();
			pst.close();

			pst = con.prepareStatement("select * from probation_policy where emp_id = ?");
			pst.setInt(1, uF.parseToInt(strEmpId));
			rs = pst.executeQuery();
			String strAllowedLeaves = null;
			boolean isProbation = false;
			while (rs.next()) {
				strAllowedLeaves = rs.getString("leaves_types_allowed");
			}
			rs.close();
			pst.close();

			List<String> alEmpLeaves = null;
			if (strAllowedLeaves != null && strAllowedLeaves.length() > 0) {
				alEmpLeaves = Arrays.asList(strAllowedLeaves.split(","));
			}
			if (alEmpLeaves == null)
				alEmpLeaves = new ArrayList<String>();

			StringBuilder sbQuery = new StringBuilder();
			sbQuery.append("select * from emp_leave_type elt, leave_type lt where level_id = ? "
					+ "and wlocation_id = ? and elt.org_id = ? and elt.leave_type_id = lt.leave_type_id"
					+ " and lt.is_compensatory=false and elt.is_constant_balance=false ");
			sbQuery.append(" and (");
			sbQuery.append(" elt.leave_available like '%,0,%'");

			if (empStatus != null && empStatus.equals(PROBATION)) {
				sbQuery.append(" OR elt.leave_available like '%,1,%' ");
			}
			if (empStatus != null && empStatus.equals(PERMANENT)) {
				sbQuery.append(" OR elt.leave_available like '%,2,%' ");
			}
			if (empStatus != null && empStatus.equals(RESIGNED)) {
				sbQuery.append(" OR elt.leave_available like '%,3,%' ");
			}
			if (empStatus != null && empStatus.equals(TEMPORARY)) {
				sbQuery.append(" OR elt.leave_available like '%,4,%' ");
			}
			sbQuery.append(" ) and (lt.is_leave_opt_holiday is null or lt.is_leave_opt_holiday = false) ");
			pst = con.prepareStatement(sbQuery.toString());
			// pst =
			// con.prepareStatement("select * from emp_leave_type where level_id=?");
			pst.setInt(1, uF.parseToInt(strLevel));
			pst.setInt(2, wLocationId);
			pst.setInt(3, orgId);
			// System.out.println("pst ========>> " + pst);
			rs = pst.executeQuery();
			while (rs.next()) {
				// System.out.println("joiningDate ========>> " + joiningDate);
				if (!alEmpLeaves.contains(rs.getString("leave_type_id"))) {
					continue;
				}

				double dblTotal = 0;
				if (uF.parseToBoolean(rs.getString("is_prorata"))) {
					if ("CY".equalsIgnoreCase(rs.getString("effective_date_type"))) {
						dblTotal = CF.getLeavesCount1(joiningDate, uF.getDateFormat("31/12/" + uF.getYear(), DATE_FORMAT, DATE_FORMAT),
								rs.getDouble("no_of_leave"), rs.getBoolean("is_carryforward"), CF);
						// System.out.println("CY rs.getString(leave_type_id) ========>> "
						// +
						// rs.getString("leave_type_id")+"--dblTotal==>"+dblTotal);
					} else if ("FY".equalsIgnoreCase(rs.getString("effective_date_type"))) {
						dblTotal = CF.getLeavesCount1(joiningDate, CF.getStrFinancialYearTo(), rs.getDouble("no_of_leave"), rs.getBoolean("is_carryforward"),
								CF);
						// System.out.println("FY rs.getString(leave_type_id) ========>> "
						// +
						// rs.getString("leave_type_id")+"--dblTotal==>"+dblTotal);
					} else {
						dblTotal = CF.getLeavesCount1(joiningDate, uF.getDateFormat("31/12/" + uF.getYear(), DATE_FORMAT, DATE_FORMAT),
								rs.getDouble("no_of_leave"), rs.getBoolean("is_carryforward"), CF);
						// System.out.println("else rs.getString(leave_type_id) ========>> "
						// +
						// rs.getString("leave_type_id")+"--dblTotal==>"+dblTotal);
					}
				} else {
					if (!uF.parseToBoolean(rs.getString("is_leave_accrual"))) {
						dblTotal = rs.getDouble("no_of_leave");
					}
				}
				if (rs.getInt("leave_type_id") > 0 && dblTotal > 0) {
					List<String> innerList = new ArrayList<String>();
					innerList.add(rs.getString("leave_type_id"));
					innerList.add(rs.getString("leave_type_name"));
					innerList.add("" + dblTotal);
					leaveTypeListWithBalance.add(innerList);
					if (!alExistLeave.contains(rs.getString("leave_type_id"))) {
						alExistLeave.add(rs.getString("leave_type_id"));
					}
				}
			}
			rs.close();
			pst.close();
			// System.out.println("alExistLeave ========>> " + alExistLeave);

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return leaveTypeListWithBalance;
	}

	public Map<String, String> getDishNamesMap(Connection con) {
		PreparedStatement pst = null;
		ResultSet rs = null;

		Map<String, String> hmDishNames = new HashMap<String, String>();

		try {
			pst = con.prepareStatement("SELECT * FROM dish_details");
			rs = pst.executeQuery();
			while (rs.next()) {
				hmDishNames.put(rs.getString("dish_id"), rs.getString("dish_name"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

		return hmDishNames;
	}

	public Map<String, String> getDishTypes() {

		Map<String, String> hmDishTypes = new HashMap<String, String>();

		try {

			hmDishTypes.put(BREAKFAST, "Breakfast");
			hmDishTypes.put(LUNCH, "Lunch");
			hmDishTypes.put(DINNER, "Dinner");
			hmDishTypes.put(OTHER, "Other");

		} catch (Exception e) {
			e.printStackTrace();
		}

		return hmDishTypes;
	}

	public Map<String, String> getSalaryHeadsMapByGrade(Connection con, int nGradeId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmSalaryHeadsMap = new LinkedHashMap<String, String>();
		try {
			pst = con.prepareStatement("SELECT * FROM salary_details where grade_id =? order by weight");
			pst.setInt(1, nGradeId);
			rs = pst.executeQuery();
			List<String> salHeadList = new ArrayList<String>();
			while (rs.next()) {
				hmSalaryHeadsMap.put(rs.getString("salary_head_id"), rs.getString("salary_head_name"));
				if (!salHeadList.contains(rs.getString("salary_head_id"))
						&& (rs.getInt("salary_head_id") == EMPLOYEE_EPF || rs.getInt("salary_head_id") == EMPLOYEE_ESI || rs.getInt("salary_head_id") == EMPLOYEE_LWF)) {
					salHeadList.add(rs.getString("salary_head_id"));
				}
			}
			rs.close();
			pst.close();
			if (salHeadList != null && salHeadList.contains(EMPLOYEE_EPF + "")) {
				hmSalaryHeadsMap.put(EMPLOYER_EPF + "", "Employer PF");
			}
			if (salHeadList != null && salHeadList.contains(EMPLOYEE_ESI + "")) {
				hmSalaryHeadsMap.put(EMPLOYER_ESI + "", "Employer ESI");
			}
			if (salHeadList != null && salHeadList.contains(EMPLOYEE_LWF + "")) {
				hmSalaryHeadsMap.put(EMPLOYER_LWF + "", "Employer LWF");
			}

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmSalaryHeadsMap;
	}

	public int getEmpNoticePeriod(Connection con, String empId) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		int noticePeriod = 0;
		try {

			pst = con.prepareStatement("SELECT * FROM probation_policy where emp_id = ?");
			pst.setInt(1, uF.parseToInt(empId));
			rs = pst.executeQuery();
			while (rs.next()) {
				noticePeriod = rs.getInt("notice_duration");
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return noticePeriod;
	}

	public List<String> getCXOLocationAccessIds(Connection con, UtilityFunctions uF, int empId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		List<String> accessLocIds = new ArrayList<String>();
		try {
			pst = con.prepareStatement("select wlocation_id_access from user_details where emp_id=?");
			pst.setInt(1, empId);
			rs = pst.executeQuery();
			while (rs.next()) {
				if (rs.getString("wlocation_id_access") != null) {
					accessLocIds = Arrays.asList(rs.getString("wlocation_id_access").split(","));
				}
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
		}
		return accessLocIds;
	}

	public Map<String, Map<String, String>> getSalaryCalculationByGrade(Connection con, Map<String, Map<String, String>> hmInnerisDisplay, int nEmpId,
			double dblPresent, double dblAbsent, double dblBreaks, int nTotalNumberOfDays, double dblIncrementBasic, double dblIncrementDA, String strGradeId,
			UtilityFunctions uF, CommonFunctions CF, String strD2, Map<String, Map<String, String>> hmSalaryDetails, String strEmpVDAAmount,
			String strSalCalStatus) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, Map<String, String>> hmSalaryHeadReCalculatedMap = new LinkedHashMap<String, Map<String, String>>();

		try {
			StringBuilder sbQuery = new StringBuilder();
			sbQuery.append("select * from (select *, 1 as aa from emp_salary_details where emp_id=? and effective_date=(select max(effective_date) "
					+ "from emp_salary_details where emp_id=? and effective_date<=? and is_approved=true) and salary_head_id not in ("
					+ CTC
					+ ","
					+ TDS
					+ ","
					+ DA1
					+ ","
					+ GROSS
					+ ") "
					+ "and is_approved=true and salary_head_id in (select salary_head_id from salary_details where (is_delete is null or is_delete=false) "
					+ "and org_id in (select org_id from employee_personal_details epd, employee_official_details eod where epd.emp_per_id=eod.emp_id "
					+ "and eod.emp_id=?) and grade_id=?) order by earning_deduction desc, salary_head_id, emp_salary_id ) ac "
					+ " union "
					+ "(select *, 2 as aa from emp_salary_details where emp_id=? and effective_date=(select max(effective_date) from emp_salary_details "
					+ "where emp_id=? and effective_date<=? and is_approved=true) and salary_head_id in ("
					+ TDS
					+ ") and salary_head_id not in ("
					+ CTC
					+ ") "
					+ "and salary_head_id in (select salary_head_id from salary_details where (is_delete is null or is_delete=false) and org_id in "
					+ "(select org_id from employee_personal_details epd, employee_official_details eod where epd.emp_per_id=eod.emp_id and eod.emp_id=?) "
					+ "and grade_id=?) order by earning_deduction desc, salary_head_id, emp_salary_id) order by aa, earning_deduction desc, salary_head_id, emp_salary_id");
			pst = con.prepareStatement(sbQuery.toString());
			pst.setInt(1, nEmpId);
			pst.setInt(2, nEmpId);
			pst.setDate(3, uF.getDateFormat(strD2, DATE_FORMAT));
			pst.setInt(4, nEmpId);
			pst.setInt(5, uF.parseToInt(strGradeId));
			pst.setInt(6, nEmpId);
			pst.setInt(7, nEmpId);
			pst.setDate(8, uF.getDateFormat(strD2, DATE_FORMAT));
			pst.setInt(9, nEmpId);
			pst.setInt(10, uF.parseToInt(strGradeId));
			// if(nEmpId==181){
			// System.out.println("pst ========>> " + pst);
			// }
			rs = pst.executeQuery();
			while (rs.next()) {

				String strSalaryHeadId = rs.getString("salary_head_id");
				String strAmount = rs.getString("amount");
				double dblAmount = uF.parseToDouble(strAmount);
				if (uF.parseToInt(strSalaryHeadId) == VDA && !uF.parseToBoolean(strSalCalStatus)) {
					dblAmount = uF.parseToDouble(strEmpVDAAmount);
					// System.out.println("dblAmount ===>> " + dblAmount);
				}

				Map<String, String> hmInnerSal = hmSalaryDetails.get(strSalaryHeadId);
				if (hmInnerSal == null)
					hmInnerSal = new HashMap<String, String>();

				String strSalPercentage = hmInnerSal.get("SALARY_HEAD_AMOUNT");
				String strSalAmountType = hmInnerSal.get("SALARY_AMOUNT_TYPE");
				String isCTCVariable = hmInnerSal.get("IS_CTC_VARIABLE");
				String strMultipleCalculation = hmInnerSal.get("MULTIPLE_CALCULATION");
				String isAlignWithPerk = hmInnerSal.get("IS_ALIGN_WITH_PERK");
				String isDefaultCalAllowance = hmInnerSal.get("IS_DEFAULT_CAL_ALLOWANCE");

				String strEarningDeduction = hmInnerSal.get("EARNING_DEDUCTION");
				String strSalaryType = hmInnerSal.get("SALARY_TYPE");

				if (strSalaryType != null && strSalaryType.equalsIgnoreCase("F")) {
					// dblAmount = dblAmount;
				} else if (strSalaryType != null && strSalaryType.equalsIgnoreCase("D")) {
					dblAmount = dblAmount * dblPresent;
				} else {
					dblAmount = dblAmount * (dblPresent / nTotalNumberOfDays);
				}

				if (strEarningDeduction != null) {
					Map<String, String> hmSalaryInner = new HashMap<String, String>();
					hmSalaryInner.put("EARNING_DEDUCTION", strEarningDeduction);
					hmSalaryInner.put("AMOUNT", uF.getRoundOffValue(uF.parseToInt(CF.getRoundOffCondtion()), dblAmount));
					hmSalaryInner.put("SALARY_AMOUNT_TYPE", strSalAmountType);
					hmSalaryInner.put("MULTIPLE_CALCULATION", strMultipleCalculation);
					hmSalaryInner.put("IS_ALIGN_WITH_PERK", isAlignWithPerk);
					hmSalaryInner.put("SALARY_PERCENTAGE", strSalPercentage);
					hmSalaryInner.put("IS_DEFAULT_CAL_ALLOWANCE", isDefaultCalAllowance);

					if (!rs.getBoolean("isdisplay") && uF.parseToBoolean(isCTCVariable)) {
						hmInnerisDisplay.put(strSalaryHeadId, hmSalaryInner);
					} else if (rs.getBoolean("isdisplay") && !uF.parseToBoolean(isCTCVariable)) {
						hmSalaryHeadReCalculatedMap.put(strSalaryHeadId, hmSalaryInner);
					}
				}
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmSalaryHeadReCalculatedMap;
	}

	// public Map<String, Map<String, String>>
	// getSalaryCalculationByGrade(Connection con,Map<String, Map<String,
	// String>> hmInnerisDisplay, int nEmpId, double dblPresent, double
	// dblAbsent, double dblBreaks, int nTotalNumberOfDays, double
	// dblIncrementBasic, double dblIncrementDA,
	// String strGradeId, UtilityFunctions uF, CommonFunctions CF, String strD2)
	// {
	//
	// PreparedStatement pst = null;
	// ResultSet rs = null;
	// Map<String, Map<String, String>> hmSalaryHeadReCalculatedMap = new
	// LinkedHashMap<String, Map<String, String>>();
	//
	// Map<String, Map<String, String>> hmSalaryHeadMap = new
	// LinkedHashMap<String, Map<String, String>>();
	// try {
	//
	// String orgId = CF.getEmpOrgId(con, uF, ""+nEmpId);
	// String strLevelId = CF.getEmpLevelId(con, ""+nEmpId);
	// String[] strPayCycleDate = CF.getPayCycleFromDate(con, strD2,
	// CF.getStrTimeZone(), CF, orgId);
	//
	// String[] strFinancialYear = CF.getFinancialYear(con, strD2, CF, uF);
	// double dblReimbursementCTC = CF.getReimbursementCTCHeadTotalAmount(con,
	// uF, nEmpId, strFinancialYear[0], strFinancialYear[1], strPayCycleDate[0],
	// strPayCycleDate[1], strPayCycleDate[2], uF.parseToInt(orgId),
	// uF.parseToInt(strLevelId));
	//
	// Map<String, String> hmSalaryEarningDeduction = new
	// HashMap<String,String>();
	// Map<String, String> hmSalaryType = new HashMap<String,String>();
	// pst =
	// con.prepareStatement("select * from salary_details where grade_id = ? and (is_delete is null or is_delete=false) order by salary_head_id, salary_id");
	// pst.setInt(1, uF.parseToInt(strGradeId));
	// rs = pst.executeQuery();
	// if(nEmpId==459){
	// // System.out.println("pst===sal==>"+pst);
	// }
	// Map<String,Map<String,String>> hmSalaryDetails = new
	// HashMap<String,Map<String,String>>();
	// while (rs.next()) {
	//
	// Map<String, String> hmInnerSal = new HashMap<String, String>();
	//
	// hmInnerSal.put("SALARY_HEAD_ID", rs.getString("salary_head_id"));
	// hmInnerSal.put("EARNING_DEDUCTION", rs.getString("earning_deduction"));
	// hmInnerSal.put("SALARY_AMOUNT_TYPE",
	// rs.getString("salary_head_amount_type"));
	// hmInnerSal.put("SUB_SALARY_HEAD_ID", rs.getString("sub_salary_head_id"));
	// hmInnerSal.put("SALARY_HEAD_AMOUNT", rs.getString("salary_head_amount"));
	// hmInnerSal.put("IS_CTC_VARIABLE",
	// ""+uF.parseToBoolean(rs.getString("is_ctc_variable")));
	// hmInnerSal.put("MULTIPLE_CALCULATION",
	// rs.getString("multiple_calculation"));
	// hmInnerSal.put("IS_ALIGN_WITH_PERK",
	// ""+uF.parseToBoolean(rs.getString("is_align_with_perk")));
	//
	// hmSalaryDetails.put(rs.getString("salary_head_id"), hmInnerSal);
	//
	// hmSalaryEarningDeduction.put(rs.getString("salary_head_id"),
	// rs.getString("earning_deduction"));
	// hmSalaryType.put(rs.getString("salary_head_id"),
	// rs.getString("salary_type"));
	// }
	// rs.close();
	// pst.close();
	//
	// // if(nEmpId==181){
	// // System.out.println("hmSalaryDetails========>"+hmSalaryDetails);
	// // }
	//
	// pst =
	// con.prepareStatement("select * from emp_salary_details where emp_id = ? and effective_date = (select max(effective_date) "
	// +
	// "from emp_salary_details where emp_id =? and effective_date <= ? and is_approved=true) and salary_head_id in ("+CTC+") "
	// +
	// "and salary_head_id in (select salary_head_id from salary_details where (is_delete is null or is_delete=false) "
	// +
	// "and org_id in (select org_id from employee_personal_details epd, employee_official_details eod "
	// +
	// "where epd.emp_per_id=eod.emp_id and eod.emp_id=?) and grade_id = ?)");
	// pst.setInt(1, nEmpId);
	// pst.setInt(2, nEmpId);
	// pst.setDate(3, uF.getDateFormat(strD2, DATE_FORMAT));
	// pst.setInt(4, nEmpId);
	// pst.setInt(5, uF.parseToInt(strGradeId));
	// if(nEmpId==459){
	// // System.out.println("pst========>"+pst);
	// }
	// rs = pst.executeQuery();
	// boolean isCtc = false;
	// double dblCTC = 0.0d;
	// while(rs.next()){
	// isCtc = true;
	// dblCTC = uF.parseToDouble(rs.getString("amount"));
	// }
	// rs.close();
	// pst.close();
	// // if(nEmpId==181){
	// // System.out.println("dblCTC========>"+dblCTC);
	// // }
	//
	// StringBuilder sbQuery = new StringBuilder();
	// sbQuery.append("select * from (	select *, 0 as aa from emp_salary_details where emp_id = ? and effective_date = (select max(effective_date) "
	// +
	// "from emp_salary_details where emp_id =? and effective_date <= ? and is_approved=true) and salary_head_id in ("+DA1+", "+GROSS+") "
	// +
	// "and salary_head_id not in ("+CTC+") and salary_head_id in (select salary_head_id from salary_details where (is_delete is null or is_delete=false) "
	// +
	// "and org_id in (select org_id from employee_personal_details epd, employee_official_details eod where epd.emp_per_id=eod.emp_id "
	// +
	// "and eod.emp_id=?) and grade_id = ?) order by earning_deduction desc, salary_head_id, emp_salary_id ) ac1"
	// +
	// " union " +
	// "select * from (select *, 1 as aa from emp_salary_details where emp_id = ? and effective_date = (select max(effective_date) "
	// +
	// "from emp_salary_details where emp_id =? and effective_date <= ? and is_approved=true) and salary_head_id not in ("+CTC+","+TDS+","+DA1+","+GROSS+") "
	// +
	// "and is_approved=true and salary_head_id in (select salary_head_id from salary_details where (is_delete is null or is_delete=false) "
	// +
	// "and org_id in (select org_id from employee_personal_details epd, employee_official_details eod where epd.emp_per_id=eod.emp_id "
	// +
	// "and eod.emp_id=?) and grade_id = ?) order by earning_deduction desc, salary_head_id, emp_salary_id ) ac"
	// +
	// " union " +
	// "(select *, 2 as aa from emp_salary_details where emp_id = ? and effective_date = (select max(effective_date) from emp_salary_details "
	// +
	// "where emp_id =? and effective_date <= ? and is_approved=true) and salary_head_id in ("+TDS+") and salary_head_id not in ("+CTC+") "
	// +
	// "and salary_head_id in (select salary_head_id from salary_details where (is_delete is null or is_delete=false) "
	// +
	// "and org_id in (select org_id from employee_personal_details epd, employee_official_details eod where epd.emp_per_id=eod.emp_id "
	// +
	// "and eod.emp_id=?) and grade_id = ?) order by earning_deduction desc, salary_head_id, emp_salary_id) order by aa, earning_deduction desc, salary_head_id, emp_salary_id");
	// pst = con.prepareStatement(sbQuery.toString());
	// pst.setInt(1, nEmpId);
	// pst.setInt(2, nEmpId);
	// pst.setDate(3, uF.getDateFormat(strD2, DATE_FORMAT));
	// pst.setInt(4, nEmpId);
	// pst.setInt(5, uF.parseToInt(strGradeId));
	// pst.setInt(6, nEmpId);
	// pst.setInt(7, nEmpId);
	// pst.setDate(8, uF.getDateFormat(strD2, DATE_FORMAT));
	// pst.setInt(9, nEmpId);
	// pst.setInt(10, uF.parseToInt(strGradeId));
	// pst.setInt(11, nEmpId);
	// pst.setInt(12, nEmpId);
	// pst.setDate(13, uF.getDateFormat(strD2, DATE_FORMAT));
	// pst.setInt(14, nEmpId);
	// pst.setInt(15, uF.parseToInt(strGradeId));
	// // if(nEmpId==181){
	// // System.out.println("pst========>"+pst);
	// // }
	// rs = pst.executeQuery();
	//
	// double dblBasicDA = 0;
	// boolean isGross = false;
	// boolean isHRAll = false;
	// Map<String, String> hmMainTotal = new HashMap<String, String>();
	// while (rs.next()) {
	// Map<String, String> hmSalaryInner = new HashMap<String, String>();
	// Map<String, String> hmInner = new HashMap<String, String>();
	// double dblAmount = 0;
	//
	// String strSalaryHeadId = rs.getString("salary_head_id");
	// String strEarningDeduction =
	// hmSalaryEarningDeduction.get(rs.getString("salary_head_id"));
	// String strSalaryType = hmSalaryType.get(rs.getString("salary_head_id"));
	//
	// if(uF.parseToInt(strSalaryHeadId)==GROSS){
	// isGross = true;
	// }
	//
	// isHRAll = false;
	// if(uF.parseToInt(strSalaryHeadId)==211){
	// isHRAll = true;
	// }
	//
	// String strAmount = rs.getString("amount");
	// dblAmount = uF.parseToDouble(strAmount);
	//
	// Map<String,String> hmInnerSal = hmSalaryDetails.get(strSalaryHeadId);
	// if (hmInnerSal == null) hmInnerSal = new HashMap<String,String>();
	//
	// String strSubSalAmount = hmInnerSal.get("SALARY_HEAD_AMOUNT");
	// String strSubSalAmountType = hmInnerSal.get("SALARY_AMOUNT_TYPE");
	// String strSubSalId = hmInnerSal.get("SUB_SALARY_HEAD_ID");
	// String isCTCVariable=hmInnerSal.get("IS_CTC_VARIABLE");
	// String strMultipleCalculation = hmInnerSal.get("MULTIPLE_CALCULATION");
	// String isAlignWithPerk = hmInnerSal.get("IS_ALIGN_WITH_PERK");
	//
	// if(isCtc){
	// if (strSubSalAmountType != null &&
	// strSubSalAmountType.equalsIgnoreCase("P")) {
	// Map<String, String> hmEmpSalaryInner = hmSalaryHeadMap.get(strSubSalId);
	// if (hmEmpSalaryInner == null) hmEmpSalaryInner = new
	// HashMap<String,String>();
	// String strEmpSalAmount = hmEmpSalaryInner.get("AMOUNT");
	//
	// if(uF.parseToInt(strSubSalId) == CTC){
	//
	// // double dblSalAmount = uF.parseToDouble(strEmpSalAmount);
	// double dblSalAmount = uF.parseToDouble(strSubSalAmount);
	// // double dblSubSalAmount = uF.parseToDouble(strSubSalAmount);
	// double dblSubSalAmount = dblCTC;
	// double dblTotalAmount = dblSalAmount * dblSubSalAmount / 100;
	//
	//
	// // if(nEmpId==668){
	// // System.out.println("dblCTC=="+dblCTC);
	// // System.out.println("strSalaryHeadId=="+strSalaryHeadId);
	// // System.out.println("dblSalAmount=="+dblSalAmount);
	// // System.out.println("strSubSalAmount=="+strSubSalAmount);
	// // System.out.println("dblTotalAmount=="+dblTotalAmount);
	// // System.out.println("dblPresent=="+dblPresent);
	// // System.out.println("nTotalNumberOfDays=="+nTotalNumberOfDays);
	// // }
	//
	// if (dblIncrementBasic > 0 && (uF.parseToInt(strSalaryHeadId) == BASIC ||
	// uF.parseToInt(strSalaryHeadId) == GROSS)) {
	// dblAmount = dblAmount + dblIncrementBasic;
	// }
	//
	// hmMainTotal.put(strSalaryHeadId, ""+dblAmount);
	//
	// if (!isGross && isHRAll) {
	// dblBasicDA = dblAmount;
	// }
	//
	// if (!isGross && (uF.parseToInt(strSalaryHeadId) == BASIC ||
	// uF.parseToInt(strSalaryHeadId) == DA || uF.parseToInt(strSalaryHeadId) ==
	// DA1)) {
	// dblBasicDA += dblAmount;
	// }
	//
	// if (uF.parseToInt(strSalaryHeadId) == GROSS) {
	// dblBasicDA = dblAmount;
	// }
	//
	// if(strSalaryType!=null && strSalaryType.equalsIgnoreCase("F")){
	// dblAmount = dblTotalAmount;
	// }else if(strSalaryType!=null && strSalaryType.equalsIgnoreCase("D")){
	// dblAmount = dblTotalAmount * dblPresent;
	// }else{
	// dblAmount = dblTotalAmount * (dblPresent / nTotalNumberOfDays);
	// }
	//
	// // if(nEmpId==668){
	// // System.out.println("dblAmount=="+dblAmount);
	// // System.out.println("dblBasicDA=="+dblBasicDA);
	// // }
	//
	// hmInner.put("AMOUNT",
	// uF.getRoundOffValue(uF.parseToInt(CF.getRoundOffCondtion()),dblAmount));
	//
	// if(uF.parseToInt(strSalaryHeadId) == BREAKS){
	// dblAmount = dblTotalAmount * dblBreaks;
	// hmInner.put("AMOUNT",
	// uF.getRoundOffValue(uF.parseToInt(CF.getRoundOffCondtion()),dblAmount));
	// }
	//
	// } else if (strSubSalAmountType != null &&
	// strSubSalAmountType.equalsIgnoreCase("P")) {
	// if ((uF.parseToInt(strSubSalId) == BASIC || uF.parseToInt(strSubSalId) ==
	// GROSS ) && (uF.parseToInt(strSalaryHeadId) != DA &&
	// uF.parseToInt(strSalaryHeadId) != DA1)) {
	// strEmpSalAmount = dblBasicDA + "";
	// } else if(uF.parseToInt(strSubSalId) == REIMBURSEMENT_CTC){
	// strEmpSalAmount = ""+dblReimbursementCTC;
	// } else {
	// strEmpSalAmount = hmMainTotal.get(""+strSubSalId);
	// }
	//
	// double dblSalAmount = uF.parseToDouble(strEmpSalAmount);
	// double dblSubSalAmount = uF.parseToDouble(strSubSalAmount);
	// double dblTotalAmount = dblSalAmount * dblSubSalAmount / 100;
	//
	// if (dblIncrementDA > 0 && (uF.parseToInt(strSalaryHeadId) == DA ||
	// uF.parseToInt(strSalaryHeadId) == DA1)) {
	// dblTotalAmount = dblTotalAmount + dblIncrementDA;
	// }
	//
	// hmMainTotal.put(strSalaryHeadId, ""+dblTotalAmount);
	//
	// if(strSalaryType!=null && strSalaryType.equalsIgnoreCase("F")){
	// dblAmount = dblTotalAmount;
	// }else if(strSalaryType!=null && strSalaryType.equalsIgnoreCase("D")){
	// dblAmount = dblTotalAmount * dblPresent;
	// }else{
	// dblAmount = dblTotalAmount * (dblPresent / nTotalNumberOfDays);
	// }
	//
	// hmInner.put("AMOUNT",
	// uF.getRoundOffValue(uF.parseToInt(CF.getRoundOffCondtion()),dblAmount));
	//
	// if(uF.parseToInt(strSalaryHeadId) == BREAKS){
	// dblAmount = dblTotalAmount * dblBreaks;
	// hmInner.put("AMOUNT",
	// uF.getRoundOffValue(uF.parseToInt(CF.getRoundOffCondtion()),dblAmount));
	// }
	//
	//
	//
	// } else if (uF.parseToInt(strSalaryHeadId) != BASIC &&
	// uF.parseToInt(strSalaryHeadId) != GROSS && uF.parseToInt(strSalaryHeadId)
	// != DA && uF.parseToInt(strSalaryHeadId) != DA1 &&
	// !"D".equalsIgnoreCase(rs.getString("earning_deduction"))) {
	// // System.out.println("2 else if==");
	// if(strSubSalAmountType != null &&
	// strSubSalAmountType.equalsIgnoreCase("P") &&
	// uF.parseToInt(strSubSalId)==BASIC){
	// if(strSalaryType!=null && strSalaryType.equalsIgnoreCase("F")){
	// dblAmount = dblBasicDA;
	// }else if(strSalaryType!=null && strSalaryType.equalsIgnoreCase("D")){
	// dblAmount = dblBasicDA * dblPresent;
	// }else{
	// dblAmount = dblBasicDA * (dblPresent / nTotalNumberOfDays);
	// }
	// }else{
	// if(strSalaryType!=null && strSalaryType.equalsIgnoreCase("F")){
	// // dblAmount = dblAmount;
	// }else if(strSalaryType!=null && strSalaryType.equalsIgnoreCase("D")){
	// dblAmount = dblAmount * dblPresent;
	// }else{
	// dblAmount = dblAmount * (dblPresent / nTotalNumberOfDays);
	// }
	// }
	//
	// // if(nEmpId==668){
	// // System.out.println("dblCTC=="+dblCTC);
	// // System.out.println("strSalaryHeadId=="+strSalaryHeadId);
	// // System.out.println("strSubSalAmountType=="+strSubSalAmountType);
	// // System.out.println("strSubSalAmount=="+strSubSalAmount);
	// // System.out.println("strSubSalId=="+strSubSalId);
	// // System.out.println("strSalaryType=="+strSalaryType);
	// // System.out.println("dblPresent=="+dblPresent);
	// // System.out.println("nTotalNumberOfDays=="+nTotalNumberOfDays);
	// // }
	//
	// hmInner.put("AMOUNT",
	// uF.getRoundOffValue(uF.parseToInt(CF.getRoundOffCondtion()),dblAmount));
	// }else{
	// if(strSalaryType!=null && strSalaryType.equalsIgnoreCase("F")){
	// // dblAmount = dblAmount;
	// }else if(strSalaryType!=null && strSalaryType.equalsIgnoreCase("D")){
	// dblAmount = dblAmount * dblPresent;
	// }else{
	// dblAmount = dblAmount * (dblPresent / nTotalNumberOfDays);
	// }
	// hmInner.put("AMOUNT",
	// uF.getRoundOffValue(uF.parseToInt(CF.getRoundOffCondtion()),dblAmount));
	// }
	//
	//
	// } else if (uF.parseToInt(strSalaryHeadId) != BASIC &&
	// uF.parseToInt(strSalaryHeadId) != GROSS && uF.parseToInt(strSalaryHeadId)
	// != DA && uF.parseToInt(strSalaryHeadId) != DA1 &&
	// !"D".equalsIgnoreCase(rs.getString("earning_deduction"))) {
	// if(strSubSalAmountType != null &&
	// strSubSalAmountType.equalsIgnoreCase("P") &&
	// uF.parseToInt(strSubSalId)==BASIC){
	// if(strSalaryType!=null && strSalaryType.equalsIgnoreCase("F")){
	// dblAmount = dblBasicDA;
	// }else if(strSalaryType!=null && strSalaryType.equalsIgnoreCase("D")){
	// dblAmount = dblBasicDA * dblPresent;
	// }else{
	// dblAmount = dblBasicDA * (dblPresent / nTotalNumberOfDays);
	// }
	// }else{
	// if(strSalaryType!=null && strSalaryType.equalsIgnoreCase("F")){
	// // dblAmount = dblAmount;
	// }else if(strSalaryType!=null && strSalaryType.equalsIgnoreCase("D")){
	// dblAmount = dblAmount * dblPresent;
	// }else{
	// dblAmount = dblAmount * (dblPresent / nTotalNumberOfDays);
	// }
	// }
	//
	// // if(nEmpId==668){
	// // System.out.println("dblCTC=="+dblCTC);
	// // System.out.println("strSalaryHeadId=="+strSalaryHeadId);
	// // System.out.println("strSubSalAmountType=="+strSubSalAmountType);
	// // System.out.println("strSubSalAmount=="+strSubSalAmount);
	// // System.out.println("strSubSalId=="+strSubSalId);
	// // System.out.println("strSalaryType=="+strSalaryType);
	// // System.out.println("dblPresent=="+dblPresent);
	// // System.out.println("nTotalNumberOfDays=="+nTotalNumberOfDays);
	// // }
	//
	// hmInner.put("AMOUNT",
	// uF.getRoundOffValue(uF.parseToInt(CF.getRoundOffCondtion()),dblAmount));
	// }else{
	// if(strSalaryType!=null && strSalaryType.equalsIgnoreCase("F")){
	// // dblAmount = dblAmount;
	// }else if(strSalaryType!=null && strSalaryType.equalsIgnoreCase("D")){
	// dblAmount = dblAmount * dblPresent;
	// }else{
	// dblAmount = dblAmount * (dblPresent / nTotalNumberOfDays);
	// }
	// hmInner.put("AMOUNT",
	// uF.getRoundOffValue(uF.parseToInt(CF.getRoundOffCondtion()),dblAmount));
	// }
	//
	// hmInner.put("SALARY_HEAD_ID", strSalaryHeadId);
	// hmInner.put("EARNING_DEDUCTION", strEarningDeduction);
	// hmInner.put("SALARY_AMOUNT_TYPE", strSubSalAmountType);
	// hmInner.put("MULTIPLE_CALCULATION", strMultipleCalculation);
	// hmInner.put("IS_ALIGN_WITH_PERK", isAlignWithPerk);
	//
	// hmSalaryHeadMap.put(strSalaryHeadId, hmInner);
	//
	// if (strEarningDeduction != null) {
	// hmSalaryInner.put("EARNING_DEDUCTION", strEarningDeduction);
	// hmSalaryInner.put("AMOUNT",
	// uF.getRoundOffValue(uF.parseToInt(CF.getRoundOffCondtion()),dblAmount) +
	// "");
	// hmSalaryInner.put("SALARY_AMOUNT_TYPE", strSubSalAmountType);
	// hmSalaryInner.put("MULTIPLE_CALCULATION", strMultipleCalculation);
	// hmSalaryInner.put("IS_ALIGN_WITH_PERK", isAlignWithPerk);
	//
	// if (!rs.getBoolean("isdisplay") && uF.parseToBoolean(isCTCVariable)) {
	// hmInnerisDisplay.put(strSalaryHeadId, hmSalaryInner);
	// // } else if (rs.getBoolean("isdisplay")){
	// } else if (rs.getBoolean("isdisplay") &&
	// !uF.parseToBoolean(isCTCVariable)){
	// hmSalaryHeadReCalculatedMap.put(strSalaryHeadId, hmSalaryInner);
	// }
	// }
	//
	// } else {
	//
	// if (dblIncrementBasic > 0 && (uF.parseToInt(strSalaryHeadId) == BASIC ||
	// uF.parseToInt(strSalaryHeadId) == GROSS)) {
	// dblAmount = dblAmount + dblIncrementBasic;
	// }
	//
	// if (!isGross && isHRAll) {
	// dblBasicDA = dblAmount;
	// }
	//
	// if (!isGross && (uF.parseToInt(strSalaryHeadId) == BASIC ||
	// uF.parseToInt(strSalaryHeadId) == DA || uF.parseToInt(strSalaryHeadId) ==
	// DA1)) {
	// dblBasicDA += dblAmount;
	// }
	//
	// if (uF.parseToInt(strSalaryHeadId) == GROSS) {
	// dblBasicDA = dblAmount;
	// }
	//
	//
	// // boolean isFixed = false;
	// if (strSubSalAmountType != null &&
	// strSubSalAmountType.equalsIgnoreCase("P")) {
	// Map<String, String> hmEmpSalaryInner = hmSalaryHeadMap.get(strSubSalId);
	// if (hmEmpSalaryInner == null) hmEmpSalaryInner = new
	// HashMap<String,String>();
	// String strEmpSalAmount = hmEmpSalaryInner.get("AMOUNT");
	//
	// if ((uF.parseToInt(strSubSalId) == BASIC || uF.parseToInt(strSubSalId) ==
	// GROSS ) && (uF.parseToInt(strSalaryHeadId) != DA &&
	// uF.parseToInt(strSalaryHeadId) != DA1)) {
	// strEmpSalAmount = dblBasicDA + "";
	// } else if(uF.parseToInt(strSubSalId) == REIMBURSEMENT_CTC){
	// strEmpSalAmount = ""+dblReimbursementCTC;
	// }
	//
	// double dblSalAmount = uF.parseToDouble(strEmpSalAmount);
	// double dblSubSalAmount = uF.parseToDouble(strSubSalAmount);
	// double dblTotalAmount = dblSalAmount * dblSubSalAmount / 100;
	//
	// if (dblIncrementDA > 0 && (uF.parseToInt(strSalaryHeadId) == DA ||
	// uF.parseToInt(strSalaryHeadId) == DA1)) {
	// dblTotalAmount = dblTotalAmount + dblIncrementDA;
	// }
	//
	// if(strSalaryType!=null && strSalaryType.equalsIgnoreCase("F")){
	// dblAmount = dblTotalAmount;
	// }else if(strSalaryType!=null && strSalaryType.equalsIgnoreCase("D")){
	// dblAmount = dblTotalAmount * dblPresent;
	// }else{
	// dblAmount = dblTotalAmount * (dblPresent / nTotalNumberOfDays);
	// }
	//
	// /**
	// * ----- Customised for Lift and Shift ----
	// * Policy of HRA = 10% (Basic + DA) or 500 whichever is less
	// * 29/07/2013
	// * -- Vipin
	// */
	//
	// /*if(dblAmount>=500 && uF.parseToInt(strSalaryHeadId) == HRA){
	// dblAmount = 500;
	// }
	// if(uF.parseToInt(strSalaryHeadId) == HRA){
	// dblAmount=Math.round(dblAmount);
	// }*/
	//
	// // hmInner.put("AMOUNT", uF.formatIntoTwoDecimal(dblTotalAmount));
	// hmInner.put("AMOUNT",
	// uF.getRoundOffValue(uF.parseToInt(CF.getRoundOffCondtion()),dblAmount));
	//
	// if(uF.parseToInt(strSalaryHeadId) == BREAKS){
	// dblAmount = dblTotalAmount * dblBreaks;
	// hmInner.put("AMOUNT",
	// uF.getRoundOffValue(uF.parseToInt(CF.getRoundOffCondtion()),dblAmount));
	// }
	//
	//
	//
	// } else if (uF.parseToInt(strSalaryHeadId) != BASIC &&
	// uF.parseToInt(strSalaryHeadId) != GROSS && uF.parseToInt(strSalaryHeadId)
	// != DA && uF.parseToInt(strSalaryHeadId) != DA1 &&
	// !"D".equalsIgnoreCase(rs.getString("earning_deduction"))) {
	//
	// if(strSubSalAmountType != null &&
	// strSubSalAmountType.equalsIgnoreCase("P") &&
	// uF.parseToInt(strSubSalId)==BASIC){
	// if(strSalaryType!=null && strSalaryType.equalsIgnoreCase("F")){
	// dblAmount = dblBasicDA;
	// }else if(strSalaryType!=null && strSalaryType.equalsIgnoreCase("D")){
	// dblAmount = dblBasicDA * dblPresent;
	// }else{
	// dblAmount = dblBasicDA * (dblPresent / nTotalNumberOfDays);
	// }
	// }else{
	// if(strSalaryType!=null && strSalaryType.equalsIgnoreCase("F")){
	// // dblAmount = dblAmount;
	// }else if(strSalaryType!=null && strSalaryType.equalsIgnoreCase("D")){
	// dblAmount = dblAmount * dblPresent;
	// }else{
	// dblAmount = dblAmount * (dblPresent / nTotalNumberOfDays);
	// }
	// }
	//
	// hmInner.put("AMOUNT",
	// uF.getRoundOffValue(uF.parseToInt(CF.getRoundOffCondtion()),dblAmount));
	// }else{
	// if(strSalaryType!=null && strSalaryType.equalsIgnoreCase("F")){
	// // dblAmount = dblAmount;
	// }else if(strSalaryType!=null && strSalaryType.equalsIgnoreCase("D")){
	// dblAmount = dblAmount * dblPresent;
	// }else{
	// dblAmount = dblAmount * (dblPresent / nTotalNumberOfDays);
	// }
	// hmInner.put("AMOUNT",
	// uF.getRoundOffValue(uF.parseToInt(CF.getRoundOffCondtion()),dblAmount));
	// }
	//
	//
	// hmInner.put("SALARY_HEAD_ID", strSalaryHeadId);
	// hmInner.put("EARNING_DEDUCTION", strEarningDeduction);
	// hmInner.put("SALARY_AMOUNT_TYPE", strSubSalAmountType);
	// hmInner.put("MULTIPLE_CALCULATION", strMultipleCalculation);
	// hmInner.put("IS_ALIGN_WITH_PERK", isAlignWithPerk);
	//
	// hmSalaryHeadMap.put(strSalaryHeadId, hmInner);
	//
	// if (strEarningDeduction != null) {
	// hmSalaryInner.put("EARNING_DEDUCTION", strEarningDeduction);
	// hmSalaryInner.put("AMOUNT",
	// uF.getRoundOffValue(uF.parseToInt(CF.getRoundOffCondtion()),dblAmount) +
	// "");
	// hmSalaryInner.put("SALARY_AMOUNT_TYPE", strSubSalAmountType);
	// hmSalaryInner.put("MULTIPLE_CALCULATION", strMultipleCalculation);
	// hmSalaryInner.put("IS_ALIGN_WITH_PERK", isAlignWithPerk);
	//
	// if (!rs.getBoolean("isdisplay") && uF.parseToBoolean(isCTCVariable)) {
	// hmInnerisDisplay.put(strSalaryHeadId, hmSalaryInner);
	// // }else if (rs.getBoolean("isdisplay")){
	// } else if (rs.getBoolean("isdisplay") &&
	// !uF.parseToBoolean(isCTCVariable)){
	// hmSalaryHeadReCalculatedMap.put(strSalaryHeadId, hmSalaryInner);
	// }
	// }
	// }
	// }
	// rs.close();
	// pst.close();
	//
	//
	// // if(nEmpId==668){
	// // System.out.println("hmSalaryHeadMap=="+hmSalaryHeadMap);
	// //
	// System.out.println("hmSalaryHeadReCalculatedMap=="+hmSalaryHeadReCalculatedMap);
	// // }
	//
	// } catch (Exception e) {
	// e.printStackTrace();
	// } finally {
	// if(rs != null) {
	// try {
	// rs.close();
	// } catch (SQLException e1) {
	// e1.printStackTrace();
	// }
	// }
	// if(pst != null) {
	// try {
	// pst.close();
	// } catch (SQLException e1) {
	// e1.printStackTrace();
	// }
	// }
	// }
	// return hmSalaryHeadReCalculatedMap;
	//
	// }

	// updated by kalpana on 19/10/2016
	// start
	public void getOrientationMemberDetails(HttpServletRequest request) {

		Connection con = null;
		PreparedStatement pst = null;
		ResultSet rs = null;
		Database db = new Database();
		db.setRequest(request);

		List<String> orientationMembersList = new ArrayList<String>();
		Map<String, String> hmOrientationViewAccess = new HashMap<String, String>();
		Map<String, String> hmOrientationEditAccess = new HashMap<String, String>();
		try {
			con = db.makeConnection(con);
			pst = con.prepareStatement("select * from orientation_details  order by orientation_details_id desc");
			rs = pst.executeQuery();
			while (rs.next()) {
				List<String> accessList = new ArrayList<String>();
				accessList.add(rs.getString("orientation_details_id"));// 0
				accessList.add(rs.getString("orientation_id"));// 1
				accessList.add(rs.getString("member_id"));// 2
				accessList.add(rs.getString("view_access"));// 3
				accessList.add(rs.getString("edit_access"));// 4
				orientationMembersList.add(rs.getString("orientation_id") + "_" + rs.getString("member_id"));
				hmOrientationViewAccess.put(rs.getString("orientation_id") + "_" + rs.getString("member_id"), rs.getString("view_access"));
				hmOrientationEditAccess.put(rs.getString("orientation_id") + "_" + rs.getString("member_id"), rs.getString("edit_access"));

			}
			rs.close();
			pst.close();

			request.setAttribute("orientationMembersList", orientationMembersList);
			request.setAttribute("hmOrientationViewAccess", hmOrientationViewAccess);
			request.setAttribute("hmOrientationEditAccess", hmOrientationEditAccess);

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			db.closeResultSet(rs);
			db.closeStatements(pst);
			db.closeConnection(con);

		}

	}

	// end
	public Map<String, String> getTravelTransportType(UtilityFunctions uF) {
		Map<String, String> hmTravelTransportType = new HashMap<String, String>();
		hmTravelTransportType.put("1", "Train");
		hmTravelTransportType.put("2", "Bus");
		hmTravelTransportType.put("3", "Flight");
		hmTravelTransportType.put("4", "Car");
		return hmTravelTransportType;
	}

	public Map<String, String> getTrainType(UtilityFunctions uF) {
		Map<String, String> hmTrainType = new HashMap<String, String>();
		hmTrainType.put("1", "3 Tier");
		hmTrainType.put("2", "Chair Car");
		hmTrainType.put("3", "AC 3 Tier");
		hmTrainType.put("4", "AC 2 Tier");
		hmTrainType.put("5", "AC 1st Clas");
		return hmTrainType;
	}

	public Map<String, String> getBusType(UtilityFunctions uF) {
		Map<String, String> hmBusType = new HashMap<String, String>();
		hmBusType.put("1", "A/c Bus");
		hmBusType.put("2", "Non- A/c Bus");
		return hmBusType;
	}

	public Map<String, String> getFlightType(UtilityFunctions uF) {
		Map<String, String> hmFlightType = new HashMap<String, String>();
		hmFlightType.put("1", "Economy Class");
		hmFlightType.put("2", "Business Class");
		return hmFlightType;
	}

	public Map<String, String> getCarType(UtilityFunctions uF) {
		Map<String, String> hmCarType = new HashMap<String, String>();
		hmCarType.put("1", "Cab");
		hmCarType.put("2", "Self Owned");
		return hmCarType;
	}

	public Map<String, String> getLocalType(UtilityFunctions uF) {
		Map<String, String> hmLocalType = new HashMap<String, String>();
		hmLocalType.put("1", "Local Conveyance");
		hmLocalType.put("2", "Food & Beverage (Non-Alcoholic)");
		hmLocalType.put("3", "Local Travel");
		return hmLocalType;
	}

	public Map<String, String> getLimitType(UtilityFunctions uF) {
		Map<String, String> hmLimitType = new HashMap<String, String>();
		hmLimitType.put("1", "No Limit");
		hmLimitType.put("2", "Actual");
		return hmLimitType;
	}

	public Map<String, String> getEligibleType(UtilityFunctions uF) {
		Map<String, String> hmEligibleType = new HashMap<String, String>();
		hmEligibleType.put("1", "Day");
		hmEligibleType.put("2", "Week");
		hmEligibleType.put("3", "Month");
		return hmEligibleType;
	}

	public Map<String, String> getLodgingType(UtilityFunctions uF) {
		Map<String, String> hmLodgingType = new HashMap<String, String>();
		hmLodgingType.put("1", "2 Star- Single Occupancy");
		hmLodgingType.put("2", "2 Star- Double Occupancy");
		hmLodgingType.put("3", "3 Star- Single Occupancy");
		hmLodgingType.put("4", "3 Star- Double Occupancy");
		hmLodgingType.put("5", "4 Star- Single Occupancy");
		hmLodgingType.put("6", "4 Star- Double Occupancy");
		hmLodgingType.put("7", "5 Star- Single Occupancy");
		hmLodgingType.put("8", "5 Star- Double Occupancy");
		hmLodgingType.put("9", "Service Apartment");
		return hmLodgingType;
	}

	public Map<String, String> getWorkLocationWorkingHrs(Connection con) {
		Map<String, String> hmworkingHrsByLocation = new HashMap<String, String>();
		PreparedStatement pst = null;
		ResultSet rs = null;
		try {

			pst = con.prepareStatement("select * from work_location_info order by wlocation_id ");
			rs = pst.executeQuery();
			while (rs.next()) {
				String locationstarttime = rs.getString("wlocation_start_time");
				String locationendtime = rs.getString("wlocation_end_time");
				// System.out.println("locationstarttime==>"+locationstarttime+"==>locationendtime==>"+locationendtime);
				Time t = uF.getTimeFormat(locationstarttime, DBTIME);
				long long_startTime = t.getTime();
				// System.out.println("long_startTime==>"+long_startTime);
				Time t1 = uF.getTimeFormat(locationendtime, DBTIME);
				long long_endTime = t1.getTime();
				// System.out.println("long_endTime==>"+long_endTime);
				double total_time = uF.parseToDouble(uF.getTimeDiffInHoursMins(long_startTime, long_endTime));
				// System.out.println("==>total_time==>"+total_time+"==>location==>"+rs.getString("wlocation_id"));
				hmworkingHrsByLocation.put(rs.getString("wlocation_id"), "" + total_time);
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmworkingHrsByLocation;
	}

	public String getEmpJoiningDate(Connection con, UtilityFunctions uF, int nEmpId) {
		String strEmpJoiningDate = null;
		PreparedStatement pst = null;
		ResultSet rs = null;
		try {
			pst = con.prepareStatement("SELECT * FROM employee_official_details eod, employee_personal_details epd "
					+ "WHERE epd.emp_per_id=eod.emp_id and eod.emp_id=?");
			pst.setInt(1, nEmpId);
			rs = pst.executeQuery();
			while (rs.next()) {
				strEmpJoiningDate = uF.getDateFormat(rs.getString("joining_date"), DBDATE, DATE_FORMAT);
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return strEmpJoiningDate;
	}

	public Map<String, String> getEmpHRIdMap(Connection con, UtilityFunctions uF) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmEmpHrId = new HashMap<String, String>();
		try {
			pst = con.prepareStatement("SELECT emp_id,emp_hr FROM employee_official_details");
			rs = pst.executeQuery();
			while (rs.next()) {
				hmEmpHrId.put(rs.getString("emp_id"), rs.getString("emp_hr"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmEmpHrId;
	}

	public List<String> getOrientationMemberDetails(Connection con, int id) {

		PreparedStatement pst = null;

		ResultSet rs = null;
		List<String> memberList = new ArrayList<String>();
		try {

			pst = con.prepareStatement("select * from orientation_details where orientation_id=?");
			pst.setInt(1, id);
			rs = pst.executeQuery();
			while (rs.next()) {
				memberList.add(rs.getString("member_id"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return memberList;
	}

	public Map<String, String> getOrientMemberID(Connection con) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> orientationMemberMp = new HashMap<String, String>();

		try {

			pst = con.prepareStatement("select * from orientation_member where status=true order by weightage");
			rs = pst.executeQuery();
			while (rs.next()) {
				orientationMemberMp.put(rs.getString("member_name"), rs.getString("member_id"));
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
		}
		return orientationMemberMp;
	}

	public void deleteWRUserAlerts(CommonFunctions CF, HttpServletRequest request, String strDomain, String alertID) {
		Connection con = null;
		PreparedStatement pst = null;
		Database db = new Database();
		db.setRequest(request);
		UtilityFunctions uF = new UtilityFunctions();
		try {
			con = db.makeConnection(con);

			UserAlerts userAlerts = new UserAlerts(con, uF, CF, request);
			userAlerts.setStrDomain(strDomain);
			userAlerts.setAlertID(alertID);
			userAlerts.setStatus(DELETE_WR_ALERT);
			Thread t = new Thread(userAlerts);
			t.run();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			db.closeStatements(pst);
			db.closeConnection(con);
		}
	}

	public List<String> getEmpAccountantList(Connection con, UtilityFunctions uF, String strEmpId, Map<String, String> hmUserTypeId) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		List<String> alAccountant = new ArrayList<String>();

		try {
			String strLocationId = getEmpWlocationId(con, uF, strEmpId);

			pst = con.prepareStatement("select emp_id from user_details where usertype_id=? and wlocation_id_access like '%," + strLocationId + ",%'");
			pst.setInt(1, uF.parseToInt(hmUserTypeId.get(ACCOUNTANT)));
			rs = pst.executeQuery();
			while (rs.next()) {
				alAccountant.add(rs.getString("emp_id"));
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
		}
		return alAccountant;
	}

	public List<String> getGlobalHRList(Connection con, UtilityFunctions uF, Map<String, String> hmUserTypeId) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		List<String> alGlobalHR = new ArrayList<String>();

		try {

			pst = con.prepareStatement("select emp_id from user_details where usertype_id=?");
			pst.setInt(1, uF.parseToInt(hmUserTypeId.get(ADMIN)));
			rs = pst.executeQuery();
			while (rs.next()) {
				alGlobalHR.add(rs.getString("emp_id"));
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
		}
		return alGlobalHR;
	}

	public void getPerkAlignAmount(Connection con, UtilityFunctions uF, int nEmpId, String strFinancialYearStart, String strFinancialYearEnd, String strD1,
			String strD2, String strPC, int nEmpOrgId, int nLevelId, Map<String, String> hmPerkAlignAmount) {
		PreparedStatement pst = null;
		ResultSet rs = null;

		try {

			StringBuilder sbQuery = new StringBuilder();
			// sbQuery.append("select (amount/12) as amount, salary_head_id from (select sum(amount) as amount, salary_head_id from "
			// +
			// "(select psd.* from perk_salary_details psd, perk_assign_salary_details pasd where psd.perk_salary_id = pasd.perk_salary_id "
			// +
			// "and pasd.emp_id=? and psd.level_id=? and psd.org_id=? and psd.financial_year_start=? and psd.financial_year_end=? "
			// +
			// "and pasd.financial_year_start=? and pasd.financial_year_end=? and pasd.paycycle_from=? and pasd.paycycle_to=? "
			// +
			// "and pasd.paycycle=? and pasd.status=true and pasd.trail_status=true and psd.is_attachment = false");
			// sbQuery.append(" union ");
			// sbQuery.append("select psd.* from perk_salary_details psd, perk_assign_salary_details pasd where psd.perk_salary_id = pasd.perk_salary_id "
			// +
			// "and pasd.emp_id=? and psd.level_id=? and psd.org_id=? and psd.financial_year_start=? and psd.financial_year_end=? "
			// +
			// "and pasd.financial_year_start=? and pasd.financial_year_end=? and pasd.paycycle_from=? and pasd.paycycle_to=? "
			// +
			// "and pasd.paycycle=? and pasd.status=true and pasd.trail_status=true and psd.is_attachment= true) a group by salary_head_id) a");
			sbQuery.append("select sum(amount) as amount, salary_head_id from "
					+ "(select psd.* from perk_salary_details psd, perk_assign_salary_details pasd where psd.perk_salary_id = pasd.perk_salary_id "
					+ "and pasd.emp_id=? and psd.level_id=? and psd.org_id=? and psd.financial_year_start=? and psd.financial_year_end=? "
					+ "and pasd.financial_year_start=? and pasd.financial_year_end=? and pasd.paycycle_from=? and pasd.paycycle_to=? "
					+ "and pasd.paycycle=? and pasd.status=false and pasd.trail_status=true and psd.is_attachment = false");
			sbQuery.append(" union ");
			sbQuery.append("select psd.* from perk_salary_details psd, perk_assign_salary_details pasd where psd.perk_salary_id = pasd.perk_salary_id "
					+ "and pasd.emp_id=? and psd.level_id=? and psd.org_id=? and psd.financial_year_start=? and psd.financial_year_end=? "
					+ "and pasd.financial_year_start=? and pasd.financial_year_end=? and pasd.paycycle_from=? and pasd.paycycle_to=? "
					+ "and pasd.paycycle=? and pasd.status=true and pasd.trail_status=true and psd.is_attachment= true) a group by salary_head_id");
			pst = con.prepareStatement(sbQuery.toString());
			pst.setInt(1, nEmpId);
			pst.setInt(2, nLevelId);
			pst.setInt(3, nEmpOrgId);
			pst.setDate(4, uF.getDateFormat(strFinancialYearStart, DATE_FORMAT));
			pst.setDate(5, uF.getDateFormat(strFinancialYearEnd, DATE_FORMAT));
			pst.setDate(6, uF.getDateFormat(strFinancialYearStart, DATE_FORMAT));
			pst.setDate(7, uF.getDateFormat(strFinancialYearEnd, DATE_FORMAT));
			pst.setDate(8, uF.getDateFormat(strD1, DATE_FORMAT));
			pst.setDate(9, uF.getDateFormat(strD2, DATE_FORMAT));
			pst.setInt(10, uF.parseToInt(strPC));
			pst.setInt(11, nEmpId);
			pst.setInt(12, nLevelId);
			pst.setInt(13, nEmpOrgId);
			pst.setDate(14, uF.getDateFormat(strFinancialYearStart, DATE_FORMAT));
			pst.setDate(15, uF.getDateFormat(strFinancialYearEnd, DATE_FORMAT));
			pst.setDate(16, uF.getDateFormat(strFinancialYearStart, DATE_FORMAT));
			pst.setDate(17, uF.getDateFormat(strFinancialYearEnd, DATE_FORMAT));
			pst.setDate(18, uF.getDateFormat(strD1, DATE_FORMAT));
			pst.setDate(19, uF.getDateFormat(strD2, DATE_FORMAT));
			pst.setInt(20, uF.parseToInt(strPC));
			// System.out.println("pst=====>"+pst);
			rs = pst.executeQuery();
			while (rs.next()) {
				double amount = uF.parseToDouble(rs.getString("amount"));
				if (amount > 0.0d) {
					amount = amount / 12.0d;
				}
				hmPerkAlignAmount.put(rs.getString("salary_head_id"), uF.formatIntoZeroWithOutComma(amount));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
		}
	}

	public double getPerkAlignTDSAmount(Connection con, CommonFunctions CF, UtilityFunctions uF, int nEmpId, String strFinancialYearStart,
			String strFinancialYearEnd, int nEmpOrgId, int nLevelId) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		double dblPerkAlignTDSAmount = 0.0d;
		try {

			StringBuilder sbQuery = new StringBuilder();
			sbQuery.append("select sum(applied_amount) as applied_amount from (select psd.*,psad.applied_amount "
					+ "from perk_salary_details psd, perk_assign_salary_details pasd, perk_salary_applied_details psad "
					+ "where psd.perk_salary_id = pasd.perk_salary_id and psd.perk_salary_id = psad.perk_salary_id "
					+ "and psad.perk_salary_id = pasd.perk_salary_id and pasd.emp_id=? and psd.level_id=? and psd.org_id=? "
					+ "and psd.financial_year_start=? and psd.financial_year_end=? and pasd.financial_year_start=? "
					+ "and pasd.financial_year_end=? and pasd.status=true and pasd.trail_status=true and psd.is_attachment= true "
					+ "and psad.emp_id=? and psad.is_approved=1 and psad.financial_year_start=? and psad.financial_year_end=? "
					+ "and psad.is_nontaxable = true) a ");
			pst = con.prepareStatement(sbQuery.toString());
			pst.setInt(1, nEmpId);
			pst.setInt(2, nLevelId);
			pst.setInt(3, nEmpOrgId);
			pst.setDate(4, uF.getDateFormat(strFinancialYearStart, DATE_FORMAT));
			pst.setDate(5, uF.getDateFormat(strFinancialYearEnd, DATE_FORMAT));
			pst.setDate(6, uF.getDateFormat(strFinancialYearStart, DATE_FORMAT));
			pst.setDate(7, uF.getDateFormat(strFinancialYearEnd, DATE_FORMAT));
			pst.setInt(8, nEmpId);
			pst.setDate(9, uF.getDateFormat(strFinancialYearStart, DATE_FORMAT));
			pst.setDate(10, uF.getDateFormat(strFinancialYearEnd, DATE_FORMAT));
			// System.out.println("pst=====>"+pst);
			rs = pst.executeQuery();
			while (rs.next()) {
				dblPerkAlignTDSAmount = uF.parseToDouble(rs.getString("applied_amount"));
			}
			rs.close();
			pst.close();

			// System.out.println("dblPerkAlignTDSAmount=====>"+dblPerkAlignTDSAmount);
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
		}
		return dblPerkAlignTDSAmount;
	}

	public Map<String, List<Map<String, String>>> getIndividualPerkAlignAmount(Connection con, UtilityFunctions uF, CommonFunctions CF, int nEmpId,
			String strFYS, String strFYE, String strPCS, String strPCE, int nPC) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, List<Map<String, String>>> hmPerkAlign = new HashMap<String, List<Map<String, String>>>();
		try {

			String strOrgId = CF.getEmpOrgId(con, uF, "" + nEmpId);
			String strLevelId = CF.getEmpLevelId(con, "" + nEmpId);
			int nEmpOrgId = uF.parseToInt(strOrgId);
			int nLevelId = uF.parseToInt(strLevelId);

			StringBuilder sbQuery = new StringBuilder();
			sbQuery.append("select psd.* from perk_salary_details psd, perk_assign_salary_details pasd where psd.perk_salary_id = pasd.perk_salary_id "
					+ "and pasd.emp_id=? and psd.level_id=? and psd.org_id=? and psd.financial_year_start=? and psd.financial_year_end=? "
					+ "and pasd.financial_year_start=? and pasd.financial_year_end=? and pasd.paycycle_from=? and pasd.paycycle_to=? "
					+ "and pasd.paycycle=? and pasd.status=true and pasd.trail_status=true and psd.is_attachment = false");
			sbQuery.append(" union ");
			sbQuery.append("select psd.* from perk_salary_details psd, perk_assign_salary_details pasd where psd.perk_salary_id = pasd.perk_salary_id "
					+ "and pasd.emp_id=? and psd.level_id=? and psd.org_id=? and psd.financial_year_start=? and psd.financial_year_end=? "
					+ "and pasd.financial_year_start=? and pasd.financial_year_end=? and pasd.paycycle_from=? and pasd.paycycle_to=? "
					+ "and pasd.paycycle=? and pasd.status=true and pasd.trail_status=true and psd.is_attachment= true");
			pst = con.prepareStatement(sbQuery.toString());
			pst.setInt(1, nEmpId);
			pst.setInt(2, nLevelId);
			pst.setInt(3, nEmpOrgId);
			pst.setDate(4, uF.getDateFormat(strFYS, DATE_FORMAT));
			pst.setDate(5, uF.getDateFormat(strFYE, DATE_FORMAT));
			pst.setDate(6, uF.getDateFormat(strFYS, DATE_FORMAT));
			pst.setDate(7, uF.getDateFormat(strFYE, DATE_FORMAT));
			pst.setDate(8, uF.getDateFormat(strPCS, DATE_FORMAT));
			pst.setDate(9, uF.getDateFormat(strPCE, DATE_FORMAT));
			pst.setInt(10, nPC);
			pst.setInt(11, nEmpId);
			pst.setInt(12, nLevelId);
			pst.setInt(13, nEmpOrgId);
			pst.setDate(14, uF.getDateFormat(strFYS, DATE_FORMAT));
			pst.setDate(15, uF.getDateFormat(strFYE, DATE_FORMAT));
			pst.setDate(16, uF.getDateFormat(strFYS, DATE_FORMAT));
			pst.setDate(17, uF.getDateFormat(strFYE, DATE_FORMAT));
			pst.setDate(18, uF.getDateFormat(strPCS, DATE_FORMAT));
			pst.setDate(19, uF.getDateFormat(strPCE, DATE_FORMAT));
			pst.setInt(20, nPC);
			// System.out.println("pst=====>"+pst);
			rs = pst.executeQuery();
			while (rs.next()) {
				List<Map<String, String>> alPerkAlign = hmPerkAlign.get(rs.getString("salary_head_id"));
				if (alPerkAlign == null)
					alPerkAlign = new ArrayList<Map<String, String>>();

				Map<String, String> hmPerkAlignInner = new HashMap<String, String>();
				hmPerkAlignInner.put("PERK_SALARY_ID", rs.getString("perk_salary_id"));
				hmPerkAlignInner.put("PERK_NAME", rs.getString("perk_name"));
				hmPerkAlignInner.put("PERK_SALARY_HEAD_ID", rs.getString("salary_head_id"));

				double dblAmount = uF.parseToDouble(rs.getString("amount")) / 12;
				hmPerkAlignInner.put("PERK_SALARY_AMOUNT", uF.formatIntoTwoDecimal(dblAmount));

				alPerkAlign.add(hmPerkAlignInner);
				hmPerkAlign.put(rs.getString("salary_head_id"), alPerkAlign);
			}
			rs.close();
			pst.close();

			// System.out.println("hmPerkAlign=====>" + hmPerkAlign);
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
		}
		return hmPerkAlign;
	}

	public Map<String, String> getEmpUANMap(Connection con) {
		Map<String, String> hmEmpUAN = new HashMap<String, String>();
		PreparedStatement pst = null;
		ResultSet rs = null;
		try {
			pst = con.prepareStatement(selectEmployeeR3);
			rs = pst.executeQuery();
			while (rs.next()) {
				hmEmpUAN.put(rs.getString("emp_id"), rs.getString("uan_no"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmEmpUAN;
	}

	public double getHRAExemptionCalculation(Connection con, UtilityFunctions uF2, int nMonthsLeft, Map<String, String> hmPaidSalaryDetails,
			String strFinancialYearStart, String strFinancialYearEnd, String strEmpId, double dblHRA, double dblBasicDA, Map<String, String> hmEmpMertoMap,
			Map<String, String> hmEmpRentPaidMap, int nAttendanceApproveMonth, double dblHraSalHeadsCalAttendace, double dblBasicSalCalAttendace) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		double dblHRAExemption = 0;

		try {

			pst = con.prepareStatement("select * from hra_exemption_details where financial_year_from = ? and financial_year_to =? ");
			pst.setDate(1, uF.getDateFormat(strFinancialYearStart, DATE_FORMAT));
			pst.setDate(2, uF.getDateFormat(strFinancialYearEnd, DATE_FORMAT));
			rs = pst.executeQuery();
//			System.out.println("pst ===>> " + pst);

			double dblCondition1 = 0;
			double dblCondition2 = 0;
			double dblCondition3 = 0;
			String strHraSalHeads = null;
			while (rs.next()) {
				dblCondition1 = rs.getDouble("condition1");
				dblCondition2 = rs.getDouble("condition2");
				dblCondition3 = rs.getDouble("condition3");
				strHraSalHeads = rs.getString("salary_head_id");
			}
			rs.close();
			pst.close();

			String[] hraSalaryHeads = null;
			if (strHraSalHeads != null) {
				hraSalaryHeads = strHraSalHeads.split(",");
			}

			double dblHraSalHeadsAmount = 0;
			for (int i = 0; hraSalaryHeads != null && i < hraSalaryHeads.length; i++) {
				dblHraSalHeadsAmount += uF.parseToDouble((String) hmPaidSalaryDetails.get(hraSalaryHeads[i]));
			}

			boolean isMetro = uF.parseToBoolean(hmEmpMertoMap.get(strEmpId));

			// String strBasicPaidAmount = hmPaidSalaryDetails.get(BASIC+"");
			String strHRAPaidAmount = hmPaidSalaryDetails.get(HRA + "");

			// log.debug("<===            ===>");
			// log.debug(HRA + " hmEmpPaidHRA==>" + hmPaidSalaryDetails);
			// log.debug("hmEmpPaidHRA.get(strEmpId)==>" +
			// hmPaidSalaryDetails.get(strEmpId));

			// String strMonthsLeft = uF.dateDifference(strD1, DATE_FORMAT,
			// strFinancialYearEnd, DATE_FORMAT);
			// int nMonthsLeft = uF.parseToInt(strMonthsLeft) / 30;

//			 System.out.println("nMonthsLeft=="+nMonthsLeft);

			double dblBasicToBePaidAmount = (nMonthsLeft - nAttendanceApproveMonth) * dblBasicDA;
			dblBasicToBePaidAmount += dblBasicSalCalAttendace;

			double dblHRAToBePaidAmount = (nMonthsLeft - nAttendanceApproveMonth) * dblHRA;
			dblHRAToBePaidAmount += dblHraSalHeadsCalAttendace;

			// double dblTotalBasicDAAmount =
			// uF.parseToDouble(strBasicPaidAmount) + dblBasicToBePaidAmount;
			double dblTotalBasicDAAmount = dblHraSalHeadsAmount + dblBasicToBePaidAmount;
			double dblTotalHRAAmount = uF.parseToDouble(strHRAPaidAmount) + dblHRAToBePaidAmount;

			double dblTotalRentPaid = uF.parseToDouble(hmEmpRentPaidMap.get(strEmpId));

			// if(strEmpId.equalsIgnoreCase("91")){
//			 System.out.println("hra nMonthsLeft====>"+nMonthsLeft);
//			 System.out.println("hra nAttendanceApproveMonth====>"+nAttendanceApproveMonth);
//			 System.out.println("hra dblBasicDA====>"+dblBasicDA);
//			 System.out.println("hra dblHRA====>"+dblHRA);
//			 System.out.println("hra dblBasicToBePaidAmount====>"+dblBasicToBePaidAmount);
//			 System.out.println("hra dblHRAToBePaidAmount====>"+dblHRAToBePaidAmount);
//			 System.out.println("hra dblTotalBasicDAAmount====>"+dblTotalBasicDAAmount);
//			 System.out.println("hra dblTotalHRAAmount====>"+dblTotalHRAAmount);
//			 System.out.println("hra dblTotalRentPaid====>"+dblTotalRentPaid);
//			 System.out.println("hra dblBasicSalCalAttendace====>"+dblBasicSalCalAttendace);
//			 System.out.println("hra dblHraSalHeadsCalAttendace====>"+dblHraSalHeadsCalAttendace);
			// }

			// double dblRentPaidGreaterThanCondition1 = dblCondition1 *
			// dblTotalBasicDAAmount /100;
			double dblRentPaidGreaterThanCondition1 = 0;

			// log.debug("dblRentPaidGreaterThanCondition1==>" +
			// dblRentPaidGreaterThanCondition1);
			// log.debug("dblCondition1==>" + dblCondition1);
			// log.debug("dblTotalBasicDAAmount==>" + dblTotalBasicDAAmount);

			if (dblTotalRentPaid > dblRentPaidGreaterThanCondition1) {

//				System.out.println("dblCondition1 ====>"+dblCondition1 + " -- dblTotalBasicDAAmount ===>> " + dblTotalBasicDAAmount);
				dblRentPaidGreaterThanCondition1 = dblCondition1 * dblTotalBasicDAAmount / 100;
//				System.out.println("dblTotalRentPaid ====>"+dblTotalRentPaid + " -- dblRentPaidGreaterThanCondition1 ===>> " + dblRentPaidGreaterThanCondition1);
				dblRentPaidGreaterThanCondition1 = dblTotalRentPaid - dblRentPaidGreaterThanCondition1;

			} else if (dblTotalRentPaid > 0) {
				dblRentPaidGreaterThanCondition1 = dblCondition1 * dblTotalBasicDAAmount / 100;

			}

			double dblRentPaidCondition23 = 0;

			if (isMetro) {
				dblRentPaidCondition23 = dblCondition2 * dblTotalBasicDAAmount / 100;
			} else {
				dblRentPaidCondition23 = dblCondition3 * dblTotalBasicDAAmount / 100;
			}

			dblHRAExemption = Math.min(dblTotalHRAAmount, dblRentPaidGreaterThanCondition1);
			// if(strEmpId.equalsIgnoreCase("23")){
//			 System.out.println("1 dblHRAExemption====>"+dblHRAExemption);
			// }
			dblHRAExemption = Math.min(dblHRAExemption, dblRentPaidCondition23);

			// if(strEmpId.equalsIgnoreCase("23")){
//			 System.out.println("dblTotalHRAAmount====>"+dblTotalHRAAmount);
//			 System.out.println("dblRentPaidGreaterThanCondition1====>"+dblRentPaidGreaterThanCondition1);
//			 System.out.println("dblRentPaidCondition23====>"+dblRentPaidCondition23);
//			 System.out.println("dblHRAExemption====>"+dblHRAExemption);
			//
			// }

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return dblHRAExemption;
	}

	public List<String> getAppraisalFinalStatus(Connection con) {
		List<String> appraisalFinalList = new ArrayList<String>();

		PreparedStatement pst = null;
		ResultSet rs = null;

		try {

			pst = con.prepareStatement("select * from appraisal_final_sattlement order by appraisal_id");
			rs = pst.executeQuery();
			while (rs.next()) {
				appraisalFinalList.add(rs.getString("appraisal_id"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return appraisalFinalList;
	}

	public List<String> getAppraisalQueAnsStatus(Connection con) {
		List<String> appQueAnsStatusList = new ArrayList<String>();

		PreparedStatement pst = null;
		ResultSet rs = null;

		try {

			pst = con.prepareStatement("select appraisal_id,appraisal_freq_id from appraisal_question_answer order by appraisal_id");
			rs = pst.executeQuery();
			while (rs.next()) {
				appQueAnsStatusList.add(rs.getString("appraisal_id") + "_" + rs.getString("appraisal_freq_id"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return appQueAnsStatusList;
	}

	public void getReimbursementCTCHeadAmount(Connection con, UtilityFunctions uF, int nEmpId, String strFinancialYearStart, String strFinancialYearEnd,
			String strD1, String strD2, String strPC, int nEmpOrgId, int nLevelId, Map<String, String> hmReimCTCHeadAmount) {
		PreparedStatement pst = null;
		ResultSet rs = null;

		try {

			StringBuilder sbQuery = new StringBuilder();
			// sbQuery.append("select sum(amount) as amount,reimbursement_ctc_id from (select * from reimbursement_head_amt_details rhad, "
			// +
			// "reimbursement_head_details rhd where rhad.reimbursement_head_id=rhd.reimbursement_head_id and rhad.financial_year_start=? "
			// +
			// "and rhad.financial_year_end=? and rhd.level_id=? and rhd.org_id=? and rhad.is_attachment= false and rhad.is_optimal=true "
			// +
			// "and rhd.reimbursement_ctc_id in (select reimbursement_ctc_id from reimbursement_ctc_details where level_id=? and org_id=?) "
			// +
			// "and rhd.reimbursement_head_id in (select reimbursement_head_id from reimbursement_assign_head_details where emp_id=? "
			// +
			// "and financial_year_start=? and financial_year_end=? and level_id=? and org_id=? and paycycle_from=? and paycycle_to=? "
			// +
			// "and paycycle=? and status=false and trail_status=true) ");
			// sbQuery.append(" union ");
			// sbQuery.append("select * from reimbursement_head_amt_details rhad, reimbursement_head_details rhd where rhad.reimbursement_head_id=rhd.reimbursement_head_id "
			// +
			// "and rhad.financial_year_start=? and rhad.financial_year_end=? and rhd.level_id=? and rhd.org_id=? and rhad.is_attachment= true "
			// +
			// "and rhad.is_optimal=false and rhd.reimbursement_ctc_id in (select reimbursement_ctc_id from reimbursement_ctc_details "
			// +
			// "where level_id=? and org_id=?) and rhd.reimbursement_head_id in (select reimbursement_head_id from reimbursement_assign_head_details "
			// +
			// "where emp_id=? and financial_year_start=? and financial_year_end=? and level_id=? and org_id=? and paycycle_from=? and paycycle_to=? "
			// +
			// "and paycycle=? and status=true and trail_status=true)) a group by reimbursement_ctc_id");
			// pst = con.prepareStatement(sbQuery.toString());
			// pst.setDate(1, uF.getDateFormat(strFinancialYearStart,
			// DATE_FORMAT));
			// pst.setDate(2, uF.getDateFormat(strFinancialYearEnd,
			// DATE_FORMAT));
			// pst.setInt(3, nLevelId);
			// pst.setInt(4, nEmpOrgId);
			// pst.setInt(5, nLevelId);
			// pst.setInt(6, nEmpOrgId);
			// pst.setInt(7, nEmpId);
			// pst.setDate(8, uF.getDateFormat(strFinancialYearStart,
			// DATE_FORMAT));
			// pst.setDate(9, uF.getDateFormat(strFinancialYearEnd,
			// DATE_FORMAT));
			// pst.setInt(10, nLevelId);
			// pst.setInt(11, nEmpOrgId);
			// pst.setDate(12, uF.getDateFormat(strD1, DATE_FORMAT));
			// pst.setDate(13, uF.getDateFormat(strD2, DATE_FORMAT));
			// pst.setInt(14, uF.parseToInt(strPC));
			//
			// pst.setDate(15, uF.getDateFormat(strFinancialYearStart,
			// DATE_FORMAT));
			// pst.setDate(16, uF.getDateFormat(strFinancialYearEnd,
			// DATE_FORMAT));
			// pst.setInt(17, nLevelId);
			// pst.setInt(18, nEmpOrgId);
			// pst.setInt(19, nLevelId);
			// pst.setInt(20, nEmpOrgId);
			// pst.setInt(21, nEmpId);
			// pst.setDate(22, uF.getDateFormat(strFinancialYearStart,
			// DATE_FORMAT));
			// pst.setDate(23, uF.getDateFormat(strFinancialYearEnd,
			// DATE_FORMAT));
			// pst.setInt(24, nLevelId);
			// pst.setInt(25, nEmpOrgId);
			// pst.setDate(26, uF.getDateFormat(strD1, DATE_FORMAT));
			// pst.setDate(27, uF.getDateFormat(strD2, DATE_FORMAT));
			// pst.setInt(28, uF.parseToInt(strPC));

			sbQuery.append("select sum(amount) as amount,reimbursement_ctc_id from (select * from reimbursement_head_amt_details rhad, "
					+ "reimbursement_head_details rhd where rhad.reimbursement_head_id=rhd.reimbursement_head_id "
					+ "and rhad.financial_year_start=? and rhad.financial_year_end=? and rhd.level_id=? and rhd.org_id=? and rhad.is_attachment= true "
					+ "and rhad.is_optimal=false and rhd.reimbursement_ctc_id in (select reimbursement_ctc_id from reimbursement_ctc_details "
					+ "where level_id=? and org_id=?) and rhd.reimbursement_head_id in (select reimbursement_head_id from reimbursement_assign_head_details "
					+ "where emp_id=? and financial_year_start=? and financial_year_end=? and level_id=? and org_id=? and paycycle_from=? and paycycle_to=? "
					+ "and paycycle=? and status=true and trail_status=true)) a group by reimbursement_ctc_id");
			pst = con.prepareStatement(sbQuery.toString());
			pst.setDate(1, uF.getDateFormat(strFinancialYearStart, DATE_FORMAT));
			pst.setDate(2, uF.getDateFormat(strFinancialYearEnd, DATE_FORMAT));
			pst.setInt(3, nLevelId);
			pst.setInt(4, nEmpOrgId);
			pst.setInt(5, nLevelId);
			pst.setInt(6, nEmpOrgId);
			pst.setInt(7, nEmpId);
			pst.setDate(8, uF.getDateFormat(strFinancialYearStart, DATE_FORMAT));
			pst.setDate(9, uF.getDateFormat(strFinancialYearEnd, DATE_FORMAT));
			pst.setInt(10, nLevelId);
			pst.setInt(11, nEmpOrgId);
			pst.setDate(12, uF.getDateFormat(strD1, DATE_FORMAT));
			pst.setDate(13, uF.getDateFormat(strD2, DATE_FORMAT));
			pst.setInt(14, uF.parseToInt(strPC));
			// System.out.println("pst=====>"+pst);
			rs = pst.executeQuery();
			while (rs.next()) {
				double amount = uF.parseToDouble(rs.getString("amount"));
				if (amount > 0.0d) {
					amount = amount / 12.0d;
				}
				hmReimCTCHeadAmount.put(rs.getString("reimbursement_ctc_id"), uF.formatIntoZeroWithOutComma(amount));
				hmReimCTCHeadAmount.put(rs.getString("reimbursement_ctc_id") + "_ANNUAL",
						uF.formatIntoZeroWithOutComma(uF.parseToDouble(rs.getString("amount"))));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
		}
	}

	public void getReimbursementCTC(Connection con, UtilityFunctions uF, int nEmpId, String strFinancialYearStart, String strFinancialYearEnd, String strD1,
			String strD2, String strPC, int nEmpOrgId, int nLevelId, Map<String, String> hmReimCTCHead) {
		PreparedStatement pst = null;
		ResultSet rs = null;

		try {

			StringBuilder sbQuery = new StringBuilder();
			// sbQuery.append("select * from reimbursement_ctc_details where level_id=? and org_id=? and reimbursement_ctc_id in "
			// +
			// "(select rhd.reimbursement_ctc_id from reimbursement_head_amt_details rhad, reimbursement_head_details rhd where "
			// +
			// "rhad.reimbursement_head_id=rhd.reimbursement_head_id and rhad.financial_year_start=? and rhad.financial_year_end=? "
			// +
			// "and rhd.level_id=? and rhd.org_id=? and rhad.is_attachment=false and rhad.is_optimal=true and rhd.reimbursement_head_id "
			// +
			// "in (select reimbursement_head_id from reimbursement_assign_head_details where emp_id=? and financial_year_start=? "
			// +
			// "and financial_year_end=? and level_id=? and org_id=? and paycycle_from=? and paycycle_to=? and paycycle=? "
			// +
			// "and status=false and trail_status=true))");
			// sbQuery.append(" union ");
			// sbQuery.append("select * from reimbursement_ctc_details where level_id=? and org_id=? and reimbursement_ctc_id in "
			// +
			// "(select rhd.reimbursement_ctc_id from reimbursement_head_amt_details rhad, reimbursement_head_details rhd "
			// +
			// "where rhad.reimbursement_head_id=rhd.reimbursement_head_id and rhad.financial_year_start=? and rhad.financial_year_end=? "
			// +
			// "and rhd.level_id=? and rhd.org_id=? and rhad.is_attachment= true and rhad.is_optimal=false and rhd.reimbursement_head_id "
			// +
			// "in (select reimbursement_head_id from reimbursement_assign_head_details where emp_id=? and financial_year_start=? "
			// +
			// "and financial_year_end=? and level_id=? and org_id=? and paycycle_from=? and paycycle_to=? and paycycle=? and status=true "
			// +
			// "and trail_status=true))");
			// pst = con.prepareStatement(sbQuery.toString());
			// pst.setInt(1, nLevelId);
			// pst.setInt(2, nEmpOrgId);
			// pst.setDate(3, uF.getDateFormat(strFinancialYearStart,
			// DATE_FORMAT));
			// pst.setDate(4, uF.getDateFormat(strFinancialYearEnd,
			// DATE_FORMAT));
			// pst.setInt(5, nLevelId);
			// pst.setInt(6, nEmpOrgId);
			// pst.setInt(7, nEmpId);
			// pst.setDate(8, uF.getDateFormat(strFinancialYearStart,
			// DATE_FORMAT));
			// pst.setDate(9, uF.getDateFormat(strFinancialYearEnd,
			// DATE_FORMAT));
			// pst.setInt(10, nLevelId);
			// pst.setInt(11, nEmpOrgId);
			// pst.setDate(12, uF.getDateFormat(strD1, DATE_FORMAT));
			// pst.setDate(13, uF.getDateFormat(strD2, DATE_FORMAT));
			// pst.setInt(14, uF.parseToInt(strPC));
			//
			// pst.setInt(15, nLevelId);
			// pst.setInt(16, nEmpOrgId);
			// pst.setDate(17, uF.getDateFormat(strFinancialYearStart,
			// DATE_FORMAT));
			// pst.setDate(18, uF.getDateFormat(strFinancialYearEnd,
			// DATE_FORMAT));
			// pst.setInt(19, nLevelId);
			// pst.setInt(20, nEmpOrgId);
			// pst.setInt(21, nEmpId);
			// pst.setDate(22, uF.getDateFormat(strFinancialYearStart,
			// DATE_FORMAT));
			// pst.setDate(23, uF.getDateFormat(strFinancialYearEnd,
			// DATE_FORMAT));
			// pst.setInt(24, nLevelId);
			// pst.setInt(25, nEmpOrgId);
			// pst.setDate(26, uF.getDateFormat(strD1, DATE_FORMAT));
			// pst.setDate(27, uF.getDateFormat(strD2, DATE_FORMAT));
			// pst.setInt(28, uF.parseToInt(strPC));
			sbQuery.append("select * from reimbursement_ctc_details where level_id=? and org_id=? and reimbursement_ctc_id in "
					+ "(select rhd.reimbursement_ctc_id from reimbursement_head_amt_details rhad, reimbursement_head_details rhd "
					+ "where rhad.reimbursement_head_id=rhd.reimbursement_head_id and rhad.financial_year_start=? and rhad.financial_year_end=? "
					+ "and rhd.level_id=? and rhd.org_id=? and rhad.is_attachment= true and rhad.is_optimal=false and rhd.reimbursement_head_id "
					+ "in (select reimbursement_head_id from reimbursement_assign_head_details where emp_id=? and financial_year_start=? "
					+ "and financial_year_end=? and level_id=? and org_id=? and paycycle_from=? and paycycle_to=? and paycycle=? and status=true "
					+ "and trail_status=true))");
			pst = con.prepareStatement(sbQuery.toString());
			pst.setInt(1, nLevelId);
			pst.setInt(2, nEmpOrgId);
			pst.setDate(3, uF.getDateFormat(strFinancialYearStart, DATE_FORMAT));
			pst.setDate(4, uF.getDateFormat(strFinancialYearEnd, DATE_FORMAT));
			pst.setInt(5, nLevelId);
			pst.setInt(6, nEmpOrgId);
			pst.setInt(7, nEmpId);
			pst.setDate(8, uF.getDateFormat(strFinancialYearStart, DATE_FORMAT));
			pst.setDate(9, uF.getDateFormat(strFinancialYearEnd, DATE_FORMAT));
			pst.setInt(10, nLevelId);
			pst.setInt(11, nEmpOrgId);
			pst.setDate(12, uF.getDateFormat(strD1, DATE_FORMAT));
			pst.setDate(13, uF.getDateFormat(strD2, DATE_FORMAT));
			pst.setInt(14, uF.parseToInt(strPC));
			// System.out.println("pst=====>"+pst);
			rs = pst.executeQuery();
			while (rs.next()) {
				hmReimCTCHead.put(rs.getString("reimbursement_ctc_id"), uF.showData(rs.getString("reimbursement_name"), ""));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
		}
	}

	public Map<String, Map<String, String>> getEmpTDSReimbursementCTCAmount(Connection con, CommonFunctions CF, UtilityFunctions uF, String strEmpId,
			String strFinancialYearStart, String strFinancialYearEnd) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, Map<String, String>> hmEmpTDSReimbCTC = new HashMap<String, Map<String, String>>();
		try {
			pst = con.prepareStatement("select a.*,rcd.reimbursement_name from (select sum(amount) as amount,reimbursement_ctc_id "
					+ "from reimbursement_ctc_tax_pay where emp_id=? and  financial_year_start=? and financial_year_end=? "
					+ "group by reimbursement_ctc_id) a, reimbursement_ctc_details rcd where a.reimbursement_ctc_id = rcd.reimbursement_ctc_id");
			pst.setInt(1, uF.parseToInt(strEmpId));
			pst.setDate(2, uF.getDateFormat(strFinancialYearStart, DATE_FORMAT));
			pst.setDate(3, uF.getDateFormat(strFinancialYearEnd, DATE_FORMAT));
			rs = pst.executeQuery();
			while (rs.next()) {
				Map<String, String> hmEmpTDSReimbCTCInner = new HashMap<String, String>();
				hmEmpTDSReimbCTCInner.put("REIMBURSEMENT_NAME", uF.showData(rs.getString("reimbursement_name"), ""));
				hmEmpTDSReimbCTCInner.put("REIMBURSEMENT_TDS_AMOUNT", uF.formatIntoZeroWithOutComma(uF.parseToDouble(rs.getString("amount"))));

				hmEmpTDSReimbCTC.put(rs.getString("reimbursement_ctc_id"), hmEmpTDSReimbCTCInner);
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
		}
		return hmEmpTDSReimbCTC;
	}

	public Map<String, String> getEmpAnnualVariablePolicyMonthAmount(Connection con, UtilityFunctions uF, String strEmpId, String strFinancialYearStart,
			String strFinancialYearEnd) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmEmpAnnualVarPolicyAmount = new HashMap<String, String>();
		try {
			pst = con.prepareStatement("select * from annual_variable_details avd, salary_details sd where sd.salary_head_id=avd.salary_head_id " +
				"and avd.emp_id=? and financial_year_start=? and financial_year_end=? and is_annual_variable=true");
			pst.setInt(1, uF.parseToInt(strEmpId));
			pst.setDate(2, uF.getDateFormat(strFinancialYearStart, DATE_FORMAT));
			pst.setDate(3, uF.getDateFormat(strFinancialYearEnd, DATE_FORMAT));
			rs = pst.executeQuery();
			while (rs.next()) {
				double amtAnnual = uF.parseToDouble(rs.getString("variable_amount"));
				amtAnnual = amtAnnual > 0.0d ? (amtAnnual / 12.0d) : 0.0d;
				hmEmpAnnualVarPolicyAmount.put(rs.getString("salary_head_id"), uF.formatIntoTwoDecimalWithOutComma(amtAnnual));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmEmpAnnualVarPolicyAmount;
	}

	public double getMultipleCalAmount(UtilityFunctions uF, String salaryHeadId, String strAmount, Map<String, String> hmEmpAnnualVarPolicyAmount,
			double dblReimbursementCTC) {
		double dblAnnualAmt = 0.0d;
		try {
			if (hmEmpAnnualVarPolicyAmount == null)
				hmEmpAnnualVarPolicyAmount = new HashMap<String, String>();
			if (hmEmpAnnualVarPolicyAmount.containsKey(salaryHeadId)) {
				dblAnnualAmt = uF.parseToDouble(hmEmpAnnualVarPolicyAmount.get(salaryHeadId));
			} else if (uF.parseToInt(salaryHeadId) == REIMBURSEMENT_CTC) {
				dblAnnualAmt = dblReimbursementCTC;
			} else {
				dblAnnualAmt = uF.parseToDouble(strAmount);
			}

		} catch (Exception e) {
			e.printStackTrace();
		}
		return dblAnnualAmt;
	}

	public Map<String, String> getShiftBreak(Connection con, UtilityFunctions uF, String orgId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmShiftBreak = new HashMap<String, String>();
		try {
			pst = con.prepareStatement("SELECT * FROM shift_details where shift_id > 1 and org_id=? order by shift_id ");
			pst.setInt(1, uF.parseToInt(orgId));
			rs = pst.executeQuery();
			while (rs.next()) {
				long fromTime = uF.getTimeFormat(rs.getString("break_start"), DBTIME).getTime();
				long toTime = uF.getTimeFormat(rs.getString("break_end"), DBTIME).getTime();

				double timeDiff = uF.parseToDouble((uF.getTimeDiffInHoursMins(fromTime, toTime)));

				hmShiftBreak.put(rs.getString("shift_id"), "" + timeDiff);
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmShiftBreak;
	}

	public Map<String, String> getWorkLocationLunchDeductionByEmp(Connection con, UtilityFunctions uF, String strEmpId) {
		Map<String, String> hmLunchDeduction = new HashMap<String, String>();

		PreparedStatement pst = null;
		ResultSet rs = null;

		try {

			pst = con.prepareStatement("select * from work_location_info where wlocation_id in (select eod.wlocation_id "
					+ "from employee_personal_details epd, employee_official_details eod where epd.emp_per_id=eod.emp_id and eod.emp_id=?)");
			pst.setInt(1, uF.parseToInt(strEmpId));
			rs = pst.executeQuery();
			if (rs.next()) {
				hmLunchDeduction.put("IS_BREAK_TIME_POLICY", rs.getString("is_break_time_policy"));
				hmLunchDeduction.put("LUNCH_BREAK_DEDUCT", rs.getString("lunch_break_deduct"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmLunchDeduction;
	}

	public boolean checkHoliday(Connection con, UtilityFunctions uF, String strDate, String strWLocationId, String strOrgId) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		boolean isHoliday = false;
		try {
			pst = con
					.prepareStatement("SELECT * FROM holidays WHERE _date=? and wlocation_id=? and org_id=? and (is_optional_holiday is null or is_optional_holiday=false)");
			pst.setDate(1, uF.getDateFormat(strDate, DATE_FORMAT));
			pst.setInt(2, uF.parseToInt(strWLocationId));
			pst.setInt(3, uF.parseToInt(strOrgId));
			rs = pst.executeQuery();
			if (rs.next()) {
				isHoliday = true;
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return isHoliday;
	}

	public boolean checkEmpRosterWeeklyOff(Connection con, CommonFunctions CF, UtilityFunctions uF, String strEmp, String strDate, String strLevelId,
			String strWLocationId, String strOrgId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		boolean isEmpRosterWeekOff = false;
		try {
			// pst =
			// con.prepareStatement("select * from roster_details where emp_id=? and _date=? and roster_weeklyoff_id > 1");
			pst = con.prepareStatement("select * from roster_details where emp_id=? and _date=? ");
			pst.setInt(1, uF.parseToInt(strEmp));
			pst.setDate(2, uF.getDateFormat(strDate, DATE_FORMAT));
			// System.out.println("pst==>"+pst);
			rs = pst.executeQuery();
			Map<String, List<List<String>>> hmRosterWeekOffType = new HashMap<String, List<List<String>>>();
			boolean isRoster = false;
			while (rs.next()) {
				List<List<String>> alList = hmRosterWeekOffType.get(rs.getString("emp_id"));
				if (alList == null)
					alList = new ArrayList<List<String>>();

				List<String> alInner = new ArrayList<String>();
				alInner.add(uF.getDateFormat(rs.getString("_date"), DBDATE, DATE_FORMAT));
				alInner.add(rs.getString("roster_weeklyoff_id"));
				alInner.add(rs.getString("shift_id"));
				alList.add(alInner);

				hmRosterWeekOffType.put(rs.getString("emp_id"), alList);
				isRoster = true;
			}
			rs.close();
			pst.close();

			Map<String, Map<String, String>> hmRosterWeeklyoff = CF.getRosterWeeklyOffDetails(con, CF, uF);
			if (hmRosterWeeklyoff == null)
				hmRosterWeeklyoff = new HashMap<String, Map<String, String>>();

			Map<String, Set<String>> hmWeekEndHalfDates = new HashMap<String, Set<String>>();
			Map<String, Set<String>> hmWeekEndDates = CF.getWeekEndDateList(con, strDate, strDate, CF, uF, hmWeekEndHalfDates, null);
			if (hmWeekEndDates == null)
				hmWeekEndDates = new HashMap<String, Set<String>>();
			// System.out.println("hmWeekEndHalfDates==>"+hmWeekEndHalfDates);
			// System.out.println("hmWeekEndDates==>"+hmWeekEndDates);

			Iterator<String> it = hmRosterWeekOffType.keySet().iterator();
			while (it.hasNext()) {
				String strEmpId = it.next();
				List<List<String>> alList = hmRosterWeekOffType.get(strEmpId);

				Set<String> weeklyOffSet = hmWeekEndDates.get(strWLocationId);
				if (weeklyOffSet == null)
					weeklyOffSet = new HashSet<String>();

				Set<String> halfDayWeeklyOffSet = hmWeekEndHalfDates.get(strWLocationId);
				if (halfDayWeeklyOffSet == null)
					halfDayWeeklyOffSet = new HashSet<String>();

				for (int i = 0; alList != null && i < alList.size(); i++) {
					List<String> alInner = alList.get(i);
					if (uF.parseToInt(alInner.get(1)) == 1) {
						if (weeklyOffSet.contains(alInner.get(0))) {
							// System.out.println("week true");
							isEmpRosterWeekOff = true;
						} /*
						 * else
						 * if(halfDayWeeklyOffSet.contains(alInner.get(0))){
						 * isEmpRosterWeekOff = true; }
						 */
					} else {
						String strDay = uF.getDateFormat(alInner.get(0), DATE_FORMAT, "EEEE");
						if (strDay != null)
							strDay = strDay.toUpperCase();

						Map<String, String> hmInner = (Map<String, String>) hmRosterWeeklyoff.get(alInner.get(1));
						if (hmInner == null)
							hmInner = new HashMap<String, String>();
						List<String> weeklyOffDayList = hmInner.get("WEEKLYOFF_DAY") != null && !hmInner.get("WEEKLYOFF_DAY").equals("") ? Arrays
								.asList(hmInner.get("WEEKLYOFF_DAY").trim().split(",")) : new ArrayList<String>();
						List<String> weekNoList = hmInner.get("WEEKLYOFF_WEEKNO") != null && !hmInner.get("WEEKLYOFF_WEEKNO").equals("") ? Arrays
								.asList(hmInner.get("WEEKLYOFF_WEEKNO").trim().split(",")) : new ArrayList<String>();

						if (weeklyOffDayList != null && weeklyOffDayList.contains(strDay)) {
							String strDate1 = uF.getDateFormat(alInner.get(0), DATE_FORMAT, DATE_FORMAT);
							int checkWeek = CF.getMonthCount(uF, strDate1);
							if (weekNoList.contains("" + checkWeek)) {
								// System.out.println("roster true");
								isEmpRosterWeekOff = true;
							}
						}
					}
				}
			}

			if (!isRoster) {
				boolean isWeeklyOff = CF.checkWeeklyOff(con, CF, uF, strEmp, strDate, strLevelId, strWLocationId, strOrgId);
				// System.out.println("isRoster==>"+isRoster+"--isWeeklyOff==>"+isWeeklyOff);
				if (isWeeklyOff) {
					isEmpRosterWeekOff = true;
				}
			}

			// System.out.println("isRoster==>"+isRoster+"--isEmpRosterWeekOff==>"+isEmpRosterWeekOff);
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return isEmpRosterWeekOff;
	}

	public boolean checkWeeklyOff(Connection con, CommonFunctions CF, UtilityFunctions uF, String strEmp, String strDate, String strLevelId,
			String strWLocationId, String strOrgId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		boolean isWeeklyOff = false;
		try {
			Map<String, Set<String>> hmWeekEndHalfDates = new HashMap<String, Set<String>>();
			Map<String, Set<String>> hmWeekEndDates = CF.getWeekEndDateList(con, strDate, strDate, CF, uF, hmWeekEndHalfDates, null);

			Set<String> weeklyOffSet = hmWeekEndDates.get(strWLocationId);
			if (weeklyOffSet == null)
				weeklyOffSet = new HashSet<String>();

			Set<String> halfDayWeeklyOffSet = hmWeekEndHalfDates.get(strWLocationId);
			if (halfDayWeeklyOffSet == null)
				halfDayWeeklyOffSet = new HashSet<String>();

			// System.out.println("strDate====>"+strDate+"--weeklyOffSet====>"+weeklyOffSet+"--hmWeekEndDates====>"+hmWeekEndDates);

			if (weeklyOffSet.contains(strDate)) {
				isWeeklyOff = true;
			}/*
			 * else if(halfDayWeeklyOffSet.contains(strDate)){ isWeeklyOff =
			 * true; }
			 */

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return isWeeklyOff;
	}

	public Map<String, String> getReimbursementHead(Connection con) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmSalaryHeadsMap = new LinkedHashMap<String, String>();

		try {
			pst = con.prepareStatement(selectReimbursementHead);
			rs = pst.executeQuery();

			while (rs.next()) {
				hmSalaryHeadsMap.put(rs.getString("reimbursement_head_id"), rs.getString("reimbursement_head_name"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmSalaryHeadsMap;
	}

	public Map<String, String> getAnnualVariablePolicyAmount(Connection con, UtilityFunctions uF, String strFinancialYearStart, String strFinancialYearEnd) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmAnnualVarPolicyAmount = new HashMap<String, String>();
		try {
			pst = con.prepareStatement("select * from annual_variable_details where financial_year_start=? and financial_year_end=?");
			pst.setDate(1, uF.getDateFormat(strFinancialYearStart, DATE_FORMAT));
			pst.setDate(2, uF.getDateFormat(strFinancialYearEnd, DATE_FORMAT));
			rs = pst.executeQuery();
			while (rs.next()) {
				hmAnnualVarPolicyAmount.put(rs.getString("emp_id") + "_" + rs.getString("salary_head_id"), rs.getString("variable_amount"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmAnnualVarPolicyAmount;
	}

	public int getEmpServiceId(Connection con, UtilityFunctions uF, String strEmpId) {
		int nEmpServiceId = 0;
		ResultSet rs = null;
		PreparedStatement pst = null;
		try {
			String strServiceId = null;
			pst = con.prepareStatement("SELECT * FROM employee_official_details eod, employee_personal_details epd "
					+ "WHERE epd.emp_per_id=eod.emp_id and eod.emp_id=?");
			pst.setInt(1, uF.parseToInt(strEmpId));
			rs = pst.executeQuery();
			while (rs.next()) {
				strServiceId = rs.getString("service_id");
			}
			rs.close();
			pst.close();

			if (strServiceId != null && !strServiceId.trim().equals("") && !strServiceId.trim().equalsIgnoreCase("NULL")) {
				String[] str = strServiceId.split(",");
				for (int i = 0; str != null && i < str.length; i++) {
					if (uF.parseToInt(str[i]) > 0) {
						nEmpServiceId = uF.parseToInt(str[i]);
						break;
					}
				}
			}

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return nEmpServiceId;
	}

	public int getEmpShiftBaseType(UtilityFunctions uF, String strEmpId, HttpServletRequest request) {
		int nShiftBaseType = 0;
		PreparedStatement pst = null;
		Database db = new Database();
		db.setRequest(request);
		Connection con = null;
		ResultSet rs = null;

		try {
			con = db.makeConnection(con);

			pst = con.prepareStatement("select shift_base_type from work_location_info wli, employee_official_details eod "
					+ "where wli.wlocation_id=eod.wlocation_id and eod.emp_id=?");
			pst.setInt(1, uF.parseToInt(strEmpId));
			rs = pst.executeQuery();
			if (rs.next()) {
				nShiftBaseType = uF.parseToInt(rs.getString("shift_base_type"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			db.closeResultSet(rs);
			db.closeStatements(pst);
			db.closeConnection(con);
		}
		return nShiftBaseType;
	}

	public double getReimbursementCTCHeadTotalAmount(Connection con, UtilityFunctions uF, int nEmpId, String strFinancialYearStart, String strFinancialYearEnd,
			String strD1, String strD2, String strPC, int nEmpOrgId, int nLevelId) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		double dblAmount = 0.0d;
		try {

			StringBuilder sbQuery = new StringBuilder();
			// sbQuery.append("select sum(amount) as amount,reimbursement_ctc_id from (select * from reimbursement_head_amt_details rhad, "
			// +
			// "reimbursement_head_details rhd where rhad.reimbursement_head_id=rhd.reimbursement_head_id and rhad.financial_year_start=? "
			// +
			// "and rhad.financial_year_end=? and rhd.level_id=? and rhd.org_id=? and rhad.is_attachment= false and rhad.is_optimal=true "
			// +
			// "and rhd.reimbursement_ctc_id in (select reimbursement_ctc_id from reimbursement_ctc_details where level_id=? and org_id=?) "
			// +
			// "and rhd.reimbursement_head_id in (select reimbursement_head_id from reimbursement_assign_head_details where emp_id=? "
			// +
			// "and financial_year_start=? and financial_year_end=? and level_id=? and org_id=? and paycycle_from=? and paycycle_to=? "
			// +
			// "and paycycle=? and status=false and trail_status=true) ");
			// sbQuery.append(" union ");
			// sbQuery.append("select * from reimbursement_head_amt_details rhad, reimbursement_head_details rhd where rhad.reimbursement_head_id=rhd.reimbursement_head_id "
			// +
			// "and rhad.financial_year_start=? and rhad.financial_year_end=? and rhd.level_id=? and rhd.org_id=? and rhad.is_attachment= true "
			// +
			// "and rhad.is_optimal=false and rhd.reimbursement_ctc_id in (select reimbursement_ctc_id from reimbursement_ctc_details "
			// +
			// "where level_id=? and org_id=?) and rhd.reimbursement_head_id in (select reimbursement_head_id from reimbursement_assign_head_details "
			// +
			// "where emp_id=? and financial_year_start=? and financial_year_end=? and level_id=? and org_id=? and paycycle_from=? and paycycle_to=? "
			// +
			// "and paycycle=? and status=true and trail_status=true)) a group by reimbursement_ctc_id");
			// pst = con.prepareStatement(sbQuery.toString());
			// pst.setDate(1, uF.getDateFormat(strFinancialYearStart,
			// DATE_FORMAT));
			// pst.setDate(2, uF.getDateFormat(strFinancialYearEnd,
			// DATE_FORMAT));
			// pst.setInt(3, nLevelId);
			// pst.setInt(4, nEmpOrgId);
			// pst.setInt(5, nLevelId);
			// pst.setInt(6, nEmpOrgId);
			// pst.setInt(7, nEmpId);
			// pst.setDate(8, uF.getDateFormat(strFinancialYearStart,
			// DATE_FORMAT));
			// pst.setDate(9, uF.getDateFormat(strFinancialYearEnd,
			// DATE_FORMAT));
			// pst.setInt(10, nLevelId);
			// pst.setInt(11, nEmpOrgId);
			// pst.setDate(12, uF.getDateFormat(strD1, DATE_FORMAT));
			// pst.setDate(13, uF.getDateFormat(strD2, DATE_FORMAT));
			// pst.setInt(14, uF.parseToInt(strPC));
			//
			// pst.setDate(15, uF.getDateFormat(strFinancialYearStart,
			// DATE_FORMAT));
			// pst.setDate(16, uF.getDateFormat(strFinancialYearEnd,
			// DATE_FORMAT));
			// pst.setInt(17, nLevelId);
			// pst.setInt(18, nEmpOrgId);
			// pst.setInt(19, nLevelId);
			// pst.setInt(20, nEmpOrgId);
			// pst.setInt(21, nEmpId);
			// pst.setDate(22, uF.getDateFormat(strFinancialYearStart,
			// DATE_FORMAT));
			// pst.setDate(23, uF.getDateFormat(strFinancialYearEnd,
			// DATE_FORMAT));
			// pst.setInt(24, nLevelId);
			// pst.setInt(25, nEmpOrgId);
			// pst.setDate(26, uF.getDateFormat(strD1, DATE_FORMAT));
			// pst.setDate(27, uF.getDateFormat(strD2, DATE_FORMAT));
			// pst.setInt(28, uF.parseToInt(strPC));

			sbQuery.append("select sum(amount) as amount,reimbursement_ctc_id from (select * from reimbursement_head_amt_details rhad, reimbursement_head_details rhd where rhad.reimbursement_head_id=rhd.reimbursement_head_id "
					+ "and rhad.financial_year_start=? and rhad.financial_year_end=? and rhd.level_id=? and rhd.org_id=? and rhad.is_attachment= true "
					+ "and rhad.is_optimal=false and rhd.reimbursement_ctc_id in (select reimbursement_ctc_id from reimbursement_ctc_details "
					+ "where level_id=? and org_id=?) and rhd.reimbursement_head_id in (select reimbursement_head_id from reimbursement_assign_head_details "
					+ "where emp_id=? and financial_year_start=? and financial_year_end=? and level_id=? and org_id=? and paycycle_from=? and paycycle_to=? "
					+ "and paycycle=? and status=true and trail_status=true)) a group by reimbursement_ctc_id");
			pst = con.prepareStatement(sbQuery.toString());
			pst.setDate(1, uF.getDateFormat(strFinancialYearStart, DATE_FORMAT));
			pst.setDate(2, uF.getDateFormat(strFinancialYearEnd, DATE_FORMAT));
			pst.setInt(3, nLevelId);
			pst.setInt(4, nEmpOrgId);
			pst.setInt(5, nLevelId);
			pst.setInt(6, nEmpOrgId);
			pst.setInt(7, nEmpId);
			pst.setDate(8, uF.getDateFormat(strFinancialYearStart, DATE_FORMAT));
			pst.setDate(9, uF.getDateFormat(strFinancialYearEnd, DATE_FORMAT));
			pst.setInt(10, nLevelId);
			pst.setInt(11, nEmpOrgId);
			pst.setDate(12, uF.getDateFormat(strD1, DATE_FORMAT));
			pst.setDate(13, uF.getDateFormat(strD2, DATE_FORMAT));
			pst.setInt(14, uF.parseToInt(strPC));
			// System.out.println("pst=====>"+pst);
			rs = pst.executeQuery();
			while (rs.next()) {
				double amount = uF.parseToDouble(rs.getString("amount"));
				if (amount > 0.0d) {
					amount = amount / 12.0d;
				}
				dblAmount += amount;
			}
			rs.close();
			pst.close();

			// System.out.println("getReimbursementCTCHeadTotalAmount dblAmount=====>"+dblAmount);

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
		}
		return uF.parseToDouble(uF.formatIntoTwoDecimalWithOutComma(dblAmount));
	}

	public void calculateAndUpdateEmpCTC(Connection con, HttpServletRequest request, HttpSession session, CommonFunctions CF, UtilityFunctions uF,
			String strEmpId) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		try {
			Map<String, String> hmEmpProfile = CF.getEmpProfileDetail(con, request, session, CF, uF, null, strEmpId);

			MyProfile myProfile = new MyProfile();
			myProfile.session = session;
			myProfile.request = request;
			myProfile.CF = CF;
			int intEmpIdReq = uF.parseToInt(strEmpId);
			myProfile.getSalaryHeadsforEmployee(con, uF, intEmpIdReq, hmEmpProfile);

			double grossAmount = 0.0d;
			double grossYearAmount = 0.0d;
			double deductAmount = 0.0d;
			double deductYearAmount = 0.0d;
			double netAmount = 0.0d;
			double netYearAmount = 0.0d;

			List<List<String>> salaryHeadDetailsList = (List<List<String>>) request.getAttribute("salaryHeadDetailsList");
			for (int i = 0; salaryHeadDetailsList != null && !salaryHeadDetailsList.isEmpty() && i < salaryHeadDetailsList.size(); i++) {
				List<String> innerList = salaryHeadDetailsList.get(i);
				if (innerList.get(1).equals("E")) {
					grossAmount += uF.parseToDouble(innerList.get(2));
					grossYearAmount += uF.parseToDouble(innerList.get(3));
				} else if (innerList.get(1).equals("D")) {
					double dblDeductMonth = 0.0d;
					double dblDeductAnnual = 0.0d;
					if (uF.parseToInt(innerList.get(4)) == EMPLOYEE_ESI) {
						dblDeductMonth = Math.ceil(uF.parseToDouble(innerList.get(2)));
						dblDeductAnnual = Math.ceil(uF.parseToDouble(innerList.get(3)));
					} else if (uF.parseToInt(innerList.get(4)) == EMPLOYER_ESI) {
						dblDeductMonth = Math.ceil(uF.parseToDouble(innerList.get(2)));
						dblDeductAnnual = Math.ceil(uF.parseToDouble(innerList.get(3)));
					} else {
						dblDeductMonth += Math.round(uF.parseToDouble(innerList.get(2)));
						dblDeductAnnual += Math.round(uF.parseToDouble(innerList.get(3)));
					}
					deductAmount += dblDeductMonth;
					deductYearAmount += dblDeductAnnual;
				}
			}

			Map<String, String> hmContribution = (Map<String, String>) request.getAttribute("hmContribution");
			if (hmContribution == null)
				hmContribution = new HashMap<String, String>();
			double dblMonthContri = 0.0d;
			double dblAnnualContri = 0.0d;
			boolean isEPF = uF.parseToBoolean((String) request.getAttribute("isEPF"));
			boolean isESIC = uF.parseToBoolean((String) request.getAttribute("isESIC"));
			boolean isLWF = uF.parseToBoolean((String) request.getAttribute("isLWF"));
			if (isEPF || isESIC || isLWF) {
				if (isEPF) {
					double dblEPFMonth = Math.round(uF.parseToDouble(hmContribution.get("EPF_MONTHLY")));
					double dblEPFAnnual = Math.round(uF.parseToDouble(hmContribution.get("EPF_ANNUALY")));
					dblMonthContri += dblEPFMonth;
					dblAnnualContri += dblEPFAnnual;
				}
				if (isESIC) {
					double dblESIMonth = Math.ceil(uF.parseToDouble(hmContribution.get("ESI_MONTHLY")));
					double dblESIAnnual = Math.ceil(uF.parseToDouble(hmContribution.get("ESI_ANNUALY")));
					dblMonthContri += dblESIMonth;
					dblAnnualContri += dblESIAnnual;
				}
				if (isLWF) {
					double dblLWFMonth = Math.round(uF.parseToDouble(hmContribution.get("LWF_MONTHLY")));
					double dblLWFAnnual = Math.round(uF.parseToDouble(hmContribution.get("LWF_ANNUALY")));
					dblMonthContri += dblLWFMonth;
					dblAnnualContri += dblLWFAnnual;
				}
			}

			double dblCTCMonthly = grossAmount + dblMonthContri;
			double dblCTCAnnualy = grossYearAmount + dblAnnualContri;

			List<List<String>> salaryAnnualVariableDetailsList = (List<List<String>>) request.getAttribute("salaryAnnualVariableDetailsList");
			if (salaryAnnualVariableDetailsList == null)
				salaryAnnualVariableDetailsList = new ArrayList<List<String>>();
			int nAnnualVariSize = salaryAnnualVariableDetailsList.size();
			if (nAnnualVariSize > 0) {
				double grossAnnualAmount = 0.0d;
				double grossAnnualYearAmount = 0.0d;
				for (int i = 0; i < nAnnualVariSize; i++) {
					List<String> innerList = salaryAnnualVariableDetailsList.get(i);
					double dblEarnMonth = Math.round(uF.parseToDouble(innerList.get(2)));
					double dblEarnAnnual = Math.round(uF.parseToDouble(innerList.get(3)));
					grossAnnualAmount += dblEarnMonth;
					grossAnnualYearAmount += dblEarnAnnual;
				}
				dblCTCMonthly += grossAnnualAmount;
				dblCTCAnnualy += grossAnnualYearAmount;
			}

			netAmount = uF.parseToDouble(uF.formatIntoTwoDecimalWithOutComma(dblCTCMonthly));
			netYearAmount = uF.parseToDouble(uF.formatIntoTwoDecimalWithOutComma(dblCTCAnnualy));

			EmpSalaryApproval salaryApproval = new EmpSalaryApproval();
			salaryApproval.request = request;
			salaryApproval.session = session;
			salaryApproval.CF = CF;
			Map<String, String> hmPrevCTC = salaryApproval.getPrevCTCDetails(con, uF, strEmpId);

			if (hmPrevCTC == null)
				hmPrevCTC = new HashMap<String, String>();
			double dblIncrementMonthAmt = netAmount - uF.parseToDouble(hmPrevCTC.get("PREV_MONTH_CTC"));
			double dblIncrementAnnualAmt = netAmount - uF.parseToDouble(hmPrevCTC.get("PREV_ANNUAL_CTC"));

			pst = con.prepareStatement("update employee_official_details set month_ctc=?,annual_ctc=?,prev_month_ctc=?,"
					+ "prev_annual_ctc=?,incre_month_amount=?,incre_annual_amount=? where emp_id=?");
			pst.setDouble(1, netAmount);
			pst.setDouble(2, netYearAmount);
			pst.setDouble(3, uF.parseToDouble(hmPrevCTC.get("PREV_MONTH_CTC")));
			pst.setDouble(4, uF.parseToDouble(hmPrevCTC.get("PREV_ANNUAL_CTC")));
			pst.setDouble(5, dblIncrementMonthAmt);
			pst.setDouble(6, dblIncrementAnnualAmt);
			pst.setInt(7, uF.parseToInt(strEmpId));
			pst.execute();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
		}
	}

	public double getEmpShiftBaseBufferTime(Connection con, UtilityFunctions uF, String strEmpId) {
		double dblShiftBaseBufferTime = 0;
		PreparedStatement pst = null;
		ResultSet rs = null;

		try {
			pst = con.prepareStatement("select shift_base_buffer_time from work_location_info wli, employee_official_details eod "
					+ "where wli.wlocation_id=eod.wlocation_id and eod.emp_id=?");
			pst.setInt(1, uF.parseToInt(strEmpId));
			rs = pst.executeQuery();
			if (rs.next()) {
				dblShiftBaseBufferTime = uF.parseToDouble(rs.getString("shift_base_buffer_time"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
		}
		return dblShiftBaseBufferTime;
	}

	public Map<String, String> getSubjectsMap(Connection con) {
		Map<String, String> hmSubjectName = new HashMap<String, String>();
		PreparedStatement pst = null;
		ResultSet rst = null;
		try {
			pst = con.prepareStatement("select * from course_subject_details");
			rst = pst.executeQuery();
			while (rst.next()) {
				hmSubjectName.put(rst.getString("course_subject_id"), rst.getString("course_subject_name"));
			}
			rst.close();
			pst.close();
		} catch (Exception e) {

		} finally {
			if (rst != null) {
				try {
					rst.close();
				} catch (Exception e) {
					e.printStackTrace();
				}
			}

			if (pst != null) {
				try {
					pst.close();
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		}
		return hmSubjectName;
	}

	public Map<String, String> getEmpTypeMap() {
		Map<String, String> hmEmpType = new LinkedHashMap<String, String>();
		hmEmpType.put("FT", "Full Time");
		hmEmpType.put("PT", "Part Time");
		hmEmpType.put("CON", "Contractual");
		hmEmpType.put("CO", "Consultant");
		hmEmpType.put("I", "Intern");
		return hmEmpType;
	}

	public double getReimbursementCTCOptinalHeadTotalAmount(Connection con, UtilityFunctions uF, int nEmpId, String strFinancialYearStart,
			String strFinancialYearEnd, String strD1, String strD2, String strPC, int nEmpOrgId, int nLevelId) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		double dblAmount = 0.0d;
		try {

			StringBuilder sbQuery = new StringBuilder();
			sbQuery.append("select sum(amount) as amount,reimbursement_ctc_id from reimbursement_head_amt_details rhad, reimbursement_head_details rhd "
					+ "where rhad.reimbursement_head_id=rhd.reimbursement_head_id and rhad.financial_year_start=? and rhad.financial_year_end=? "
					+ "and rhd.level_id=? and rhd.org_id=? and rhad.is_attachment=false and rhad.is_optimal=true and rhd.reimbursement_ctc_id "
					+ "in (select reimbursement_ctc_id from reimbursement_ctc_details where level_id=? and org_id=?) and rhd.reimbursement_head_id in "
					+ "(select reimbursement_head_id from reimbursement_assign_head_details where emp_id=? and financial_year_start=? "
					+ "and financial_year_end=? and level_id=? and org_id=? and paycycle_from=? and paycycle_to=? and paycycle=? and status=true "
					+ "and trail_status=true) group by reimbursement_ctc_id");
			pst = con.prepareStatement(sbQuery.toString());
			pst.setDate(1, uF.getDateFormat(strFinancialYearStart, DATE_FORMAT));
			pst.setDate(2, uF.getDateFormat(strFinancialYearEnd, DATE_FORMAT));
			pst.setInt(3, nLevelId);
			pst.setInt(4, nEmpOrgId);
			pst.setInt(5, nLevelId);
			pst.setInt(6, nEmpOrgId);
			pst.setInt(7, nEmpId);
			pst.setDate(8, uF.getDateFormat(strFinancialYearStart, DATE_FORMAT));
			pst.setDate(9, uF.getDateFormat(strFinancialYearEnd, DATE_FORMAT));
			pst.setInt(10, nLevelId);
			pst.setInt(11, nEmpOrgId);
			pst.setDate(12, uF.getDateFormat(strD1, DATE_FORMAT));
			pst.setDate(13, uF.getDateFormat(strD2, DATE_FORMAT));
			pst.setInt(14, uF.parseToInt(strPC));
			// System.out.println("pst=====>"+pst);
			rs = pst.executeQuery();
			while (rs.next()) {
				double amount = uF.parseToDouble(rs.getString("amount"));
				if (amount > 0.0d) {
					amount = amount / 12.0d;
				}
				dblAmount += amount;
			}
			rs.close();
			pst.close();

			// System.out.println("getReimbursementCTCOptinalHeadTotalAmount dblAmount=====>"+dblAmount);

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
		}
		return uF.parseToDouble(uF.formatIntoTwoDecimalWithOutComma(dblAmount));
	}

	public List<String> getEmpAllLeaves(Connection con, UtilityFunctions uF, String strD1, String strD2, String strEmpId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		List<String> leaveDateList = new ArrayList<String>();

		try {

			pst = con.prepareStatement("select * from leave_application_register where _date between ? and ? and emp_id = ? "
					+ "and is_modify = false and is_paid=true");
			pst.setDate(1, uF.getDateFormat(strD1, DATE_FORMAT));
			pst.setDate(2, uF.getDateFormat(strD2, DATE_FORMAT));
			pst.setInt(3, uF.parseToInt(strEmpId));
			// System.out.println("pst======>"+pst);
			rs = pst.executeQuery();
			while (rs.next()) {
				leaveDateList.add(uF.getDateFormat(rs.getString("_date"), DBDATE, DATE_FORMAT));
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return leaveDateList;
	}

	public int getEmpLevelId(String empId, HttpServletRequest request) {
		Connection con = null;
		PreparedStatement pst = null;
		ResultSet rs = null;
		Database db = new Database();
		db.setRequest(request);
		UtilityFunctions uF = new UtilityFunctions();
		int levelId = 0;
		try {
			con = db.makeConnection(con);

			pst = con
					.prepareStatement("select * from level_details ld, grades_details gd, designation_details dd where dd.level_id = ld.level_id and dd.designation_id = gd.designation_id and grade_id in (select grade_id from employee_official_details where emp_id = ?)");
			pst.setInt(1, uF.parseToInt(empId));
			rs = pst.executeQuery();
			while (rs.next()) {
				levelId = rs.getInt("level_id");
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			db.closeResultSet(rs);
			db.closeStatements(pst);
			db.closeConnection(con);
		}
		return levelId;
	}

	public String getEmpGradeId(Connection con, String empId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		UtilityFunctions uF = new UtilityFunctions();
		int gradeId = 0;
		try {
			pst = con.prepareStatement("select * from grades_details where grade_id in (select grade_id from employee_official_details where emp_id = ?)");
			pst.setInt(1, uF.parseToInt(empId));
			rs = pst.executeQuery();
			while (rs.next()) {
				gradeId = rs.getInt("grade_id");
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return gradeId + "";
	}

	public void appendMultiplePercentageCalType(UtilityFunctions uF, StringBuilder sbMulcalType, String strMulCal, Map<String, String> hmSalaryMap,
			List<String> alAnnualSalaryHead) {
		if (alAnnualSalaryHead == null)
			alAnnualSalaryHead = new ArrayList<String>();

		if (strMulCal != null && !strMulCal.trim().equals("") && !strMulCal.trim().equalsIgnoreCase("NULL")) {
			List<String> al = Arrays.asList(strMulCal.trim().split(","));
			int nAl = al != null ? al.size() : 0;
			for (int i = 0; i < nAl; i++) {
				String str = al.get(i);
				if (str != null && !str.trim().equals("") && !str.trim().equalsIgnoreCase("NULL")) {
					boolean isInteger = uF.isInteger(str.trim());
					if (isInteger) {
						if (uF.parseToInt(str.trim()) == REIMBURSEMENT_CTC) {
							sbMulcalType.append("Reimbursement CTC");
						} else {
							String strAnnualMonth = "";
							if (alAnnualSalaryHead.contains(str.trim())) {
								strAnnualMonth = "(Calculated Monthly)";
							}
							sbMulcalType.append(uF.showData(hmSalaryMap.get(str.trim()), "") + strAnnualMonth);
						}
					} else {
						sbMulcalType.append(str.trim());
					}
				}
			}
		}
	}

	public String getGradeStructureFormula(Connection con, UtilityFunctions uF, String strGrade, String strMulPerCalFormula) {
		StringBuilder sbFormula = new StringBuilder();
		PreparedStatement pst = null;
		ResultSet rs = null;
		try {
			if (strMulPerCalFormula != null && !strMulPerCalFormula.trim().equals("") && !strMulPerCalFormula.trim().equalsIgnoreCase("NULL")) {
				List<String> al = Arrays.asList(strMulPerCalFormula.trim().split(","));
				int nAl = al != null ? al.size() : 0;

				for (int i = 0; i < nAl; i++) {
					String str = al.get(i);
					if (str != null && !str.trim().equals("") && !str.trim().equalsIgnoreCase("NULL")) {
						boolean isInteger = uF.isInteger(str.trim());
						if (isInteger) {
							if (uF.parseToInt(str.trim()) == EMPLOYER_EPF) {
								sbFormula.append("" + 0.0d);
							}
							if (uF.parseToInt(str.trim()) == EMPLOYER_ESI) {
								sbFormula.append("" + 0.0d);
							}
							if (uF.parseToInt(str.trim()) == EMPLOYER_LWF) {
								sbFormula.append("" + 0.0d);
							}
							pst = con
									.prepareStatement("select * from salary_details where salary_head_id=? and grade_id=? and (is_delete is null or is_delete=false);");
							pst.setInt(1, uF.parseToInt(str.trim()));
							pst.setInt(2, uF.parseToInt(strGrade));
							rs = pst.executeQuery();
							while (rs.next()) {
								if (rs.getString("salary_head_amount_type") != null && rs.getString("salary_head_amount_type").trim().equalsIgnoreCase("P")) {
									sbFormula.append("" + uF.parseToDouble(rs.getString("salary_calculate_amount")));
								} else {
									sbFormula.append("" + uF.parseToDouble(rs.getString("salary_head_amount")));
								}
							}
							rs.close();
							pst.close();
						} else {
							sbFormula.append(str.trim());
						}
					}
				}
			}
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
		}
		return sbFormula.toString();
	}

	public String getLevelStructureFormula(Connection con, UtilityFunctions uF, String strLevel, String salaryBand, String strMulPerCalFormula) {
		StringBuilder sbFormula = new StringBuilder();
		PreparedStatement pst = null;
		ResultSet rs = null;
		try {
			if (strMulPerCalFormula != null && !strMulPerCalFormula.trim().equals("") && !strMulPerCalFormula.trim().equalsIgnoreCase("NULL")) {
				List<String> al = Arrays.asList(strMulPerCalFormula.trim().split(","));
				int nAl = al != null ? al.size() : 0;

				for (int i = 0; i < nAl; i++) {
					String str = al.get(i);
					if (str != null && !str.trim().equals("") && !str.trim().equalsIgnoreCase("NULL")) {
						boolean isInteger = uF.isInteger(str.trim());
						if (isInteger) {
							if (uF.parseToInt(str.trim()) == EMPLOYER_EPF) {
								sbFormula.append("" + 0.0d);
							}
							if (uF.parseToInt(str.trim()) == EMPLOYER_ESI) {
								sbFormula.append("" + 0.0d);
							}
							if (uF.parseToInt(str.trim()) == EMPLOYER_LWF) {
								sbFormula.append("" + 0.0d);
							}

							if (uF.parseToInt(str.trim()) == REIMBURSEMENT_CTC) {
								pst = con.prepareStatement("select * from salary_details where salary_head_id=? and (is_delete is null or is_delete=false);");
								pst.setInt(1, uF.parseToInt(str.trim()));
								rs = pst.executeQuery();
								while (rs.next()) {
									if (rs.getString("salary_head_amount_type") != null && rs.getString("salary_head_amount_type").trim().equalsIgnoreCase("P")) {
										sbFormula.append("" + uF.parseToDouble(rs.getString("salary_calculate_amount")));
									} else {
										sbFormula.append("" + uF.parseToDouble(rs.getString("salary_head_amount")));
									}
								}
								rs.close();
								pst.close();
							} else {
								pst = con.prepareStatement("select * from salary_details where salary_head_id=? and level_id=? and salary_band_id=? and (is_delete is null or is_delete=false);");
								pst.setInt(1, uF.parseToInt(str.trim()));
								pst.setInt(2, uF.parseToInt(strLevel));
								pst.setInt(3, uF.parseToInt(salaryBand));
								rs = pst.executeQuery();
								while (rs.next()) {
									if (rs.getString("salary_head_amount_type") != null && rs.getString("salary_head_amount_type").trim().equalsIgnoreCase("P")) {
										sbFormula.append("" + uF.parseToDouble(rs.getString("salary_calculate_amount")));
									} else {
										sbFormula.append("" + uF.parseToDouble(rs.getString("salary_head_amount")));
									}
								}
								rs.close();
								pst.close();
							}
						} else {
							sbFormula.append(str.trim());
						}
					}
				}
			}
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
		}
		return sbFormula.toString();
	}

	public List<String> getMultipleCalHead(UtilityFunctions uF, String strMulPerCalFormula) {
		List<String> alHead = new ArrayList<String>();
		PreparedStatement pst = null;
		ResultSet rs = null;
		try {
			if (strMulPerCalFormula != null && !strMulPerCalFormula.trim().equals("") && !strMulPerCalFormula.trim().equalsIgnoreCase("NULL")) {
				List<String> al = Arrays.asList(strMulPerCalFormula.trim().split(","));
				int nAl = al != null ? al.size() : 0;

				for (int i = 0; i < nAl; i++) {
					String str = al.get(i);
					if (str != null && !str.trim().equals("") && !str.trim().equalsIgnoreCase("NULL")) {
						boolean isInteger = uF.isInteger(str.trim());
						if (isInteger) {
							alHead.add(str.trim());
						}
					}
				}
			}
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
		}
		return alHead;
	}

	public String getEmpStructureFormula(Connection con, UtilityFunctions uF, Map<String, String> hmEmpSalaryHeadAmt, String strMulPerCalFormula) {
		StringBuilder sbFormula = new StringBuilder();
		try {
			if (strMulPerCalFormula != null && !strMulPerCalFormula.trim().equals("") && !strMulPerCalFormula.trim().equalsIgnoreCase("NULL")) {
				List<String> al = Arrays.asList(strMulPerCalFormula.trim().split(","));
				int nAl = al != null ? al.size() : 0;

				for (int i = 0; i < nAl; i++) {
					String str = al.get(i);
					if (str != null && !str.trim().equals("") && !str.trim().equalsIgnoreCase("NULL")) {
						boolean isInteger = uF.isInteger(str.trim());
						if (isInteger) {
							sbFormula.append("" + uF.parseToDouble(hmEmpSalaryHeadAmt.get(str.trim())));
						} else {
							sbFormula.append(str.trim());
						}
					}
				}
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
		return sbFormula.toString();
	}

	public List<String> getAccrueLeave(Connection con, CommonFunctions CF, UtilityFunctions uF, int nOrgId, int nWlocationId, int nLevelId, String strLeaves) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		List<String> alAccrueLeave = new ArrayList<String>();
		try {

			List<String> alEmpLeaves1 = null;
			if (strLeaves != null && strLeaves.length() > 0) {
				alEmpLeaves1 = Arrays.asList(strLeaves.split(","));
			}
			if (alEmpLeaves1 == null)
				alEmpLeaves1 = new ArrayList<String>();

			StringBuilder sbLeaves = null;
			for (String strLeaveId : alEmpLeaves1) {
				if (uF.parseToInt(strLeaveId) > 0) {
					if (sbLeaves == null) {
						sbLeaves = new StringBuilder();
						sbLeaves.append(strLeaveId);
					} else {
						sbLeaves.append("," + strLeaveId);
					}
				}
			}

			if (sbLeaves != null) {

				pst = con.prepareStatement("select leave_type_id from emp_leave_type where leave_type_id in (select leave_type_id from leave_type "
						+ "where is_compensatory = false and org_id=? and leave_type_id in (" + sbLeaves.toString()
						+ ")) and is_constant_balance=false and org_id=? and wlocation_id=? and level_id=? "
						+ "and is_leave_accrual=true and leave_type_id in (" + sbLeaves.toString()
						+ ") and (is_accrued_cal_days is null or is_accrued_cal_days =false)" + " union "
						+ "select leave_type_id from emp_leave_type where leave_type_id in (select leave_type_id from leave_type where "
						+ "is_compensatory = true and org_id=? and leave_type_id in (" + sbLeaves.toString()
						+ ")) and is_constant_balance=false and org_id=? and wlocation_id=? and level_id=? "
						+ "and is_leave_accrual=false and leave_type_id in (" + sbLeaves.toString() + ")");
				pst.setInt(1, nOrgId);
				pst.setInt(2, nOrgId);
				pst.setInt(3, nWlocationId);
				pst.setInt(4, nLevelId);
				pst.setInt(5, nOrgId);
				pst.setInt(6, nOrgId);
				pst.setInt(7, nWlocationId);
				pst.setInt(8, nLevelId);
				// System.out.println("pst==>" + pst);
				rs = pst.executeQuery();
				while (rs.next()) {
					if (!alAccrueLeave.contains(rs.getString("leave_type_id"))) {
						alAccrueLeave.add(rs.getString("leave_type_id"));
					}
				}
				rs.close();
				pst.close();
			}
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return alAccrueLeave;
	}

	public boolean getEmpDisableSalaryCalculation(Connection con, UtilityFunctions uF, String empId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		boolean isDisableSalCalculate = false;
		try {
			pst = con.prepareStatement("select is_disable_sal_calculate from employee_official_details where emp_id= ?");
			pst.setInt(1, uF.parseToInt(empId));
			rs = pst.executeQuery();
			if (rs.next()) {
				if (uF.parseToBoolean(rs.getString("is_disable_sal_calculate"))) {
					isDisableSalCalculate = true;
				} else {
					isDisableSalCalculate = false;
				}
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return isDisableSalCalculate;
	}

	public Map<String, String> getEmpResignedMap(Connection con, UtilityFunctions uF, String strOrgId) {
		Map<String, String> hmLoanPoliciesMap = new HashMap<String, String>();

		PreparedStatement pst = null;
		ResultSet rs = null;
		try {
			pst = con.prepareStatement(resignedemployeeorganisationwise);
			pst.setInt(1, uF.parseToInt(strOrgId));
			// System.out.println("pst==>" + pst);
			rs = pst.executeQuery();
			while (rs.next()) {
				hmLoanPoliciesMap.put(rs.getString("emp_id"), rs.getString("last_day_date"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmLoanPoliciesMap;
	}

	public String getEmpServiceId(Connection con, UtilityFunctions uF, int nEmpId) {
		String strEmpServiceId = null;
		ResultSet rs = null;
		PreparedStatement pst = null;
		try {
			pst = con.prepareStatement("SELECT * FROM employee_official_details eod, employee_personal_details epd "
					+ "WHERE epd.emp_per_id=eod.emp_id and eod.emp_id=?");
			pst.setInt(1, nEmpId);
			rs = pst.executeQuery();
			while (rs.next()) {
				if (rs.getString("service_id") != null && !rs.getString("service_id").trim().equals("")
						&& !rs.getString("service_id").trim().equalsIgnoreCase("NULL")) {
					List<String> sbuIdList = Arrays.asList(rs.getString("service_id").split(","));
					int nSbuIdListSize = sbuIdList != null ? sbuIdList.size() : 0;
					for (int i = 0; i < nSbuIdListSize; i++) {
						if (uF.parseToInt(sbuIdList.get(1).trim()) > 0) {
							strEmpServiceId = sbuIdList.get(1).trim();
							break;
						}
					}
				}

			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return strEmpServiceId;
	}

	public String getEmpGender(Connection con, UtilityFunctions uF, String strEmpId) {
		PreparedStatement pst = null;
		ResultSet rs = null;

		String strEmpGender = null;
		try {

			pst = con
					.prepareStatement("SELECT epd.emp_gender FROM employee_personal_details epd, employee_official_details eod where epd.emp_per_id=eod.emp_id "
							+ "and eod.emp_id=?");
			pst.setInt(1, uF.parseToInt(strEmpId));
			rs = pst.executeQuery();
			while (rs.next()) {
				strEmpGender = rs.getString("emp_gender");
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return strEmpGender;
	}

	public String getCheckClientStatus(HttpServletRequest request, CommonFunctions CF) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Connection con = null;
		Database db = new Database();
		db.setRequest(request);
		String IS_SUSPENDED = null;
		try {
			con = db.makeConnection(con);
			pst = con.prepareStatement(selectSettings);
			rs = pst.executeQuery();
			while (rs.next()) {
				if (rs.getString("options").equalsIgnoreCase(O_IS_SUSPENDED)) {
					IS_SUSPENDED = rs.getString("value");
				}
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			db.closeResultSet(rs);
			db.closeStatements(pst);
			db.closeConnection(con);
		}
		return IS_SUSPENDED;
	}

	public void assignReimbursementCTCForEmployee(HttpServletRequest request, Connection con, CommonFunctions CF, UtilityFunctions uF, int empId) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		try {
			int nOrgId = uF.parseToInt(CF.getEmpOrgId(con, uF, "" + empId));
			int nLevelId = uF.parseToInt(CF.getEmpLevelId(con, "" + empId));

			if (nLevelId > 0 && nOrgId > 0) {
				String strEmpJoiningDate = null;
				String strEmpEndDate = null;
				pst = con
						.prepareStatement("SELECT * FROM employee_official_details eod, employee_personal_details epd WHERE epd.emp_per_id=eod.emp_id and eod.emp_id=? order by emp_id");
				pst.setInt(1, empId);
				rs = pst.executeQuery();
				while (rs.next()) {
					if (rs.getString("joining_date") != null && !rs.getString("joining_date").trim().equals("")
							&& !rs.getString("joining_date").trim().equalsIgnoreCase("NULL")
							&& uF.isThisDateValid(uF.getDateFormat(rs.getString("joining_date"), DBDATE, DATE_FORMAT), DATE_FORMAT)) {
						strEmpJoiningDate = uF.getDateFormat(rs.getString("joining_date"), DBDATE, DATE_FORMAT);
					}
					if (rs.getString("employment_end_date") != null && !rs.getString("employment_end_date").trim().equals("")
							&& !rs.getString("employment_end_date").equalsIgnoreCase("NULL")
							&& uF.isThisDateValid(uF.getDateFormat(rs.getString("employment_end_date"), DBDATE, DATE_FORMAT), DATE_FORMAT)) {
						strEmpEndDate = uF.getDateFormat(rs.getString("employment_end_date"), DBDATE, DATE_FORMAT);
					}
				}
				rs.close();
				pst.close();

				// System.out.println("strEmpEndDate==>"+strEmpEndDate);

				Map<String, String> hmOrg = CF.getOrgDetails(con, uF, "" + nOrgId);
				if (hmOrg == null)
					hmOrg = new HashMap<String, String>();

				String strOrgStartPaycycle = hmOrg.get("ORG_START_PAYCYCLE");

				if (uF.isThisDateValid(strEmpJoiningDate, DATE_FORMAT) && uF.isThisDateValid(strOrgStartPaycycle, DATE_FORMAT)) {
					java.util.Date joiningDate = uF.getDateFormatUtil(strEmpJoiningDate, DATE_FORMAT);
					java.util.Date paycycleStartDate = uF.getDateFormatUtil(strOrgStartPaycycle, DATE_FORMAT);
					// System.out.println("joiningDate==>"+joiningDate+"--paycycleStartDate==>"+paycycleStartDate);

					String strPayccyleStartInsertDate = strEmpJoiningDate;
					if (joiningDate.before(paycycleStartDate)) {
						strPayccyleStartInsertDate = strOrgStartPaycycle;
					}
					// System.out.println("strPayccyleStartInsertDate==>"+strPayccyleStartInsertDate);
					String[] strPayCycleDate = CF.getPayCycleFromDate(con, strPayccyleStartInsertDate, CF.getStrTimeZone(), CF, "" + nOrgId);
					if (strPayCycleDate != null && strPayCycleDate.length > 0) {
						String startDate = strPayCycleDate[0];
						java.util.Date startDate1 = uF.getDateFormatUtil(startDate, DATE_FORMAT);

						List<FillPayCycles> paycycleListFull = new FillPayCycles(request).fillPayCycles(CF, "" + nOrgId);
						if (paycycleListFull == null)
							paycycleListFull = new ArrayList<FillPayCycles>();

						if (paycycleListFull.size() > 0) {
							List<String> alPaycycle = new ArrayList<String>();
							for (int i = paycycleListFull.size() - 1; i > -1; i--) {
								FillPayCycles fillPayCycles = paycycleListFull.get(i);
								String[] strDatePaycycle = fillPayCycles.getPaycycleId().split("-");
								String startPaycycleDate = strDatePaycycle[0];

								java.util.Date startPaycycleDate1 = uF.getDateFormatUtil(startPaycycleDate, DATE_FORMAT);
								if (startPaycycleDate1.before(startDate1)) {
									continue;
								}

								if (strEmpEndDate != null && !strEmpEndDate.trim().equals("") && !strEmpEndDate.equalsIgnoreCase("NULL")
										&& uF.isThisDateValid(strEmpEndDate, DATE_FORMAT)) {
									java.util.Date strEmpEndDate1 = uF.getDateFormatUtil(strEmpEndDate, DATE_FORMAT);
									if (strEmpEndDate1.before(startPaycycleDate1)) {
										continue;
									}
								}

								// System.out.println("paycycleId==>"+fillPayCycles.getPaycycleId()+"--paycycleName==>"+fillPayCycles.getPaycycleName());
								alPaycycle.add(fillPayCycles.getPaycycleId());
							}

							// System.out.println("alPaycycle==>"+alPaycycle);
							for (String strPaycycle : alPaycycle) {
								String[] strPayCycleDates = strPaycycle.trim().split("-");
								String strD1 = strPayCycleDates[0];
								String strD2 = strPayCycleDates[1];
								String strPC = strPayCycleDates[2];

								String[] strFinancialDates = CF.getFinancialYear(con, strD1, CF, uF);
								String strFinancialYearStart = strFinancialDates[0];
								String strFinancialYearEnd = strFinancialDates[1];

								Map<String, List<Map<String, String>>> hmReimbursementCTCHead = new HashMap<String, List<Map<String, String>>>();
								pst = con
										.prepareStatement("select rhd.reimbursement_ctc_id,rhd.reimbursement_head_id,rhad.amount,rhad.is_optimal "
												+ "from reimbursement_head_details rhd, reimbursement_head_amt_details rhad where rhd.reimbursement_head_id=rhad.reimbursement_head_id "
												+ "and rhd.level_id=? and rhd.org_id=? and rhad.financial_year_start=? and rhad.financial_year_end=?");
								pst.setInt(1, nLevelId);
								pst.setInt(2, nOrgId);
								pst.setDate(3, uF.getDateFormat(strFinancialYearStart, DATE_FORMAT));
								pst.setDate(4, uF.getDateFormat(strFinancialYearEnd, DATE_FORMAT));
								// System.out.println("pst====>"+pst);
								rs = pst.executeQuery();
								while (rs.next()) {
									List<Map<String, String>> outerList = hmReimbursementCTCHead.get(rs.getString("reimbursement_ctc_id"));
									if (outerList == null)
										outerList = new ArrayList<Map<String, String>>();

									Map<String, String> hmReimCTCHead = new HashMap<String, String>();
									hmReimCTCHead.put("REIMBURSEMENT_HEAD_ID", rs.getString("reimbursement_head_id"));
									hmReimCTCHead.put("REIMBURSEMENT_HEAD_AMOUNT", uF.showData(rs.getString("amount"), ""));
									hmReimCTCHead.put("REIMBURSEMENT_HEAD_IS_OPTIMAL", "" + uF.parseToBoolean(rs.getString("is_optimal")));

									outerList.add(hmReimCTCHead);

									hmReimbursementCTCHead.put(rs.getString("reimbursement_ctc_id"), outerList);

								}
								rs.close();
								pst.close();

								Iterator<String> it = hmReimbursementCTCHead.keySet().iterator();
								while (it.hasNext()) {
									String strReimCTCId = it.next();
									//
									List<Map<String, String>> outerList = hmReimbursementCTCHead.get(strReimCTCId);
									if (outerList == null)
										outerList = new ArrayList<Map<String, String>>();
									int nOuterList = outerList.size();
									for (int i = 0; i < nOuterList; i++) {
										Map<String, String> hmReimCTCHead = outerList.get(i);
										String strReimCTCHeadId = hmReimCTCHead.get("REIMBURSEMENT_HEAD_ID");
										double dblAmount = uF.parseToDouble(hmReimCTCHead.get("REIMBURSEMENT_HEAD_AMOUNT"));
										boolean isOptimal = uF.parseToBoolean(hmReimCTCHead.get("REIMBURSEMENT_HEAD_IS_OPTIMAL"));

										//
										pst = con
												.prepareStatement("select * from reimbursement_assign_head_details where emp_id=? and reimbursement_head_id=? "
														+ "and reimbursement_ctc_id=? and level_id=? and org_id=? and financial_year_start=? and financial_year_end=? "
														+ "and paycycle_from=? and paycycle_to=? and paycycle=? and trail_status=?");
										pst.setInt(1, empId);
										pst.setInt(2, uF.parseToInt(strReimCTCHeadId));
										pst.setInt(3, uF.parseToInt(strReimCTCId));
										pst.setInt(4, nLevelId);
										pst.setInt(5, nOrgId);
										pst.setDate(6, uF.getDateFormat(strFinancialYearStart, DATE_FORMAT));
										pst.setDate(7, uF.getDateFormat(strFinancialYearEnd, DATE_FORMAT));
										pst.setDate(8, uF.getDateFormat(strD1, DATE_FORMAT));
										pst.setDate(9, uF.getDateFormat(strD2, DATE_FORMAT));
										pst.setInt(10, uF.parseToInt(strPC));
										pst.setBoolean(11, true);
										// if(nEmpId == 847){
										// System.out.println("pst==>"+pst);
										// }
										rs = pst.executeQuery();
										boolean assignStatus = false;
										if (rs.next()) {
											assignStatus = true;
										}
										rs.close();
										pst.close();
										//
										if (!assignStatus) {
											pst = con.prepareStatement("select * from reimbursement_assign_head_details where emp_id=? "
													+ "and level_id=? and org_id=? and reimbursement_ctc_id=? and reimbursement_head_id=? "
													+ "and financial_year_start=? and financial_year_end=? and trail_status=true "
													+ "and paycycle in (select max(paycycle) as paycycle from reimbursement_assign_head_details "
													+ "where emp_id=? and level_id=? and org_id=? and reimbursement_ctc_id=? "
													+ "and reimbursement_head_id=? and financial_year_start=? and financial_year_end=? "
													+ "and trail_status=true)");
											pst.setInt(1, empId);
											pst.setInt(2, nLevelId);
											pst.setInt(3, nOrgId);
											pst.setInt(4, uF.parseToInt(strReimCTCId));
											pst.setInt(5, uF.parseToInt(strReimCTCHeadId));
											pst.setDate(6, uF.getDateFormat(strFinancialYearStart, DATE_FORMAT));
											pst.setDate(7, uF.getDateFormat(strFinancialYearEnd, DATE_FORMAT));
											pst.setInt(8, empId);
											pst.setInt(9, nLevelId);
											pst.setInt(10, nOrgId);
											pst.setInt(11, uF.parseToInt(strReimCTCId));
											pst.setInt(12, uF.parseToInt(strReimCTCHeadId));
											pst.setDate(13, uF.getDateFormat(strFinancialYearStart, DATE_FORMAT));
											pst.setDate(14, uF.getDateFormat(strFinancialYearEnd, DATE_FORMAT));
											// if(nEmpId == 847){
											// System.out.println("pst==>"+pst);
											// }
											rs = pst.executeQuery();
											boolean statusFlag = false;
											boolean availableFlag = false;
											while (rs.next()) {
												statusFlag = uF.parseToBoolean(rs.getString("status"));
												availableFlag = true;
											}
											rs.close();
											pst.close();
											//
											if (availableFlag) {
												pst = con
														.prepareStatement("insert into reimbursement_assign_head_details (emp_id,reimbursement_head_id,"
																+ "reimbursement_ctc_id,level_id,org_id,amount,financial_year_start,financial_year_end,status,trail_status,"
																+ "update_by,update_date,paycycle_from,paycycle_to,paycycle) values(?,?,?,?, ?,?,?,?, ?,?,?,?, ?,?,?)");
												pst.setInt(1, empId);
												pst.setInt(2, uF.parseToInt(strReimCTCHeadId));
												pst.setInt(3, uF.parseToInt(strReimCTCId));
												pst.setInt(4, nLevelId);
												pst.setInt(5, nOrgId);
												pst.setDouble(6, dblAmount);
												pst.setDate(7, uF.getDateFormat(strFinancialYearStart, DATE_FORMAT));
												pst.setDate(8, uF.getDateFormat(strFinancialYearEnd, DATE_FORMAT));
												pst.setBoolean(9, statusFlag);
												pst.setBoolean(10, true);
												pst.setInt(11, 1);
												pst.setDate(12, uF.getCurrentDate(CF.getStrTimeZone()));
												pst.setDate(13, uF.getDateFormat(strD1, DATE_FORMAT));
												pst.setDate(14, uF.getDateFormat(strD2, DATE_FORMAT));
												pst.setInt(15, uF.parseToInt(strPC));
												// System.out.println("pst====>"+pst);
												pst.execute();
											} else {
												statusFlag = false;
												if (!isOptimal) {
													statusFlag = true;
												}

												pst = con
														.prepareStatement("insert into reimbursement_assign_head_details (emp_id,reimbursement_head_id,"
																+ "reimbursement_ctc_id,level_id,org_id,amount,financial_year_start,financial_year_end,status,trail_status,"
																+ "update_by,update_date,paycycle_from,paycycle_to,paycycle) values(?,?,?,?, ?,?,?,?, ?,?,?,?, ?,?,?)");
												pst.setInt(1, empId);
												pst.setInt(2, uF.parseToInt(strReimCTCHeadId));
												pst.setInt(3, uF.parseToInt(strReimCTCId));
												pst.setInt(4, nLevelId);
												pst.setInt(5, nOrgId);
												pst.setDouble(6, dblAmount);
												pst.setDate(7, uF.getDateFormat(strFinancialYearStart, DATE_FORMAT));
												pst.setDate(8, uF.getDateFormat(strFinancialYearEnd, DATE_FORMAT));
												pst.setBoolean(9, statusFlag);
												pst.setBoolean(10, true);
												pst.setInt(11, 1);
												pst.setDate(12, uF.getCurrentDate(CF.getStrTimeZone()));
												pst.setDate(13, uF.getDateFormat(strD1, DATE_FORMAT));
												pst.setDate(14, uF.getDateFormat(strD2, DATE_FORMAT));
												pst.setInt(15, uF.parseToInt(strPC));
												// System.out.println("pst====>"+pst);
												pst.execute();
											}
										}
									}
								}
							}
						}
					}
				}
			}

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
	}

	public Map<String, Map<String, String>> getActualUnPaidLeaveDates(Connection con, CommonFunctions CF, UtilityFunctions uF, String strD1, String strD2,
			Map<String, Map<String, String>> hmUnPaidLeaveTypeDays, Map<String, String> hmUnPaidMonthlyLeaves) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, Map<String, String>> hmUnPaidLeaveDates = new HashMap<String, Map<String, String>>();
		try {
			StringBuilder sbQuery = new StringBuilder();
			sbQuery.append("select emp_id,_date,leave_no,lt.leave_type_id,lt.leave_type_code from leave_application_register lar, leave_type lt "
					+ "where lar.leave_type_id = lt.leave_type_id and _date between ? and ? and _type = true and is_paid = false ");
			sbQuery.append("and is_modify= false and lar.leave_type_id not in (select leave_type_id from leave_type where is_compensatory = true) "
					+ "and lar.leave_id in (select leave_id from emp_leave_entry) order by emp_id");
			pst = con.prepareStatement(sbQuery.toString());
			pst.setDate(1, uF.getDateFormat(strD1, DATE_FORMAT));
			pst.setDate(2, uF.getDateFormat(strD2, DATE_FORMAT));
			rs = pst.executeQuery();
			double dblLeaveCount = 0;
			while (rs.next()) {
				String strEmpId = rs.getString("emp_id");
				String strLeaveDate = uF.getDateFormat(rs.getString("_date"), DBDATE, DATE_FORMAT);
				String strLeaveNo = rs.getString("leave_no");
				String strLeaveTypeId = rs.getString("leave_type_id");
				String strLeaveTypeCode = rs.getString("leave_type_code");

				/**
				 * Leave Dates
				 * */
				Map<String, String> hmLeaveDateTemp = (Map<String, String>) hmUnPaidLeaveDates.get(strEmpId);
				if (hmLeaveDateTemp == null)
					hmLeaveDateTemp = new HashMap<String, String>();
				hmLeaveDateTemp.put(strLeaveDate, strLeaveTypeCode);
				hmUnPaidLeaveDates.put(strEmpId, hmLeaveDateTemp);

				/**
				 * Leave Type (Half day or Full day)
				 * */
				if (hmUnPaidLeaveTypeDays != null) {
					Map<String, String> hmTempType = (Map<String, String>) hmUnPaidLeaveTypeDays.get(strEmpId);
					if (hmTempType == null) {
						hmTempType = new HashMap<String, String>();
						dblLeaveCount = 0;
					}
					if (uF.parseToDouble(strLeaveNo) == 0.5) {
						hmTempType.put(strLeaveDate, "H");
						dblLeaveCount += 0.5;
						hmTempType.put("COUNT", dblLeaveCount + "");
					} else if (uF.parseToDouble(strLeaveNo) == 1) {
						hmTempType.put(strLeaveDate, "F");
						dblLeaveCount += 1;
						hmTempType.put("COUNT", dblLeaveCount + "");
					}
					hmUnPaidLeaveTypeDays.put(strEmpId, hmTempType);
				}

				/**
				 * UnPaid Monthly leave type count
				 * */
				if (hmUnPaidMonthlyLeaves != null) {
					double dblMontlycount = uF.parseToDouble(hmUnPaidMonthlyLeaves.get(strEmpId + "_" + strLeaveTypeId));
					if (uF.parseToDouble(strLeaveNo) == 0.5) {
						dblMontlycount += 0.5;
					} else if (uF.parseToDouble(strLeaveNo) == 1) {
						dblMontlycount += 1;
					}
					hmUnPaidMonthlyLeaves.put(strEmpId + "_" + strLeaveTypeId, dblMontlycount + "");
				}
			}
			rs.close();
			pst.close();

			sbQuery = new StringBuilder();
			sbQuery.append("select * from travel_application_register where _date between ? and ? and is_modify= false and is_paid = false order by emp_id");
			pst = con.prepareStatement(sbQuery.toString());
			pst.setDate(1, uF.getDateFormat(strD1, DATE_FORMAT));
			pst.setDate(2, uF.getDateFormat(strD2, DATE_FORMAT));
			rs = pst.executeQuery();
			dblLeaveCount = 0;
			while (rs.next()) {
				String strEmpId = rs.getString("emp_id");
				String strTravelDate = uF.getDateFormat(rs.getString("_date"), DBDATE, DATE_FORMAT);
				String strTravelNo = rs.getString("travel_no");

				/**
				 * Leave Dates
				 * */
				Map<String, String> hmLeaveDateTemp = (Map<String, String>) hmUnPaidLeaveDates.get(strEmpId);
				if (hmLeaveDateTemp == null)
					hmLeaveDateTemp = new HashMap<String, String>();
				if (!hmLeaveDateTemp.containsKey(strTravelDate)) {
					hmLeaveDateTemp.put(strTravelDate, "T");
					hmUnPaidLeaveDates.put(strEmpId, hmLeaveDateTemp);
				}
				/**
				 * Leave Type (Half day or Full day)
				 * */
				if (hmUnPaidLeaveTypeDays != null) {
					Map<String, String> hmTempType = (Map<String, String>) hmUnPaidLeaveTypeDays.get(strEmpId);
					if (hmTempType == null) {
						hmTempType = new HashMap<String, String>();
						dblLeaveCount = 0;
					}

					if (!hmTempType.containsKey(strTravelDate)) {
						if (uF.parseToDouble(strTravelNo) == 0.5) {
							hmTempType.put(strTravelDate, "H");
							dblLeaveCount += 0.5;
							hmTempType.put("COUNT", dblLeaveCount + "");
						} else if (uF.parseToDouble(strTravelNo) == 1) {
							hmTempType.put(strTravelDate, "F");
							dblLeaveCount += 1;
							hmTempType.put("COUNT", dblLeaveCount + "");
						}
						hmUnPaidLeaveTypeDays.put(strEmpId, hmTempType);
					}
				}
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmUnPaidLeaveDates;
	}

	public Map<String, String> getEmpDepartmentNameMap(Connection con) {
		Map<String, String> hmEmpDepartment = new HashMap<String, String>();
		ResultSet rs = null;
		PreparedStatement pst = null;
		try {
			pst = con
					.prepareStatement("select di.dept_name, eod.emp_id from employee_official_details eod , department_info  di  WHERE di.dept_id=eod.depart_id order by emp_id");
			rs = pst.executeQuery();
			while (rs.next()) {
				hmEmpDepartment.put(rs.getString("emp_id"), rs.getString("dept_name"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmEmpDepartment;
	}

	public Map<String, String> getOrgNameCode(Connection con) {
		Map<String, String> hmOrg = new HashMap<String, String>();
		PreparedStatement pst = null;
		ResultSet rs = null;
		try {
			pst = con.prepareStatement("select org_id,org_name,org_code from org_details");
			rs = pst.executeQuery();
			while (rs.next()) {
				hmOrg.put(rs.getString("org_id"), rs.getString("org_name") + " [" + rs.getString("org_code") + "]");
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmOrg;
	}

	public List<String> viewEmployeeIdsList(HttpServletRequest request, UtilityFunctions uF, String strBaseUserType, String strSessionEmpId,
			String strWLocationAccess) {
		Connection con = null;
		PreparedStatement pst = null;
		ResultSet rs = null;
		Database db = new Database();
		db.setRequest(request);
		List<String> alEmpIds = new ArrayList<String>();
		try {
			con = db.makeConnection(con);
			StringBuilder sbQuery = new StringBuilder();

			sbQuery.append("SELECT emp_per_id FROM employee_personal_details epd, employee_official_details eod where epd.emp_per_id = eod.emp_id"); // epd.is_alive =
			if (strBaseUserType != null && (strBaseUserType.equals(MANAGER) || strBaseUserType.equals(HOD))) {
//				sbQuery.append(" and eod.supervisor_emp_id = " + uF.parseToInt(strSessionEmpId) + "");
				sbQuery.append(" and (supervisor_emp_id = "+uF.parseToInt(strSessionEmpId)+" or hod_emp_id = "+uF.parseToInt(strSessionEmpId)+" or eod.emp_id = "+uF.parseToInt(strSessionEmpId)+")");
			} else if (strBaseUserType != null && (strBaseUserType.equals(HRMANAGER) || strBaseUserType.equals(RECRUITER) || strBaseUserType.equals(CEO) || strBaseUserType.equals(ACCOUNTANT))) {
				if(strWLocationAccess!=null && !strWLocationAccess.equals("")) {
					sbQuery.append(" and (eod.wlocation_id in (" + strWLocationAccess + ") or eod.wlocation_id is null) ");
				} else {
					sbQuery.append(" and (eod.wlocation_id in (0) or eod.wlocation_id is null) ");
				}
			} else if (strBaseUserType != null && (strBaseUserType.equals(EMPLOYEE))) {
				sbQuery.append(" and epd.emp_per_id=0 ");
			}
			pst = con.prepareStatement(sbQuery.toString());
//			System.out.println("pst ===>> " + pst);
			rs = pst.executeQuery();
			while (rs.next()) {
				alEmpIds.add(rs.getString("emp_per_id"));
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			db.closeResultSet(rs);
			db.closeStatements(pst);
			db.closeConnection(con);
		}
		return alEmpIds;
	}

	public String getCheckServiceStatus(HttpServletRequest request, CommonFunctions CF) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Connection con = null;
		Database db = new Database();
		db.setRequest(request);
		String IS_SERVICE_TERMINATED = null;
		try {
			con = db.makeConnection(con);
			pst = con.prepareStatement(selectSettings);
			rs = pst.executeQuery();
			while (rs.next()) {
				if (rs.getString("options").equalsIgnoreCase(O_IS_SERVICE_TERMINATED)) {
					IS_SERVICE_TERMINATED = rs.getString("value");
				}
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			db.closeResultSet(rs);
			db.closeStatements(pst);
			db.closeConnection(con);
		}
		return IS_SERVICE_TERMINATED;
	}

	public boolean getFeatureManagementStatus(HttpServletRequest request, UtilityFunctions uF, String fFeatureStatus) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		Connection con = null;
		Database db = new Database();
		db.setRequest(request);

		boolean isFeatureStatus = false;
		try {
			con = db.makeConnection(con);

			pst = con.prepareStatement("select feature_status from feature_management where feature_name=?");
			pst.setString(1, fFeatureStatus);
			rs = pst.executeQuery();
			while (rs.next()) {
				isFeatureStatus = uF.parseToBoolean(rs.getString("feature_status"));
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			db.closeResultSet(rs);
			db.closeStatements(pst);
			db.closeConnection(con);
		}
		return isFeatureStatus;
	}
	

	public Map<String, String> getEmpWLocationMap(Connection con, UtilityFunctions uF, String strEmpIds) {
		Map<String, String> hmEmpWLocation = new HashMap<String, String>();
		PreparedStatement pst = null;
		ResultSet rs = null;
		try {
			if (strEmpIds != null && !strEmpIds.trim().equals("") && !strEmpIds.trim().equalsIgnoreCase("NULL")) {
				pst = con.prepareStatement("select eod.emp_id, wli.wlocation_id,wli.wlocation_name from work_location_info wli, employee_official_details eod "
						+ "where wli.wlocation_id=eod.wlocation_id and eod.emp_id in (" + strEmpIds + ")");
				rs = pst.executeQuery();
				while (rs.next()) {
					hmEmpWLocation.put(rs.getString("emp_id") + "_EMP_WLOCATION_ID", rs.getString("wlocation_id"));
					hmEmpWLocation.put(rs.getString("emp_id") + "_EMP_WLOCATION_NAME", rs.getString("wlocation_name"));
				}
				rs.close();
				pst.close();
			}

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmEmpWLocation;
	}

	public Map<String, String> getEmpDesignationMap(Connection con, UtilityFunctions uF2, String strEmpIds) {
		Map<String, String> hmEmpDesignation = new HashMap<String, String>();
		PreparedStatement pst = null;
		ResultSet rs = null;
		try {
			if (strEmpIds != null && !strEmpIds.trim().equals("") && !strEmpIds.trim().equalsIgnoreCase("NULL")) {
				pst = con
						.prepareStatement("select a.emp_id,dd.designation_id,dd.designation_name from (select eod.emp_id, gd.designation_id from grades_details gd, "
								+ "employee_official_details eod where gd.grade_id=eod.grade_id and eod.emp_id in ("
								+ strEmpIds
								+ ")) a, designation_details dd " + "where dd.designation_id = a.designation_id");
				rs = pst.executeQuery();
				while (rs.next()) {
					hmEmpDesignation.put(rs.getString("emp_id") + "_EMP_DESIGNATION_ID", rs.getString("designation_id"));
					hmEmpDesignation.put(rs.getString("emp_id") + "_EMP_DESIGNATION_NAME", rs.getString("designation_name"));
				}
				rs.close();
				pst.close();
			}

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmEmpDesignation;
	}

	public Map<String, String> getEmpGradeMap(Connection con, UtilityFunctions uF2, String strEmpIds) {
		Map<String, String> hmEmpGrade = new HashMap<String, String>();
		PreparedStatement pst = null;
		ResultSet rs = null;
		try {
			if (strEmpIds != null && !strEmpIds.trim().equals("") && !strEmpIds.trim().equalsIgnoreCase("NULL")) {
				pst = con.prepareStatement("select eod.emp_id, gd.grade_id, gd.grade_name from grades_details gd, employee_official_details eod "
						+ "where gd.grade_id=eod.grade_id and eod.emp_id in (" + strEmpIds + ")");
				rs = pst.executeQuery();
				while (rs.next()) {
					hmEmpGrade.put(rs.getString("emp_id") + "_EMP_GRADE_ID", rs.getString("grade_id"));
					hmEmpGrade.put(rs.getString("emp_id") + "_EMP_GRADE_NAME", rs.getString("grade_name"));
				}
				rs.close();
				pst.close();
			}

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmEmpGrade;
	}

	public void updateNextEmpSalaryEffectiveDate(Connection con, UtilityFunctions uF, int nEmpId, String effectiveDate, String dateFormat) {
		PreparedStatement pst = null;
		try {
			if (nEmpId > 0 && uF.isThisDateValid(effectiveDate, dateFormat)) {
				pst = con.prepareStatement("update emp_salary_details set is_approved=false where emp_id=? and effective_date > ?");
				pst.setInt(1, nEmpId);
				pst.setDate(2, uF.getDateFormat(effectiveDate, dateFormat));
				pst.execute();
				pst.close();
			}

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
	}

	public boolean checkSalaryForImportAttendance(Connection con, CommonFunctions CF, UtilityFunctions uF, int nEmpId, String strStartDate, String strEndDate,
			String dateFormat) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		boolean checkSalaryFlag = false;
		try {
			if (nEmpId > 0 && uF.isThisDateValid(strStartDate, dateFormat) && uF.isThisDateValid(strEndDate, dateFormat)) {
				pst = con.prepareStatement("select * from payroll_generation where emp_id=? "
						+ "and ((? between paid_from and paid_to) or (? between paid_from and paid_to)) limit 1");
				pst.setInt(1, nEmpId);
				pst.setDate(2, uF.getDateFormat(strStartDate, dateFormat));
				pst.setDate(3, uF.getDateFormat(strEndDate, dateFormat));
				rs = pst.executeQuery();
				if (rs.next()) {
					checkSalaryFlag = true;
				}
				rs.close();
				pst.close();
			}

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return checkSalaryFlag;
	}

	public boolean checkAttendanceApproveForImportAttendance(Connection con, CommonFunctions CF, UtilityFunctions uF, int nEmpId, String strStartDate,
			String strEndDate, String dateFormat) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		boolean checkAttendanceApproveFlag = false;
		try {
			if (nEmpId > 0 && uF.isThisDateValid(strStartDate, dateFormat) && uF.isThisDateValid(strEndDate, dateFormat)) {
				pst = con.prepareStatement("select * from approve_attendance where emp_id=? "
						+ "and ((? between approve_from and approve_to) or (? between approve_from and approve_to))");
				pst.setInt(1, nEmpId);
				pst.setDate(2, uF.getDateFormat(strStartDate, dateFormat));
				pst.setDate(3, uF.getDateFormat(strEndDate, dateFormat));
				rs = pst.executeQuery();
				// System.out.println("pst=====>"+pst);
				while (rs.next()) {
					checkAttendanceApproveFlag = true;
				}
				rs.close();
				pst.close();
			}

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return checkAttendanceApproveFlag;
	}

	public boolean checkLeaveForImportAttendance(Connection con, CommonFunctions CF, UtilityFunctions uF, int nEmpId, String strStartDate, String strEndDate,
			String dateFormat) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		boolean checkLeaveFlag = false;
		try {
			if (nEmpId > 0 && uF.isThisDateValid(strStartDate, dateFormat) && uF.isThisDateValid(strEndDate, dateFormat)) {
				pst = con.prepareStatement("select a.*,b.is_modify as modify,a.is_modify as modify1 from (select * from emp_leave_entry where "
						+ "emp_id=? and ((? between approval_from and approval_to_date) or (? between approval_from and approval_to_date) "
						+ "or (approval_from >= ? and approval_from<=?)) and is_approved in (0,1)) a "
						+ "left join (select * from leave_application_register where emp_id=? and _date between ? and ?) b on a.leave_id=b.leave_id");
				pst.setInt(1, nEmpId);
				pst.setDate(2, uF.getDateFormat(strStartDate, DATE_FORMAT));
				pst.setDate(3, uF.getDateFormat(strEndDate, DATE_FORMAT));
				pst.setDate(4, uF.getDateFormat(strStartDate, DATE_FORMAT));
				pst.setDate(5, uF.getDateFormat(strEndDate, DATE_FORMAT));
				pst.setInt(6, nEmpId);
				pst.setDate(7, uF.getDateFormat(strStartDate, DATE_FORMAT));
				pst.setDate(8, uF.getDateFormat(strEndDate, DATE_FORMAT));
				// System.out.println("pst=====>"+pst);
				rs = pst.executeQuery();
				while (rs.next()) {
					// System.out.println("modify=====>"+uF.parseToBoolean(rs.getString("modify")));
					// System.out.println("modify1=====>"+uF.parseToBoolean(rs.getString("modify1")));
					if (uF.parseToBoolean(rs.getString("modify"))) {
						checkLeaveFlag = false;
						// System.out.println("if flag=====>");
					} else if (!uF.parseToBoolean(rs.getString("modify1"))
							&& (uF.parseToInt(rs.getString("is_approved")) == 1 || uF.parseToInt(rs.getString("is_approved")) == 0)) {
						checkLeaveFlag = true;
						// System.out.println("else if flag=====>");
						break;
					}
				}
				rs.close();
				pst.close();
			}

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return checkLeaveFlag;
	}

	public boolean checkAttendanceForImportAttendance(Connection con, CommonFunctions CF, UtilityFunctions uF, int nEmpId, String strStartDate,
			String strEndDate, String dateFormat) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		boolean checkAttendanceApproveFlag = false;
		try {
			if (nEmpId > 0 && uF.isThisDateValid(strStartDate, dateFormat) && uF.isThisDateValid(strEndDate, dateFormat)) {
				pst = con.prepareStatement("select * from attendance_details where emp_id=? and to_date(in_out_timestamp::text,'yyyy-MM-dd') between ? and ?");
				pst.setInt(1, nEmpId);
				pst.setDate(2, uF.getDateFormat(strStartDate, dateFormat));
				pst.setDate(3, uF.getDateFormat(strEndDate, dateFormat));
				rs = pst.executeQuery();
				// System.out.println("pst=====>"+pst);
				while (rs.next()) {
					checkAttendanceApproveFlag = true;
				}
				rs.close();
				pst.close();
			}

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return checkAttendanceApproveFlag;
	}

	public String[] getPayCycleDatesOnPaycycleId(Connection con, String strPaycycle, String strOrgId, String strTimeZone, CommonFunctions CF,
			HttpServletRequest request) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		UtilityFunctions uF = new UtilityFunctions();
		String[] strPayCycleDate = new String[3];

		try {

			String startDate = null;
			String strDisplayPaycycle = null;
			String strPaycycleDuration = null;

			pst = con.prepareStatement("select * from org_details where org_id=?");
			pst.setInt(1, uF.parseToInt(strOrgId));
			rs = pst.executeQuery();
			while (rs.next()) {
				startDate = rs.getString("start_paycycle");
				strDisplayPaycycle = rs.getString("display_paycycle");
				strPaycycleDuration = rs.getString("duration_paycycle");
			}
			rs.close();
			pst.close();

			String[] arrDisplayPAycycle = null;
			int minCycle = 0;
			int maxCycle = 0;
			if (strDisplayPaycycle != null) {
				arrDisplayPAycycle = strDisplayPaycycle.split("-");
				minCycle = uF.parseToInt(arrDisplayPAycycle[0]);
				maxCycle = uF.parseToInt(arrDisplayPAycycle[1]);
			}

			Calendar cal = GregorianCalendar.getInstance(TimeZone.getTimeZone(strTimeZone));
			cal.set(Calendar.DAY_OF_MONTH, uF.parseToInt(uF.getDateFormat(startDate, DBDATE, "dd")));
			cal.set(Calendar.MONTH, uF.parseToInt(uF.getDateFormat(startDate, DBDATE, "MM")) - 1);
			cal.set(Calendar.YEAR, uF.parseToInt(uF.getDateFormat(startDate, DBDATE, "yyyy")));

			int nPayCycle = 0;
			int nDurationCount = 0;
			String dt1 = null;
			String dt2 = null;
			while (true) {
				nPayCycle++;
				if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("M")) {
					nDurationCount = cal.getActualMaximum(Calendar.DAY_OF_MONTH) - 1;
				} else if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("F")) {
					nDurationCount = 15 - 1;
					if (cal.get(Calendar.DAY_OF_MONTH) == 16) {
						int nActual = cal.getActualMaximum(Calendar.DAY_OF_MONTH);
						nDurationCount = nActual - 15 - 1;
					}
				} else if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("BW")) {
					nDurationCount = 14 - 1;
				} else if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("W")) {
					nDurationCount = 7 - 1;
				} else {
					nDurationCount = cal.getMaximum(Calendar.DAY_OF_MONTH) - 1;
				}
				dt1 = ((cal.get(Calendar.DAY_OF_MONTH) < 10) ? "0" + cal.get(Calendar.DAY_OF_MONTH) : cal.get(Calendar.DAY_OF_MONTH)) + "/"
						+ (((cal.get(Calendar.MONTH) + 1) < 10) ? "0" + (cal.get(Calendar.MONTH) + 1) : (cal.get(Calendar.MONTH) + 1)) + "/"
						+ cal.get(Calendar.YEAR);
				cal.add(Calendar.DAY_OF_MONTH, nDurationCount);
				dt2 = ((cal.get(Calendar.DAY_OF_MONTH) < 10) ? "0" + cal.get(Calendar.DAY_OF_MONTH) : cal.get(Calendar.DAY_OF_MONTH)) + "/"
						+ (((cal.get(Calendar.MONTH) + 1) < 10) ? "0" + (cal.get(Calendar.MONTH) + 1) : (cal.get(Calendar.MONTH) + 1)) + "/"
						+ cal.get(Calendar.YEAR);
				if (nPayCycle < minCycle) {
					cal.add(Calendar.DAY_OF_MONTH, 1);
					continue;
				}
				cal.add(Calendar.DAY_OF_MONTH, 1);
				if (nPayCycle == uF.parseToInt(strPaycycle)) {
					strPayCycleDate[0] = dt1;
					strPayCycleDate[1] = dt2;
					strPayCycleDate[2] = nPayCycle + "";
					break;
				}
			}
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return strPayCycleDate;
	}

	public Map<String, String> getBloodGroupMap() {
		Map<String, String> hmBloodGroup = new HashMap<String, String>();

		hmBloodGroup.put("A+", "A+");
		hmBloodGroup.put("A-", "A-");
		hmBloodGroup.put("B+", "B+");
		hmBloodGroup.put("B-", "B-");
		hmBloodGroup.put("AB+", "AB+");
		hmBloodGroup.put("AB-", "AB-");
		hmBloodGroup.put("O+", "O+");
		hmBloodGroup.put("O-", "O-");

		return hmBloodGroup;
	}

	public String getEmpDesigId(Connection con, UtilityFunctions uF, String strEmpId) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		String empDesignation = null;
		try {
			pst = con
					.prepareStatement("select * from grades_details gd, designation_details dd, level_details ld, employee_official_details eod where dd.designation_id = gd.designation_id and ld.level_id = dd.level_id and gd.grade_id = eod.grade_id and eod.emp_id = ?");
			pst.setInt(1, uF.parseToInt(strEmpId));
			rs = pst.executeQuery();
			while (rs.next()) {
				empDesignation = rs.getString("designation_id");

			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return empDesignation;
	}

	public String getCheckImplementationStatus(HttpServletRequest request, CommonFunctions CF) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Connection con = null;
		Database db = new Database();
		db.setRequest(request);
		String IS_UNDER_IMPLEMENTATION = null;
		try {
			con = db.makeConnection(con);
			pst = con.prepareStatement(selectSettings);
			rs = pst.executeQuery();
			while (rs.next()) {
				if (rs.getString("options").equalsIgnoreCase(O_IS_UNDER_IMPLEMENTATION)) {
					IS_UNDER_IMPLEMENTATION = rs.getString("value");
				}
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			db.closeResultSet(rs);
			db.closeStatements(pst);
			db.closeConnection(con);
		}
		return IS_UNDER_IMPLEMENTATION;
	}

	public String[] getPayCycleByOrg(Connection con, String strDate, String strTimeZone, String f_org) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		UtilityFunctions uF = new UtilityFunctions();
		String[] strPayCycleDate = new String[3];

		try {

			String startDate = null;
			String strDisplayPaycycle = null;
			String strPaycycleDuration = null;

			pst = con.prepareStatement("select * from org_details where org_id=?");
			pst.setInt(1, uF.parseToInt(f_org));
			rs = pst.executeQuery();

			while (rs.next()) {
				startDate = rs.getString("start_paycycle");
				strDisplayPaycycle = rs.getString("display_paycycle");
				strPaycycleDuration = rs.getString("duration_paycycle");
			}
			rs.close();
			pst.close();

			String[] arrDisplayPAycycle = null;
			int minCycle = 0;
			int maxCycle = 0;
			if (strDisplayPaycycle != null) {
				arrDisplayPAycycle = strDisplayPaycycle.split("-");
				minCycle = uF.parseToInt(arrDisplayPAycycle[0]);
				maxCycle = uF.parseToInt(arrDisplayPAycycle[1]);
			}

			Calendar calCurrent = GregorianCalendar.getInstance(TimeZone.getTimeZone((strTimeZone)));
			calCurrent.set(Calendar.DAY_OF_MONTH, uF.parseToInt(uF.getDateFormat(strDate, DATE_FORMAT, "dd")));
			calCurrent.set(Calendar.MONTH, uF.parseToInt(uF.getDateFormat(strDate, DATE_FORMAT, "MM")));
			calCurrent.set(Calendar.YEAR, uF.parseToInt(uF.getDateFormat(strDate, DATE_FORMAT, "yyyy")));

			// calCurrent.add(Calendar.DAY_OF_MONTH, -1);

			Calendar cal = GregorianCalendar.getInstance(TimeZone.getTimeZone(strTimeZone));
			cal.set(Calendar.DAY_OF_MONTH, uF.parseToInt(uF.getDateFormat(startDate, DBDATE, "dd")));
			cal.set(Calendar.MONTH, uF.parseToInt(uF.getDateFormat(startDate, DBDATE, "MM")) - 1);
			cal.set(Calendar.YEAR, uF.parseToInt(uF.getDateFormat(startDate, DBDATE, "yyyy")));

			StringBuilder sb = new StringBuilder();
			int nPayCycle = 0;

			int nDurationCount = 0;
			String dt1 = null;
			String dt2 = null;

			java.util.Date strCurrentDate = uF.getDateFormatUtil(
					((calCurrent.get(Calendar.DAY_OF_MONTH) < 10) ? "0" + calCurrent.get(Calendar.DAY_OF_MONTH) : calCurrent.get(Calendar.DAY_OF_MONTH)) + "/"
							+ (((calCurrent.get(Calendar.MONTH) + 1) < 10) ? "0" + calCurrent.get(Calendar.MONTH) : calCurrent.get(Calendar.MONTH)) + "/"
							+ calCurrent.get(Calendar.YEAR), DATE_FORMAT);

			java.util.Date strCurrentPayCycleD1 = null;
			java.util.Date strCurrentPayCycleD2 = null;

			while (true) {
				sb = new StringBuilder();
				nPayCycle++;

				if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("M")) {
					nDurationCount = cal.getActualMaximum(Calendar.DAY_OF_MONTH) - 1;
				} else if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("F")) {
					nDurationCount = 15 - 1;
					if (cal.get(Calendar.DAY_OF_MONTH) == 16) {
						int nActual = cal.getActualMaximum(Calendar.DAY_OF_MONTH);
						nDurationCount = nActual - 15 - 1;
					}
				} else if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("BW")) {
					nDurationCount = 14 - 1;
				} else if (strPaycycleDuration != null && strPaycycleDuration.equalsIgnoreCase("W")) {
					nDurationCount = 7 - 1;
				} else {
					nDurationCount = cal.getMaximum(Calendar.DAY_OF_MONTH) - 1;
				}

				dt1 = ((cal.get(Calendar.DAY_OF_MONTH) < 10) ? "0" + cal.get(Calendar.DAY_OF_MONTH) : cal.get(Calendar.DAY_OF_MONTH)) + "/"
						+ (((cal.get(Calendar.MONTH) + 1) < 10) ? "0" + (cal.get(Calendar.MONTH) + 1) : (cal.get(Calendar.MONTH) + 1)) + "/"
						+ cal.get(Calendar.YEAR);
				cal.add(Calendar.DAY_OF_MONTH, nDurationCount);
				dt2 = ((cal.get(Calendar.DAY_OF_MONTH) < 10) ? "0" + cal.get(Calendar.DAY_OF_MONTH) : cal.get(Calendar.DAY_OF_MONTH)) + "/"
						+ (((cal.get(Calendar.MONTH) + 1) < 10) ? "0" + (cal.get(Calendar.MONTH) + 1) : (cal.get(Calendar.MONTH) + 1)) + "/"
						+ cal.get(Calendar.YEAR);

				if (nPayCycle < minCycle) {
					cal.add(Calendar.DAY_OF_MONTH, 1);
					continue;
				}

				sb.append("Pay Cycle " + nPayCycle + ", " + dt1 + " - " + dt2);

				strCurrentPayCycleD1 = uF.getDateFormatUtil(dt1, DATE_FORMAT);
				strCurrentPayCycleD2 = uF.getDateFormatUtil(dt2, DATE_FORMAT);

				// System.out.println("strCurrentDate ===>> " + strCurrentDate +
				// " -- strCurrentPayCycleD1 ===>> " + strCurrentPayCycleD1 +
				// " -- strCurrentPayCycleD2 ===>> " + strCurrentPayCycleD2);
				// log.debug("nPayCycle===>" + nPayCycle);

				if (strCurrentDate.equals(strCurrentPayCycleD1) || strCurrentDate.equals(strCurrentPayCycleD2)
						|| (strCurrentDate.after(strCurrentPayCycleD1) && strCurrentDate.before(strCurrentPayCycleD2))) {
					strPayCycleDate[0] = dt1;
					strPayCycleDate[1] = dt2;
					strPayCycleDate[2] = nPayCycle + "";
				}

				cal.add(Calendar.DAY_OF_MONTH, 1);
				if (nPayCycle >= maxCycle) {
					break;
				}
			}

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return strPayCycleDate;
	}

	public Map<String, Map<String, String>> getIncrementArearDetails(Connection con, UtilityFunctions uF, CommonFunctions CF, String strD2) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, Map<String, String>> hmArearAmountMap = new HashMap<String, Map<String, String>>();

		try {

			pst = con.prepareStatement("select * from arear_details where effective_date <= ? and is_paid=false and is_approved=1 and arrear_type=2");
			pst.setDate(1, uF.getDateFormat(strD2, DATE_FORMAT));
			rs = pst.executeQuery();

			while (rs.next()) {
				Map<String, String> hmInner = new HashMap<String, String>();

				hmInner.put("AMOUNT_PAID", rs.getString("total_amount_paid"));
				hmInner.put("AMOUNT_BALANCE", rs.getString("arear_amount_balance"));
				hmInner.put("TOTAL_AMOUNT", rs.getString("arear_amount"));
				hmInner.put("DURATION", rs.getString("duration_months"));
				hmInner.put("MONTHLY_AREAR", rs.getString("monthly_arear"));
				hmInner.put("AREAR_ID", rs.getString("arear_id"));

				hmInner.put("BASIC_AMOUNT", rs.getString("basic_amount"));

				hmArearAmountMap.put(rs.getString("emp_id"), hmInner);
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmArearAmountMap;
	}

	public double getIncrementArearCalculation(UtilityFunctions uF, String strEmpId, Map<String, Map<String, String>> hmArearAmountMap) {
		double dblMonthlyAmount = 0;
		try {
			Map<String, String> hmArearMap = hmArearAmountMap.get(strEmpId);
			if (hmArearMap == null)
				hmArearMap = new HashMap<String, String>();

			double dblBalanceAmount = uF.parseToDouble(hmArearMap.get("AMOUNT_BALANCE"));
			dblMonthlyAmount = uF.parseToDouble(hmArearMap.get("MONTHLY_AREAR"));

			if (dblBalanceAmount > 0 && (dblBalanceAmount - dblMonthlyAmount) < 0) {
				dblMonthlyAmount = dblBalanceAmount;
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
		return dblMonthlyAmount;
	}

	public Map<String, Map<String, String>> getWorkLocationHalfDayFullDayMinHours(Connection con, UtilityFunctions uF, String strD2) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, Map<String, String>> hmHalfDayFullDayMinHrs = new HashMap<String, Map<String, String>>();

		try {

			pst = con.prepareStatement("select * from roster_halfday_fullday_hrs_policy where effective_date <= ? order by wlocation_id,effective_date");
			pst.setDate(1, uF.getDateFormat(strD2, DATE_FORMAT));
			rs = pst.executeQuery();

			while (rs.next()) {
				Map<String, String> hmInner = hmHalfDayFullDayMinHrs.get(rs.getString("wlocation_id"));
				if (hmInner == null)
					hmInner = new HashMap<String, String>();
				hmInner.put("MIN_HRS_" + rs.getString("exception_type"), rs.getString("min_hrs"));

				hmHalfDayFullDayMinHrs.put(rs.getString("wlocation_id"), hmInner);
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmHalfDayFullDayMinHrs;
	}

	public boolean checkEmployeeClockOnOffAccess(Connection con, UtilityFunctions uF, int empId, String strOnOffType) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		boolean isEmpClockOnOffAccess = false;
		try {

			pst = con.prepareStatement("select * from emp_clock_on_off_access where emp_id=?");
			pst.setInt(1, empId);
			// System.out.println("pst=====>"+pst);
			rs = pst.executeQuery();
			while (rs.next()) {
				if (strOnOffType != null && strOnOffType.equals("WEB")) {
					isEmpClockOnOffAccess = uF.parseToBoolean(rs.getString("is_web_access"));
				} else if (strOnOffType != null && strOnOffType.equals("MOB")) {
					isEmpClockOnOffAccess = uF.parseToBoolean(rs.getString("is_mobile_access"));
				} else if (strOnOffType != null && strOnOffType.equals("BIO")) {
					isEmpClockOnOffAccess = uF.parseToBoolean(rs.getString("is_biomatric_access"));
				}
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return isEmpClockOnOffAccess;
	}

	public Map<String, String> getEmpSupervisorIdMap(Connection con) {

		Map<String, String> hmEmpSupervisorId = new HashMap<String, String>();

		PreparedStatement pst = null;
		ResultSet rs = null;
		try {
			pst = con
					.prepareStatement("SELECT emp_id, supervisor_emp_id FROM employee_official_details eod, employee_personal_details epd WHERE epd.emp_per_id=eod.emp_id order by emp_id");
			// System.out.println("pst=====>"+pst);
			rs = pst.executeQuery();
			while (rs.next()) {
				if (rs.getInt("emp_id") < 0) {
					continue;
				}

				hmEmpSupervisorId.put(rs.getString("emp_id"), rs.getString("supervisor_emp_id"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmEmpSupervisorId;
	}

	public StringBuilder getEmployeeSalaryAnnualBonusDetails(Connection con, CommonFunctions CF, UtilityFunctions uF, String empId, HttpServletRequest request,
			HttpSession session) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		StringBuilder sbEmpSalTable = new StringBuilder();
		try {
			Map<String, String> hmEmpProfile = CF.getEmpProfileDetail(con, request, session, CF, uF, null, empId);

			MyProfile myProfile = new MyProfile();
			myProfile.session = session;
			myProfile.request = request;
			myProfile.CF = CF;
			int intEmpIdReq = uF.parseToInt(empId);
			int nSalaryStrucuterType = uF.parseToInt(CF.getStrSalaryStructure());
			if (nSalaryStrucuterType == S_GRADE_WISE) {
				myProfile.getSalaryHeadsforEmployeeByGrade(con, uF, intEmpIdReq, hmEmpProfile);
			} else {
				myProfile.getSalaryHeadsforEmployee(con, uF, intEmpIdReq, hmEmpProfile);
			}

			myProfile.getPrevSalaryHeadsforEmployee(con, uF, intEmpIdReq, hmEmpProfile);

			pst = con.prepareStatement("SELECT * FROM document_labels_for_revised_salary_details");
			// System.out.println("pst=====>"+pst);
			rs = pst.executeQuery();
			List<String> alLabelList = new ArrayList<String>();
			while (rs.next()) {
				alLabelList.add(rs.getString("label_name"));
			}
			rs.close();
			pst.close();

			/**
			 * Salary Structure Table
			 * */

			sbEmpSalTable.append("<table border=\"1\">");
			sbEmpSalTable.append("<tr>");
			String bgColor1 = "#d3d3d3";
			String bgColor2 = "#ff9f7e";
			String bgColor3 = "#88d6a9";

			for (int i = 0; alLabelList != null && i < alLabelList.size(); i++) {
				sbEmpSalTable.append("<td align=\"center\"");
				if (i < 3) {
					sbEmpSalTable.append(" bgcolor=\"" + bgColor1 + "\"");
				} else if (i > 2 && i < 7) {
					sbEmpSalTable.append(" bgcolor=\"" + bgColor2 + "\"");
				} else if (i > 6) {
					sbEmpSalTable.append(" bgcolor=\"" + bgColor3 + "\"");
				}
				sbEmpSalTable.append(" ><b>" + alLabelList.get(i) + "</b></td>");
			}
			sbEmpSalTable.append("</tr>");

			List<List<String>> prevSalaryHeadDetailsList = (List<List<String>>) request.getAttribute("prevSalaryHeadDetailsList");
			// System.out.println("prevSalaryHeadDetailsList ===>> " +
			// prevSalaryHeadDetailsList);
			if (prevSalaryHeadDetailsList == null)
				prevSalaryHeadDetailsList = new ArrayList<List<String>>();
			// if (prevSalaryHeadDetailsList != null &&
			// !prevSalaryHeadDetailsList.isEmpty() &&
			// prevSalaryHeadDetailsList.size() > 0) {

			double prevGrossYearAmount = 0.0d;
			for (int i = 0; i < prevSalaryHeadDetailsList.size(); i++) {
				List<String> innerList = prevSalaryHeadDetailsList.get(i);
				if (innerList.get(1).equals("E")) {
					double dblEarnAnnual = Math.round(uF.parseToDouble(innerList.get(3)));
					prevGrossYearAmount += dblEarnAnnual;
				}
			}

			Map<String, String> hmPrevContribution = (Map<String, String>) request.getAttribute("hmPrevContribution");
			// System.out.println("hmPrevContribution ===>> " +
			// hmPrevContribution);
			if (hmPrevContribution == null)
				hmPrevContribution = new HashMap<String, String>();
			double dblPrevAnnualContri = 0.0d;
			boolean isPrevEPF = uF.parseToBoolean((String) request.getAttribute("isPrevEPF"));
			boolean isPrevESIC = uF.parseToBoolean((String) request.getAttribute("isPrevESIC"));
			boolean isPrevLWF = uF.parseToBoolean((String) request.getAttribute("isPrevLWF"));

			if (isPrevEPF || isPrevESIC || isPrevLWF) {

				if (isPrevEPF) {
					double dblEPFAnnual = Math.round(uF.parseToDouble(hmPrevContribution.get("EPF_ANNUALY")));
					dblPrevAnnualContri += dblEPFAnnual;
				}
				if (isPrevESIC) {
					double dblESIAnnual = Math.ceil(uF.parseToDouble(hmPrevContribution.get("ESI_ANNUALY")));
					dblPrevAnnualContri += dblESIAnnual;
				}
				if (isPrevLWF) {
					double dblLWFAnnual = Math.round(uF.parseToDouble(hmPrevContribution.get("LWF_ANNUALY")));
					dblPrevAnnualContri += dblLWFAnnual;
				}
			}

			List<List<String>> prevSalaryAnnualVariableDetailsList = (List<List<String>>) request.getAttribute("prevSalaryAnnualVariableDetailsList");
			// System.out.println("prevSalaryAnnualVariableDetailsList ===>> " +
			// prevSalaryAnnualVariableDetailsList);
			if (prevSalaryAnnualVariableDetailsList == null)
				prevSalaryAnnualVariableDetailsList = new ArrayList<List<String>>();

			int nPrevAnnualVariSize = prevSalaryAnnualVariableDetailsList.size();
			double prevGrossAnnualYearAmount = 0.0d;
			if (nPrevAnnualVariSize > 0) {
				for (int i = 0; i < nPrevAnnualVariSize; i++) {
					List<String> innerList = prevSalaryAnnualVariableDetailsList.get(i);
					double dblEarnAnnual = Math.round(uF.parseToDouble(innerList.get(3)));
					prevGrossAnnualYearAmount += dblEarnAnnual;
				}
			}
			// }

			List<List<String>> salaryHeadDetailsList = (List<List<String>>) request.getAttribute("salaryHeadDetailsList");
			if (salaryHeadDetailsList == null)
				salaryHeadDetailsList = new ArrayList<List<String>>();
			// System.out.println("salaryHeadDetailsList 111 ===>> " +
			// salaryHeadDetailsList);
			if (salaryHeadDetailsList != null && !salaryHeadDetailsList.isEmpty() && salaryHeadDetailsList.size() > 0) {

				// double grossAmount = 0.0d;
				double grossYearAmount = 0.0d;
				// double netTakeHome = 0.0d;
				for (int i = 0; i < salaryHeadDetailsList.size(); i++) {
					List<String> innerList = salaryHeadDetailsList.get(i);
					if (innerList.get(1).equals("E")) {
						// double dblEarnMonth =
						// Math.round(uF.parseToDouble(innerList.get(2)));
						double dblEarnAnnual = Math.round(uF.parseToDouble(innerList.get(3)));
						// grossAmount += dblEarnMonth;
						grossYearAmount += dblEarnAnnual;
					}
				}

				Map<String, String> hmContribution = (Map<String, String>) request.getAttribute("hmContribution");
				if (hmContribution == null)
					hmContribution = new HashMap<String, String>();
				// double dblMonthContri = 0.0d;
				double dblAnnualContri = 0.0d;
				boolean isEPF = uF.parseToBoolean((String) request.getAttribute("isEPF"));
				boolean isESIC = uF.parseToBoolean((String) request.getAttribute("isESIC"));
				boolean isLWF = uF.parseToBoolean((String) request.getAttribute("isLWF"));

				if (isEPF || isESIC || isLWF) {

					if (isEPF) {
						// double dblEPFMonth =
						// Math.round(uF.parseToDouble(hmContribution.get("EPF_MONTHLY")));
						double dblEPFAnnual = Math.round(uF.parseToDouble(hmContribution.get("EPF_ANNUALY")));
						// dblMonthContri += dblEPFMonth;
						dblAnnualContri += dblEPFAnnual;
					}
					if (isESIC) {
						// double dblESIMonth =
						// Math.ceil(uF.parseToDouble(hmContribution.get("ESI_MONTHLY")));
						double dblESIAnnual = Math.ceil(uF.parseToDouble(hmContribution.get("ESI_ANNUALY")));
						// dblMonthContri += dblESIMonth;
						dblAnnualContri += dblESIAnnual;
					}
					if (isLWF) {
						// double dblLWFMonth =
						// Math.round(uF.parseToDouble(hmContribution.get("LWF_MONTHLY")));
						double dblLWFAnnual = Math.round(uF.parseToDouble(hmContribution.get("LWF_ANNUALY")));
						// dblMonthContri += dblLWFMonth;
						dblAnnualContri += dblLWFAnnual;
					}
				}

				List<List<String>> salaryAnnualVariableDetailsList = (List<List<String>>) request.getAttribute("salaryAnnualVariableDetailsList");
				if (salaryAnnualVariableDetailsList == null)
					salaryAnnualVariableDetailsList = new ArrayList<List<String>>();

				int nAnnualVariSize = salaryAnnualVariableDetailsList.size();
				double grossAnnualYearAmount = 0.0d;
				if (nAnnualVariSize > 0) {
					// double grossAnnualAmount = 0.0d;
					for (int i = 0; i < nAnnualVariSize; i++) {
						List<String> innerList = salaryAnnualVariableDetailsList.get(i);
						// double dblEarnMonth =
						// Math.round(uF.parseToDouble(innerList.get(2)));
						double dblEarnAnnual = Math.round(uF.parseToDouble(innerList.get(3)));
						// grossAnnualAmount += dblEarnMonth;
						grossAnnualYearAmount += dblEarnAnnual;
					}
				}

				sbEmpSalTable.append("<tr>");
				sbEmpSalTable.append("<td bgcolor=\"#f4f4f4\">" + uF.formatIntoTwoDecimal((prevGrossYearAmount + dblPrevAnnualContri)) + "</td>");
				sbEmpSalTable.append("<td bgcolor=\"#f4f4f4\">" + uF.formatIntoTwoDecimal(prevGrossAnnualYearAmount) + "</td>");
				sbEmpSalTable.append("<td bgcolor=\"#f4f4f4\">"
						+ uF.formatIntoTwoDecimal((prevGrossYearAmount + dblPrevAnnualContri + prevGrossAnnualYearAmount)) + "</td>");
				sbEmpSalTable.append("<td bgcolor=\"#fff8ed\">" + uF.formatIntoTwoDecimal((grossYearAmount + dblAnnualContri)) + "</td>");
				sbEmpSalTable.append("<td bgcolor=\"#fff8ed\">" + uF.formatIntoTwoDecimal((grossAnnualYearAmount / 2)) + "</td>");
				sbEmpSalTable.append("<td bgcolor=\"#fff8ed\">" + uF.formatIntoTwoDecimal((grossAnnualYearAmount / 2)) + "</td>");
				sbEmpSalTable.append("<td bgcolor=\"#fff8ed\">" + uF.formatIntoTwoDecimal((grossYearAmount + dblAnnualContri + grossAnnualYearAmount))
						+ "</td>");
				double pramotionDiffAmt = (grossYearAmount + dblAnnualContri + grossAnnualYearAmount)
						- (prevGrossYearAmount + dblPrevAnnualContri + prevGrossAnnualYearAmount);
				double pramotionPercent = (pramotionDiffAmt * 100) / (grossYearAmount + dblAnnualContri + grossAnnualYearAmount);
				sbEmpSalTable.append("<td bgcolor=\"#ecf8ec\">" + Math.round(pramotionPercent) + "%</td>");
				sbEmpSalTable.append("<td bgcolor=\"#ecf8ec\">-</td>");
				sbEmpSalTable.append("</tr>");

				sbEmpSalTable.append("</table>::::" + Math.round(pramotionPercent));
			}
			/**
			 * Salary Structure End
			 * */

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return sbEmpSalTable;
	}

	public Map<String, Map<String, String>> getShiftTimeBaseOnShiftId(Connection con) {

		Map<String, Map<String, String>> hmShiftTime = new HashMap<String, Map<String, String>>();
		PreparedStatement pst = null;
		ResultSet rs = null;
		try {

			pst = con.prepareStatement("Select * from shift_details ");
			rs = pst.executeQuery();
			while (rs.next()) {
				Map<String, String> hm = new HashMap<String, String>();
				hm.put("SHIFT_ID", rs.getString("shift_id"));
				hm.put("SHIFT_NAME", rs.getString("shift_name"));
				hm.put("SHIFT_COLOR", rs.getString("colour_code"));
				hm.put("FROM", rs.getString("_from"));
				hm.put("TO", rs.getString("_to"));
				hm.put("BSTART", rs.getString("break_start"));
				hm.put("BEND", rs.getString("break_end"));

				hmShiftTime.put(rs.getString("shift_id"), hm);
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

		return hmShiftTime;
	}

	public Map<String, String> getLeaveTypeCode(Connection con) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmLeaveTypeMap = new HashMap<String, String>();

		try {
			pst = con.prepareStatement(selectLeaveTypeF);
			rs = pst.executeQuery();

			while (rs.next()) {
				hmLeaveTypeMap.put(rs.getString("leave_type_id"), rs.getString("leave_type_code"));
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmLeaveTypeMap;
	}

	public Map<String, Map<String, String>> getSalaryCalculationForArrear(Connection con, Map<String, Map<String, String>> hmInnerisDisplay, int nEmpId,
			double dblPresent, double dblAbsent, double dblBreaks, int nTotalNumberOfDays, double dblIncrementBasic, double dblIncrementDA, String strLevelId,
			UtilityFunctions uF, CommonFunctions CF, String strD2, Map<String, Map<String, String>> hmSalaryDetails, String strEmpVDAAmount,
			String strSalCalStatus, Map<String, String> hmCurrSalHeadsAndAmt) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, Map<String, String>> hmSalaryHeadReCalculatedMap = new LinkedHashMap<String, Map<String, String>>();

		try {
			int cnt = 0;
			StringBuilder sbQuery = new StringBuilder();
			sbQuery.append("select * from (select *, 1 as aa from emp_salary_details where emp_id=? and effective_date=(select max(effective_date) from emp_salary_details "
					+ "where emp_id=? and effective_date<=? and is_approved=true) and salary_head_id not in ("
					+ CTC
					+ ","
					+ TDS
					+ ","
					+ DA1
					+ ","
					+ GROSS
					+ ") and is_approved=true "
					+ "and salary_head_id in (select salary_head_id from salary_details where (is_delete is null or is_delete=false) and org_id in (select org_id from "
					+ "employee_personal_details epd, employee_official_details eod where epd.emp_per_id=eod.emp_id and eod.emp_id=?) and level_id=?) order by earning_deduction desc, "
					+ "salary_head_id, emp_salary_id ) ac "
					+ " union "
					+ "(select *, 2 as aa from emp_salary_details where emp_id=? and effective_date=(select max(effective_date) from emp_salary_details where emp_id=? "
					+ "and effective_date<=? and is_approved=true) and salary_head_id in ("
					+ TDS
					+ ") and salary_head_id not in ("
					+ CTC
					+ ") and salary_head_id in "
					+ "(select salary_head_id from salary_details where (is_delete is null or is_delete=false) and org_id in (select org_id from employee_personal_details epd, "
					+ "employee_official_details eod where epd.emp_per_id=eod.emp_id and eod.emp_id=?) and level_id=?) order by earning_deduction desc, salary_head_id, emp_salary_id) "
					+ "order by aa, earning_deduction desc, salary_head_id, emp_salary_id");
			pst = con.prepareStatement(sbQuery.toString());
			pst.setInt(1, nEmpId);
			pst.setInt(2, nEmpId);
			pst.setDate(3, uF.getDateFormat(strD2, DATE_FORMAT));
			pst.setInt(4, nEmpId);
			pst.setInt(5, uF.parseToInt(strLevelId));
			pst.setInt(6, nEmpId);
			pst.setInt(7, nEmpId);
			pst.setDate(8, uF.getDateFormat(strD2, DATE_FORMAT));
			pst.setInt(9, nEmpId);
			pst.setInt(10, uF.parseToInt(strLevelId));
			// if(nEmpId==181){
			cnt++;
			// System.out.println("cnt ===>> " + cnt + " -- pst ========> " +
			// pst);
			// }
			rs = pst.executeQuery();
			while (rs.next()) {
				String strSalaryHeadId = rs.getString("salary_head_id");
				String strAmount = hmCurrSalHeadsAndAmt.get(strSalaryHeadId);
				// String strAmount = rs.getString("amount");
				double dblAmount = uF.parseToDouble(strAmount);

				if (uF.parseToInt(strSalaryHeadId) == VDA && !uF.parseToBoolean(strSalCalStatus)) {
					dblAmount = uF.parseToDouble(strEmpVDAAmount);
					// System.out.println("dblAmount ===>> " + dblAmount);
				}

				Map<String, String> hmInnerSal = hmSalaryDetails.get(strSalaryHeadId);
				if (hmInnerSal == null)
					hmInnerSal = new HashMap<String, String>();

				String strSalPercentage = hmInnerSal.get("SALARY_HEAD_AMOUNT");
				String strSalAmountType = hmInnerSal.get("SALARY_AMOUNT_TYPE");
				String isCTCVariable = hmInnerSal.get("IS_CTC_VARIABLE");
				String strMultipleCalculation = hmInnerSal.get("MULTIPLE_CALCULATION");
				String isAlignWithPerk = hmInnerSal.get("IS_ALIGN_WITH_PERK");
				String isDefaultCalAllowance = hmInnerSal.get("IS_DEFAULT_CAL_ALLOWANCE");

				String strEarningDeduction = hmInnerSal.get("EARNING_DEDUCTION");
				String strSalaryType = hmInnerSal.get("SALARY_TYPE");

				if (strSalaryType != null && strSalaryType.equalsIgnoreCase("F")) {
					// dblAmount = dblAmount;
				} else if (strSalaryType != null && strSalaryType.equalsIgnoreCase("D")) {
					dblAmount = dblAmount * dblPresent;
				} else {
					dblAmount = dblAmount * (dblPresent / nTotalNumberOfDays);
				}

				if (strEarningDeduction != null) {
					Map<String, String> hmSalaryInner = new HashMap<String, String>();
					hmSalaryInner.put("EARNING_DEDUCTION", strEarningDeduction);
					hmSalaryInner.put("AMOUNT", uF.getRoundOffValue(uF.parseToInt(CF.getRoundOffCondtion()), dblAmount));
					hmSalaryInner.put("SALARY_AMOUNT_TYPE", strSalAmountType);
					hmSalaryInner.put("MULTIPLE_CALCULATION", strMultipleCalculation);
					hmSalaryInner.put("IS_ALIGN_WITH_PERK", isAlignWithPerk);
					hmSalaryInner.put("SALARY_PERCENTAGE", strSalPercentage);
					hmSalaryInner.put("IS_DEFAULT_CAL_ALLOWANCE", isDefaultCalAllowance);
					hmSalaryInner.put("AMOUNT_ACTUAL", uF.getRoundOffValue(uF.parseToInt(CF.getRoundOffCondtion()), uF.parseToDouble(strAmount)));

					if (rs.getBoolean("isdisplay") && uF.parseToBoolean(isCTCVariable)) {
						hmInnerisDisplay.put(strSalaryHeadId, hmSalaryInner);
					} else if (rs.getBoolean("isdisplay") && !uF.parseToBoolean(isCTCVariable)) {
						hmSalaryHeadReCalculatedMap.put(strSalaryHeadId, hmSalaryInner);
					}
				}
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmSalaryHeadReCalculatedMap;

	}

	public Map<String, String> getShiftNameMap(Connection con) {
		Map<String, String> hmShiftMap = new HashMap<String, String>();
		PreparedStatement pst = null;
		ResultSet rs = null;
		try {
			pst = con.prepareStatement("Select * from shift_details ");
			rs = pst.executeQuery();
			while (rs.next()) {
				hmShiftMap.put(rs.getString("shift_id"), rs.getString("shift_name"));
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmShiftMap;
	}

	public Map<String, String> getClientBrandMap(Connection con) {
		Map<String, String> hmClientBrand = new HashMap<String, String>();
		PreparedStatement pst = null;
		ResultSet rs = null;
		try {
			pst = con.prepareStatement("select * from client_brand_details");
			rs = pst.executeQuery();
			while (rs.next()) {
				hmClientBrand.put(rs.getString("client_brand_id"), rs.getString("client_brand_name"));
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmClientBrand;
	}

	public String getClientOrgIdById(Connection con, String clientId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		String orgId = null;
		try {
			pst = con.prepareStatement("SELECT org_id FROM client_details where client_id = ? ");
			pst.setInt(1, uF.parseToInt(clientId));
			rs = pst.executeQuery();
			// System.out.println("pst ===>> " + pst);
			while (rs.next()) {
				orgId = rs.getString("org_id");
			}
			rs.close();
			pst.close();
			// System.out.println("serviceName ===>> " + serviceName);
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return orgId;
	}

	public String getProjectTaskRequestAutoApproved(Connection con, String orgId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		String taskRequestAutoApproved = null;
		try {
			pst = con.prepareStatement("select task_request_autoapproved from task_type_setting where org_id=?");
			pst.setInt(1, uF.parseToInt(orgId));
			rs = pst.executeQuery();
			while (rs.next()) {
				taskRequestAutoApproved = rs.getString("task_request_autoapproved");
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return taskRequestAutoApproved;
	}

	public String getEmpIncomeTaxSlabType(Connection con, CommonFunctions CF, String strEmpId, String strFinancialYearStart, String strFinancialYearEnd) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		// Map<String, String> hmEmpSlabMap = new HashMap<String, String>();
		UtilityFunctions uF = new UtilityFunctions();
		String strSlabType = null;
		try {
			pst = con.prepareStatement("select * from emp_it_slab_access_details where emp_id=? and fyear_start=? and fyear_end=?");
			pst.setInt(1, uF.parseToInt(strEmpId));
			pst.setDate(2, uF.getDateFormat(strFinancialYearStart, DATE_FORMAT));
			pst.setDate(3, uF.getDateFormat(strFinancialYearEnd, DATE_FORMAT));
			rs = pst.executeQuery();
			while (rs.next()) {
				// hmEmpSlabMap.put(rs.getString("emp_id"),
				// rs.getString("slab_type"));
				strSlabType = rs.getString("slab_type");
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return strSlabType;
	}

	public Map<String, String> getEmpIncomeTaxSlabTypeMap(Connection con, CommonFunctions CF, String strFinancialYearStart, String strFinancialYearEnd) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmEmpSlabMap = new HashMap<String, String>();
		UtilityFunctions uF = new UtilityFunctions();
		// String strSlabType = null;
		try {
			pst = con.prepareStatement("select * from emp_it_slab_access_details where fyear_start=? and fyear_end=?");
			pst.setDate(1, uF.getDateFormat(strFinancialYearStart, DATE_FORMAT));
			pst.setDate(2, uF.getDateFormat(strFinancialYearEnd, DATE_FORMAT));
			rs = pst.executeQuery();
			while (rs.next()) {
				hmEmpSlabMap.put(rs.getString("emp_id"), rs.getString("slab_type"));
				// strSlabType = rs.getString("slab_type");
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmEmpSlabMap;
	}

	public Map<String, String> getHrCodeMap(Connection con, UtilityFunctions uF, int org_id, int wlocation) {
		PreparedStatement pst = null;
		ResultSet rs = null;

		Map<String, String> hmHrMap = new LinkedHashMap<String, String>();
		try {
			StringBuilder sbQuery = new StringBuilder();

			sbQuery.append("select * from employee_official_details eod,employee_personal_details epd,user_details ud where epd.emp_per_id=eod.emp_id "
					+ "and epd.is_alive= true and epd.joining_date <= ?  and ud.emp_id=epd.emp_per_id and (usertype_id = (select user_type_id "
					+ "from user_type where user_type = '" + ADMIN + "') or (usertype_id = (select user_type_id from user_type where user_type = '" + HRMANAGER
					+ "') ");
			if (org_id > 0) {
				sbQuery.append(" and org_id_access like '%," + org_id + ",%'");
			}
			if (wlocation > 0) {
				sbQuery.append(" and wlocation_id_access like '%," + wlocation + ",%'");
			}
			sbQuery.append(")) order by epd.emp_fname");

			pst = con.prepareStatement(sbQuery.toString());
			pst.setDate(1, uF.getCurrentDate(getStrTimeZone()));
			rs = pst.executeQuery();
			while (rs.next()) {
				hmHrMap.put(rs.getString("emp_per_id"), "[" + rs.getString("empcode") + "]" + rs.getString("emp_fname") + " " + rs.getString("emp_lname"));

			}

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

		return hmHrMap;
	}
	public Map<String, String> getClientCodeMap(Connection con, UtilityFunctions uF) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmClientCodeMap = new LinkedHashMap<String, String>();
		try {
			pst = con.prepareStatement("SELECT * FROM client_details");
			rs = pst.executeQuery();
			while (rs.next()) {
				hmClientCodeMap.put(rs.getString("client_id"), "[" + rs.getString("client_id") + "]" + rs.getString("client_name"));
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

		return hmClientCodeMap;
	}

	public List<String> getHRList(Connection con, UtilityFunctions uF) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		List<String> hmHRMap = new ArrayList<String>();
		try {
			pst = con
					.prepareStatement("select * from employee_official_details eod,employee_personal_details epd,user_details ud where epd.emp_per_id=eod.emp_id and epd.is_alive= true and usertype_id = (select user_type_id from user_type where user_type in('Global HR','HR')) ");
			rs = pst.executeQuery();
			while (rs.next()) {
				hmHRMap.add("[" + rs.getString("empcode") + "]" + rs.getString("emp_fname") + " " + rs.getString("emp_lname"));
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmHRMap;
	}

	public List<String> getClientList(Connection con, UtilityFunctions uF) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		List<String> hmDepartmentCodeMap = new ArrayList<String>();
		try {
			pst = con.prepareStatement("SELECT * FROM client_details");
			rs = pst.executeQuery();
			while (rs.next()) {
				hmDepartmentCodeMap.add("[" + rs.getString("client_id") + "]" + rs.getString("client_name"));
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmDepartmentCodeMap;
	}

	public String getSettingsShortCurrency(HttpServletRequest request) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Connection con = null;
		Database db = new Database();
		db.setRequest(request);
		String strShortCurr = null;
		try {
			con = db.makeConnection(con);
			pst = con.prepareStatement("select * FROM settings where options=?");
			pst.setString(1, O_SHORT_CURR);
			rs = pst.executeQuery();
			while (rs.next()) {
				strShortCurr = rs.getString("value");
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			db.closeResultSet(rs);
			db.closeStatements(pst);
			db.closeConnection(con);
		}
		return strShortCurr;
	}

	public Map<String, String> getEmpHODIdMap(Connection con, UtilityFunctions uF) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmEmpHrId = new HashMap<String, String>();
		try {
			pst = con.prepareStatement("SELECT emp_id,hod_emp_id FROM employee_official_details");
			rs = pst.executeQuery();
			while (rs.next()) {
				hmEmpHrId.put(rs.getString("emp_id"), rs.getString("hod_emp_id"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmEmpHrId;
	}

	public Map<String, String> getEmpFlatTDSDeduction(Connection con, UtilityFunctions uF) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmEmpFlatDeductPercent = new HashMap<String, String>();
		try {
			pst = con
					.prepareStatement("SELECT emp_id,flat_deduct_percent FROM employee_official_details where flat_deduct_percent is not null or flat_deduct_percent>=0");
			rs = pst.executeQuery();
			while (rs.next()) {
				hmEmpFlatDeductPercent.put(rs.getString("emp_id"), rs.getString("flat_deduct_percent"));
			}
			rs.close();
			pst.close();
//			System.out.println("hmEmpFlatDeductPercent ===>> " + hmEmpFlatDeductPercent);
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmEmpFlatDeductPercent;
	}

	
	public List<String> getOrientationMembers(Connection con, UtilityFunctions uF, HttpServletRequest request, String orientationId) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		List<String> alOrientationMembers = new ArrayList<String>();
		try {
			 StringBuilder sb = new StringBuilder();
			 pst = con.prepareStatement("select member_name from orientation_details od,orientation_member om  where orientation_id=? and od.member_id= om.orientation_member_id");
			 pst.setInt(1,uF.parseToInt(orientationId));
			 rs = pst.executeQuery();
			 int i=0;
				while(rs.next()) {
					alOrientationMembers.add(rs.getString("member_name"));
					if(i==0) {
					sb.append(rs.getString("member_name"));
					} else {
						sb.append(","+rs.getString("member_name"));
					}
					i++;
				}
				rs.close();
				pst.close();
//				System.out.println("orientation members==>"+ sb.toString());
				request.setAttribute("members", sb.toString());
		} catch (Exception e) {
			e.printStackTrace();
		}
		return alOrientationMembers;
	}

	public String getSalaryBandId(Connection con, String ctcAmt, String level_id) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		String salBandId = null;
		try {
			 pst = con.prepareStatement("select * from salary_band_details where ((? between band_min_amount and band_max_amount) or (band_min_amount=0 and band_max_amount=0)) and level_id=?");
			 pst.setDouble(1, uF.parseToDouble(ctcAmt));
			 pst.setInt(2, uF.parseToInt(level_id));
			 rs = pst.executeQuery();
				while(rs.next()) {
					salBandId = rs.getString("salary_band_id");	
				}
				rs.close();
				pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
		return salBandId;
	}

	/**
	 * @author Dattatray
	 * @since 23-08-21
	 * @param con
	 * @param strWLocation
	 * @return location name
	 */
	public String getCandidatePreferedLocation(Connection con, String strWLocation) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		List<String> workLocationList = new ArrayList<String>();
		String strLocation = "-";
		try {
			if (strWLocation != null && !strWLocation.isEmpty()) {
				pst = con.prepareStatement("SELECT * FROM work_location_info where wlocation_id in (" + strWLocation + ") order by wlocation_name");
				rs = pst.executeQuery();
				while (rs.next()) {
					workLocationList.add(rs.getString("wlocation_name"));
				}

				int k = 0;
				for (int i = 0; workLocationList != null && i < workLocationList.size(); i++) {
					if (k == 0) {
						strLocation = workLocationList.get(i);
					} else {
						strLocation += ", " + workLocationList.get(i);
					}
					k++;
				}

				rs.close();
				pst.close();
			}
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return strLocation;
	}

	/**
	 * @author Dattatray
	 * @since 23-08-21
	 * @param con
	 * @param uF
	 * @param candidateId
	 * @return candidate prev location
	 */
	public String getCandidatePrevLocation(Connection con, UtilityFunctions uF, String candidateId) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		String strLocation = "-";
		try {
			if (candidateId != null && !candidateId.isEmpty()) {
				pst = con.prepareStatement("select company_location from candidate_prev_employment where emp_id = ?");
				pst.setInt(1, uF.parseToInt(candidateId));
				rs = pst.executeQuery();
				while (rs.next()) {
					strLocation = rs.getString("company_location");
				}

				rs.close();
				pst.close();
			}
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return strLocation;
	}
	
	/**
	 * @author Dattatray
	 * @since 23-08-21
	 * @param con
	 * @param candiId
	 * @return candidate certification
	 */
	public List<List<String>> selectCandidateCertification(Connection con, int candiId) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		List<List<String>> alCertification = new ArrayList<List<String>>();
		try {
			pst = con.prepareStatement("SELECT * FROM candidate_certification_details WHERE candidate_id = ?");
			pst.setInt(1, candiId);
//			System.out.println("pst=>" + pst);
			rs = pst.executeQuery();
			while (rs.next()) {
				List<String> alInner = new ArrayList<String>();
				alInner.add(rs.getString("candidate_certification_details_id"));//0
				alInner.add(uF.showData(rs.getString("certification_title"), "-"));//1
				alInner.add(uF.showData(rs.getString("certification_completion_year"), "-"));//2
				alInner.add(uF.showData(rs.getString("location"), "-"));//3
				alCertification.add(alInner);
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return alCertification;
	}

	//===start parvez date 30-08-2021===
	public Map<String, List<String>> getDegreeNameMap1(Connection con) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, List<String>> hmDegreeName = new HashMap<String, List<String>>();
		List<String> innerList;
		try {
			pst = con.prepareStatement("select edu_id, education_name, education_type from educational_details");
			rs = pst.executeQuery();
			while (rs.next()) {
				innerList = new ArrayList<String>();
				innerList.add(rs.getString("education_name"));
				innerList.add(rs.getString("education_type"));
//				System.out.println("CF/14893--innerList="+innerList);
				hmDegreeName.put(rs.getString("edu_id"), innerList);
			}
			rs.close();
			pst.close();
			// System.out.println("hmEmpDetails ====>"+hmEmpDetails);
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmDegreeName;
	}
//===end parvez date:30-08-2021===

	//===added by parvez date: 08-09-2021===
	//===start
	public Map<String, List<String>> selectCandidateEducationDocument(Connection con, int candidateId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, List<String>> hmDegreeDocs = new LinkedHashMap<String, List<String>>();
		try {
			pst = con.prepareStatement("SELECT * FROM candidate_degree_certificate_details WHERE emp_id = ? order by degree_id");
			pst.setInt(1, candidateId);
			rs = pst.executeQuery();
			while (rs.next()) {
				List<String> alInner = hmDegreeDocs.get(rs.getString("degree_id"));
				if (alInner == null)
					alInner = new ArrayList<String>();
				alInner.add(rs.getString("degree_certificate_name"));
				hmDegreeDocs.put(rs.getString("degree_id"), alInner);
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmDegreeDocs;
	}
	//===end ===

	/**
	 * @author Dattatray
	 * @since 14-09-21
	 * 
	 * @param con
	 * @param levelId
	 * @param leaveTypeId
	 * @param locationId
	 * @param orgId
	 * @return
	 */
	public String getSandwitchType(Connection con, String levelId,String leaveTypeId,String locationId,String orgId) {

		PreparedStatement pst = null;
		ResultSet rs = null;
		String strSandwitchType="0";
		try {
			pst = con.prepareStatement("SELECT sandwich_type FROM emp_leave_type WHERE level_id = ? AND leave_type_id = ? and wlocation_id = ? and org_id = ?");
			pst.setInt(1, uF.parseToInt(levelId));
			pst.setInt(2, uF.parseToInt(leaveTypeId));
			pst.setInt(3, uF.parseToInt(locationId));
			pst.setInt(4, uF.parseToInt(orgId));
//			System.out.println("PST : "+pst.toString());
			rs = pst.executeQuery();

			while (rs.next()) {
				strSandwitchType = rs.getString("sandwich_type");
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return strSandwitchType;
	}
	
	//===added by parvez date: 08-10-2021===
	//===start===
	public Map<String, String> getVideoNameMap(Connection con) {
		Map<String, String> hmVideoName = new HashMap<String, String>();
		PreparedStatement pst = null;
		ResultSet rst = null;
		try {
			pst = con.prepareStatement("select * from video_link_details");
			rst = pst.executeQuery();
			while (rst.next()) {
				hmVideoName.put(rst.getString("video_link_id"), rst.getString("video_name"));
			}
			rst.close();
			pst.close();
		} catch (Exception e) {

		} finally {
			if (rst != null) {
				try {
					rst.close();
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		}
		return hmVideoName;
	}
	//===end===
	
	/**
	 * Note : Candidate Reject
	 * @author Dattatray
	 * @since 11-10-21
	 * 
	 * @param uF
	 * @param candiID
	 * @param recrtuitID
	 * @param strSessionEmpId
	 */
	public void candidateReject(Connection con, UtilityFunctions uF, String candiID,String recrtuitID,String strSessionEmpId) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		try {
			
			pst = con.prepareStatement("SELECT * FROM candidate_application_details WHERE candidate_id = ? AND application_status != -1");
			pst.setInt(1, uF.parseToInt(candiID));
			rs = pst.executeQuery();
			List<String>  alRecruitIds = new ArrayList<String>();
			while (rs.next()) {
				alRecruitIds.add(rs.getString("recruitment_id"));
			}
			rs.close();
			pst.close();

			for (int i = 0; alRecruitIds!=null && i < alRecruitIds.size() && !alRecruitIds.isEmpty(); i++) {
				pst = con.prepareStatement("update candidate_application_details set application_status = -1,application_status_date=? where candidate_id = ? and recruitment_id = ?");
				pst.setDate(1, uF.getCurrentDate(CF.getStrTimeZone()));
				pst.setInt(2, uF.parseToInt(candiID));
				pst.setInt(3, uF.parseToInt(alRecruitIds.get(i)));
				pst.executeUpdate();
				pst.close();
				
				pst=con.prepareStatement("insert into candidate_activity_details(recruitment_id,candi_id,activity_name,user_id,entry_date,activity_id) values(?,?,?,?,?,?)");
				pst.setInt(1,uF.parseToInt(alRecruitIds.get(i)));
				pst.setInt(2,uF.parseToInt(candiID));
				pst.setString(3, "Application Rejected");
				pst.setInt(4,uF.parseToInt(strSessionEmpId));
				pst.setDate	(5, uF.getDateFormat(uF.getCurrentDate(CF.getStrTimeZone())+"", DBDATE));
				pst.setInt(6, CANDI_ACTIVITY_APPLI_SHORTLIST_OR_REJECT_ID);
				pst.execute();
				pst.close();
			}
			
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	
//===start parvez date: 22-03-2022===
	public Map<String, String> getAppraisalRevieweesId(Connection con, UtilityFunctions uF) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmRevieweeId = new HashMap<String, String>();
		try {
			pst = con.prepareStatement("SELECT * FROM appraisal_reviewee_details");
			rs = pst.executeQuery();
			while (rs.next()) {
				hmRevieweeId.put(rs.getString("appraisal_id")+"_"+rs.getString("reviewee_id")+"_SUBORDINATE", rs.getString("subordinate_ids"));
				hmRevieweeId.put(rs.getString("appraisal_id")+"_"+rs.getString("reviewee_id")+"_PEER", rs.getString("peer_ids"));
				hmRevieweeId.put(rs.getString("appraisal_id")+"_"+rs.getString("reviewee_id")+"_OTHER_PEER", rs.getString("other_peer_ids"));
				hmRevieweeId.put(rs.getString("appraisal_id")+"_"+rs.getString("reviewee_id")+"_SUPERVISOR", rs.getString("supervisor_ids"));
				hmRevieweeId.put(rs.getString("appraisal_id")+"_"+rs.getString("reviewee_id")+"_GRAND_SUPERVISOR", rs.getString("grand_supervisor_ids"));
				hmRevieweeId.put(rs.getString("appraisal_id")+"_"+rs.getString("reviewee_id")+"_HOD", rs.getString("hod_ids"));
				hmRevieweeId.put(rs.getString("appraisal_id")+"_"+rs.getString("reviewee_id")+"_CEO", rs.getString("ceo_ids"));
				hmRevieweeId.put(rs.getString("appraisal_id")+"_"+rs.getString("reviewee_id")+"_HR", rs.getString("hr_ids"));
				hmRevieweeId.put(rs.getString("appraisal_id")+"_"+rs.getString("reviewee_id")+"_GLOBAL_HR", rs.getString("ghr_ids"));
				hmRevieweeId.put(rs.getString("appraisal_id")+"_"+rs.getString("reviewee_id")+"_RECRUITER", rs.getString("recruiter_ids"));
				hmRevieweeId.put(rs.getString("appraisal_id")+"_"+rs.getString("reviewee_id")+"_OTHER", rs.getString("other_ids"));
				
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmRevieweeId;
	}
//===end parvez date: 22-03-2022===	
	
//===start parvez date: 07-04-2022===
	public Map<String, String> getLeaveEncashmentNew(Connection con, UtilityFunctions uF, CommonFunctions CF, HttpSession session, String orgId, Map<String,String> hmEmpLevelMap, Map<String, String> hmEmpWlocationMap, String strEmpId) {
		PreparedStatement pst = null;
		ResultSet rs = null;
		Map<String, String> hmLeaveEncashment = new HashMap<String, String>();

		try {
			
			StringBuilder sbLeaveTypeId = null;
			pst = con.prepareStatement("SELECT * FROM leave_type  where leave_type_id>0  and is_leave_encashment = true and org_id=? order by leave_type_name");
			pst.setInt(1,uF.parseToInt(orgId));
			rs = pst.executeQuery();
			List<String> alEnCashLeave = new ArrayList<String>();
			while (rs.next()) {
				if(sbLeaveTypeId == null){
					sbLeaveTypeId = new StringBuilder();
					sbLeaveTypeId.append(rs.getString("leave_type_id"));
				} else{
					sbLeaveTypeId.append(","+rs.getString("leave_type_id"));
				}
				alEnCashLeave.add(rs.getString("leave_type_id"));
			}
			rs.close();
			pst.close();
			
			EmployeeLeaveEntryReport leaveEntryReport = new EmployeeLeaveEntryReport();
			leaveEntryReport.request = request;
			leaveEntryReport.session = session;
			leaveEntryReport.CF = CF;
			leaveEntryReport.setStrEmpId(strEmpId);
			leaveEntryReport.setDataType("L");
			leaveEntryReport.viewEmployeeLeaveEntry1();
			 
			List<List<String>> leaveList = (List<List<String>>)request.getAttribute("leaveList");
			if(leaveList == null) leaveList = new ArrayList<List<String>>();
			
			
			for(int a=0; a<alEnCashLeave.size(); a++){
				
				double leaveEncashDays = 0;
				
				pst = con.prepareStatement("select elt.min_leave_encashment,elt.encashment_applicable," +
						"elt.encashment_times,elt.max_leave_encash,is_carryforward,effective_date_type " +
						"from leave_type lt, emp_leave_type elt where lt.leave_type_id = elt.leave_type_id " +
						"and lt.leave_type_id=? and elt.level_id=? and elt.wlocation_id=? and elt.org_id=?");
				
				pst.setInt(1, uF.parseToInt(alEnCashLeave.get(a)));
				pst.setInt(2, uF.parseToInt(hmEmpLevelMap.get(strEmpId)));
				pst.setInt(3, uF.parseToInt(hmEmpWlocationMap.get(strEmpId)));
				pst.setInt(4, uF.parseToInt(orgId));
//				System.out.println("pst=="+pst);
				rs = pst.executeQuery();
				double dblMinLeavesForEncashment = 0;
				int encashApplicable=0;
				int encashNoOfTimes=0;
				boolean isCarryforward = false;
				String effective_date_type = "";
				double dblMaxLeavesForEncashment = 0;
				while(rs.next()){
					dblMinLeavesForEncashment = rs.getDouble("min_leave_encashment");
					encashApplicable = rs.getInt("encashment_applicable");
					encashNoOfTimes = rs.getInt("encashment_times");
					isCarryforward = uF.parseToBoolean(rs.getString("is_carryforward"));
					effective_date_type = rs.getString("effective_date_type");
					dblMaxLeavesForEncashment = rs.getDouble("max_leave_encash");
				}
				rs.close();
				pst.close();
				if(isCarryforward || encashApplicable == 2){
					String effectiveDate="";
					boolean isEncahsmentApplied = false;
					String strEntryDate = null;
					
					if(effective_date_type.equals("CY")){
						int nCurrentYear = uF.parseToInt(uF.getDateFormat(uF.getCurrentDate(CF.getStrTimeZone())+"", DBDATE, "yyyy"));
						effectiveDate = "01/01/"+nCurrentYear;
					} else {
						String strDate = uF.getDateFormat(uF.getCurrentDate(CF.getStrTimeZone())+"", DBDATE, DATE_FORMAT);
						String[] arrDate = CF.getFinancialYear(con, strDate, CF, uF);
						int nCurrentYear = uF.parseToInt(uF.getDateFormat(arrDate[0], DATE_FORMAT, "yyyy"));
						effectiveDate = "01/04/"+nCurrentYear;
					}
					
					/*pst = con.prepareStatement("select * from emp_leave_encashment where emp_id = ? and leave_type_id = ? and entry_date>=?");
					pst.setInt(1, uF.parseToInt(strEmpId));
					pst.setInt(2, uF.parseToInt(alEnCashLeave.get(a)));
					pst.setDate(3, uF.getDateFormat(effectiveDate, DATE_FORMAT));
					rs = pst.executeQuery();
					while(rs.next()){
						isEncahsmentApplied = true;
						strEntryDate = uF.getDateFormat(rs.getString("entry_date"), DBDATE, CF.getStrReportDateFormat());
					}
					rs.close();
					pst.close();*/
					
					pst = con.prepareStatement("select count(leave_encash_id) as cnt from emp_leave_encashment where emp_id = ? and leave_type_id = ? and entry_date>=?");
					pst.setInt(1, uF.parseToInt(strEmpId));
					pst.setInt(2, uF.parseToInt(alEnCashLeave.get(a)));
					pst.setDate(3, uF.getDateFormat(effectiveDate, DATE_FORMAT));
					rs = pst.executeQuery();
					int nApllied=0;
					while(rs.next()){
						nApllied = rs.getInt("cnt");
					}
					rs.close();
					pst.close();
					
					if(nApllied <encashNoOfTimes){
						
						int nLeaveListSize = leaveList.size();
						double dblBalance = 0;
						double dblPendingLeaves = 0;
						
						for (int j=0; j<nLeaveListSize; j++) {
							List<String> cinnerlist = (List<String>)leaveList.get(j);
							getBalanceLeaveMap(con, strEmpId, CF);
							
							if(uF.parseToInt(cinnerlist.get(6)) == uF.parseToInt(alEnCashLeave.get(a))){
								dblBalance = uF.parseToDouble(cinnerlist.get(5));							
								dblPendingLeaves = uF.parseToDouble(cinnerlist.get(8));							
							}
						}
						
//						System.out.println("CF/38646--dblBalance="+dblBalance+"---dblPendingLeaves="+dblPendingLeaves+"---dblMinLeavesForEncashment="+dblMinLeavesForEncashment);
//						System.out.println("CF/38647--dblMaxLeavesForEncashment="+dblMaxLeavesForEncashment);
						/*double dblAvailbleForEncashment = 0;
						dblAvailbleForEncashment = dblBalance - dblMinLeavesForEncashment - dblPendingLeaves;
						if(dblAvailbleForEncashment<=0){
							dblAvailbleForEncashment = 0;
						}else{
//							leaveEncashDays = dblAvailbleForEncashment;
							hmLeaveEncashment.put(alEnCashLeave.get(a), dblAvailbleForEncashment+"");
						}*/
						
						if(dblBalance > dblMinLeavesForEncashment){
							if(dblMaxLeavesForEncashment > 0){
								hmLeaveEncashment.put(alEnCashLeave.get(a), dblMaxLeavesForEncashment+"");
							} else if(dblMaxLeavesForEncashment == 0){
								hmLeaveEncashment.put(alEnCashLeave.get(a), dblBalance+"");
							}
						}
					}
				} else{
					
					String effectiveDate="";
					String effectiveEndDate="";
					
					boolean isEncahsmentApplied = false;
					String strEntryDate = null;
					
					if(effective_date_type.equals("CY")){
						int nCurrentYear = uF.parseToInt(uF.getDateFormat(uF.getCurrentDate(CF.getStrTimeZone())+"", DBDATE, "yyyy"));
						effectiveDate = "01/01/"+(nCurrentYear-1);
						effectiveEndDate = "31/12/"+nCurrentYear;
					} else {
						String strDate = uF.getDateFormat(uF.getCurrentDate(CF.getStrTimeZone())+"", DBDATE, DATE_FORMAT);
						String[] arrDate = CF.getFinancialYear(con, strDate, CF, uF);
						int nCurrentYear = uF.parseToInt(uF.getDateFormat(arrDate[0], DATE_FORMAT, "yyyy"));
						effectiveDate = "01/04/"+(nCurrentYear-1);
						effectiveEndDate = "31/03/"+nCurrentYear;
					}
					
					/*pst = con.prepareStatement("select * from emp_leave_encashment where emp_id = ? and leave_type_id = ? and entry_date between ? and ?");
					pst.setInt(1, uF.parseToInt(strEmpId));
					pst.setInt(2, uF.parseToInt(alEnCashLeave.get(a)));
					pst.setDate(3, uF.getDateFormat(effectiveDate, DATE_FORMAT));
					pst.setDate(4, uF.getDateFormat(effectiveEndDate, DATE_FORMAT));
					rs = pst.executeQuery();
					while(rs.next()){
						isEncahsmentApplied = true;
						strEntryDate = uF.getDateFormat(rs.getString("entry_date"), DBDATE, CF.getStrReportDateFormat());
					}
					rs.close();
					pst.close();*/
					
					pst = con.prepareStatement("select count(leave_encash_id) as cnt from emp_leave_encashment where emp_id = ? and leave_type_id = ? and entry_date>=?");
					pst.setInt(1, uF.parseToInt(strEmpId));
					pst.setInt(2, uF.parseToInt(alEnCashLeave.get(a)));
					pst.setDate(3, uF.getDateFormat(effectiveDate, DATE_FORMAT));
					rs = pst.executeQuery();
					int nApllied=0;
					while(rs.next()){
						nApllied = rs.getInt("cnt");
					}
					rs.close();
					pst.close();
					
					if(nApllied <=encashNoOfTimes){
						
						int nLeaveListSize = leaveList.size();
						double dblBalance = 0;
						double dblPendingLeaves = 0;
						for (int j=0; j<nLeaveListSize; j++) {
							List<String> cinnerlist = (List<String>)leaveList.get(j);
							
							if(uF.parseToInt(cinnerlist.get(6)) == uF.parseToInt(alEnCashLeave.get(a))){
								dblBalance = uF.parseToDouble(cinnerlist.get(5));							
								dblPendingLeaves = uF.parseToDouble(cinnerlist.get(8));							
							}					
						}
						
//						System.out.println("CF/38646--dblBalance="+dblBalance+"---dblPendingLeaves="+dblPendingLeaves+"---dblMinLeavesForEncashment="+dblMinLeavesForEncashment);
//						System.out.println("CF/38647--dblMaxLeavesForEncashment="+dblMaxLeavesForEncashment);
						/*double dblAvailbleForEncashment = 0;
						dblAvailbleForEncashment = dblBalance - dblMinLeavesForEncashment - dblPendingLeaves;
						if(dblAvailbleForEncashment<=0){
							dblAvailbleForEncashment = 0;
						} else{
//							leaveEncashDays += dblAvailbleForEncashment;
							hmLeaveEncashment.put(alEnCashLeave.get(a), dblAvailbleForEncashment+"");
						}*/
						
						if(dblBalance > dblMinLeavesForEncashment){
							if(dblMaxLeavesForEncashment > 0){
								hmLeaveEncashment.put(alEnCashLeave.get(a), dblMaxLeavesForEncashment+"");
							} else if(dblMaxLeavesForEncashment == 0){
								hmLeaveEncashment.put(alEnCashLeave.get(a), dblBalance+"");
							}
						}
					}
				}
			} //outer For loop
			

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}

		return hmLeaveEncashment;
	}
//===end parvez date: 07-04-2022===	

	
	public Map<String, String> getUserTypeAccessMap(Connection con) {
		Map<String, String> hmUserTypeMap = new HashMap<String, String>();
		PreparedStatement pst = null;
		ResultSet rs = null;

		try {
			pst = con.prepareStatement("SELECT * FROM user_type order by user_type_id");
			rs = pst.executeQuery();
			while (rs.next()) {
				hmUserTypeMap.put(rs.getString("user_type_id"), rs.getString("access_usertype_ids"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmUserTypeMap;
	}
	
	public Map<String, String> getYearlyPaidSalaryEarningAndDeduction(Connection con, String fyStart, String fyEnd) {
		Map<String, String> hmEmpSalary_E_D = new HashMap<String, String>();
		PreparedStatement pst = null;
		ResultSet rs = null;
		try {
			pst = con.prepareStatement("select sum(amount) as amount, emp_id, earning_deduction from payroll_generation where financial_year_from_date = ? "
					+ " and financial_year_to_date = ? group by emp_id,earning_deduction");
			pst.setDate(1, uF.getDateFormat(fyStart, DATE_FORMAT));
			pst.setDate(2, uF.getDateFormat(fyEnd, DATE_FORMAT));
			rs = pst.executeQuery();
			while (rs.next()) {
				hmEmpSalary_E_D.put(rs.getString("emp_id")+"_"+rs.getString("earning_deduction"), rs.getString("amount"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
			log.error(e.getClass() + ": " + e.getMessage(), e);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmEmpSalary_E_D;
	}
	

	public String[] getPrevFinancialYear(Connection con, String strDate, CommonFunctions CF, UtilityFunctions uF) {
		String[] arr = new String[2];
		PreparedStatement pst = null;
		ResultSet rs = null;
		try {
			pst = con.prepareStatement("select * from financial_year_details where financial_year_from<=? order by financial_year_from desc limit 2");
			pst.setDate(1, uF.getDateFormat(strDate, DATE_FORMAT));
//			pst.setDate(2, uF.getDateFormat(strDate, DATE_FORMAT));
			rs = pst.executeQuery();
			while (rs.next()) {
				arr[0] = uF.getDateFormat(rs.getString("financial_year_from"), DBDATE, DATE_FORMAT);
				arr[1] = uF.getDateFormat(rs.getString("financial_year_to"), DBDATE, DATE_FORMAT);
			}
			rs.close();
			pst.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
		return arr;
	}

	/**
	 * <b>Page Visit Audit Trail</b>
	 * Date : 08-06-2022
	 * @param con
	 * @param uF
	 * @param empId
	 * @param actionName
	 * @param empBaseVisit
	 * @param remark
	 */
	public void pageVisitAuditTrail(Connection con, CommonFunctions CF, UtilityFunctions uF, String empId,String actionName,String empBaseVisit,String remark) {
		PreparedStatement pst = null;
		Database db = new Database();
		db.setRequest(request);
		try {
				pst=con.prepareStatement("insert into page_visit_audit_trail(emp_id,entry_date_time,action_name,base_user_type,remark) values(?,?,?,?,?)");
				pst.setInt(1,uF.parseToInt(empId));
				pst.setTimestamp(2, uF.getTimeStamp(uF.getCurrentDate(CF.getStrTimeZone())+""+uF.getCurrentTime(CF.getStrTimeZone())+"", DBDATE+DBTIME));
				pst.setString(3,actionName);
				pst.setString(4,empBaseVisit);
				pst.setString(5,remark);				
				pst.execute();
				pst.close();
			
			
		} catch (Exception e) {
			e.printStackTrace();
		}finally {
			db.closeStatements(pst);
		}
	}
	
//===created by parvez: 29-12-2022=== 	
	public Map<String, String> getEmpPANNoMap(Connection con) {
		Map<String, String> hmEmpPANNo = new HashMap<String, String>();
		PreparedStatement pst = null;
		ResultSet rs = null;
		try {
			pst = con.prepareStatement(selectEmployeeR3);
			rs = pst.executeQuery();
			while (rs.next()) {
				hmEmpPANNo.put(rs.getString("emp_id"), rs.getString("emp_pan_no"));
			}
			rs.close();
			pst.close();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			if (pst != null) {
				try {
					pst.close();
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
		}
		return hmEmpPANNo;
	}
	
}